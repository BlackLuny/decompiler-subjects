//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <errno.h>
#include <error.h>
#include <libintl.h>
#include <libio.h>
#include <locale.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int32_t close_stdout(void);
void usage(char * status);
void version_etc(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t version_etc_va(char * stream, int32_t a2, char * a3, char * a4, int32_t * a5);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // ebx
int32_t g2 = 0; // edi
int32_t g3 = 0; // esi
char * g4; // 0x804a03c
char * g5 = "\x01"; // 0x804b7d4
char (*g6)[50] = "Copyright (C) 2004 Free Software Foundation, Inc."; // 0x804b7e8
void (**g7)() = NULL; // 0x804b800
int32_t g8 = 0; // 0x804b808
int32_t g9 = 0; // 0x804b948
bool g10 = false; // zf

// ------------------------ Functions -------------------------

// Address range: 0x8048a80 - 0x8048b59
void usage(char * status) {
    // 0x8048a80
    printf(dcgettext(NULL, "Usage: %s [ignored command line arguments]\n  or:  %s OPTION\nExit with a status code indicating success.\n\nThese option names may not be abbreviated.\n\n", 5));
    char * v1 = dcgettext(NULL, "      --help     display this help and exit\n", 5); // 0x8048ad3
    fputs_unlocked(v1, (struct _IO_FILE *)g7);
    char * v2 = dcgettext(NULL, "      --version  output version information and exit\n", 5); // 0x8048b03
    fputs_unlocked(v2, (struct _IO_FILE *)g7);
    printf(dcgettext(NULL, "\nReport bugs to <%s>.\n", 5));
    exit((int32_t)status);
    // UNREACHABLE
}

// Address range: 0x8048b60 - 0x8048c6f
int main(int argc, char ** argv) {
    int32_t v1 = (int32_t)argv; // ebx
    g9 = *(int32_t *)argv;
    setlocale(LC_ALL, (char *)&g4);
    bindtextdomain("coreutils", "/usr/share/locale");
    textdomain("coreutils");
    atexit((void (**)())close_stdout);
    if (argc == 2) {
        // 0x8048bd3
        if (getenv("POSIXLY_CORRECT") == NULL) {
            uint32_t strncmp_rc = strncmp((char *)*(int32_t *)(v1 + 4), "--help", 7);
            g10 = strncmp_rc % 2 == 0;
            if (strncmp_rc % 2 == 0) {
                // 0x8048c4d
                usage(NULL);
                // branch -> 0x8048bfd
            }
            uint32_t strncmp_rc2 = strncmp((char *)*(int32_t *)(v1 + 4), "--version", 10);
            g10 = strncmp_rc2 % 2 == 0;
            if (strncmp_rc2 % 2 == 0) {
                // 0x8048c11
                g2 = (int32_t)"Jim Meyering";
                g3 = (int32_t)"5.2.1";
                g1 = (int32_t)"GNU coreutils";
                version_etc((int32_t)g7, (int32_t)"true", (int32_t)"GNU coreutils", (int32_t)"5.2.1");
                // branch -> 0x8048bc7
            }
        }
    }
    // 0x8048bc7
    exit(0);
    // UNREACHABLE
}

// Address range: 0x8048c80 - 0x8048d4f
int32_t close_stdout(void) {
    int32_t v1 = *(int32_t *)g7; // 0x8048c8e
    int32_t err_num = (v1 & 32) == 0; // ebx
    if ((v1 & 32) == 0) {
        // 0x8048c9f
        if (__fpending((struct _IO_FILE *)g7) == 0) {
            // 0x8048d20
            return 0;
        }
        // 0x8048cab
        // branch -> 0x8048cb1
    }
    // 0x8048cb1
    int32_t result; // bp+214
    int32_t v2; // 0x8048cc4
    if (fclose((struct _IO_FILE *)g7) == 0) {
        // 0x8048cc4
        result = 0;
        v2 = err_num;
        // branch -> 0x8048cc4
    } else {
        int32_t * v3 = __errno_location(); // 0x8048cbd
        int32_t v4 = *v3; // 0x8048cc2
        err_num = v4;
        result = (int32_t)v3;
        v2 = v4;
        // branch -> 0x8048cc4
    }
    // 0x8048cc4
    if (v2 < 0) {
        // 0x8048d20
        return result;
    }
    char * v5 = dcgettext(NULL, "write error", 5); // 0x8048ce1
    if (g8 != 0) {
        // 0x8048cf1
        abort();
        // UNREACHABLE
    }
    int32_t status = (int32_t)g5;
    error(status, err_num, "%s", v5);
    return status;
}

// Address range: 0x80498d0 - 0x8049aef
int32_t version_etc_va(char * stream, int32_t a2, char * a3, char * a4, int32_t * a5) {
    int32_t v1 = (int32_t)a5;
    int32_t v2 = 0; // ebx
    int32_t stream2 = (int32_t)stream; // esi
    if (*a5 != 0) {
        int32_t v3 = v1 + 4; // 0x8049905
        int32_t v4 = 1; // 0x8049902
        v2 = v4;
        while (*(int32_t *)v3 != 0) {
            // 0x8049900
            v1 = v3;
            v3 = v1 + 4;
            v4++;
            v2 = v4;
            // continue -> 0x8049900
        }
        // 0x804990c
        // branch -> 0x804990c
    }
    // 0x804990c
    char * v5;
    if (a2 == 0) {
        // 0x8049a92
        fprintf((struct _IO_FILE *)stream, "%s %s\n", a3, a4);
        v5 = a3;
        // branch -> 0x8049937
    } else {
        char * v6 = (char *)a2;
        fprintf((struct _IO_FILE *)stream, "%s (%s) %s\n", v6, a3, a4);
        v5 = v6;
        // branch -> 0x8049937
    }
    char * v7 = (char *)5;
    int32_t v8 = (int32_t)"Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n"; // 0x8049951
    char * format; // 0x804995c
    char * v9;
    struct _IO_FILE * v10;
    int32_t v11; // 0x8049971
    uint32_t v12; // 0x8049971
    switch (v2) {
        case 0: {
            // 0x8049a8d
            abort();
            // UNREACHABLE
        }
        case 1: {
            // 0x8049a7a
            v7 = (char *)5;
            v8 = (int32_t)"Written by %s.\n";
            // branch -> 0x8049951
            break;
        }
        case 2: {
            // 0x8049a63
            // branch -> 0x8049955
            // 0x8049955
            format = dcgettext(NULL, (char *)(struct _IO_FILE *)"Written by %s and %s.\n", (int32_t)(char *)5);
            vfprintf((struct _IO_FILE *)stream2, format, v1);
            v11 = stream2;
            v12 = *(int32_t *)(v11 + 20);
            if (v12 < *(int32_t *)(v11 + 24)) {
              lab_0x804997d:
                // 0x804997d
                *(char *)v12 = 10;
                int32_t * v13 = (int32_t *)(stream2 + 20); // 0x8049980_0
                *v13 = *v13 + 1;
                // branch -> 0x8049983
            } else {
              lab_0x8049acc:
                // 0x8049acc
                __overflow((struct _IO_FILE *)v11, 10);
                // branch -> 0x8049983
            }
            // 0x8049983
            fputs_unlocked((char *)*(int32_t *)&g6, (struct _IO_FILE *)stream2);
            int32_t v14 = stream2; // 0x8049994
            uint32_t v15 = *(int32_t *)(v14 + 20); // 0x8049994
            if (v15 < *(int32_t *)(v14 + 24)) {
                // 0x80499a0
                *(char *)v15 = 10;
                int32_t * v16 = (int32_t *)(stream2 + 20); // 0x80499a3_0
                *v16 = *v16 + 1;
                // branch -> 0x80499a6
            } else {
                // 0x8049ab6
                __overflow((struct _IO_FILE *)v14, 10);
                // branch -> 0x80499a6
            }
            // 0x80499a6
            dcgettext(NULL, "This is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n", 5);
            stream2 = g3;
            v1 = g2;
            int32_t v17;
            int32_t v18;
            fputs_unlocked((char *)v18, (struct _IO_FILE *)v17);
            // branch -> 0x80499d6
            // 0x80499d6
            v7 = (char *)5;
            v8 = (int32_t)"Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n";
            // branch -> 0x8049951
            break;
        }
        case 3: {
            // 0x8049a50
            v7 = (char *)5;
            v8 = (int32_t)"Written by %s, %s, and %s.\n";
            // branch -> 0x8049951
            break;
        }
        case 4: {
            // 0x8049a3d
            v7 = (char *)5;
            v8 = (int32_t)"Written by %s, %s, %s,\nand %s.\n";
            // branch -> 0x8049951
            break;
        }
        case 5: {
            // 0x8049a2a
            v7 = (char *)5;
            v8 = (int32_t)"Written by %s, %s, %s,\n%s, and %s.\n";
            // branch -> 0x8049951
            break;
        }
        case 6: {
            // 0x8049a13
            // branch -> 0x8049955
        }
        case 7: {
            v9 = (char *)5;
            v10 = (struct _IO_FILE *)"Written by %s, %s, %s,\n%s, %s, %s, and %s.\n";
          lab_0x8049955:
            // 0x8049955
            format = dcgettext(NULL, (char *)v10, (int32_t)v9);
            vfprintf((struct _IO_FILE *)stream2, format, v1);
            v11 = stream2;
            v12 = *(int32_t *)(v11 + 20);
            if (v12 < *(int32_t *)(v11 + 24)) {
                goto lab_0x804997d;
            }
            goto lab_0x8049acc;
            break;
        }
        case 8: {
            // 0x80499e9
            v7 = (char *)5;
            v8 = (int32_t)"Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n";
            // branch -> 0x8049951
            break;
        }
        case 9: {
            // 0x80499d6
            v7 = v5;
            v8 = (int32_t)"Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n";
            // branch -> 0x8049951
            break;
        }
    }
    // 0x8049951
    v9 = v7;
    v10 = (struct _IO_FILE *)v8;
    // branch -> 0x8049955
    goto lab_0x8049955;
}

// Address range: 0x8049af0 - 0x8049b1f
void version_etc(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1;
    version_etc_va((char *)a1, a2, (char *)a3, (char *)a4, &v1);
}

// --------------- Statically Linked Functions ----------------

// int atexit(void(* func)(void));

// --------------- Dynamically Linked Functions ---------------

// int * __errno_location(void);
// size_t __fpending(FILE * fp);
// int __overflow(_IO_FILE *, int);
// void abort(void);
// char * bindtextdomain(const char * domainname, const char * dirname);
// char * dcgettext(const char * domainname, const char * msgid, int category);
// void error(int status, int errnum, const char * format, ...);
// void exit(int status);
// int fclose(FILE * stream);
// int fprintf(FILE * restrict stream, const char * restrict format, ...);
// int fputs_unlocked(const char * restrict s, FILE * restrict stream);
// char * getenv(const char * name);
// int printf(const char * restrict format, ...);
// char * setlocale(int category, const char * locale);
// char * textdomain(const char * domainname);
// int vfprintf(FILE * restrict s, const char * restrict format, _G_va_list arg);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (i686-redhat-linux-gcc) (4.6.3)
// Detected functions: 5
// Decompiler release: VERSION
// Decompilation date: DATE
