//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <ctype.h>
#include <errno.h>
#include <error.h>
#include <libintl.h>
#include <libio.h>
#include <locale.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <wctype.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct _TYPEDEF___mbstate_t {
    int32_t e0;
    int32_t e1;
};

// ------------------- Function Prototypes --------------------

int32_t close_stdout(void);
int32_t entry_point(int32_t a1, int32_t a2);
int32_t function_80488bc(void);
void function_80488d4(void);
int32_t function_8048ae4(void);
int32_t function_8048aed(int32_t a1);
int32_t function_8048b08(void);
int32_t function_8048b3a(int32_t a1);
int32_t function_8048b3c(void);
int32_t function_8048b68(char * status, int32_t a2, int32_t a3);
int32_t function_8048c4a(int32_t a1, int32_t * a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_8048d64(void);
int32_t function_8048d68(int32_t result, int32_t a2);
int32_t * function_8048e5f(void);
int32_t * function_8048e70(int32_t * a1);
int32_t function_8048f0d(int32_t * a1, int32_t result, int32_t a3);
int32_t function_8048f36(int32_t a1, uint32_t a2, uint32_t a3);
char * function_8048fa3(int32_t a1, int32_t a2);
int32_t function_8048ff6(char * a1, int32_t a2, uint32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11);
int32_t * function_80496c3(int32_t a1, int32_t a2, int32_t * a3, int32_t a4, int32_t * a5);
int32_t * function_8049721(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
void function_80498ae(void);
int32_t function_8049905(int32_t a1);
int32_t function_804995f(int32_t a1, int32_t a2, int32_t a3);
int32_t function_804998f(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_80499be(int32_t a1, int32_t a2);
int32_t function_80499f0(int32_t a1, int32_t a2);
int32_t function_8049a8b(int32_t a1);
int32_t function_8049ac0(struct _IO_FILE * stream, int32_t a2, int32_t a3, int32_t a4, int32_t * a5);
int32_t function_8049ccd(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_8049d10(int64_t a1, int64_t a2, int32_t a3);
int32_t function_8049dc5(int32_t size, int32_t a2, int32_t a3);
int32_t function_8049e3f(char * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_8049f60(int32_t nmemb, char * a2);
int32_t function_8049fe0(char * a1);
void function_804a008(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_804a016(int32_t a1, int32_t a2, int32_t a3);
int32_t function_804a05a(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_804a067(int32_t a1, int32_t a2, int32_t a3);
void function_804a0a0(int32_t a1);
void function_804a0a9(void);
int32_t function_804a0d0(void);
void function_804a0f4(int32_t a1);
int32_t function_804a0fd(int32_t a1);
int32_t unknown_ffffffff(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // eax
int32_t g2 = 0; // ebp
int32_t g3 = 0; // ebx
int32_t g4 = 0; // ecx
int32_t g5 = 0; // edi
int32_t g6 = 0; // edx
int32_t g7 = 0; // esi
int32_t g8 = -1; // 0x804b82c
int32_t g9 = 0; // 0x804b838
int32_t g10 = 0; // 0x804b83c
char g12 = 0; // 0x804ba00
bool g13 = false; // zf
int32_t * g11 = &g9; // 0x804b9d4

// ------------------------ Functions -------------------------

// Address range: 0x80488bc - 0x80488d2
int32_t function_80488bc(void) {
    // 0x80488bc
    function_8048ae4();
    function_8048b3c();
    int32_t result = function_804a0d0(); // 0x80488cc
    int32_t v1;
    g2 = v1;
    return result;
}

// Address range: 0x80488d4 - 0x8048ab3
void function_80488d4(void) {
    // 0x80488d4
    return;
}

// Address range: 0x8048ac0 - 0x8048ae3
int32_t entry_point(int32_t a1, int32_t a2) {
    int32_t v1;
    int32_t result = __libc_start_main((int32_t * (*)(int32_t, char **, char **))function_8048c4a, v1, (char **)&a1, (void (**)())function_804a008, (void (**)())0x804a05c, (void (**)())g6); // 0x8048adc
    return result;
}

// Address range: 0x8048ae4 - 0x8048aec
int32_t function_8048ae4(void) {
    int32_t v1;
    g2 = &v1;
    return function_8048aed(g3);
}

// Address range: 0x8048aed - 0x8048b07
int32_t function_8048aed(int32_t a1) {
    // 0x8048aed
    int32_t v1;
    g3 = v1 + 0x2e5f;
    int32_t v2 = *(int32_t *)(v1 + 0x2e5b); // 0x8048af5
    g1 = v2;
    g13 = v2 == 0;
    if (v2 != 0) {
        // 0x8048aff
        ((int32_t (*)())v2)();
        // branch -> 0x8048b01
    }
    // 0x8048b01
    g3 = a1;
    g2 = *(int32_t *)g2;
    return g6;
}

// Address range: 0x8048b08 - 0x8048b39
int32_t function_8048b08(void) {
    int32_t v1;
    g2 = &v1;
    int32_t result; // 0x8048b264
    if (g12 == 0) {
        // 0x8048b26
        result = *(int32_t *)&g11;
        int32_t v2 = *(int32_t *)result; // 0x8048b2b6
        g6 = v2;
        if (v2 != 0) {
            int32_t v3 = result + 4; // 0x8048b1c
            g13 = v3 == 0;
            g1 = v3;
            *(int32_t *)&g11 = v3;
            ((int32_t (*)())v2)();
            int32_t v4 = *(int32_t *)&g11; // 0x8048b26
            int32_t v5 = *(int32_t *)v4; // 0x8048b2b
            g6 = v5;
            while (v5 != 0) {
                // 0x8048b1c
                v3 = v4 + 4;
                g13 = v3 == 0;
                g1 = v3;
                *(int32_t *)&g11 = v3;
                ((int32_t (*)())v5)();
                v4 = *(int32_t *)&g11;
                v5 = *(int32_t *)v4;
                g6 = v5;
                // continue -> 0x8048b1c
            }
            // 0x8048b26
            result = v4;
            // branch -> 0x8048b31
        }
        // 0x8048b31
        g12 = 1;
        // branch -> 0x8048b38
    }
    // 0x8048b38
    g2 = v1;
    return result;
}

// Address range: 0x8048b3a - 0x8048b3b
int32_t function_8048b3a(int32_t a1) {
    // 0x8048b3a
    return g7;
}

// Address range: 0x8048b3c - 0x8048b67
int32_t function_8048b3c(void) {
    // 0x8048b3c
    if (g10 != 0) {
        // 0x8048b4b
        // branch -> 0x8048b64
    }
    // 0x8048b64
    int32_t v1;
    g2 = v1;
    return 0;
}

// Address range: 0x8048b68 - 0x8048c49
int32_t function_8048b68(char * status, int32_t a2, int32_t a3) {
    // 0x8048b68
    function_8048d64();
    int32_t v1 = g3; // 0x8048b72
    g3 = v1 + 0x2dda;
    printf(dcgettext(NULL, (char *)(v1 + 0x15a6), 5));
    char * v2 = dcgettext(NULL, (char *)(g3 - 0x179c), 5); // 0x8048bca
    int32_t v3 = *(int32_t *)(g3 - 12); // 0x8048bcf
    fputs_unlocked(v2, (struct _IO_FILE *)*(int32_t *)v3);
    char * v4 = dcgettext(NULL, (char *)(g3 - 0x176c), 5); // 0x8048bfc
    fputs_unlocked(v4, (struct _IO_FILE *)*(int32_t *)v3);
    printf(dcgettext(NULL, (char *)(g3 - 0x1736), 5));
    exit((int32_t)status);
    // UNREACHABLE
}

// Address range: 0x8048c4a - 0x8048d63
int32_t function_8048c4a(int32_t a1, int32_t * a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x8048c4a
    function_8048d64();
    int32_t v1 = g3; // 0x8048c55
    int32_t v2 = v1 + 0x2cf7; // ebx
    int32_t v3 = v1 + 0x1638; // esi
    *(int32_t *)*(int32_t *)(v1 + 0x2ce3) = *a2;
    setlocale(LC_ALL, (char *)(v2 - 0x1720));
    int32_t v4 = v2 - 0x1709; // 0x8048c8d
    bindtextdomain((char *)v3, (char *)v4);
    textdomain((char *)v3);
    function_804a0a0(*(int32_t *)(v2 - 32));
    if (a1 == 2) {
        char * env_val = getenv((char *)(g3 - 0x16f7)); // 0x8048cd0
        if (env_val == NULL) {
            int32_t * v5 = (int32_t *)((int32_t)a2 + 4); // 0x8048cdf_0
            int32_t str = *v5; // 0x8048cdf
            uint32_t strncmp_rc = strncmp((char *)str, (char *)(g3 - 0x16e7), (int32_t)env_val & -256 | 7);
            g4 = strncmp_rc;
            g13 = strncmp_rc % 2 == 0;
            if (strncmp_rc % 2 == 0) {
                // 0x8048d4d
                int32_t v6;
                function_8048b68(NULL, v4, v6);
                str = *v5;
                // branch -> 0x8048cf3
            }
            int32_t str2 = g3 - 0x16e0; // 0x8048cf9
            g5 = str2;
            g7 = str;
            uint32_t strncmp_rc2 = strncmp((char *)str, (char *)str2, 10);
            g4 = strncmp_rc2;
            g13 = strncmp_rc2 % 2 == 0;
            if (strncmp_rc2 % 2 == 0) {
                int32_t v7 = g3; // 0x8048d08
                int32_t v8 = *(int32_t *)(v7 - 12); // 0x8048d38
                function_8049ccd(*(int32_t *)v8, v7 - 0x16b5, v7 - 0x16c3, v7 - 0x16c9);
                // branch -> 0x8048cbb
            }
        }
    }
    // 0x8048cbb
    exit(0);
    // UNREACHABLE
}

// Address range: 0x8048d64 - 0x8048d67
int32_t function_8048d64(void) {
    // 0x8048d64
    int32_t v1;
    g3 = v1;
    return g4;
}

// Address range: 0x8048d68 - 0x8048d80
int32_t function_8048d68(int32_t result, int32_t a2) {
    // 0x8048d68
    function_8048e5f();
    *(int32_t *)(g4 + 0x2c96) = result;
    return result;
}

// Address range: 0x8048d81 - 0x8048e5e
int32_t close_stdout(void) {
    int32_t v1 = g5; // 0x8048d84
    int32_t v2 = g7; // 0x8048d85
    int32_t v3 = g3; // bp-16
    g4 = function_8048d64();
    int32_t v4 = g3; // 0x8048d8c
    g3 = v4 + 0x2bc0;
    int32_t file = *(int32_t *)(v4 + 0x2bb4); // 0x8048d95
    int32_t v5 = *(int32_t *)file; // 0x8048d9b
    uint32_t v6 = *(int32_t *)v5; // 0x8048d9d
    g7 = v6 / 32 % 2 == 0;
    int32_t v7;
    if (v6 / 32 % 2 == 0) {
        // 0x8048dae
        if (__fpending((struct _IO_FILE *)v5) == 0) {
            // 0x8048e24
            g3 = v3;
            g7 = v2;
            g5 = v1;
            g2 = v7;
            return 0;
        }
        // 0x8048dae
        // branch -> 0x8048dba
    }
    // 0x8048dba
    int32_t result; // bp+215
    int32_t v8; // 0x8048dc8
    if (fclose((struct _IO_FILE *)*(int32_t *)file) == 0) {
        // 0x8048dc8
        result = 0;
        v8 = g7;
        // branch -> 0x8048dc8
    } else {
        int32_t * v9 = __errno_location(); // 0x8048e2c
        int32_t v10 = *v9; // 0x8048e31
        g7 = v10;
        result = (int32_t)v9;
        v8 = v10;
        // branch -> 0x8048dc8
    }
    // 0x8048dc8
    if (v8 < 0) {
        // 0x8048e24
        g3 = v3;
        g7 = v2;
        g5 = v1;
        g2 = v7;
        return result;
    }
    // 0x8048dcc
    g5 = (int32_t)dcgettext(NULL, (char *)(g3 - 0x16b0), 5);
    int32_t v11 = g3; // 0x8048dec
    int32_t v12 = *(int32_t *)(v11 + 184); // 0x8048dec
    if (v12 == 0) {
        int32_t status = *(int32_t *)*(int32_t *)(v11 - 16); // 0x8048e4d
        error(status, g7, (char *)(v11 - 0x16a0));
        g3 = v3;
        g7 = v2;
        g5 = v1;
        g2 = v7;
        return status;
    }
    // 0x8048df6
    function_8049a8b(v12);
    int32_t status2 = *(int32_t *)*(int32_t *)(g3 - 16); // 0x8048e1a
    error(status2, g7, (char *)(g3 - 0x16a4));
    // branch -> 0x8048e24
    // 0x8048e24
    g3 = v3;
    g7 = v2;
    g5 = v1;
    g2 = v7;
    return status2;
}

// Address range: 0x8048e5f - 0x8048e6f
int32_t * function_8048e5f(void) {
    // 0x8048e5f
    int32_t v1;
    g4 = v1;
    return (int32_t *)g1;
}

// Address range: 0x8048e70 - 0x8048f0c
int32_t * function_8048e70(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    g4 = function_8048d64();
    g3 += 0x2ad1;
    int32_t * v2 = __errno_location(); // 0x8048e84
    g5 = *v2;
    g7 = (int32_t)v2;
    int32_t v3;
    int32_t v4 = function_8049dc5(36, 0, v3); // 0x8048e94
    if (a1 == NULL) {
        // 0x8048ee2
        v1 = g3 + 468;
        // branch -> 0x8048ea2
    }
    // 0x8048ea2
    *(int32_t *)v4 = *(int32_t *)v1;
    *(int32_t *)(v4 + 4) = *(int32_t *)(v1 + 4);
    *(int32_t *)(v4 + 8) = *(int32_t *)(v1 + 8);
    *(int32_t *)(v4 + 12) = *(int32_t *)(v1 + 12);
    *(int32_t *)(v4 + 16) = *(int32_t *)(v1 + 16);
    *(int32_t *)(v4 + 20) = *(int32_t *)(v1 + 20);
    *(int32_t *)(v4 + 24) = *(int32_t *)(v1 + 24);
    *(int32_t *)(v4 + 28) = *(int32_t *)(v1 + 28);
    *(int32_t *)(v4 + 32) = *(int32_t *)(v1 + 32);
    *(int32_t *)g7 = g5;
    return (int32_t *)v4;
}

// Address range: 0x8048f0d - 0x8048f35
int32_t function_8048f0d(int32_t * a1, int32_t result, int32_t a3) {
    // 0x8048f0d
    function_8048e5f();
    if (a1 == NULL) {
        // 0x8048f29
        *(int32_t *)(g4 + 0x2c0d) = result;
        return result;
    }
    // 0x8048f22
    *a1 = result;
    return result;
}

// Address range: 0x8048f36 - 0x8048fa2
int32_t function_8048f36(int32_t a1, uint32_t a2, uint32_t a3) {
    int32_t v1 = g3; // bp-16
    function_8048d64();
    int32_t v2 = 4 * a2 % 256 / 32; // 0x8048f59
    if (a1 == 0) {
        uint32_t v3 = a2 % 32; // 0x8048f87
        g4 = v3;
        uint32_t v4 = a3 % 2; // 0x8048f8a
        int32_t * v5 = (int32_t *)((v2 | 0x2be3) + g3); // 0x8048f8d_0
        uint32_t v6 = *v5; // 0x8048f8d
        int32_t v7;
        int32_t result; // 0x8048f9330
        if (v3 == 0) {
            // after_if_8048f91_0.thread
            result = v6 % 2;
            v7 = result ^ v4;
            // branch -> after_if_8048f98_0
        } else {
            int32_t v8 = (v6 >> v3) % 2; // 0x8048f93
            v7 = (v8 ^ v4) << v3;
            result = v8;
            // branch -> after_if_8048f98_0
        }
        // after_if_8048f98_0
        *v5 = v7 ^ v6;
        g3 = v1;
        return result;
    }
    int32_t * v9 = (int32_t *)(a1 + 4 + v2); // 0x8048f64_0
    uint32_t v10 = *v9; // 0x8048f64
    uint32_t v11 = a2 % 32; // 0x8048f66
    g4 = v11;
    uint32_t v12 = a3 % 2; // 0x8048f69
    int32_t v13;
    int32_t result2; // 0x8048f7026
    if (v11 == 0) {
        // after_if_8048f6e_0.thread
        result2 = v10 % 2;
        v13 = result2 ^ v12;
        // branch -> after_if_8048f75_0
    } else {
        int32_t v14 = (v10 >> v11) % 2; // 0x8048f70
        v13 = (v14 ^ v12) << v11;
        result2 = v14;
        // branch -> after_if_8048f75_0
    }
    // after_if_8048f75_0
    *v9 = v13 ^ v10;
    g3 = v1;
    return result2;
}

// Address range: 0x8048fa3 - 0x8048ff5
char * function_8048fa3(int32_t a1, int32_t a2) {
    // 0x8048fa3
    function_8048d64();
    int32_t v1 = (int32_t)dcgettext(NULL, (char *)g1, 5); // 0x8048fce_6
    int32_t v2; // 0x8048fef
    if ((int32_t)(g6 == 6) != ((int32_t)(v1 == g1) || g6 & -256)) {
        // 0x8048fe6
        v2 = g3 + 0x15d6;
        // branch -> 0x8048fec
    } else {
        v2 = v1;
    }
    // 0x8048fec
    return (char *)v2;
}

// Address range: 0x8048ff6 - 0x80496c2
int32_t function_8048ff6(char * a1, int32_t a2, uint32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11) {
    int32_t * str3 = (int32_t *)a1;
    int32_t v1;
    g2 = &v1;
    g4 = function_8048d64();
    g3 += 0x294b;
    int32_t v2 = g1; // 0x804900a
    uint32_t v3 = g6; // 0x804900d
    int32_t v4 = __ctype_get_mb_cur_max(); // 0x804902c
    int32_t str2 = 0; // 0x804924b111
    int32_t n = 0; // 0x80490bd109
    if (a3 <= 6) {
        // 0x8049043
        g6 = a3;
        int32_t v5 = g3; // 0x8049046
        int32_t v6 = *(int32_t *)(4 * a3 - 0x1680 + v5) + v5; // 0x804904d
        g13 = v6 == 0;
        g1 = v6;
        ((int32_t (*)())v6)();
        g6 = v3;
        if (v3 != 0) {
            // 0x8049059
            g4 = v2;
            *(char *)v2 = 39;
            // branch -> 0x804905f
        }
        int32_t v7 = g3 - 0x13c2; // 0x804905f
        g7 = v7;
        str2 = v7;
        n = 1;
        // branch -> 0x8049076
    }
    // 0x8049076
    int32_t v8; // 0x8049207
    int32_t v9; // 0x8049387113
    int32_t result; // 0x8049387116
    int32_t v10; // 0x8049387117151
    int32_t v11; // 0x8049387118
    int32_t v12; // 0x8049098
    char v13; // 0x804924e146
    int32_t v14; // 0x804920f
    char v15;
    int32_t v16; // 0x804924b110152
    int32_t v17; // 0x804959c123
    int32_t v18; // 0x80495a2134
    int32_t v19; // 0x80495a2135
    if (a2 != -1) {
        v19 = a2;
        v14 = 0;
        v8 = n;
        // 0x8049087
        if (v14 != v19) {
            v12 = v19;
            v18 = v19;
            v17 = v14;
            v9 = v8;
            goto lab_0x8049093_2;
        }
        v11 = v8;
        // 0x8049228
        result = v11;
        if (str2 != 0) {
            // 0x804924b
            g4 = str2;
            v13 = *(char *)str2;
            if (v13 != 0) {
                v15 = v13;
                v16 = str2;
                v10 = v11;
                while (true) {
                    // 0x8049232
                    if (v10 < v3) {
                        goto lab_0x804923a_3;
                    }
                    goto lab_0x8049243_3;
                }
            } else {
                result = v11;
            }
        }
        // 0x8049255
        if (result < v3) {
            // 0x804925d
            *(char *)(result + v2) = 0;
            // branch -> 0x8049267
        }
        // 0x8049267
        return result;
    }
    int32_t v20 = 0; // 0x804959c125
    int32_t v21 = n; // 0x8049387115
  lab_0x8049218:
    // 0x8049218
    if (*(char *)((int32_t)str3 + v20) != 0) {
        // 0x8049218
        v12 = g6;
        v18 = -1;
        v17 = v20;
        v9 = v21;
        // branch -> 0x8049093
      lab_0x8049093_2:
        // 0x8049093
        g5 = 0;
        int32_t v22 = v9; // 0x8049387112
        if ((int32_t)(n != 0) != (v12 & -256)) {
            // 0x80490a8
            if (v17 + n <= v18) {
                int32_t str = (int32_t)str3 + v17; // 0x80490ba
                g7 = str;
                g5 = str2;
                uint32_t strncmp_rc = strncmp((char *)str, (char *)str2, n);
                g4 = strncmp_rc;
                g13 = strncmp_rc % 2 == 0;
                if (strncmp_rc % 2 == 0) {
                    // 0x80490c9
                    if (v9 < v3) {
                        // 0x80490d1
                        g4 = v9;
                        *(char *)(v9 + v2) = 92;
                        // branch -> 0x80490db
                    }
                    // 0x80490db
                    v22 = v9 + 1;
                    // branch -> 0x80490df
                } else {
                    v22 = v9;
                }
            } else {
                v22 = v9;
            }
        }
        // 0x80490df
        g6 = v17;
        unsigned char v23 = *(char *)((int32_t)str3 + v17); // 0x80490e5
        int32_t v24 = v23; // 0x80490e5
        int32_t v25 = v23; // 0x80490e9_0
        if (v23 <= 126) {
            int32_t v26 = g3; // 0x80490f4
            int32_t v27 = *(int32_t *)(4 * v24 - 0x1664 + v26); // 0x80490f4
            int32_t v28 = v27 + v26; // 0x80490fb
            g13 = v28 == 0;
            g1 = v28;
            ((int32_t (*)())v28)();
            // branch -> 0x80490ff
        }
        // 0x80490ff
        int32_t v29; // edx
        int32_t v30;
        int32_t v31; // 0x8049387121
        int32_t v32; // 0x8049175
        int32_t v33; // 0x0107
        int32_t v34; // 0x804959c129
        int32_t v35; // 0x80495a2133
        int32_t v36; // 0x80495a2138
        int32_t v37; // 0x80495b8104
        if (v4 != 1) {
            int32_t ps = 0;
            int32_t len = v18; // 0x80495a2139
            if (v18 == -1) {
                // 0x8049545
                len = strlen((char *)str3);
                // branch -> 0x804929e
            }
            int32_t v38 = (int32_t)str3 + v17; // 0x80492a4
            v29 = v38;
            int32_t v39 = 0; // 0x80495b8100
            int32_t v40 = 1;
            // branch -> 0x80492ad
            while (true) {
                int32_t v41 = v39 + v17; // 0x80492ba
                g7 = v41;
                int32_t pwc;
                int32_t v42 = mbrtowc(&pwc, (char *)(v41 + (int32_t)str3), len - v41, (struct _TYPEDEF___mbstate_t *)&ps); // 0x80492d3
                int32_t v43 = v42; // edi
                int32_t v44; // 0x80491e7
                int32_t v45;
                int32_t v46;
                int32_t v47; // 0x8049387120
                int32_t v48; // 0x0106
                int32_t v49; // 0x80495a2137
                int32_t v50; // 0x80495b8102
                int32_t v51; // 0x80495b8103
                if (v42 == 0) {
                    v50 = v39;
                    v45 = v40;
                  lab_0x804931a_4:
                    // 0x804931a
                    if (v50 > 1) {
                        v36 = len;
                        v37 = v50;
                        v30 = v45;
                      lab_0x8049142_4:
                        // 0x8049142
                        g4 = v37 + v17;
                        v32 = v29;
                        v34 = v17;
                        v31 = v22;
                        v33 = v25;
                        // branch -> 0x8049170
                      lab_0x8049170_2:
                        while (true) {
                            // 0x8049170
                            g7 = 0;
                            v47 = v31;
                            v48 = v33;
                            if ((int32_t)(v30 == 0) != (v32 & -256)) {
                                // 0x8049185
                                if (v31 < v3) {
                                    // 0x804918d
                                    g7 = v2;
                                    *(char *)(v31 + v2) = 92;
                                    // branch -> 0x8049197
                                }
                                int32_t v52 = v31 + 1; // 0x8049197
                                if (v52 < v3) {
                                    // 0x80491a3
                                    g7 = v52;
                                    *(char *)(v52 + v2) = (char)(v33 / 64 % 4 | 48);
                                    // branch -> 0x80491b5
                                }
                                int32_t v53 = v31 + 2; // 0x80491b5
                                if (v53 < v3) {
                                    // 0x80491c1
                                    g7 = v53;
                                    *(char *)(v53 + v2) = (char)(v33 / 8 % 8 | 48);
                                    // branch -> 0x80491d5
                                }
                                // 0x80491d5
                                v47 = v31 + 3;
                                v48 = v33 % 8 | 48;
                                // branch -> 0x80491e4
                            }
                            // 0x80491e4
                            v44 = v34 + 1;
                            g6 = v44;
                            if (v44 >= g4) {
                                v49 = v36;
                              lab_0x80491f2:
                                // 0x80491f2
                                v14 = v44;
                                if (v47 < v3) {
                                    // 0x80491fa
                                    g4 = v2;
                                    g7 = v47;
                                    *(char *)(v47 + v2) = (char)v48;
                                    v14 = g6;
                                    // branch -> 0x8049207
                                }
                                // 0x8049207
                                v8 = v47 + 1;
                                if (v49 == -1) {
                                    v20 = v14;
                                    v21 = v8;
                                    goto lab_0x8049218;
                                }
                                v19 = v49;
                                // 0x8049087
                                if (v14 != v19) {
                                    v12 = v19;
                                    v18 = v19;
                                    v17 = v14;
                                    v9 = v8;
                                    goto lab_0x8049093_2;
                                }
                                v11 = v8;
                                // 0x8049228
                                result = v11;
                                if (str2 != 0) {
                                    // 0x804924b
                                    g4 = str2;
                                    v13 = *(char *)str2;
                                    if (v13 != 0) {
                                        v15 = v13;
                                        v16 = str2;
                                        v10 = v11;
                                        while (true) {
                                            // 0x8049232
                                            if (v10 < v3) {
                                              lab_0x804923a_3:
                                                // 0x804923a
                                                *(char *)(v10 + v2) = v15;
                                                // branch -> 0x8049243
                                            }
                                          lab_0x8049243_3:;
                                            int32_t v54 = v10 + 1; // 0x8049243
                                            int32_t v55 = v16 + 1; // 0x8049247
                                            g4 = v55;
                                            char v56 = *(char *)v55; // 0x804924e
                                            if (v56 == 0) {
                                                result = v54;
                                                // break -> 0x8049255
                                                break;
                                            }
                                            v15 = v56;
                                            v16 = v55;
                                            v10 = v54;
                                            // continue -> 0x8049232
                                        }
                                        // 0x8049255
                                        if (result >= v3) {
                                            // 0x8049267
                                            return result;
                                        }
                                        // 0x804925d
                                        *(char *)(result + v2) = 0;
                                        // branch -> 0x8049267
                                        // 0x8049267
                                        return result;
                                    }
                                    result = v11;
                                }
                                // 0x8049255
                                if (result >= v3) {
                                    // 0x8049267
                                    return result;
                                }
                                // 0x804925d
                                *(char *)(result + v2) = 0;
                                // branch -> 0x8049267
                                // 0x8049267
                                return result;
                            }
                            if (v47 < v3) {
                                // 0x8049152
                                *(char *)(v47 + v2) = (char)v48;
                                v44 = g6;
                                // branch -> 0x804915f
                            }
                            // 0x804915f
                            v32 = v44;
                            v34 = v44;
                            v31 = v47 + 1;
                            v33 = (int32_t)*(char *)((int32_t)str3 + v44);
                            // branch -> 0x8049170
                        }
                    } else {
                        v51 = v50;
                        v46 = v45;
                    }
                } else {
                    // 0x80492de
                    if (v42 == -1) {
                        // 0x804955d
                        if (v39 >= 2) {
                            v36 = len;
                            v37 = v39;
                            v30 = 0;
                            goto lab_0x8049142_4;
                        }
                        v51 = v39;
                        v46 = 0;
                      lab_0x8049325_2:
                        // 0x8049325
                        v29 &= -256;
                        if (v46 == 0) {
                            v36 = len;
                            v37 = v51;
                            v30 = v46;
                            goto lab_0x8049142_4;
                        }
                        v35 = len;
                      lab_0x804933e_2:;
                        int32_t v57 = v17 + 1; // 0x8049341
                        g6 = v57;
                        g4 = 0;
                        v44 = v57;
                        v49 = v35;
                        v47 = v22;
                        v48 = v25;
                        // branch -> 0x80491f2
                        goto lab_0x80491f2;
                    } else {
                        // 0x80492e7
                        if (v42 == -2) {
                            // 0x8049573
                            if (g7 >= len) {
                                v50 = v39;
                                v45 = 0;
                                goto lab_0x804931a_4;
                            }
                            // 0x8049587
                            v29 = v38;
                            if (*(char *)(v39 + v38) == 0) {
                                v50 = v39;
                                v45 = 0;
                                goto lab_0x804931a_4;
                            }
                            int32_t v58 = v39; // 0x80495b8101
                            int32_t v59; // 0x8049598
                            while (true) {
                                // 0x8049598
                                v59 = v58 + 1;
                                if (v59 + v17 >= len) {
                                    v50 = v59;
                                    v45 = 0;
                                    goto lab_0x804931a_4;
                                }
                                // 0x80495ac
                                g7 = v38;
                                if (*(char *)(v59 + v38) == 0) {
                                    // break -> 0x80495b8
                                    break;
                                }
                                v58 = v59;
                                // continue -> 0x8049598
                            }
                            // 0x80495b8
                            if (v59 < 2) {
                                v51 = v59;
                                v46 = 0;
                                goto lab_0x8049325_2;
                            }
                            v36 = len;
                            v37 = v59;
                            v30 = 0;
                            goto lab_0x8049142_4;
                        } else {
                            int32_t v60 = v43 + v39; // 0x8049300
                            int32_t v61 = iswprint(pwc) != 0 ? v40 : 0; // 0x8049308
                            if (mbsinit((struct _TYPEDEF___mbstate_t *)&ps) != 0) {
                                v50 = v60;
                                v45 = v61;
                                goto lab_0x804931a_4;
                            }
                            // 0x80492f0
                            v39 = v60;
                            v40 = v61;
                            // branch -> 0x80492ad
                            continue;
                        }
                        // 0x804931a
                        if (v50 > 1) {
                            v36 = len;
                            v37 = v50;
                            v30 = v45;
                            goto lab_0x8049142_4;
                        }
                        v51 = v50;
                        v46 = v45;
                        goto lab_0x8049325_2;
                    }
                  lab_0x8049142_6:
                    // 0x8049142
                    g4 = v37 + v17;
                    v32 = v29;
                    v34 = v17;
                    v31 = v22;
                    v33 = v25;
                    // branch -> 0x8049170
                    goto lab_0x8049170_2;
                }
                // 0x8049325
                v29 &= -256;
                if (v46 != 0) {
                    v35 = len;
                    goto lab_0x804933e_2;
                }
                v36 = len;
                v37 = v51;
                v30 = v46;
                goto lab_0x8049142_6;
            }
        } else {
            int32_t v62 = *(int32_t *)__ctype_b_loc(); // 0x804911d
            int32_t v63 = (int32_t)*(int16_t *)(v62 + 2 * (v25 % 256)) & 0x4000; // 0x8049123
            v29 = v63;
            if ((int32_t)(v63 == 0) == v63) {
                v35 = v18;
                goto lab_0x804933e_2;
            }
            v36 = v18;
            v37 = 1;
            v30 = v63;
            goto lab_0x8049142_6;
        }
        // 0x8049142
        g4 = v37 + v17;
        int32_t v64 = v29;
        v32 = v64;
        v34 = v17;
        v31 = v22;
        v33 = v25;
        // branch -> 0x8049170
        goto lab_0x8049170_2;
    } else {
        v11 = v21;
    }
    // 0x8049228
    result = v11;
    if (str2 != 0) {
        // 0x804924b
        g4 = str2;
        v13 = *(char *)str2;
        if (v13 != 0) {
            v15 = v13;
            v16 = str2;
            v10 = v11;
            while (true) {
                // 0x8049232
                if (v10 < v3) {
                    goto lab_0x804923a_3;
                }
                goto lab_0x8049243_3;
            }
        } else {
            result = v11;
        }
    }
    // 0x8049255
    if (result < v3) {
        // 0x804925d
        *(char *)(result + v2) = 0;
        // branch -> 0x8049267
    }
    // 0x8049267
    return result;
}

// Address range: 0x80496c3 - 0x8049720
int32_t * function_80496c3(int32_t a1, int32_t a2, int32_t * a3, int32_t a4, int32_t * a5) {
    int32_t v1 = g5; // 0x80496c6
    int32_t v2 = g7; // 0x80496c7
    int32_t v3 = g3; // bp-16
    g4 = function_8048d64();
    int32_t v4 = g3; // 0x80496ce
    g3 = v4 + 0x227e;
    g5 = (int32_t)a5;
    if (a5 == NULL) {
        // 0x8049719
        g5 = v4 + 0x2452;
        // branch -> 0x80496de
    }
    int32_t * v5 = __errno_location(); // 0x80496de
    g6 = a2;
    g7 = (int32_t)v5;
    int32_t v6 = *v5; // 0x80496e8
    int32_t v7 = g5; // 0x80496ea
    int32_t v8 = *(int32_t *)v7; // 0x80496f1
    g1 = a1;
    int32_t v9;
    int32_t v10 = function_8048ff6((char *)a3, a4, v8, v7, 0, 0, v6, v3, v2, v1, v9); // 0x8049707
    *v5 = v6;
    g3 = v3;
    g5 = v1;
    return (int32_t *)v10;
}

// Address range: 0x8049721 - 0x80498ad
int32_t * function_8049721(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = g5; // 0x8049724
    int32_t v2 = g7; // 0x8049725
    int32_t v3 = g3; // 0x8049726
    g4 = function_8048d64();
    g3 += 0x2220;
    int32_t v4 = g1; // 0x8049735
    int32_t v5 = g6; // 0x8049738
    int32_t v6 = *__errno_location(); // 0x8049740
    if (v4 < 0) {
        // 0x80498a4
        abort();
        // UNREACHABLE
    }
    int32_t v7 = g3; // 0x8049753
    int32_t v8 = v7; // 0x80497c5
    if (*(int32_t *)(v7 + 144) <= v4) {
        int32_t v9 = v4 + 1; // 0x804975d
        g5 = v9;
        int32_t v10;
        int32_t v11;
        if (v9 > 0x1fffffff) {
            // 0x80498a9
            int32_t v12;
            function_8049d10((int64_t)(int32_t)(char *)v12, (int64_t)v11, v10);
            return NULL;
        }
        int32_t v13 = *(int32_t *)(v7 + 156); // 0x804976c
        g7 = v13;
        int32_t v14 = v13; // 0x8049787
        if (v13 == v7 + 148) {
            int32_t v15 = function_8049dc5(8, v11, v10); // 0x8049881
            int32_t v16 = g3; // 0x8049886
            g7 = v15;
            *(int32_t *)(v16 + 156) = v15;
            *(int32_t *)g7 = *(int32_t *)(g3 + 148);
            *(int32_t *)(g7 + 4) = *(int32_t *)(v16 + 152);
            v14 = g7;
            v9 = g5;
            // branch -> 0x8049780
        }
        // 0x8049780
        int32_t v17;
        int32_t v18 = function_8049e3f((char *)v14, 8 * v9, v10, v17); // 0x804978e
        int32_t v19 = g3; // 0x8049793
        int32_t v20 = *(int32_t *)(v19 + 144); // edx
        g7 = v18;
        *(int32_t *)(v19 + 156) = v18;
        char * v21 = (char *)(8 * v20 + v18);
        memset(v21, 0, 8 * (g5 - v20));
        *(int32_t *)(g3 + 144) = g5;
        v8 = g3;
        // branch -> 0x80497c5
    }
    int32_t v22 = *(int32_t *)(v8 + 156); // 0x80497c5
    int32_t v23 = 8 * v4; // 0x80497ce
    uint32_t v24 = *(int32_t *)(v22 + v23); // 0x80497ce
    int32_t v25 = v23 | 4; // 0x80497d713
    int32_t v26 = *(int32_t *)(v22 + v25); // 0x80497d7
    g5 = v26;
    int32_t * v27 = (int32_t *)v5;
    int32_t * v28 = (int32_t *)a2;
    uint32_t v29 = (int32_t)function_80496c3(v26, v24, v27, a1, v28); // 0x80497fa_6
    int32_t v30; // 0x8049873
    if (v24 > v29) {
        // 0x8049866
        *__errno_location() = v6;
        v30 = g5;
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return (int32_t *)v30;
    }
    int32_t v31 = v29 + 1; // 0x8049804
    int32_t v32 = *(int32_t *)(g3 + 156); // 0x8049807
    g7 = v32;
    g6 = v4;
    *(int32_t *)(v32 + v23) = v31;
    int32_t v33 = g5; // 0x804981c
    if (v33 != g3 + 212) {
        // 0x8049820
        function_8049fe0((char *)v33);
        g7 = *(int32_t *)(g3 + 156);
        // branch -> 0x804982e
    }
    int32_t v34 = function_8049dc5(v31, v24, v5); // 0x8049834
    *(int32_t *)(g7 + v25) = v34;
    g5 = v34;
    function_80496c3(v34, v31, v27, a1, v28);
    // branch -> 0x8049866
    // 0x8049866
    *__errno_location() = v6;
    v30 = g5;
    g3 = v3;
    g7 = v2;
    g5 = v1;
    return (int32_t *)v30;
}

// Address range: 0x80498ae - 0x8049904
void function_80498ae(void) {
    // 0x80498ae
    function_8048d64();
    int32_t v1 = g3 + 0x2269; // 0x80498bd
    g4 = v1;
    int32_t v2;
    g1 = v2;
    int32_t v3;
    g6 = v3;
    int32_t v4;
    int32_t v5;
    function_8049721(v5, v4, -1, v1);
    g4 = function_8048d64();
    g3 += 0x2069;
    function_80498ae();
}

// Address range: 0x8049905 - 0x804995e
int32_t function_8049905(int32_t a1) {
    int32_t v1;
    g4 = (int32_t)memset((char *)&v1, 0, 8);
    *(int32_t *)g1 = g6;
    *(int32_t *)(g1 + 4) = v1;
    int32_t v2;
    *(int32_t *)(g1 + 8) = v2;
    int32_t v3;
    *(int32_t *)(g1 + 12) = v3;
    int32_t v4;
    *(int32_t *)(g1 + 16) = v4;
    int32_t v5;
    *(int32_t *)(g1 + 20) = v5;
    int32_t v6;
    *(int32_t *)(g1 + 24) = v6;
    int32_t v7;
    *(int32_t *)(g1 + 28) = v7;
    int32_t v8;
    *(int32_t *)(g1 + 32) = v8;
    return g1;
}

// Address range: 0x804995f - 0x804998e
int32_t function_804995f(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1;
    int32_t v2 = &v1; // 0x8049966_0
    g7 = v2;
    g6 = a2;
    g1 = v2;
    int32_t v3;
    function_8049905(v3);
    g6 = a3;
    g1 = a1;
    return (int32_t)function_8049721(-1, g7, 0, 0);
}

// Address range: 0x804998f - 0x80499bd
int32_t function_804998f(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1;
    int32_t v2 = &v1; // 0x8049996_0
    g7 = v2;
    g6 = a2;
    g1 = v2;
    int32_t v3;
    function_8049905(v3);
    g6 = a3;
    g1 = a1;
    return (int32_t)function_8049721(a4, g7, 0, 0);
}

// Address range: 0x80499be - 0x80499ef
int32_t function_80499be(int32_t a1, int32_t a2) {
    // 0x80499be
    function_8048d64();
    g3 += 0x1f85;
    return function_804995f(0, a1, a2);
}

// Address range: 0x80499f0 - 0x8049a8a
int32_t function_80499f0(int32_t a1, int32_t a2) {
    int32_t v1 = g7; // 0x80499f3
    g4 = function_8048d64();
    int32_t v2 = g3; // 0x80499fa
    g3 = v2 + 0x1f52;
    int32_t v3;
    int32_t v4 = &v3; // 0x8049a00_0
    g7 = v4;
    v3 = *(int32_t *)(v2 + 0x2126);
    function_8048f36(v4, 0x1000000 * a2 / 0x1000000, 1);
    g6 = a1;
    g1 = 0;
    int32_t * v5 = function_8049721(-1, g7, 1, 0); // 0x8049a7f
    g7 = v1;
    return (int32_t)v5;
}

// Address range: 0x8049a8b - 0x8049abf
int32_t function_8049a8b(int32_t a1) {
    int32_t v1 = g3; // 0x8049a8e
    g4 = function_8048d64();
    g3 += 0x1eb8;
    int32_t result = function_80499f0(a1, 58); // 0x8049aab
    g3 = v1;
    return result;
}

// Address range: 0x8049ac0 - 0x8049ccc
int32_t function_8049ac0(struct _IO_FILE * stream, int32_t a2, int32_t a3, int32_t a4, int32_t * a5) {
    int32_t v1 = (int32_t)a5;
    int32_t v2;
    g2 = &v2;
    g7 = 0;
    function_8048d64();
    int32_t v3 = g3; // 0x8049acd
    g3 = v3 + 0x1e7f;
    g5 = (int32_t)stream;
    g4 = a2;
    if (*a5 != 0) {
        int32_t v4 = v1 + 4; // 0x8049ae7
        int32_t v5 = g7 + 1; // 0x8049ae9
        g7 = v5;
        // branch -> 0x8049ae7
        while (*(int32_t *)v4 != 0) {
            // 0x8049ae7
            v4 += 4;
            v5++;
            g7 = v5;
            // continue -> 0x8049ae7
        }
        // 0x8049aef
        // branch -> 0x8049af5
    }
    // 0x8049af5
    g6 = a4;
    if (a2 == 0) {
        // 0x8049c7e
        fprintf(stream, (char *)(v3 + 3350));
        // branch -> 0x8049b21
    } else {
        // 0x8049afd
        fprintf(stream, (char *)(v3 + 3271));
        // branch -> 0x8049b21
    }
    uint32_t v6 = g7; // 0x8049b21
    if (v6 < 10) {
        int32_t v7 = g3; // 0x8049b26
        int32_t v8 = *(int32_t *)(4 * v6 - 0x1160 + v7); // 0x8049b26
        int32_t v9 = v8 + v7; // 0x8049b2d
        g13 = v9 == 0;
        g1 = v9;
        ((int32_t (*)())v9)();
        // branch -> 0x8049b31
    }
    char * format = dcgettext(NULL, (char *)(g3 - 0x1388), 5); // 0x8049b4a
    vfprintf((struct _IO_FILE *)g5, format, v1);
    uint32_t v10 = *(int32_t *)(g5 + 20); // 0x8049b62
    if (v10 < *(int32_t *)(g5 + 24)) {
        // 0x8049b6e
        *(char *)v10 = 10;
        int32_t * v11 = (int32_t *)(g5 + 20); // 0x8049b71_0
        *v11 = *v11 + 1;
        // branch -> 0x8049b75
    } else {
        // 0x8049cb8
        __overflow((struct _IO_FILE *)g5, 10);
        // branch -> 0x8049b75
    }
    int32_t v12 = *(int32_t *)(g3 - 28); // 0x8049b79
    fputs_unlocked((char *)*(int32_t *)v12, (struct _IO_FILE *)g5);
    uint32_t v13 = *(int32_t *)(g5 + 20); // 0x8049b89
    if (v13 < *(int32_t *)(g5 + 24)) {
        // 0x8049b95
        *(char *)v13 = 10;
        int32_t * v14 = (int32_t *)(g5 + 20); // 0x8049b98_0
        *v14 = *v14 + 1;
        // branch -> 0x8049b9c
    } else {
        // 0x8049ca3
        __overflow((struct _IO_FILE *)g5, 10);
        // branch -> 0x8049b9c
    }
    char * v15 = dcgettext(NULL, (char *)(g3 - 0x134c), 5); // 0x8049bb5
    return fputs_unlocked(v15, (struct _IO_FILE *)g5);
}

// Address range: 0x8049ccd - 0x8049d0f
int32_t function_8049ccd(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    g4 = function_8048d64();
    g3 += 0x1c76;
    int32_t v1;
    return function_8049ac0((struct _IO_FILE *)a1, a2, a3, a4, &v1);
}

// Address range: 0x8049d10 - 0x8049dc4
int32_t function_8049d10(int64_t a1, int64_t a2, int32_t a3) {
    int32_t v1;
    g2 = &v1;
    g4 = function_8048d64();
    int32_t v2 = g3; // 0x8049d19
    int32_t v3 = v2 + 0x1c33; // 0x8049d19
    g3 = v3;
    int32_t v4 = *(int32_t *)*(int32_t *)(v2 + 0x1c0f); // 0x8049d28
    g1 = v4;
    g13 = v4 == 0;
    int32_t v5; // 0x8049d2e
    if (v4 != 0) {
        // 0x8049d77
        ((int32_t (*)())v4)();
        v5 = g3;
        // branch -> 0x8049d2e
    } else {
        v5 = v3;
    }
    // 0x8049d2e
    dcgettext(NULL, (char *)*(int32_t *)(v5 - 8), 5);
    error(*(int32_t *)*(int32_t *)(g3 - 16), 0, (char *)(g3 - 0x16a0));
    abort();
    // UNREACHABLE
}

// Address range: 0x8049dc5 - 0x8049e3e
int32_t function_8049dc5(int32_t size, int32_t a2, int32_t a3) {
    // 0x8049dc5
    int32_t v1;
    int64_t v2 = v1; // bp-4
    int32_t v3 = g3; // bp-8
    g4 = function_8048d64();
    char * mem = malloc(size); // 0x8049ddd
    if (mem != NULL) {
        // 0x8049de6
        g3 = v3;
        return (int32_t)mem;
    }
    // 0x8049dec
    uint32_t v4;
    uint64_t v5 = (int64_t)v4;
    function_8049d10((int64_t)size, (int64_t)v3, (int32_t)v2);
    int32_t v6 = g5; // 0x8049dff
    int32_t v7 = g7; // 0x8049e00
    function_8048d64();
    g5 = v4;
    int32_t v8 = v2;
    g4 = v8;
    g7 = v3;
    g6 = 0xffffffffffffffff % v5;
    int32_t v9;
    if ((int32_t)(0xffffffffffffffff / v5) < v8) {
        // 0x8049e3a
        int32_t v10;
        int32_t v11;
        function_8049d10((int64_t)(int32_t)(char *)v11, (int64_t)v10, v9);
        return 0;
    }
    int32_t v12 = v8 * v4; // 0x8049e1f
    g4 = v12;
    char * v13 = (char *)v3;
    char * mem2 = realloc(v13, v12); // 0x8049e29
    if (mem2 == NULL) {
        // 0x8049e1f
        // branch -> 0x8049e3a
        // 0x8049e3a
        function_8049d10((int64_t)(int32_t)v13, (int64_t)v12, v9);
        return 0;
    }
    // 0x8049e32
    g7 = v7;
    g5 = v6;
    return (int32_t)mem2;
}

// Address range: 0x8049e3f - 0x8049f5f
int32_t function_8049e3f(char * a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = g3; // 0x8049e42
    g4 = function_8048d64();
    g6 = (int32_t)a1;
    char * mem = realloc(a1, a2); // 0x8049e5e
    if (mem != NULL) {
        // 0x8049e67
        g3 = v1;
        return (int32_t)mem;
    }
    // 0x8049e6d
    int32_t v2;
    function_8049d10((int64_t)(int32_t)a1, (int64_t)a2, v2);
    int32_t v3 = g5; // 0x8049e78
    int32_t v4 = g3; // bp-44
    function_8048d64();
    g3 += 0x1acc;
    g5 = v2;
    uint32_t v5;
    g7 = v5;
    int32_t * v6 = (int32_t *)v2; // 0x8049e94_0
    int32_t v7 = *v6; // 0x8049e94
    g4 = v7;
    int32_t result; // 0x8049eb6
    int32_t v8;
    int32_t v9; // 0x8049eac
    if (a2 == 0) {
        // 0x8049ec3
        int32_t v10; // 0x8049ed9
        if (v7 == 0) {
            uint32_t v11 = 64 / v5; // 0x8049ece
            v10 = (int32_t)(v11 == 0) + v11;
            g4 = v10;
            // branch -> 0x8049ea7
        } else {
            v10 = v7;
        }
        // 0x8049ea7
        *v6 = v10;
        v9 = g7 * g4;
        g4 = v9;
        result = function_8049e3f((char *)a2, v9, v8, v4);
        g3 = v4;
        g5 = v3;
        return result;
    }
    // 0x8049e98
    g6 = 0x7fffffff % v5;
    if (0x7fffffff / v5 >= v7) {
        int32_t v12 = 2 * v7; // 0x8049ea5
        g4 = v12;
        // branch -> 0x8049ea7
        // 0x8049ea7
        *v6 = v12;
        v9 = g7 * g4;
        g4 = v9;
        result = function_8049e3f((char *)a2, v9, v8, v4);
        g3 = v4;
        g5 = v3;
        return result;
    }
    // 0x8049edd
    int32_t v13;
    int32_t v14;
    function_8049d10((int64_t)v14, (int64_t)v13, v8);
    int32_t v15 = g3; // 0x8049ee5
    function_8048d64();
    g3 += 0x1a61;
    g4 = v13;
    g6 = v8;
    int32_t * v16 = (int32_t *)v8; // 0x8049efc_0
    int32_t v17 = *v16; // 0x8049efc
    int32_t v18 = v17; // eax
    int32_t v19; // 0x8049f06
    if (v13 == 0) {
        // 0x8049f1a
        if (v17 == 0) {
            // 0x8049f1e
            v18 = 64;
            v19 = 64;
            // branch -> 0x8049f06
        } else {
            v19 = v17;
        }
    } else {
        // 0x8049f00
        if (v17 < 0) {
            // 0x8049f22
            int32_t v20;
            int32_t v21;
            function_8049d10((int64_t)v21, (int64_t)v20, 0);
            int32_t v22 = g3; // 0x8049f2b
            g4 = function_8048d64();
            g3 += 0x1a1b;
            g7 = v20;
            int32_t v23;
            int32_t v24;
            int32_t v25 = function_8049dc5(v20, v24, v23); // 0x8049f40
            g3 = v22;
            return (int32_t)memset((char *)v25, 0, g7);
        }
        int32_t v26 = 2 * v17; // 0x8049f04
        v18 = v26;
        v19 = v26;
        // branch -> 0x8049f06
    }
    // 0x8049f06
    *v16 = v19;
    int32_t result2 = function_8049e3f((char *)g4, v18, 0, 0); // 0x8049f0f
    g3 = v15;
    return result2;
}

// Address range: 0x8049f60 - 0x8049fdf
int32_t function_8049f60(int32_t nmemb, char * a2) {
    // 0x8049f60
    function_8048d64();
    int32_t size = (int32_t)a2;
    g4 = size;
    g7 = nmemb;
    uint64_t v1 = (int64_t)size; // 0x8049f80
    g6 = 0xffffffffffffffff % v1;
    int32_t v2; // 0x8049fbe
    int32_t v3;
    int32_t v4;
    int32_t v5;
    char * v6;
    if ((int32_t)(0xffffffffffffffff / v1) < nmemb) {
        int32_t v7;
        v6 = (char *)v7;
        // 0x8049f9d
        int32_t v8;
        function_8049d10((int64_t)v8, (int64_t)(int32_t)v6, v3);
        g4 = function_8048d64();
        g3 += 0x199d;
        g7 = v3;
        v2 = function_8049dc5(v3, v5, v4);
        return (int32_t)memcpy((char *)v2, v6, g7);
    }
    char * mem = calloc(nmemb, size); // 0x8049f8d
    if (mem != NULL) {
        // 0x8049f96
        return (int32_t)mem;
    }
    // 0x8049f86
    v6 = a2;
    // branch -> 0x8049f9d
    // 0x8049f9d
    function_8049d10((int64_t)nmemb, (int64_t)(int32_t)v6, v3);
    g4 = function_8048d64();
    g3 += 0x199d;
    g7 = v3;
    v2 = function_8049dc5(v3, v5, v4);
    return (int32_t)memcpy((char *)v2, v6, g7);
}

// Address range: 0x8049fe0 - 0x804a007
int32_t function_8049fe0(char * a1) {
    // 0x8049fe0
    g4 = function_8048d64();
    if (a1 != NULL) {
        // 0x8049ff9
        free(a1);
        // branch -> 0x804a001
    }
    // 0x804a001
    return (int32_t)a1;
}

// Address range: 0x804a008 - 0x804a015
void function_804a008(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x804a008
    int32_t v1;
    function_804a016(v1, 0, 0);
}

// Address range: 0x804a016 - 0x804a059
int32_t function_804a016(int32_t a1, int32_t a2, int32_t a3) {
    // 0x804a016
    int32_t v1;
    g3 = v1 + 0x1936;
    function_80488bc();
    int32_t v2 = g3 - 288; // 0x804a022
    g6 = v2;
    *(int32_t *)(g2 - 16) = v2;
    int32_t v3 = g6; // 0x804a031
    int32_t v4 = v2 - v3; // 0x804a031
    g7 = 0;
    int32_t result = v4 / 4; // 0x804a035
    g1 = result;
    g13 = v4 < 4;
    if (v4 < 4) {
        // 0x804a016
        // branch -> 0x804a052
        // 0x804a052
        return result;
    }
    // 0x804a03c
    g5 = v3;
    ((int32_t (*)())*(int32_t *)v3)();
    int32_t v5 = g5; // 0x804a046
    int32_t v6 = g7 + 1; // 0x804a048
    g7 = v6;
    int32_t v7 = (*(int32_t *)(g2 - 16) - v5) / 4; // 0x804a049
    g4 = v7;
    g13 = v6 == v7;
    g6 = v5;
    // branch -> 0x804a040
    while (v6 < v7) {
        // 0x804a040
        ((int32_t (*)())*(int32_t *)(4 * v6 + v5))();
        v5 = g5;
        v6 = g7 + 1;
        g7 = v6;
        v7 = (*(int32_t *)(g2 - 16) - v5) / 4;
        g4 = v7;
        g13 = v6 == v7;
        g6 = v5;
        // continue -> 0x804a040
    }
    // 0x804a052
    return result;
}

// Address range: 0x804a05a - 0x804a066
int32_t function_804a05a(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = g7; // 0x804a05a
    function_804a067(g3, result, g5);
    return result;
}

// Address range: 0x804a067 - 0x804a09f
int32_t function_804a067(int32_t a1, int32_t a2, int32_t a3) {
    // 0x804a091
    int32_t v1;
    g3 = v1 + 0x18e5;
    g5 = v1 + 0x17c5;
    g1 = 0;
    g7 = -1;
    int32_t v2;
    function_804a0f4(v2);
    return 0;
}

// Address range: 0x804a0a0 - 0x804a0a8
void function_804a0a0(int32_t a1) {
    int32_t v1;
    g2 = &v1;
    function_804a0a9();
}

// Address range: 0x804a0a9 - 0x804a0cf
void function_804a0a9(void) {
    // 0x804a0a9
    int32_t v1;
    int32_t v2 = *(int32_t *)(v1 + 0x188b); // 0x804a0b0
    char * v3; // 0x804a0be
    if (v2 != 0) {
        // 0x804a0bc
        v3 = (char *)*(int32_t *)v2;
        // branch -> 0x804a0be
    } else {
        v3 = NULL;
    }
    // 0x804a0be
    __cxa_atexit((void (**)(char *))*(int32_t *)(g2 + 8), NULL, v3);
    g3 = *(int32_t *)(g2 - 4);
}

// Address range: 0x804a0d0 - 0x804a0f3
int32_t function_804a0d0(void) {
    // 0x804a0d0
    int32_t v1;
    if (g8 == -1) {
        // 0x804a0f0
        g2 = v1;
        return g6;
    }
    int32_t v2 = &g8; // 0x804a0e4
    unknown_ffffffff();
    while (*(int32_t *)(v2 - 4) != -1) {
        // 0x804a0e4
        v2 -= 4;
        unknown_ffffffff();
        // continue -> 0x804a0e4
    }
    // 0x804a0eb
    // branch -> 0x804a0f0
    // 0x804a0f0
    g2 = v1;
    return g6;
}

// Address range: 0x804a0f4 - 0x804a0fc
void function_804a0f4(int32_t a1) {
    // 0x804a0f4
    function_804a0fd(g3);
}

// Address range: 0x804a0fd - 0x804a10d
int32_t function_804a0fd(int32_t a1) {
    // 0x804a0fd
    int32_t v1;
    g3 = v1 + 0x184f;
    int32_t result = function_8048b08(); // 0x804a105
    g2 = *(int32_t *)g2;
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// const unsigned short int ** __ctype_b_loc(void);
// size_t __ctype_get_mb_cur_max(void);
// int __cxa_atexit(void(* func)(void *), void * arg, void * dso_handle);
// int * __errno_location(void);
// size_t __fpending(FILE * fp);
// int __libc_start_main(int *(main)(int, char **, char **), int argc, char ** ubp_av, void(* init)(void), void(* fini)(void), void(* rtld_fini)(void), void(* stack_end));
// int __overflow(_IO_FILE *, int);
// void abort(void);
// char * bindtextdomain(const char * domainname, const char * dirname);
// void * calloc(size_t nmemb, size_t size);
// char * dcgettext(const char * domainname, const char * msgid, int category);
// void error(int status, int errnum, const char * format, ...);
// void exit(int status);
// int fclose(FILE * stream);
// int fprintf(FILE * restrict stream, const char * restrict format, ...);
// int fputs_unlocked(const char * restrict s, FILE * restrict stream);
// void free(void * ptr);
// char * getenv(const char * name);
// int iswprint(wint_t wc);
// void * malloc(size_t size);
// size_t mbrtowc(wchar_t * restrict pwc, const char * restrict s, size_t n, mbstate_t * restrict p);
// int mbsinit(const mbstate_t * ps);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int printf(const char * restrict format, ...);
// void * realloc(void * ptr, size_t size);
// char * setlocale(int category, const char * locale);
// char * textdomain(const char * domainname);
// int vfprintf(FILE * restrict s, const char * restrict format, _G_va_list arg);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (i686-redhat-linux-gcc) (4.6.3)
// Detected functions: 44
// Decompiler release: VERSION
// Decompilation date: DATE
