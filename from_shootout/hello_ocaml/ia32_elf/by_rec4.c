// Generated by Rec Studio 4 - build Apr 15 2012

_init()
{// addr = 0x08049D84
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    __esp = __esp - 4;
    L1();
    _pop(__ebx);
    if( *((intOrPtr*)(_t2 + 0x23910)) != 0) {
        __gmon_start__();
    }
    frame_dummy();
    __do_global_ctors_aux();
    _pop(__eax);
    return;
}

L08049D90()
{
    _unknown_ _t2;                         // _t2

    _pop(__ebx);
    if( *((intOrPtr*)(_t2 + 0x23910)) != 0) {
        __gmon_start__();
    }
    frame_dummy();
    __do_global_ctors_aux();
    _pop(__eax);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return;
}

ldexp()
{// addr = 0x08049DC4
    goto __imp__ldexp;
}

int fputs(char* str, struct _IO_FILE* fp)
{// addr = 0x08049DD4
    goto __imp__fputs;
}

fmod()
{// addr = 0x08049DE4
    goto __imp__fmod;
}

int* __errno_location()
{// addr = 0x08049DF4
    goto __imp____errno_location;
}

sigemptyset()
{// addr = 0x08049E04
    goto __imp__sigemptyset;
}

inet_ntop()
{// addr = 0x08049E14
    goto __imp__inet_ntop;
}

int sprintf(char* dst, char* format)
{// addr = 0x08049E24
    goto __imp__sprintf;
}

tcflow()
{// addr = 0x08049E34
    goto __imp__tcflow;
}

connect()
{// addr = 0x08049E44
    goto __imp__connect;
}

setgroups()
{// addr = 0x08049E54
    goto __imp__setgroups;
}

int getpid()
{// addr = 0x08049E64
    goto __imp__getpid;
}

mkdir()
{// addr = 0x08049E74
    goto __imp__mkdir;
}

char* strerror(int __errnum)
{// addr = 0x08049E84
    goto __imp__strerror;
}

getsockname()
{// addr = 0x08049E94
    goto __imp__getsockname;
}

memcmp()
{// addr = 0x08049EA4
    goto __imp__memcmp;
}

log1p()
{// addr = 0x08049EB4
    goto __imp__log1p;
}

freeaddrinfo()
{// addr = 0x08049EC4
    goto __imp__freeaddrinfo;
}

asin()
{// addr = 0x08049ED4
    goto __imp__asin;
}

shutdown()
{// addr = 0x08049EE4
    goto __imp__shutdown;
}

open64()
{// addr = 0x08049EF4
    goto __imp__open64;
}

sigismember()
{// addr = 0x08049F04
    goto __imp__sigismember;
}

__gmon_start__()
{// addr = 0x08049F14
    goto __imp____gmon_start__;
}

void* realloc(void* __ptr, int __size)
{// addr = 0x08049F24
    goto __imp__realloc;
}

sinh()
{// addr = 0x08049F34
    goto __imp__sinh;
}

__isoc99_sscanf()
{// addr = 0x08049F44
    goto __imp____isoc99_sscanf;
}

__xstat64()
{// addr = 0x08049F54
    goto __imp____xstat64;
}

localtime()
{// addr = 0x08049F64
    goto __imp__localtime;
}

cfgetispeed()
{// addr = 0x08049F74
    goto __imp__cfgetispeed;
}

getgrnam()
{// addr = 0x08049F84
    goto __imp__getgrnam;
}

double strtod(char* __nptr, char** __endptr)
{// addr = 0x08049F94
    goto __imp__strtod;
}

socketpair()
{// addr = 0x08049FA4
    goto __imp__socketpair;
}

recv()
{// addr = 0x08049FB4
    goto __imp__recv;
}

char* getenv(char* __name)
{// addr = 0x08049FC4
    goto __imp__getenv;
}

void* calloc(int __nmemb, int __size)
{// addr = 0x08049FD4
    goto __imp__calloc;
}

int system(char* __command)
{// addr = 0x08049FE4
    goto __imp__system;
}

int fchown(int __fd, int __owner, int __group)
{// addr = 0x08049FF4
    short __group;                          goto __imp__fchown;
}

int write(int __fd, void* __buf, int __n)
{// addr = 0x0804A004
    goto __imp__write;
}

sendto()
{// addr = 0x0804A014
    goto __imp__sendto;
}

pow()
{// addr = 0x0804A024
    goto __imp__pow;
}

listen()
{// addr = 0x0804A034
    goto __imp__listen;
}

dlclose()
{// addr = 0x0804A044
    goto __imp__dlclose;
}

int rename(char* _old, char* _new)
{// addr = 0x0804A054
    goto __imp__rename;
}

__caddr_t getlogin()
{// addr = 0x0804A064
    goto __imp__getlogin;
}

void* memset(void* __s, int __c, int __n)
{// addr = 0x0804A074
    goto __imp__memset;
}

setitimer()
{// addr = 0x0804A084
    goto __imp__setitimer;
}

int setsid()
{// addr = 0x0804A094
    goto __imp__setsid;
}

getprotobyname()
{// addr = 0x0804A0A4
    goto __imp__getprotobyname;
}

__libc_start_main()
{// addr = 0x0804A0B4
    goto __imp____libc_start_main;
}

wait()
{// addr = 0x0804A0C4
    goto __imp__wait;
}

floor()
{// addr = 0x0804A0D4
    goto __imp__floor;
}

modf()
{// addr = 0x0804A0E4
    goto __imp__modf;
}

tcgetattr()
{// addr = 0x0804A0F4
    goto __imp__tcgetattr;
}

chmod()
{// addr = 0x0804A104
    goto __imp__chmod;
}

int read(int __fd, void* __buf, int __nbytes)
{// addr = 0x0804A114
    goto __imp__read;
}

tcdrain()
{// addr = 0x0804A124
    goto __imp__tcdrain;
}

sigaltstack()
{// addr = 0x0804A134
    goto __imp__sigaltstack;
}

exp()
{// addr = 0x0804A144
    goto __imp__exp;
}

getrusage()
{// addr = 0x0804A154
    goto __imp__getrusage;
}

gettimeofday()
{// addr = 0x0804A164
    goto __imp__gettimeofday;
}

expm1()
{// addr = 0x0804A174
    goto __imp__expm1;
}

long strtol(char* __nptr, char** __endptr, int __base)
{// addr = 0x0804A184
    goto __imp__strtol;
}

getservbyport()
{// addr = 0x0804A194
    goto __imp__getservbyport;
}

void free(void* __ptr)
{// addr = 0x0804A1A4
    goto __imp__free;
}

inet_pton()
{// addr = 0x0804A1B4
    goto __imp__inet_pton;
}

__lxstat64()
{// addr = 0x0804A1C4
    goto __imp____lxstat64;
}

atan()
{// addr = 0x0804A1D4
    goto __imp__atan;
}

__fpclassify()
{// addr = 0x0804A1E4
    goto __imp____fpclassify;
}

getprotobynumber()
{// addr = 0x0804A1F4
    goto __imp__getprotobynumber;
}

int access(char* __name, int __type)
{// addr = 0x0804A204
    goto __imp__access;
}

dlsym()
{// addr = 0x0804A214
    goto __imp__dlsym;
}

truncate64()
{// addr = 0x0804A224
    goto __imp__truncate64;
}

sigaction()
{// addr = 0x0804A234
    goto __imp__sigaction;
}

int fflush(struct _IO_FILE* fp)
{// addr = 0x0804A244
    goto __imp__fflush;
}

sqrt()
{// addr = 0x0804A254
    goto __imp__sqrt;
}

opendir()
{// addr = 0x0804A264
    goto __imp__opendir;
}

gethostbyaddr_r()
{// addr = 0x0804A274
    goto __imp__gethostbyaddr_r;
}

accept()
{// addr = 0x0804A284
    goto __imp__accept;
}

tcflush()
{// addr = 0x0804A294
    goto __imp__tcflush;
}

int symlink(char* __from, char* __to)
{// addr = 0x0804A2A4
    goto __imp__symlink;
}

socket()
{// addr = 0x0804A2B4
    goto __imp__socket;
}

int dup2(int __fd, int __fd2)
{// addr = 0x0804A2C4
    goto __imp__dup2;
}

__ctype_b_loc()
{// addr = 0x0804A2D4
    goto __imp____ctype_b_loc;
}

int isatty(int __fd)
{// addr = 0x0804A2E4
    goto __imp__isatty;
}

getaddrinfo()
{// addr = 0x0804A2F4
    goto __imp__getaddrinfo;
}

umask()
{// addr = 0x0804A304
    goto __imp__umask;
}

tanh()
{// addr = 0x0804A314
    goto __imp__tanh;
}

setuid()
{// addr = 0x0804A324
    goto __imp__setuid;
}

int dup(int __fd)
{// addr = 0x0804A334
    goto __imp__dup;
}

mktime()
{// addr = 0x0804A344
    goto __imp__mktime;
}

readdir64()
{// addr = 0x0804A354
    goto __imp__readdir64;
}

acos()
{// addr = 0x0804A364
    goto __imp__acos;
}

void* memcpy(void* __dest, void* __src, int __n)
{// addr = 0x0804A374
    goto __imp__memcpy;
}

cfsetospeed()
{// addr = 0x0804A384
    goto __imp__cfsetospeed;
}

utime()
{// addr = 0x0804A394
    goto __imp__utime;
}

int execv(char* __path, __caddr_t* __argv)
{// addr = 0x0804A3A4
    goto __imp__execv;
}

int execvp(char* __file, __caddr_t* __argv)
{// addr = 0x0804A3B4
    goto __imp__execvp;
}

cos()
{// addr = 0x0804A3C4
    goto __imp__cos;
}

int alarm(int __seconds)
{// addr = 0x0804A3D4
    goto __imp__alarm;
}

int unlink(char* __name)
{// addr = 0x0804A3E4
    goto __imp__unlink;
}

getpwuid()
{// addr = 0x0804A3F4
    goto __imp__getpwuid;
}

int nice(int __val)
{// addr = 0x0804A404
    goto __imp__nice;
}

int getppid()
{// addr = 0x0804A414
    goto __imp__getppid;
}

__builtin_va_list setlocale(int __category, char* __locale)
{// addr = 0x0804A424
    goto __imp__setlocale;
}

waitpid()
{// addr = 0x0804A434
    goto __imp__waitpid;
}

sigdelset()
{// addr = 0x0804A444
    goto __imp__sigdelset;
}

__h_errno_location()
{// addr = 0x0804A454
    goto __imp____h_errno_location;
}

char* strcpy(char* __dest, char* __src)
{// addr = 0x0804A464
    goto __imp__strcpy;
}

int chroot(char* __path)
{// addr = 0x0804A474
    goto __imp__chroot;
}

short getegid()
{// addr = 0x0804A484
    goto __imp__getegid;
}

dlopen()
{// addr = 0x0804A494
    goto __imp__dlopen;
}

mkfifo()
{// addr = 0x0804A4A4
    goto __imp__mkfifo;
}

int chdir(char* __path)
{// addr = 0x0804A4B4
    goto __imp__chdir;
}

bind()
{// addr = 0x0804A4C4
    goto __imp__bind;
}

short getuid()
{// addr = 0x0804A4D4
    goto __imp__getuid;
}

int putenv(char* __string)
{// addr = 0x0804A4E4
    goto __imp__putenv;
}

sigpending()
{// addr = 0x0804A4F4
    goto __imp__sigpending;
}

select()
{// addr = 0x0804A504
    goto __imp__select;
}

closedir()
{// addr = 0x0804A514
    goto __imp__closedir;
}

int close(int __fd)
{// addr = 0x0804A524
    goto __imp__close;
}

int fwrite(void* src, int sz, int nitems, struct _IO_FILE* fp)
{// addr = 0x0804A534
    goto __imp__fwrite;
}

rewinddir()
{// addr = 0x0804A544
    goto __imp__rewinddir;
}

frexp()
{// addr = 0x0804A554
    goto __imp__frexp;
}

initgroups()
{// addr = 0x0804A564
    goto __imp__initgroups;
}

int fprintf(struct _IO_FILE* fp, char* format)
{// addr = 0x0804A574
    goto __imp__fprintf;
}

time()
{// addr = 0x0804A584
    goto __imp__time;
}

log10()
{// addr = 0x0804A594
    goto __imp__log10;
}

int execve(char* __path, __caddr_t* __argv, __caddr_t* __envp)
{// addr = 0x0804A5A4
    goto __imp__execve;
}

ftruncate64()
{// addr = 0x0804A5B4
    goto __imp__ftruncate64;
}

void* malloc(int __size)
{// addr = 0x0804A5C4
    goto __imp__malloc;
}

sigprocmask()
{// addr = 0x0804A5D4
    goto __imp__sigprocmask;
}

int chown(char* __file, int __owner, int __group)
{// addr = 0x0804A5E4
    short __group;                          goto __imp__chown;
}

int gethostname(__caddr_t __name, int __len)
{// addr = 0x0804A5F4
    goto __imp__gethostname;
}

atan2()
{// addr = 0x0804A604
    goto __imp__atan2;
}

int fputc(int ch, struct _IO_FILE* fp)
{// addr = 0x0804A614
    goto __imp__fputc;
}

int rmdir(char* __path)
{// addr = 0x0804A624
    goto __imp__rmdir;
}

dlerror()
{// addr = 0x0804A634
    goto __imp__dlerror;
}

getgrgid()
{// addr = 0x0804A644
    goto __imp__getgrgid;
}

int sleep(int __seconds)
{// addr = 0x0804A654
    goto __imp__sleep;
}

sigaddset()
{// addr = 0x0804A664
    goto __imp__sigaddset;
}

int readlink(char* __path, __caddr_t __buf, int __len)
{// addr = 0x0804A674
    goto __imp__readlink;
}

void* memmove(void* __dest, void* __src, int __n)
{// addr = 0x0804A684
    goto __imp__memmove;
}

cfgetospeed()
{// addr = 0x0804A694
    goto __imp__cfgetospeed;
}

getnameinfo()
{// addr = 0x0804A6A4
    goto __imp__getnameinfo;
}

char* strcat(char* __dest, char* __src)
{// addr = 0x0804A6B4
    goto __imp__strcat;
}

send()
{// addr = 0x0804A6C4
    goto __imp__send;
}

__caddr_t getcwd(__caddr_t __buf, int __size)
{// addr = 0x0804A6D4
    goto __imp__getcwd;
}

log()
{// addr = 0x0804A6E4
    goto __imp__log;
}

gethostbyname_r()
{// addr = 0x0804A6F4
    goto __imp__gethostbyname_r;
}

int fork()
{// addr = 0x0804A704
    goto __imp__fork;
}

__fxstat64()
{// addr = 0x0804A714
    goto __imp____fxstat64;
}

setsockopt()
{// addr = 0x0804A724
    goto __imp__setsockopt;
}

tcsetattr()
{// addr = 0x0804A734
    goto __imp__tcsetattr;
}

fcntl()
{// addr = 0x0804A744
    goto __imp__fcntl;
}

getrlimit64()
{// addr = 0x0804A754
    goto __imp__getrlimit64;
}

gmtime()
{// addr = 0x0804A764
    goto __imp__gmtime;
}

int getgroups(int __size, short* __list)
{// addr = 0x0804A774
    goto __imp__getgroups;
}

int link(char* __from, char* __to)
{// addr = 0x0804A784
    goto __imp__link;
}

int pipe(int* __pipedes)
{// addr = 0x0804A794
    goto __imp__pipe;
}

tan()
{// addr = 0x0804A7A4
    goto __imp__tan;
}

getsockopt()
{// addr = 0x0804A7B4
    goto __imp__getsockopt;
}

int setgid()
{// addr = 0x0804A7C4
    short __gid;                            int __rgid;                         
    int __egid;                         
    int __rgid;                         
    int __egid;                         
    goto __imp__setgid;
}

cosh()
{// addr = 0x0804A7D4
    goto __imp__cosh;
}

kill()
{// addr = 0x0804A7E4
    goto __imp__kill;
}

sin()
{// addr = 0x0804A7F4
    goto __imp__sin;
}

getpeername()
{// addr = 0x0804A804
    goto __imp__getpeername;
}

tcsendbreak()
{// addr = 0x0804A814
    goto __imp__tcsendbreak;
}

recvfrom()
{// addr = 0x0804A824
    goto __imp__recvfrom;
}

getpwnam()
{// addr = 0x0804A834
    goto __imp__getpwnam;
}

lseek64()
{// addr = 0x0804A844
    goto __imp__lseek64;
}

getitimer()
{// addr = 0x0804A854
    goto __imp__getitimer;
}

int strcmp(char* __s1, char* __s2)
{// addr = 0x0804A864
    goto __imp__strcmp;
}

__sigsetjmp()
{// addr = 0x0804A874
    goto __imp____sigsetjmp;
}

getservbyname()
{// addr = 0x0804A884
    goto __imp__getservbyname;
}

void exit(int __status)
{// addr = 0x0804A894
    goto __imp__exit;
}

cfsetispeed()
{// addr = 0x0804A8A4
    goto __imp__cfsetispeed;
}

fchmod()
{// addr = 0x0804A8B4
    goto __imp__fchmod;
}

sigsuspend()
{// addr = 0x0804A8C4
    goto __imp__sigsuspend;
}

short getgid()
{// addr = 0x0804A8D4
    goto __imp__getgid;
}

ceil()
{// addr = 0x0804A8E4
    goto __imp__ceil;
}

short geteuid()
{// addr = 0x0804A8F4
    goto __imp__geteuid;
}

_start(
    signed int __eax,                      // r0
    _unknown_ __edx                        // r3
)
{// addr = 0x0804A910
    _unknown_ __ebx;                       // r1
    signed int _t5;                        // _t5
    _unknown_ _t6;                         // _t6
    _unknown_ _t10;                        // _t10
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13

    __edx = __edx;
    _t4 = __eax;
    _pop(__esi);
    __ecx = __esp;
    __esp = __esp & 240;
    _push(__eax);
    _push(__esp);
    _push(__edx);
    _push(__libc_csu_fini);
    _push(__libc_csu_init);
    _push(__ecx);
    _push(_t10);
    _push(main);
    __libc_start_main();
    asm("hlt ");
    0;
    0;
    _push(0);
    _push(_t6);
    __esp = __esp - 4;
    if(completed.5978 == 0) {
        _t4 = dtor_idx.5980;
        _t6 = ( &__DTOR_END__ -  &__DTOR_LIST__ >> 2) - 1;
        if(_t4 < _t6) {
            while(1) {
                _t5 = _t4 + 1;
                dtor_idx.5980 = _t5;
                 *((intOrPtr*)(_t5 * 4 +  &__DTOR_LIST__))();
                _t4 = dtor_idx.5980;
                if(_t4 >= _t6) {
                    break;
                }
            }
        }
        completed.5978 = 1;
    }
    __esp = __esp + 4;
    _pop(__ebx);
    _pop(__ebp);
    return;
}

__do_global_dtors_aux(
    _unknown_ __esi                        // r5
)
{// addr = 0x0804A940
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4
    signed int _t5;                        // _t5
    signed int _t6;                        // _t6
    _unknown_ _t10;                        // _t10
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12

    if(completed.5978 == 0) {
        _t5 = dtor_idx.5980;
        _t10 = ( &__DTOR_END__ -  &__DTOR_LIST__ >> 2) - 1;
        if(_t5 >= _t10) {
L4:
            completed.5978 = 1;
            return;
        }
        while(1) {
            _t6 = _t5 + 1;
            dtor_idx.5980 = _t6;
             *((intOrPtr*)(_t6 * 4 +  &__DTOR_LIST__))();
            _t5 = dtor_idx.5980;
            if(_t5 >= _t10) {
                break;
            }
        }
        goto L4;
    }
    return;
}

frame_dummy()
{// addr = 0x0804A9A0
    _unknown_ __ebp;                       // r6

    __eax = __JCR_LIST__;
    if(__JCR_LIST__ != 0) {
        __eax = 0;
        if(__eax == 0) {
        } else {
             *__esp =  &__JCR_LIST__;
             *__eax();
            return;
        }
    }
    return;
}

caml_curry7(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AA50
    intOrPtr _t8;                          // _t8
    intOrPtr* _t9;                         // _t9

    __ebx = __ebx;
    __ecx = __eax;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t9 = _t8 + 4;
     *((intOrPtr*)(_t9 - 4)) = 4343;
     *_t9 = caml_curry7_1;
     *((intOrPtr*)(_t9 + 4)) = 3;
     *((intOrPtr*)(_t9 + 8)) = __ecx;
     *((intOrPtr*)(_t9 + 12)) = __ebx;
    return;
}

caml_curry7_1(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AA90
    intOrPtr _t8;                          // _t8
    intOrPtr* _t9;                         // _t9

    __ebx = __ebx;
    __ecx = __eax;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t9 = _t8 + 4;
     *((intOrPtr*)(_t9 - 4)) = 4343;
     *_t9 = caml_curry7_2;
     *((intOrPtr*)(_t9 + 4)) = 3;
     *((intOrPtr*)(_t9 + 8)) = __ecx;
     *((intOrPtr*)(_t9 + 12)) = __ebx;
    return;
}

caml_curry7_2(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AAD0
    intOrPtr _t8;                          // _t8
    intOrPtr* _t9;                         // _t9

    __ebx = __ebx;
    __ecx = __eax;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t9 = _t8 + 4;
     *((intOrPtr*)(_t9 - 4)) = 4343;
     *_t9 = caml_curry7_3;
     *((intOrPtr*)(_t9 + 4)) = 3;
     *((intOrPtr*)(_t9 + 8)) = __ecx;
     *((intOrPtr*)(_t9 + 12)) = __ebx;
    return;
}

caml_curry7_3(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AB10
    intOrPtr _t8;                          // _t8
    intOrPtr* _t9;                         // _t9

    __ebx = __ebx;
    __ecx = __eax;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t9 = _t8 + 4;
     *((intOrPtr*)(_t9 - 4)) = 4343;
     *_t9 = caml_curry7_4;
     *((intOrPtr*)(_t9 + 4)) = 3;
     *((intOrPtr*)(_t9 + 8)) = __ecx;
     *((intOrPtr*)(_t9 + 12)) = __ebx;
    return;
}

caml_curry7_4(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AB50
    intOrPtr _t8;                          // _t8
    intOrPtr* _t9;                         // _t9

    __ebx = __ebx;
    __ecx = __eax;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t9 = _t8 + 4;
     *((intOrPtr*)(_t9 - 4)) = 4343;
     *_t9 = caml_curry7_5;
     *((intOrPtr*)(_t9 + 4)) = 3;
     *((intOrPtr*)(_t9 + 8)) = __ecx;
     *((intOrPtr*)(_t9 + 12)) = __ebx;
    return;
}

caml_curry7_5(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AB90
    intOrPtr _t8;                          // _t8
    intOrPtr* _t9;                         // _t9

    __ebx = __ebx;
    __ecx = __eax;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t9 = _t8 + 4;
     *((intOrPtr*)(_t9 - 4)) = 4343;
     *_t9 = caml_curry7_6;
     *((intOrPtr*)(_t9 + 4)) = 3;
     *((intOrPtr*)(_t9 + 8)) = __ecx;
     *((intOrPtr*)(_t9 + 12)) = __ebx;
    return;
}

caml_curry7_6()
{// addr = 0x0804ABD0
    intOrPtr _t22;                         // _t22
    intOrPtr _t23;                         // _t23
    _unknown_ _t25;                        // _t25
    _unknown_ _t26;                        // _t26
    _unknown_ _t29;                        // _t29
    _unknown_ _t31;                        // _t31
    intOrPtr _t32;                         // _t32
    _unknown_ _t33;                        // _t33
    _unknown_ _t36;                        // _t36
    _unknown_ _t37;                        // _t37
    _unknown_ _t40;                        // _t40
    _unknown_ _t44;                        // _t44

     *((intOrPtr*)(__esp + 4)) = _t22;
    _t37 = _t26;
    _t23 =  *((intOrPtr*)(_t37 + 12));
    _t32 =  *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t23 + 12)) + 12)) + 12)) + 12)) + 12));
     *((intOrPtr*)(__esp + 8)) = _t32;
     *__esp =  *((intOrPtr*)(_t37 + 8));
     *((intOrPtr*)(__esp + 16)) =  *((intOrPtr*)(_t23 + 8));
     *((intOrPtr*)(__esp + 12)) =  *((intOrPtr*)(_t32 + 8));
    caml_extra_params =  *((intOrPtr*)(__esp + 4));
     *134693344 =  *((intOrPtr*)(__esp + 8));
    __esp = __esp + 20;
    goto __ebp;
}

caml_curry6(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AC40
    intOrPtr _t8;                          // _t8
    intOrPtr* _t9;                         // _t9

    __ebx = __ebx;
    __ecx = __eax;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t9 = _t8 + 4;
     *((intOrPtr*)(_t9 - 4)) = 4343;
     *_t9 = caml_curry6_1;
     *((intOrPtr*)(_t9 + 4)) = 3;
     *((intOrPtr*)(_t9 + 8)) = __ecx;
     *((intOrPtr*)(_t9 + 12)) = __ebx;
    return;
}

caml_curry6_1(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AC80
    intOrPtr _t8;                          // _t8
    intOrPtr* _t9;                         // _t9

    __ebx = __ebx;
    __ecx = __eax;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t9 = _t8 + 4;
     *((intOrPtr*)(_t9 - 4)) = 4343;
     *_t9 = caml_curry6_2;
     *((intOrPtr*)(_t9 + 4)) = 3;
     *((intOrPtr*)(_t9 + 8)) = __ecx;
     *((intOrPtr*)(_t9 + 12)) = __ebx;
    return;
}

caml_curry6_2(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804ACC0
    intOrPtr _t8;                          // _t8
    intOrPtr* _t9;                         // _t9

    __ebx = __ebx;
    __ecx = __eax;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t9 = _t8 + 4;
     *((intOrPtr*)(_t9 - 4)) = 4343;
     *_t9 = caml_curry6_3;
     *((intOrPtr*)(_t9 + 4)) = 3;
     *((intOrPtr*)(_t9 + 8)) = __ecx;
     *((intOrPtr*)(_t9 + 12)) = __ebx;
    return;
}

caml_curry6_3(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AD00
    intOrPtr _t8;                          // _t8
    intOrPtr* _t9;                         // _t9

    __ebx = __ebx;
    __ecx = __eax;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t9 = _t8 + 4;
     *((intOrPtr*)(_t9 - 4)) = 4343;
     *_t9 = caml_curry6_4;
     *((intOrPtr*)(_t9 + 4)) = 3;
     *((intOrPtr*)(_t9 + 8)) = __ecx;
     *((intOrPtr*)(_t9 + 12)) = __ebx;
    return;
}

caml_curry6_4(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AD40
    intOrPtr _t8;                          // _t8
    intOrPtr* _t9;                         // _t9

    __ebx = __ebx;
    __ecx = __eax;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t9 = _t8 + 4;
     *((intOrPtr*)(_t9 - 4)) = 4343;
     *_t9 = caml_curry6_5;
     *((intOrPtr*)(_t9 + 4)) = 3;
     *((intOrPtr*)(_t9 + 8)) = __ecx;
     *((intOrPtr*)(_t9 + 12)) = __ebx;
    return;
}

caml_curry6_5()
{// addr = 0x0804AD80
    intOrPtr _t18;                         // _t18
    _unknown_ _t20;                        // _t20
    _unknown_ _t21;                        // _t21
    _unknown_ _t23;                        // _t23
    _unknown_ _t25;                        // _t25
    intOrPtr _t26;                         // _t26
    _unknown_ _t28;                        // _t28
    _unknown_ _t30;                        // _t30
    _unknown_ _t32;                        // _t32
    _unknown_ _t35;                        // _t35

     *__esp = _t18;
    _t26 =  *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t21 + 12)) + 12)) + 12)) + 12)) + 12));
     *((intOrPtr*)(__esp + 4)) = _t26;
     *((intOrPtr*)(__esp + 12)) =  *((intOrPtr*)(_t21 + 8));
     *((intOrPtr*)(__esp + 8)) =  *((intOrPtr*)(_t26 + 8));
    caml_extra_params =  *((intOrPtr*)(__esp + 4));
    __esp = __esp + 16;
    goto __ebp;
}

caml_curry5(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804ADD0
    intOrPtr _t8;                          // _t8
    intOrPtr* _t9;                         // _t9

    __ebx = __ebx;
    __ecx = __eax;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t9 = _t8 + 4;
     *((intOrPtr*)(_t9 - 4)) = 4343;
     *_t9 = caml_curry5_1;
     *((intOrPtr*)(_t9 + 4)) = 3;
     *((intOrPtr*)(_t9 + 8)) = __ecx;
     *((intOrPtr*)(_t9 + 12)) = __ebx;
    return;
}

caml_curry5_1(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AE10
    intOrPtr _t8;                          // _t8
    intOrPtr* _t9;                         // _t9

    __ebx = __ebx;
    __ecx = __eax;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t9 = _t8 + 4;
     *((intOrPtr*)(_t9 - 4)) = 4343;
     *_t9 = caml_curry5_2;
     *((intOrPtr*)(_t9 + 4)) = 3;
     *((intOrPtr*)(_t9 + 8)) = __ecx;
     *((intOrPtr*)(_t9 + 12)) = __ebx;
    return;
}

caml_curry5_2(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AE50
    intOrPtr _t8;                          // _t8
    intOrPtr* _t9;                         // _t9

    __ebx = __ebx;
    __ecx = __eax;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t9 = _t8 + 4;
     *((intOrPtr*)(_t9 - 4)) = 4343;
     *_t9 = caml_curry5_3;
     *((intOrPtr*)(_t9 + 4)) = 3;
     *((intOrPtr*)(_t9 + 8)) = __ecx;
     *((intOrPtr*)(_t9 + 12)) = __ebx;
    return;
}

caml_curry5_3(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AE90
    intOrPtr _t8;                          // _t8
    intOrPtr* _t9;                         // _t9

    __ebx = __ebx;
    __ecx = __eax;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t9 = _t8 + 4;
     *((intOrPtr*)(_t9 - 4)) = 4343;
     *_t9 = caml_curry5_4;
     *((intOrPtr*)(_t9 + 4)) = 3;
     *((intOrPtr*)(_t9 + 8)) = __ecx;
     *((intOrPtr*)(_t9 + 12)) = __ebx;
    return;
}

caml_curry5_4()
{// addr = 0x0804AED0
    _unknown_ _t10;                        // _t10
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17
    _unknown_ _t18;                        // _t18

    goto __ebp;
}

caml_curry4(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AEF0
    intOrPtr _t8;                          // _t8
    intOrPtr* _t9;                         // _t9

    __ebx = __ebx;
    __ecx = __eax;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t9 = _t8 + 4;
     *((intOrPtr*)(_t9 - 4)) = 4343;
     *_t9 = caml_curry4_1;
     *((intOrPtr*)(_t9 + 4)) = 3;
     *((intOrPtr*)(_t9 + 8)) = __ecx;
     *((intOrPtr*)(_t9 + 12)) = __ebx;
    return;
}

caml_curry4_1(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AF30
    intOrPtr _t8;                          // _t8
    intOrPtr* _t9;                         // _t9

    __ebx = __ebx;
    __ecx = __eax;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t9 = _t8 + 4;
     *((intOrPtr*)(_t9 - 4)) = 4343;
     *_t9 = caml_curry4_2;
     *((intOrPtr*)(_t9 + 4)) = 3;
     *((intOrPtr*)(_t9 + 8)) = __ecx;
     *((intOrPtr*)(_t9 + 12)) = __ebx;
    return;
}

caml_curry4_2(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AF70
    intOrPtr _t8;                          // _t8
    intOrPtr* _t9;                         // _t9

    __ebx = __ebx;
    __ecx = __eax;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t9 = _t8 + 4;
     *((intOrPtr*)(_t9 - 4)) = 4343;
     *_t9 = caml_curry4_3;
     *((intOrPtr*)(_t9 + 4)) = 3;
     *((intOrPtr*)(_t9 + 8)) = __ecx;
     *((intOrPtr*)(_t9 + 12)) = __ebx;
    return;
}

caml_curry4_3()
{// addr = 0x0804AFB0
    _unknown_ _t8;                         // _t8
    _unknown_ _t9;                         // _t9
    _unknown_ _t10;                        // _t10
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14

    goto __edi;
}

caml_curry3(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AFD0
    intOrPtr _t8;                          // _t8
    intOrPtr* _t9;                         // _t9

    __ebx = __ebx;
    __ecx = __eax;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t9 = _t8 + 4;
     *((intOrPtr*)(_t9 - 4)) = 4343;
     *_t9 = caml_curry3_1;
     *((intOrPtr*)(_t9 + 4)) = 3;
     *((intOrPtr*)(_t9 + 8)) = __ecx;
     *((intOrPtr*)(_t9 + 12)) = __ebx;
    return;
}

caml_curry3_1(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804B010
    intOrPtr _t8;                          // _t8
    intOrPtr* _t9;                         // _t9

    __ebx = __ebx;
    __ecx = __eax;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t9 = _t8 + 4;
     *((intOrPtr*)(_t9 - 4)) = 4343;
     *_t9 = caml_curry3_2;
     *((intOrPtr*)(_t9 + 4)) = 3;
     *((intOrPtr*)(_t9 + 8)) = __ecx;
     *((intOrPtr*)(_t9 + 12)) = __ebx;
    return;
}

caml_curry3_2()
{// addr = 0x0804B050
    _unknown_ _t6;                         // _t6
    _unknown_ _t8;                         // _t8
    _unknown_ _t9;                         // _t9
    _unknown_ _t10;                        // _t10

    goto ( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t9 + 12)) + 12)) + 8)));
}

caml_curry2(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804B070
    intOrPtr _t8;                          // _t8
    intOrPtr* _t9;                         // _t9

    __ebx = __ebx;
    __ecx = __eax;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t9 = _t8 + 4;
     *((intOrPtr*)(_t9 - 4)) = 4343;
     *_t9 = caml_curry2_1;
     *((intOrPtr*)(_t9 + 4)) = 3;
     *((intOrPtr*)(_t9 + 8)) = __ecx;
     *((intOrPtr*)(_t9 + 12)) = __ebx;
    return;
}

caml_curry2_1()
{// addr = 0x0804B0B0
    _unknown_ _t4;                         // _t4
    _unknown_ _t5;                         // _t5
    _unknown_ _t6;                         // _t6
    _unknown_ _t7;                         // _t7

    goto ( *((intOrPtr*)( *((intOrPtr*)(_t6 + 12)) + 8)));
}

caml_tuplify2()
{// addr = 0x0804B0C0
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4
    _unknown_ _t5;                         // _t5
    _unknown_ _t6;                         // _t6

    goto ( *((intOrPtr*)(_t5 + 8)));
}

caml_tuplify3()
{// addr = 0x0804B0D0
    _unknown_ _t4;                         // _t4
    _unknown_ _t5;                         // _t5
    _unknown_ _t6;                         // _t6
    _unknown_ _t7;                         // _t7

    goto ( *((intOrPtr*)(_t6 + 8)));
}

caml_apply3()
{// addr = 0x0804B0E0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _t5;                         // _t5
    _unknown_ _t7;                         // _t7
    intOrPtr _t8;                          // _t8
    _unknown_ _t9;                         // _t9
    intOrPtr _t12;                         // _t12
    _unknown_ _t15;                        // _t15
    _unknown_ _t17;                        // _t17

    if( *((intOrPtr*)(__edx + 4)) != 7) {
        _v4 = _t12;
         *__esp = _t8;
         *((intOrPtr*)( *__edx))();
         *((intOrPtr*)( *_t5))();
        __esp = __esp + 8;
        goto __ecx;
    }
    __esp = __esp + 8;
    goto __esi;
}

caml_apply2()
{// addr = 0x0804B130
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4
    intOrPtr _t5;                          // _t5
    _unknown_ _t6;                         // _t6
    intOrPtr* _t8;                         // _t8
    _unknown_ _t9;                         // _t9
    _unknown_ _t12;                        // _t12

    if( *((intOrPtr*)(_t8 + 4)) != 5) {
         *__esp = _t5;
         *((intOrPtr*)( *_t8))();
        __esp = __esp + 4;
        goto __ecx;
    }
    __esp = __esp + 4;
    goto __edx;
}

camlStd_exit__entry()
{// addr = 0x0804B170
    _unknown_ _t2;                         // _t2
    _unknown_ _t3;                         // _t3

     *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *134678880))))))();
    return;
}

camlSource__code_begin()
{// addr = 0x0804B190
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    camlPervasives__print_endline_1274();
    return 1;
}

camlUnix__fun_2828(
    signed int __eax,                      // r0
    _unknown_ __ebx                        // r1
)
{// addr = 0x0804B200
    signed int _t9;                        // _t9
    _unknown_ _t10;                        // _t10
    _unknown_ _t12;                        // _t12
    intOrPtr _t14;                         // _t14
    intOrPtr* _t15;                        // _t15
    _unknown_ _t16;                        // _t16
    _unknown_ _t19;                        // _t19
    intOrPtr _t22;                         // _t22

    __ebx = __ebx;
    _t9 = __eax;
    if((_t9 & 1) == 0) {
        __eflags = ( *(_t9 - 4) & 255) - 1;
        if(__eflags < 0) {
            goto L9;
        } else {
            if(__eflags > 0) {
                 *((intOrPtr*)( *((intOrPtr*)(__ebx + 12)))) =  *_t9;
                return 1;
            } else {
                _t22 =  *_t9;
                while(1) {
                    _t14 = caml_young_ptr - 8;
                    caml_young_ptr = _t14;
                    __eflags = _t14 - caml_young_limit;
                    if(_t14 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                _t15 = _t14 + 4;
                 *((intOrPtr*)(_t15 - 4)) = 1024;
                 *_t15 = _t22;
                caml_modify(__ebx,  *((intOrPtr*)(__ebx + 8)), _t15);
                return 1;
            }
        }
    } else {
        if(_t9 >> 1 < 2) {
L9:
            return 1;
        } else {
             *((intOrPtr*)( *((intOrPtr*)(__ebx + 16)))) = 3;
            return 1;
        }
    }
}

camlUnix__get_port_1739(
    intOrPtr __eax,                        // r0
    intOrPtr __ecx                         // r2
)
{// addr = 0x0804B280
    intOrPtr _v0;                          // _cfa_0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _t33;                        // _t33
    _unknown_ _t34;                        // _t34
    intOrPtr _t37;                         // _t37
    intOrPtr* _t39;                        // _t39
    _unknown_ _t40;                        // _t40
    intOrPtr _t46;                         // _t46
    intOrPtr* _t48;                        // _t48
    _unknown_ _t49;                        // _t49
    intOrPtr _t51;                         // _t51
    intOrPtr* _t52;                        // _t52
    intOrPtr _t53;                         // _t53
    intOrPtr* _t55;                        // _t55
    intOrPtr* _t57;                        // _t57
    intOrPtr* _t58;                        // _t58
    intOrPtr _t61;                         // _t61
    intOrPtr _t63;                         // _t63
    intOrPtr _t64;                         // _t64
    intOrPtr _t65;                         // _t65
    _unknown_ _t66;                        // _t66
    intOrPtr _t67;                         // _t67
    _unknown_ _t68;                        // _t68
    _unknown_ _t69;                        // _t69

    _t67 = __eax;
    _t64 = __ecx;
    _t33 = caml_string_equal( *((intOrPtr*)(_t64 + 12)),  &camlUnix__215);
    if(_t33 == 1) {
        _v8 = _t64;
         *__esp = _t53;
        _v4 = _t67;
        L11();
        if( *_t33 !=  &caml_exn_Failure) {
            caml_raise_exn(_t33);
            _t65 = _t64;
            _push(caml_exception_pointer);
            caml_exception_pointer = __esp;
            _push( *((intOrPtr*)(_t65 + 12)));
            caml_c_call();
            __esp = __esp + 4;
            _t61 = caml_int_of_string;
            while(1) {
                _t37 = caml_young_ptr - 24;
                caml_young_ptr = _t37;
                if(_t37 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t55 = _t37 + 4;
             *((intOrPtr*)(_t55 - 4)) = 2048;
             *_t55 = _v0;
             *((intOrPtr*)(_t55 + 4)) = _t61;
            _t39 = _t55 + 12;
             *((intOrPtr*)(_t39 - 4)) = 2048;
             *_t39 = _t55;
             *((intOrPtr*)(_t39 + 4)) = 1;
            _pop(caml_exception_pointer);
            __esp = __esp + 4;
            return;
            goto L17;
        }
        L7();
        if( *_t33 !=  &caml_exn_Not_found) {
            caml_raise_exn(_t33);
            _push(caml_exception_pointer);
            caml_exception_pointer = __esp;
            caml_c_call( *((intOrPtr*)(_v4 + 12)), _v8);
            _t63 =  *((intOrPtr*)(unix_getservbyname + 8));
            while(1) {
                _t46 = caml_young_ptr - 24;
                caml_young_ptr = _t46;
                if(_t46 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t57 = _t46 + 4;
             *((intOrPtr*)(_t57 - 4)) = 2048;
             *_t57 = _v0;
             *((intOrPtr*)(_t57 + 4)) = _t63;
            _t48 = _t57 + 12;
             *((intOrPtr*)(_t48 - 4)) = 2048;
             *_t48 = _t57;
             *((intOrPtr*)(_t48 + 4)) = 1;
            _pop(caml_exception_pointer);
            __esp = __esp + 4;
            return;
            goto L17;
        }
        return;
    } else {
        while(1) {
            _t51 = caml_young_ptr - 24;
            caml_young_ptr = _t51;
            if(_t51 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t58 = _t51 + 4;
         *((intOrPtr*)(_t58 - 4)) = 2048;
         *_t58 = _t67;
         *((intOrPtr*)(_t58 + 4)) = 1;
        _t52 = _t58 + 12;
         *((intOrPtr*)(_t52 - 4)) = 2048;
         *_t52 = _t58;
         *((intOrPtr*)(_t52 + 4)) = 1;
        return;
    }
L17:
}

L0804B330(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{
    intOrPtr _t16;                         // _t16
    intOrPtr* _t18;                        // _t18

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_c_call( *((intOrPtr*)(_a8 + 12)), _a4);
    __ecx =  *((intOrPtr*)(unix_getservbyname + 8));
    while(1) {
        _t16 = caml_young_ptr - 24;
        caml_young_ptr = _t16;
        if(_t16 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    __ebx = _t16 + 4;
     *((intOrPtr*)(__ebx - 4)) = 2048;
     *__ebx = _a12;
     *((intOrPtr*)(__ebx + 4)) = __ecx;
    _t18 = __ebx + 12;
     *((intOrPtr*)(_t18 - 4)) = 2048;
     *_t18 = __ebx;
     *((intOrPtr*)(_t18 + 4)) = 1;
    _pop(caml_exception_pointer);
    __esp = __esp + 12;
    return;
}

L0804B3C0(
    intOrPtr _a12                          // _cfa_c
)
{
    intOrPtr _t11;                         // _t11
    intOrPtr* _t13;                        // _t13

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    _push( *((intOrPtr*)(__edi + 12)));
    caml_c_call();
    __esp = __esp + 4;
    __ecx = caml_int_of_string;
    while(1) {
        _t11 = caml_young_ptr - 24;
        caml_young_ptr = _t11;
        if(_t11 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    __ebx = _t11 + 4;
     *((intOrPtr*)(__ebx - 4)) = 2048;
     *__ebx = _a12;
     *((intOrPtr*)(__ebx + 4)) = __ecx;
    _t13 = __ebx + 12;
     *((intOrPtr*)(_t13 - 4)) = 2048;
     *_t13 = __ebx;
     *((intOrPtr*)(_t13 + 4)) = 1;
    _pop(caml_exception_pointer);
    __esp = __esp + 12;
    return;
}

camlUnix__fun_2833(
    intOrPtr __eax,                        // r0
    _unknown_ __ebx                        // r1
)
{// addr = 0x0804B450
    intOrPtr _t7;                          // _t7
    intOrPtr* _t8;                         // _t8
    _unknown_ _t9;                         // _t9

    _t9 = __ebx;
    __ecx = __eax;
    while(1) {
        _t7 = caml_young_ptr - 12;
        caml_young_ptr = _t7;
        if(_t7 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t8 = _t7 + 4;
     *((intOrPtr*)(_t8 - 4)) = 2048;
     *_t8 = __ecx;
     *((intOrPtr*)(_t8 + 4)) =  *((intOrPtr*)( *((intOrPtr*)(_t9 + 8))));
    return;
}

camlUnix__fun_2836(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx,                        // r1
    _unknown_ __ecx                        // r2
)
{// addr = 0x0804B490
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _t20;                         // _t20
    intOrPtr* _t21;                        // _t21
    _unknown_ _t22;                        // _t22
    intOrPtr _t27;                         // _t27
    intOrPtr* _t28;                        // _t28
    intOrPtr _t29;                         // _t29
    intOrPtr* _t30;                        // _t30
    _unknown_ _t31;                        // _t31
    _unknown_ _t32;                        // _t32
    _unknown_ _t34;                        // _t34
    intOrPtr _t36;                         // _t36
    intOrPtr* _t38;                        // _t38

    _t34 = __ecx;
    _t29 = __ebx;
    __esi = __eax;
    while(1) {
        _t20 = caml_young_ptr - 28;
        caml_young_ptr = _t20;
        if(_t20 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t21 = _t20 + 4;
     *((intOrPtr*)(_t21 - 4)) = 6391;
     *_t21 = caml_tuplify2;
     *((intOrPtr*)(_t21 + 4)) = -3;
     *((intOrPtr*)(_t21 + 8)) =  &camlUnix__code_begin;
     *((intOrPtr*)(_t21 + 12)) =  *((intOrPtr*)(_t34 + 12));
     *((intOrPtr*)(_t21 + 16)) = __esi;
     *((intOrPtr*)(_t21 + 20)) = _t29;
    _t30 =  *((intOrPtr*)(_t34 + 16));
    __esp = __esp - 12;
    _t38 = _t21;
    if(_t30 == 1) {
        __esp = __esp + 12;
        return;
    } else {
         *__esp = _t38;
        _v8 =  *((intOrPtr*)(_t30 + 4));
         *((intOrPtr*)( *_t38))();
        _v4 =  *_t30;
        L4();
        _t36 =  *__esp;
        while(1) {
            _t27 = caml_young_ptr - 12;
            caml_young_ptr = _t27;
            if(_t27 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t28 = _t27 + 4;
         *((intOrPtr*)(_t28 - 4)) = 2048;
         *_t28 = _v4;
         *((intOrPtr*)(_t28 + 4)) = _t36;
        __esp = __esp + 12;
        return;
    }
}

camlUnix__fun_2857()
{// addr = 0x0804B4E0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2863()
{// addr = 0x0804B4F0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2562()
{// addr = 0x0804B500
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2564()
{// addr = 0x0804B510
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2566()
{// addr = 0x0804B520
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2568()
{// addr = 0x0804B530
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2570()
{// addr = 0x0804B540
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2572()
{// addr = 0x0804B550
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(__ecx);
    caml_c_call(_t1, __ebx);
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2574()
{// addr = 0x0804B570
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2576()
{// addr = 0x0804B580
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2578()
{// addr = 0x0804B590
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2580()
{// addr = 0x0804B5A0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2582()
{// addr = 0x0804B5B0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2584()
{// addr = 0x0804B5C0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2586()
{// addr = 0x0804B5D0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2588()
{// addr = 0x0804B5E0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2590()
{// addr = 0x0804B5F0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2592()
{// addr = 0x0804B600
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2594()
{// addr = 0x0804B610
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2596()
{// addr = 0x0804B620
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2598()
{// addr = 0x0804B630
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2600()
{// addr = 0x0804B640
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2602()
{// addr = 0x0804B650
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2604()
{// addr = 0x0804B660
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(__ecx);
    caml_c_call(_t1, __ebx);
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2606()
{// addr = 0x0804B680
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(__ecx);
    caml_c_call(_t1, __ebx);
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2608()
{// addr = 0x0804B6A0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2610()
{// addr = 0x0804B6B0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2612()
{// addr = 0x0804B6C0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2614()
{// addr = 0x0804B6D0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2616()
{// addr = 0x0804B6E0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2618()
{// addr = 0x0804B6F0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2620()
{// addr = 0x0804B700
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2622()
{// addr = 0x0804B710
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2624()
{// addr = 0x0804B720
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2626()
{// addr = 0x0804B730
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2628()
{// addr = 0x0804B740
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2630()
{// addr = 0x0804B750
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2632()
{// addr = 0x0804B760
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2634()
{// addr = 0x0804B770
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2636()
{// addr = 0x0804B780
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2638()
{// addr = 0x0804B790
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2640()
{// addr = 0x0804B7A0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2642()
{// addr = 0x0804B7B0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2644()
{// addr = 0x0804B7C0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(__ecx);
    caml_c_call(_t1, __ebx);
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2646()
{// addr = 0x0804B7E0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2648()
{// addr = 0x0804B7F0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2650()
{// addr = 0x0804B800
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2652()
{// addr = 0x0804B810
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2654()
{// addr = 0x0804B820
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2656()
{// addr = 0x0804B830
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2658()
{// addr = 0x0804B840
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2660()
{// addr = 0x0804B850
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2662()
{// addr = 0x0804B860
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2664()
{// addr = 0x0804B870
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2666()
{// addr = 0x0804B880
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2668()
{// addr = 0x0804B890
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2670()
{// addr = 0x0804B8A0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(__ecx);
    caml_c_call(_t1, __ebx);
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2672()
{// addr = 0x0804B8C0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(__ecx, __edx);
    return;
}

camlUnix__fun_2674()
{// addr = 0x0804B8E0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2676()
{// addr = 0x0804B8F0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2678()
{// addr = 0x0804B900
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2680()
{// addr = 0x0804B910
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2682()
{// addr = 0x0804B920
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2684()
{// addr = 0x0804B930
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2686()
{// addr = 0x0804B940
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2688()
{// addr = 0x0804B950
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2690()
{// addr = 0x0804B960
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2692()
{// addr = 0x0804B970
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2694()
{// addr = 0x0804B980
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2696()
{// addr = 0x0804B990
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2698()
{// addr = 0x0804B9A0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2700()
{// addr = 0x0804B9B0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2702()
{// addr = 0x0804B9C0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2704()
{// addr = 0x0804B9D0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2706()
{// addr = 0x0804B9E0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2708()
{// addr = 0x0804B9F0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2710()
{// addr = 0x0804BA00
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2712()
{// addr = 0x0804BA10
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2714()
{// addr = 0x0804BA20
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2716()
{// addr = 0x0804BA30
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(__ecx);
    caml_c_call(_t1, __ebx);
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2718()
{// addr = 0x0804BA50
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(__ecx);
    caml_c_call(_t1, __ebx);
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2720()
{// addr = 0x0804BA70
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2722()
{// addr = 0x0804BA80
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2724()
{// addr = 0x0804BA90
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2726()
{// addr = 0x0804BAA0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2728()
{// addr = 0x0804BAB0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2730()
{// addr = 0x0804BAC0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2732()
{// addr = 0x0804BAD0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2734()
{// addr = 0x0804BAE0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2736()
{// addr = 0x0804BAF0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2738()
{// addr = 0x0804BB00
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2740()
{// addr = 0x0804BB10
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2742()
{// addr = 0x0804BB20
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(__ecx);
    caml_c_call(_t1, __ebx);
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2744()
{// addr = 0x0804BB40
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2746()
{// addr = 0x0804BB50
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2748()
{// addr = 0x0804BB60
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2750()
{// addr = 0x0804BB70
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2752()
{// addr = 0x0804BB80
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2754()
{// addr = 0x0804BB90
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(__ecx);
    caml_c_call(_t1, __ebx);
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2756()
{// addr = 0x0804BBB0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2758()
{// addr = 0x0804BBC0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2760()
{// addr = 0x0804BBD0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2762()
{// addr = 0x0804BBE0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2764()
{// addr = 0x0804BBF0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2766()
{// addr = 0x0804BC00
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2768()
{// addr = 0x0804BC10
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(__ecx);
    caml_c_call(_t1, __ebx);
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2770()
{// addr = 0x0804BC30
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2772()
{// addr = 0x0804BC40
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(__ecx);
    caml_c_call(_t1, __ebx);
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2774()
{// addr = 0x0804BC60
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2776()
{// addr = 0x0804BC70
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2778()
{// addr = 0x0804BC80
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2780()
{// addr = 0x0804BC90
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2782()
{// addr = 0x0804BCA0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__handle_unix_error_1171(
    intOrPtr* __esp                        // r7
)
{// addr = 0x0804BCB0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _t28;                        // _t28
    intOrPtr* _t29;                        // _t29
    _unknown_ _t30;                        // _t30
    intOrPtr _t36;                         // _t36
    intOrPtr* _t37;                        // _t37
    _unknown_ _t38;                        // _t38
    _unknown_ _t40;                        // _t40
    _unknown_ _t42;                        // _t42
    _unknown_ _t44;                        // _t44
    _unknown_ _t46;                        // _t46
    intOrPtr _t47;                         // _t47
    _unknown_ _t49;                        // _t49
    _unknown_ _t51;                        // _t51
    _unknown_ _t52;                        // _t52
    _unknown_ _t54;                        // _t54
    _unknown_ _t56;                        // _t56
    _unknown_ _t58;                        // _t58
    _unknown_ _t60;                        // _t60
    _unknown_ _t62;                        // _t62
    intOrPtr* _t63;                        // _t63
    _unknown_ _t65;                        // _t65
    intOrPtr* _t68;                        // _t68
    char* _t69;                            // _t69
    intOrPtr _t84;                         // _t84
    _unknown_ _t88;                        // _t88
    _unknown_ _t89;                        // _t89
    _unknown_ _t90;                        // _t90
    _unknown_ _t92;                        // _t92
    _unknown_ _t93;                        // _t93
    _unknown_ _t94;                        // _t94

    __esp = __esp;
    __esp = __esp - 12;
    __edx = _t28;
    _t29 = _t63;
    L6();
    _t84 = camlUnix;
    if( *_t29 != _t84) {
        caml_raise_exn(_t29);
        _push(caml_exception_pointer);
        caml_exception_pointer = __esp;
         *((intOrPtr*)( *__edx))();
        _pop(caml_exception_pointer);
        __esp = __esp + 4;
        __esp = __esp + 12;
        return;
    } else {
        _v4 =  *((intOrPtr*)(_t29 + 12));
         *__esp =  *((intOrPtr*)(_t29 + 8));
        _v8 =  *((intOrPtr*)(_t29 + 4));
        _t68 = camlSys;
        _t33 =  *(_t68 - 4) >> 9;
        if( *(_t68 - 4) >> 9 <= 1) {
            caml_ml_array_bound_error();
            if(_t84 < 1 || __edx < 1 || _t84 > (-1 + ( *(_t68 - 4) >> 10) * 4 - ( *(_t68 + -1 + ( *(_t68 - 4) >> 10) * 4) & 255) << 1) - __edx + 2) {
                _t69 = "Unix.read";
                while(1) {
                    _t36 = caml_young_ptr - 12;
                    caml_young_ptr = _t36;
                    if(_t36 >= caml_young_limit) {
                        _t37 = _t36 + 4;
                         *((intOrPtr*)(_t37 - 4)) = 2048;
                         *_t37 =  &caml_exn_Invalid_argument;
                         *((intOrPtr*)(_t37 + 4)) = _t69;
                        caml_raise_exn(_t37);
                    }
                    goto L16;
                }
            }
            caml_c_call(_t84, __edx);
            return;
            goto L18;
        }
        camlPervasives__output_string_1191( *134678648,  *_t68);
        camlPervasives__output_string_1191( *134678648,  &camlUnix__214);
        camlPervasives__output_string_1191( *134678648,  *__esp);
        camlPervasives__output_string_1191( *134678648, "" failed");
        _t47 = _v4;
        if(-1 + ( *(_t47 - 4) >> 10) * 4 - ( *(_t47 + -1 + ( *(_t47 - 4) >> 10) * 4) & 255) + -1 + ( *(_t47 - 4) >> 10) * 4 - ( *(_t47 + -1 + ( *(_t47 - 4) >> 10) * 4) & 255) + 1 > 1) {
            _v4 = _t47;
            camlPervasives__output_string_1191( *134678648,  &camlUnix__212);
            camlPervasives__output_string_1191( *134678648, _v4);
            camlPervasives__output_string_1191( *134678648,  &camlUnix__211);
        }
        camlPervasives__output_string_1191( *134678648,  &camlUnix__210);
        _push(_v8);
        caml_c_call();
        __esp = __esp + 4;
        camlPervasives__prerr_endline_1285();
        __esp = __esp + 12;
        __esp = __esp - 4;
         *__esp = 5;
         *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *134678880))))))();
        _push( *__esp);
        caml_c_call();
        __esp = __esp + 4;
        __esp = __esp + 4;
        return;
    }
L18:
}

L0804BDC0(
    _unknown_ __edx                        // r3
)
{
    __edx = __edx;
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
     *((intOrPtr*)( *((intOrPtr*)(__edx))))();
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    __esp = __esp + 12;
    return;
}

camlUnix__read_1237()
{// addr = 0x0804BDF0
    _unknown_ _t8;                         // _t8
    intOrPtr _t11;                         // _t11
    intOrPtr* _t12;                        // _t12
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    char* _t16;                            // _t16

    if(__ecx < 1 || __edx < 1 || __ecx > (-1 + ( *(_t15 - 4) >> 10) * 4 - ( *(_t15 + -1 + ( *(_t15 - 4) >> 10) * 4) & 255) << 1) - __edx + 2) {
        _t16 = "Unix.read";
        while(1) {
            _t11 = caml_young_ptr - 12;
            caml_young_ptr = _t11;
            if(_t11 >= caml_young_limit) {
                _t12 = _t11 + 4;
                 *((intOrPtr*)(_t12 - 4)) = 2048;
                 *_t12 =  &caml_exn_Invalid_argument;
                 *((intOrPtr*)(_t12 + 4)) = _t16;
                caml_raise_exn(_t12);
            }
            caml_call_gc(__esp);
        }
    }
    caml_c_call(__ecx, __edx);
    return;
}

camlUnix__write_1242()
{// addr = 0x0804BE40
    _unknown_ _t8;                         // _t8
    intOrPtr _t11;                         // _t11
    intOrPtr* _t12;                        // _t12
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    char* _t16;                            // _t16

    if(__ecx < 1 || __edx < 1 || __ecx > (-1 + ( *(_t15 - 4) >> 10) * 4 - ( *(_t15 + -1 + ( *(_t15 - 4) >> 10) * 4) & 255) << 1) - __edx + 2) {
        _t16 = "Unix.write";
        while(1) {
            _t11 = caml_young_ptr - 12;
            caml_young_ptr = _t11;
            if(_t11 >= caml_young_limit) {
                _t12 = _t11 + 4;
                 *((intOrPtr*)(_t12 - 4)) = 2048;
                 *_t12 =  &caml_exn_Invalid_argument;
                 *((intOrPtr*)(_t12 + 4)) = _t16;
                caml_raise_exn(_t12);
            }
            caml_call_gc(__esp);
        }
    }
    caml_c_call(__ecx, __edx);
    return;
}

camlUnix__single_write_1247()
{// addr = 0x0804BE90
    _unknown_ _t8;                         // _t8
    intOrPtr _t11;                         // _t11
    intOrPtr* _t12;                        // _t12
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    char* _t16;                            // _t16

    if(__ecx < 1 || __edx < 1 || __ecx > (-1 + ( *(_t15 - 4) >> 10) * 4 - ( *(_t15 + -1 + ( *(_t15 - 4) >> 10) * 4) & 255) << 1) - __edx + 2) {
        _t16 = "Unix.single_write";
        while(1) {
            _t11 = caml_young_ptr - 12;
            caml_young_ptr = _t11;
            if(_t11 >= caml_young_limit) {
                _t12 = _t11 + 4;
                 *((intOrPtr*)(_t12 - 4)) = 2048;
                 *_t12 =  &caml_exn_Invalid_argument;
                 *((intOrPtr*)(_t12 + 4)) = _t16;
                caml_raise_exn(_t12);
            }
            caml_call_gc(__esp);
        }
    }
    caml_c_call(__ecx, __edx);
    return;
}

camlUnix__fun_2804()
{// addr = 0x0804BEE0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2802()
{// addr = 0x0804BEF0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2800()
{// addr = 0x0804BF00
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__fun_2798()
{// addr = 0x0804BF10
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2796()
{// addr = 0x0804BF20
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlUnix__fun_2794()
{// addr = 0x0804BF30
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(__ecx);
    caml_c_call(_t1, __ebx);
    __esp = __esp + 4;
    return;
}

camlUnix__try_set_close_on_exec_1366(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BF50
    _unknown_ _t4;                         // _t4
    _unknown_ _t5;                         // _t5
    _unknown_ _t6;                         // _t6
    _unknown_ _t7;                         // _t7
    _unknown_ _t8;                         // _t8
    _unknown_ _t9;                         // _t9
    _unknown_ _t10;                        // _t10
    _unknown_ _t11;                        // _t11

    _t3 = __eax;
    L3();
    if( *((intOrPtr*)(__eax)) !=  &caml_exn_Invalid_argument) {
        _t4 = caml_raise_exn(_t3);
        _push(caml_exception_pointer);
        caml_exception_pointer = __esp;
        _push(_t4);
        caml_c_call();
        __esp = __esp + 4;
        _pop(caml_exception_pointer);
        __esp = __esp + 4;
        return 3;
L4:
    }
    return 1;
    goto L4;
}

L0804BF80(
    _unknown_ __eax                        // r0
)
{
    _unknown_ _t2;                         // _t2
    _unknown_ _t3;                         // _t3

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    _push(__eax);
    caml_c_call();
    __esp = __esp + 4;
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    return 3;
}

camlUnix__pause_1408()
{// addr = 0x0804BFB0
    _unknown_ _t2;                         // _t2

    caml_c_call(3, 1);
    _push(unix_sigprocmask);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__is_inet6_addr_1500(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BFD0
    return (-1 + ( *(__eax - 4) >> 10) * 4 - ( *(__eax + -1 + ( *(__eax - 4) >> 10) * 4) & 255) + -1 + ( *(__eax - 4) >> 10) * 4 - ( *(__eax + -1 + ( *(__eax - 4) >> 10) * 4) & 255) + 1 & 0xff) + (-1 + ( *(__eax - 4) >> 10) * 4 - ( *(__eax + -1 + ( *(__eax - 4) >> 10) * 4) & 255) + -1 + ( *(__eax - 4) >> 10) * 4 - ( *(__eax + -1 + ( *(__eax - 4) >> 10) * 4) & 255) + 1 & 0xff) + 1;
}

camlUnix__domain_of_sockaddr_1529(
    intOrPtr* __eax                        // r0
)
{// addr = 0x0804C000
    intOrPtr* _t8;                         // _t8
    _unknown_ _t9;                         // _t9
    _unknown_ _t15;                        // _t15
    _unknown_ _t16;                        // _t16

    _t8 = __eax;
    if(( *(_t8 - 4) & 255) == 0) {
        return 1;
    } else {
        if(-1 + ( *( *_t8 - 4) >> 10) * 4 - ( *( *_t8 + -1 + ( *( *_t8 - 4) >> 10) * 4) & 255) + -1 + ( *( *_t8 - 4) >> 10) * 4 - ( *( *_t8 + -1 + ( *( *_t8 - 4) >> 10) * 4) & 255) + 1 != 33) {
            return 3;
        } else {
            return 5;
        }
    }
}

camlUnix__recv_1558()
{// addr = 0x0804C050
    _unknown_ _t8;                         // _t8
    intOrPtr _t11;                         // _t11
    intOrPtr* _t12;                        // _t12
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    char* _t16;                            // _t16

    if(__ecx < 1 || __edx < 1 || __ecx > (-1 + ( *(_t15 - 4) >> 10) * 4 - ( *(_t15 + -1 + ( *(_t15 - 4) >> 10) * 4) & 255) << 1) - __edx + 2) {
        _t16 = "Unix.recv";
        while(1) {
            _t11 = caml_young_ptr - 12;
            caml_young_ptr = _t11;
            if(_t11 >= caml_young_limit) {
                _t12 = _t11 + 4;
                 *((intOrPtr*)(_t12 - 4)) = 2048;
                 *_t12 =  &caml_exn_Invalid_argument;
                 *((intOrPtr*)(_t12 + 4)) = _t16;
                caml_raise_exn(_t12);
            }
            caml_call_gc(__esp);
        }
    }
    _push(__esi);
    caml_c_call(__ecx, __edx);
    __esp = __esp + 4;
    return;
}

camlUnix__recvfrom_1564()
{// addr = 0x0804C0A0
    _unknown_ _t8;                         // _t8
    intOrPtr _t11;                         // _t11
    intOrPtr* _t12;                        // _t12
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    char* _t16;                            // _t16

    if(__ecx < 1 || __edx < 1 || __ecx > (-1 + ( *(_t15 - 4) >> 10) * 4 - ( *(_t15 + -1 + ( *(_t15 - 4) >> 10) * 4) & 255) << 1) - __edx + 2) {
        _t16 = "Unix.recvfrom";
        while(1) {
            _t11 = caml_young_ptr - 12;
            caml_young_ptr = _t11;
            if(_t11 >= caml_young_limit) {
                _t12 = _t11 + 4;
                 *((intOrPtr*)(_t12 - 4)) = 2048;
                 *_t12 =  &caml_exn_Invalid_argument;
                 *((intOrPtr*)(_t12 + 4)) = _t16;
                caml_raise_exn(_t12);
            }
            caml_call_gc(__esp);
        }
    }
    _push(__esi);
    caml_c_call(__ecx, __edx);
    __esp = __esp + 4;
    return;
}

camlUnix__send_1570()
{// addr = 0x0804C0F0
    _unknown_ _t8;                         // _t8
    intOrPtr _t11;                         // _t11
    intOrPtr* _t12;                        // _t12
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    char* _t16;                            // _t16

    if(__ecx < 1 || __edx < 1 || __ecx > (-1 + ( *(_t15 - 4) >> 10) * 4 - ( *(_t15 + -1 + ( *(_t15 - 4) >> 10) * 4) & 255) << 1) - __edx + 2) {
        _t16 = "Unix.send";
        while(1) {
            _t11 = caml_young_ptr - 12;
            caml_young_ptr = _t11;
            if(_t11 >= caml_young_limit) {
                _t12 = _t11 + 4;
                 *((intOrPtr*)(_t12 - 4)) = 2048;
                 *_t12 =  &caml_exn_Invalid_argument;
                 *((intOrPtr*)(_t12 + 4)) = _t16;
                caml_raise_exn(_t12);
            }
            caml_call_gc(__esp);
        }
    }
    _push(__esi);
    caml_c_call(__ecx, __edx);
    __esp = __esp + 4;
    return;
}

camlUnix__sendto_1576()
{// addr = 0x0804C140
    intOrPtr _t9;                          // _t9
    intOrPtr _t12;                         // _t12
    intOrPtr* _t13;                        // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t19;                        // _t19
    _unknown_ _t20;                        // _t20
    char* _t21;                            // _t21

    if(__ecx < 1 || __edx < 1) {
L4:
        __esp = __esp + 4;
        _t21 = "Unix.sendto";
        while(1) {
            _t12 = caml_young_ptr - 12;
            caml_young_ptr = _t12;
            if(_t12 >= caml_young_limit) {
                _t13 = _t12 + 4;
                 *((intOrPtr*)(_t13 - 4)) = 2048;
                 *_t13 =  &caml_exn_Invalid_argument;
                 *((intOrPtr*)(_t13 + 4)) = _t21;
                caml_raise_exn(_t13);
            }
            goto L8;
        }
    } else {
         *__esp = _t9;
        if(__ecx > (-1 + ( *(_t20 - 4) >> 10) * 4 - ( *(_t20 + -1 + ( *(_t20 - 4) >> 10) * 4) & 255) << 1) - __edx + 2) {
            goto L4;
        }
        _push(__edi);
        _push(__esi);
        caml_c_call(__ecx, __edx);
        __esp = __esp + 8;
        return;
    }
}

camlUnix__fun_2816()
{// addr = 0x0804C1A0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(__ecx, __edx);
    return;
}

camlUnix__fun_2814()
{// addr = 0x0804C1C0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(__ecx);
    caml_c_call(_t1, __ebx);
    __esp = __esp + 4;
    return;
}

camlUnix__getsockopt_1643()
{// addr = 0x0804C1E0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(__ebx);
    caml_c_call(1, _t1);
    __esp = __esp + 4;
    return;
}

camlUnix__setsockopt_1646()
{// addr = 0x0804C200
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(__ebx, __ecx);
    return;
}

camlUnix__getsockopt_int_1650()
{// addr = 0x0804C220
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(__ebx);
    caml_c_call(3, _t1);
    __esp = __esp + 4;
    return;
}

camlUnix__setsockopt_int_1653()
{// addr = 0x0804C240
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(__ebx, __ecx);
    return;
}

camlUnix__getsockopt_optint_1657()
{// addr = 0x0804C260
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(__ebx);
    caml_c_call(5, _t1);
    __esp = __esp + 4;
    return;
}

camlUnix__setsockopt_optint_1660()
{// addr = 0x0804C280
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(__ebx, __ecx);
    return;
}

camlUnix__getsockopt_float_1664()
{// addr = 0x0804C2A0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(__ebx);
    caml_c_call(7, _t1);
    __esp = __esp + 4;
    return;
}

camlUnix__setsockopt_float_1667()
{// addr = 0x0804C2C0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(__ebx, __ecx);
    return;
}

camlUnix__getsockopt_error_1671()
{// addr = 0x0804C2E0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(1);
    caml_c_call(9, _t1);
    __esp = __esp + 4;
    return;
}

camlUnix__getaddrinfo_emulation_1730(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __ecx,                        // r2
    intOrPtr* __esp                        // r7
)
{// addr = 0x0804C300
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _v12;                        // _cfa_fffffff4
    intOrPtr* _v16;                        // _cfa_fffffff0
    intOrPtr _t79;                         // _t79
    intOrPtr* _t80;                        // _t80
    _unknown_ _t81;                        // _t81
    intOrPtr _t83;                         // _t83
    intOrPtr* _t85;                        // _t85
    _unknown_ _t86;                        // _t86
    _unknown_ _t87;                        // _t87
    intOrPtr* _t88;                        // _t88
    _unknown_ _t89;                        // _t89
    intOrPtr _t92;                         // _t92
    intOrPtr _t95;                         // _t95
    intOrPtr* _t96;                        // _t96
    intOrPtr* _t97;                        // _t97
    _unknown_ _t98;                        // _t98
    intOrPtr* _t100;                       // _t100
    intOrPtr _t104;                        // _t104
    intOrPtr* _t105;                       // _t105
    _unknown_ _t106;                       // _t106
    _unknown_ _t108;                       // _t108
    intOrPtr _t112;                        // _t112
    intOrPtr* _t113;                       // _t113
    _unknown_ _t115;                       // _t115
    intOrPtr _t118;                        // _t118
    intOrPtr _t121;                        // _t121
    _unknown_ _t123;                       // _t123
    _unknown_ _t124;                       // _t124
    _unknown_ _t126;                       // _t126
    intOrPtr _t128;                        // _t128
    intOrPtr* _t129;                       // _t129
    _unknown_ _t132;                       // _t132
    _unknown_ _t133;                       // _t133
    _unknown_ _t134;                       // _t134
    intOrPtr _t135;                        // _t135
    intOrPtr _t136;                        // _t136
    intOrPtr* _t137;                       // _t137
    intOrPtr _t141;                        // _t141
    _unknown_ _t144;                       // _t144
    intOrPtr* _t146;                       // _t146
    intOrPtr* _t147;                       // _t147
    intOrPtr _t148;                        // _t148
    _unknown_ _t149;                       // _t149
    _unknown_ _t150;                       // _t150
    intOrPtr* _t152;                       // _t152
    intOrPtr _t155;                        // _t155
    intOrPtr* _t156;                       // _t156
    intOrPtr _t159;                        // _t159
    intOrPtr* _t162;                       // _t162
    intOrPtr* _t163;                       // _t163
    intOrPtr* _t166;                       // _t166
    _unknown_ _t167;                       // _t167
    _unknown_ _t168;                       // _t168
    intOrPtr* _t169;                       // _t169
    _unknown_ _t170;                       // _t170
    _unknown_ _t171;                       // _t171

    __esp = __esp;
    __esp = __esp - 20;
    _v8 = __eax;
     *__esp = __ebx;
    _t131 = __ecx;
    _v4 = __ecx;
    while(1) {
        _t79 = caml_young_ptr - 48;
        caml_young_ptr = _t79;
        if(_t79 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t166 = _t79 + 4;
    _v16 = _t166;
     *((intOrPtr*)(_t166 - 4)) = 1024;
     *_t166 = 1;
    _t169 = _t166 + 8;
    _v12 = _t169;
     *((intOrPtr*)(_t169 - 4)) = 1024;
     *_t169 = 1;
    _t163 = _t166 + 16;
     *((intOrPtr*)(_t163 - 4)) = 1024;
     *_t163 = 1;
    _t80 = _t166 + 24;
     *((intOrPtr*)(_t80 - 4)) = 5367;
     *_t80 = camlUnix__fun_2828;
     *((intOrPtr*)(_t80 + 4)) = 3;
     *((intOrPtr*)(_t80 + 8)) = _t166;
     *((intOrPtr*)(_t80 + 12)) = _t169;
     *((intOrPtr*)(_t80 + 16)) = _t163;
    camlList__iter_1074(_t80, _t131, __esp);
    while(1) {
        _t83 = caml_young_ptr - 20;
        caml_young_ptr = _t83;
        if(_t83 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t152 = _t83 + 4;
     *((intOrPtr*)(_t152 - 4)) = 4343;
     *_t152 = caml_curry2;
     *((intOrPtr*)(_t152 + 4)) = 5;
     *((intOrPtr*)(_t152 + 8)) = camlUnix__get_port_1739;
    _t164 =  *__esp;
     *((intOrPtr*)(_t152 + 12)) =  *__esp;
    _t85 =  *_v16;
    if(_t85 == 1) {
         *__esp = _t152;
        camlUnix__get_port_1739(3, _t152);
        _v16 = 3;
        camlUnix__get_port_1739(1,  *__esp);
        L41();
         *__esp = 1;
    } else {
        _t148 =  *_t85;
        if(_t148 == 3) {
            camlUnix__get_port_1739(3, _t152);
             *__esp = 3;
        } else {
            if(_t148 == 1) {
                camlUnix__get_port_1739(1, _t152);
                 *__esp = 1;
            } else {
                if(caml_string_equal(_t164,  &camlUnix__202) == 1) {
                     *__esp = 1;
                } else {
                    while(1) {
                        _t128 = caml_young_ptr - 24;
                        caml_young_ptr = _t128;
                        if(_t128 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                    _t162 = _t128 + 4;
                     *((intOrPtr*)(_t162 - 4)) = 2048;
                     *_t162 = _t148;
                     *((intOrPtr*)(_t162 + 4)) = 1;
                    _t129 = _t162 + 12;
                     *__esp = _t129;
                     *((intOrPtr*)(_t129 - 4)) = 2048;
                     *_t129 = _t162;
                     *((intOrPtr*)(_t129 + 4)) = 1;
                }
            }
        }
    }
    _push( &camlUnix__197);
    _t135 = _v8;
    _push(_t135);
    _t88 = caml_string_equal();
    __esp = __esp + 8;
    if(_t88 == 1) {
        _v8 = _t135;
        L28();
        _t136 =  *_t88;
        if(_t136 !=  &caml_exn_Failure) {
            caml_raise_exn(_t88);
            _push(caml_exception_pointer);
            caml_exception_pointer = __esp;
            _push(_t136);
            caml_c_call();
            __esp = __esp + 4;
            _t155 = unix_inet_addr_of_string;
            while(1) {
                _t92 = caml_young_ptr - 24;
                caml_young_ptr = _t92;
                if(_t92 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t137 = _t92 + 4;
             *((intOrPtr*)(_t137 - 4)) = 2048;
             *_t137 = _t155;
             *((intOrPtr*)(_t137 + 4)) = _v4;
            _t156 = _t137 + 12;
             *((intOrPtr*)(_t156 - 4)) = 2048;
             *_t156 = _t137;
             *((intOrPtr*)(_t156 + 4)) = 1;
            _pop(caml_exception_pointer);
            __esp = __esp + 4;
            goto L31;
        }
        L24();
        if( *_t88 !=  &caml_exn_Not_found) {
            caml_raise_exn(_t88);
            _push(caml_exception_pointer);
            caml_exception_pointer = __esp;
            _push(_v4);
            caml_c_call();
            __esp = __esp + 4;
            _v12 = unix_gethostbyname;
            _t144 = camlArray__to_list_1121( *((intOrPtr*)(unix_gethostbyname + 12)));
            while(1) {
                _t112 = caml_young_ptr - 16;
                caml_young_ptr = _t112;
                if(_t112 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t113 = _t112 + 4;
             *((intOrPtr*)(_t113 - 4)) = 3319;
             *_t113 = camlUnix__fun_2833;
             *((intOrPtr*)(_t113 + 4)) = 3;
             *((intOrPtr*)(_t113 + 8)) = _v12;
            _t156 = camlList__map_1062(_t113, _t144, __esp);
            _pop(caml_exception_pointer);
            __esp = __esp + 4;
            goto L31;
        }
        _t156 = 1;
    } else {
        if(camlList__mem_1161(5, _v4, __esp) == 1) {
            while(1) {
                _t118 = caml_young_ptr - 24;
                caml_young_ptr = _t118;
                if(_t118 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
        } else {
            while(1) {
                _t121 = caml_young_ptr - 24;
                caml_young_ptr = _t121;
                if(_t121 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t147 = _t121 + 4;
             *((intOrPtr*)(_t147 - 4)) = 2048;
             *_t147 =  *134668768;
             *((intOrPtr*)(_t147 + 4)) = "0.0.0.0";
            _t156 = _t147 + 12;
             *((intOrPtr*)(_t156 - 4)) = 2048;
             *_t156 = _t147;
             *((intOrPtr*)(_t156 + 4)) = 1;
            while(1) {
L31:
                _t95 = caml_young_ptr - 24;
                caml_young_ptr = _t95;
                if(_t95 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t96 = _t95 + 4;
             *((intOrPtr*)(_t96 - 4)) = 5367;
             *_t96 = caml_tuplify2;
             *((intOrPtr*)(_t96 + 4)) = -3;
             *((intOrPtr*)(_t96 + 8)) = camlUnix__fun_2836;
             *((intOrPtr*)(_t96 + 12)) = _v8;
             *((intOrPtr*)(_t96 + 16)) = _t156;
            _t97 = camlList__map_1062(_t96,  *__esp, __esp);
            __esp = __esp + 20;
            __esp = __esp - 4;
            if(_t97 == 1) {
                __esp = __esp + 4;
                return 1;
            } else {
                 *__esp =  *_t97;
                L47();
                _t141 =  *((intOrPtr*)(_t97 + 4));
                _t100 =  *__esp;
                __esp = __esp + 4;
                __esp = __esp - 4;
                if(_t100 == 1) {
                    __esp = __esp + 4;
                    return _t141;
                } else {
                     *__esp =  *_t100;
                    L41();
                    _t159 =  *((intOrPtr*)(_t100 + 4));
                    while(1) {
                        _t104 = caml_young_ptr - 12;
                        caml_young_ptr = _t104;
                        if(_t104 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                    _t105 = _t104 + 4;
                     *((intOrPtr*)(_t105 - 4)) = 2048;
                     *_t105 =  *__esp;
                     *((intOrPtr*)(_t105 + 4)) = _t159;
                    __esp = __esp + 4;
                    return _t105;
                }
            }
        }
        _t146 = _t118 + 4;
         *((intOrPtr*)(_t146 - 4)) = 2048;
         *_t146 =  *134668772;
         *((intOrPtr*)(_t146 + 4)) = "127.0.0.1";
        _t156 = _t146 + 12;
         *((intOrPtr*)(_t156 - 4)) = 2048;
         *_t156 = _t146;
         *((intOrPtr*)(_t156 + 4)) = 1;
    }
    goto L31;
}

L0804C5E0(
    intOrPtr* __esp,                       // r7
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    intOrPtr _a16                          // _cfa_10
)
{
    _unknown_ _t22;                        // _t22
    intOrPtr _t26;                         // _t26
    intOrPtr* _t27;                        // _t27
    intOrPtr _t30;                         // _t30
    intOrPtr* _t31;                        // _t31
    intOrPtr* _t32;                        // _t32
    _unknown_ _t33;                        // _t33
    intOrPtr* _t35;                        // _t35
    intOrPtr _t39;                         // _t39
    intOrPtr* _t40;                        // _t40
    _unknown_ _t41;                        // _t41
    intOrPtr _t45;                         // _t45
    intOrPtr _t48;                         // _t48
    intOrPtr _t51;                         // _t51

    __esp = __esp;
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    _push(_a16);
    caml_c_call();
    __esp = __esp + 4;
    _a8 = unix_gethostbyname;
    _t41 = camlArray__to_list_1121( *((intOrPtr*)(unix_gethostbyname + 12)));
    while(1) {
        _t26 = caml_young_ptr - 16;
        caml_young_ptr = _t26;
        if(_t26 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t27 = _t26 + 4;
     *((intOrPtr*)(_t27 - 4)) = 3319;
     *_t27 = camlUnix__fun_2833;
     *((intOrPtr*)(_t27 + 4)) = 3;
     *((intOrPtr*)(_t27 + 8)) = _a8;
    _t48 = camlList__map_1062(_t27, _t41, __esp);
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    while(1) {
        _t30 = caml_young_ptr - 24;
        caml_young_ptr = _t30;
        if(_t30 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t31 = _t30 + 4;
     *((intOrPtr*)(_t31 - 4)) = 5367;
     *_t31 = caml_tuplify2;
     *((intOrPtr*)(_t31 + 4)) = -3;
     *((intOrPtr*)(_t31 + 8)) = camlUnix__fun_2836;
     *((intOrPtr*)(_t31 + 12)) = _a12;
     *((intOrPtr*)(_t31 + 16)) = _t48;
    _t32 = camlList__map_1062(_t31,  *__esp, __esp);
    __esp = __esp + 20;
    __esp = __esp - 4;
    if(_t32 == 1) {
        __esp = __esp + 4;
        return 1;
    } else {
         *__esp =  *_t32;
        L13();
        _t45 =  *((intOrPtr*)(_t32 + 4));
        _t35 =  *__esp;
        __esp = __esp + 4;
        __esp = __esp - 4;
        if(_t35 == 1) {
            __esp = __esp + 4;
            return _t45;
        } else {
             *__esp =  *_t35;
            L7();
            _t51 =  *((intOrPtr*)(_t35 + 4));
            while(1) {
                _t39 = caml_young_ptr - 12;
                caml_young_ptr = _t39;
                if(_t39 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t40 = _t39 + 4;
             *((intOrPtr*)(_t40 - 4)) = 2048;
             *_t40 =  *__esp;
             *((intOrPtr*)(_t40 + 4)) = _t51;
            __esp = __esp + 4;
            return _t40;
        }
    }
}

L0804C670(
    _unknown_ __ebx,                       // r1
    intOrPtr* __esp,                       // r7
    intOrPtr _a12,                         // _cfa_c
    intOrPtr _a16                          // _cfa_10
)
{
    intOrPtr _t22;                         // _t22
    intOrPtr _t25;                         // _t25
    intOrPtr* _t26;                        // _t26
    intOrPtr* _t27;                        // _t27
    _unknown_ _t28;                        // _t28
    intOrPtr* _t30;                        // _t30
    intOrPtr _t34;                         // _t34
    intOrPtr* _t35;                        // _t35
    intOrPtr* _t37;                        // _t37
    intOrPtr _t41;                         // _t41
    intOrPtr _t43;                         // _t43
    intOrPtr* _t44;                        // _t44
    intOrPtr _t47;                         // _t47

    __esp = __esp;
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    _push(__ebx);
    caml_c_call();
    __esp = __esp + 4;
    _t43 = unix_inet_addr_of_string;
    while(1) {
        _t22 = caml_young_ptr - 24;
        caml_young_ptr = _t22;
        if(_t22 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t37 = _t22 + 4;
     *((intOrPtr*)(_t37 - 4)) = 2048;
     *_t37 = _t43;
     *((intOrPtr*)(_t37 + 4)) = _a16;
    _t44 = _t37 + 12;
     *((intOrPtr*)(_t44 - 4)) = 2048;
     *_t44 = _t37;
     *((intOrPtr*)(_t44 + 4)) = 1;
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    while(1) {
        _t25 = caml_young_ptr - 24;
        caml_young_ptr = _t25;
        if(_t25 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t26 = _t25 + 4;
     *((intOrPtr*)(_t26 - 4)) = 5367;
     *_t26 = caml_tuplify2;
     *((intOrPtr*)(_t26 + 4)) = -3;
     *((intOrPtr*)(_t26 + 8)) = camlUnix__fun_2836;
     *((intOrPtr*)(_t26 + 12)) = _a12;
     *((intOrPtr*)(_t26 + 16)) = _t44;
    _t27 = camlList__map_1062(_t26,  *__esp, __esp);
    __esp = __esp + 20;
    __esp = __esp - 4;
    if(_t27 == 1) {
        __esp = __esp + 4;
        return 1;
    } else {
         *__esp =  *_t27;
        L13();
        _t41 =  *((intOrPtr*)(_t27 + 4));
        _t30 =  *__esp;
        __esp = __esp + 4;
        __esp = __esp - 4;
        if(_t30 == 1) {
            __esp = __esp + 4;
            return _t41;
        } else {
             *__esp =  *_t30;
            L7();
            _t47 =  *((intOrPtr*)(_t30 + 4));
            while(1) {
                _t34 = caml_young_ptr - 12;
                caml_young_ptr = _t34;
                if(_t34 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t35 = _t34 + 4;
             *((intOrPtr*)(_t35 - 4)) = 2048;
             *_t35 =  *__esp;
             *((intOrPtr*)(_t35 + 4)) = _t47;
            __esp = __esp + 4;
            return _t35;
        }
    }
}

camlUnix__getaddrinfo_1751(
    intOrPtr __ecx,                        // r2
    intOrPtr* __esp                        // r7
)
{// addr = 0x0804C770
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _v12;                        // _cfa_fffffff4
    intOrPtr* _v16;                        // _cfa_fffffff0
    intOrPtr* _t83;                        // _t83
    _unknown_ _t84;                        // _t84
    _unknown_ _t86;                        // _t86
    intOrPtr _t88;                         // _t88
    intOrPtr* _t89;                        // _t89
    _unknown_ _t90;                        // _t90
    intOrPtr _t92;                         // _t92
    intOrPtr* _t94;                        // _t94
    _unknown_ _t95;                        // _t95
    _unknown_ _t96;                        // _t96
    intOrPtr* _t97;                        // _t97
    _unknown_ _t98;                        // _t98
    intOrPtr _t101;                        // _t101
    intOrPtr _t104;                        // _t104
    intOrPtr* _t105;                       // _t105
    intOrPtr* _t106;                       // _t106
    _unknown_ _t107;                       // _t107
    intOrPtr* _t109;                       // _t109
    _unknown_ _t110;                       // _t110
    intOrPtr _t113;                        // _t113
    intOrPtr* _t114;                       // _t114
    _unknown_ _t115;                       // _t115
    _unknown_ _t117;                       // _t117
    intOrPtr _t121;                        // _t121
    intOrPtr* _t122;                       // _t122
    _unknown_ _t124;                       // _t124
    intOrPtr _t127;                        // _t127
    intOrPtr _t130;                        // _t130
    _unknown_ _t132;                       // _t132
    _unknown_ _t133;                       // _t133
    _unknown_ _t135;                       // _t135
    intOrPtr _t137;                        // _t137
    intOrPtr* _t138;                       // _t138
    intOrPtr _t139;                        // _t139
    intOrPtr _t140;                        // _t140
    _unknown_ _t141;                       // _t141
    _unknown_ _t143;                       // _t143
    _unknown_ _t144;                       // _t144
    _unknown_ _t145;                       // _t145
    intOrPtr _t146;                        // _t146
    intOrPtr _t147;                        // _t147
    intOrPtr* _t148;                       // _t148
    _unknown_ _t152;                       // _t152
    _unknown_ _t155;                       // _t155
    intOrPtr* _t157;                       // _t157
    intOrPtr* _t158;                       // _t158
    intOrPtr _t159;                        // _t159
    _unknown_ _t160;                       // _t160
    _unknown_ _t161;                       // _t161
    char* _t163;                           // _t163
    intOrPtr* _t164;                       // _t164
    intOrPtr _t167;                        // _t167
    intOrPtr* _t168;                       // _t168
    intOrPtr _t171;                        // _t171
    intOrPtr* _t174;                       // _t174
    intOrPtr* _t175;                       // _t175
    _unknown_ _t178;                       // _t178
    _unknown_ _t179;                       // _t179
    intOrPtr* _t180;                       // _t180
    _unknown_ _t181;                       // _t181
    _unknown_ _t182;                       // _t182
    _unknown_ _t183;                       // _t183
    _unknown_ _t184;                       // _t184
    intOrPtr* _t185;                       // _t185
    _unknown_ _t186;                       // _t186
    _unknown_ _t187;                       // _t187

    __esp = __esp;
    __esp = __esp - 12;
     *__esp = _t83;
    _v8 = _t139;
    _v4 = __ecx;
    L44();
    _t163 =  &caml_exn_Invalid_argument;
    _t140 =  *_t83;
    if(_t140 != _t163) {
        _t84 = caml_raise_exn(_t83);
    } else {
        __eax =  *__esp;
        __ebx = _v8;
        __ecx = _v4;
        __esp = __esp + 12;
        __esp = __esp - 20;
        _v8 = _t83;
         *__esp = _t140;
        _t142 = _t163;
        _v4 = _t163;
        while(1) {
            _t88 = caml_young_ptr - 48;
            caml_young_ptr = _t88;
            if(_t88 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t180 = _t88 + 4;
        _v16 = _t180;
         *((intOrPtr*)(_t180 - 4)) = 1024;
         *_t180 = 1;
        _t185 = _t180 + 8;
        _v12 = _t185;
         *((intOrPtr*)(_t185 - 4)) = 1024;
         *_t185 = 1;
        _t175 = _t180 + 16;
         *((intOrPtr*)(_t175 - 4)) = 1024;
         *_t175 = 1;
        _t89 = _t180 + 24;
         *((intOrPtr*)(_t89 - 4)) = 5367;
         *_t89 = camlUnix__fun_2828;
         *((intOrPtr*)(_t89 + 4)) = 3;
         *((intOrPtr*)(_t89 + 8)) = _t180;
         *((intOrPtr*)(_t89 + 12)) = _t185;
         *((intOrPtr*)(_t89 + 16)) = _t175;
        camlList__iter_1074(_t89, _t142, __esp);
        while(1) {
            _t92 = caml_young_ptr - 20;
            caml_young_ptr = _t92;
            if(_t92 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t164 = _t92 + 4;
         *((intOrPtr*)(_t164 - 4)) = 4343;
         *_t164 = caml_curry2;
         *((intOrPtr*)(_t164 + 4)) = 5;
         *((intOrPtr*)(_t164 + 8)) = camlUnix__get_port_1739;
        _t176 =  *__esp;
         *((intOrPtr*)(_t164 + 12)) =  *__esp;
        _t94 =  *_v16;
        if(_t94 == 1) {
             *__esp = _t164;
            camlUnix__get_port_1739(3, _t164);
            _v16 = 3;
            camlUnix__get_port_1739(1,  *__esp);
            L45();
             *__esp = 1;
        } else {
            _t159 =  *_t94;
            if(_t159 == 3) {
                camlUnix__get_port_1739(3, _t164);
                 *__esp = 3;
            } else {
                if(_t159 == 1) {
                    camlUnix__get_port_1739(1, _t164);
                     *__esp = 1;
                } else {
                    if(caml_string_equal(_t176,  &camlUnix__202) == 1) {
                         *__esp = 1;
                    } else {
                        while(1) {
                            _t137 = caml_young_ptr - 24;
                            caml_young_ptr = _t137;
                            if(_t137 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                        _t174 = _t137 + 4;
                         *((intOrPtr*)(_t174 - 4)) = 2048;
                         *_t174 = _t159;
                         *((intOrPtr*)(_t174 + 4)) = 1;
                        _t138 = _t174 + 12;
                         *__esp = _t138;
                         *((intOrPtr*)(_t138 - 4)) = 2048;
                         *_t138 = _t174;
                         *((intOrPtr*)(_t138 + 4)) = 1;
                    }
                }
            }
        }
        _push( &camlUnix__197);
        _t146 = _v8;
        _push(_t146);
        _t97 = caml_string_equal();
        __esp = __esp + 8;
        if(_t97 == 1) {
            _v8 = _t146;
            L29();
            _t147 =  *_t97;
            if(_t147 !=  &caml_exn_Failure) {
                caml_raise_exn(_t97);
                _push(caml_exception_pointer);
                caml_exception_pointer = __esp;
                _push(_t147);
                caml_c_call();
                __esp = __esp + 4;
                _t167 = unix_inet_addr_of_string;
                while(1) {
                    _t101 = caml_young_ptr - 24;
                    caml_young_ptr = _t101;
                    if(_t101 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                _t148 = _t101 + 4;
                 *((intOrPtr*)(_t148 - 4)) = 2048;
                 *_t148 = _t167;
                 *((intOrPtr*)(_t148 + 4)) = _v4;
                _t168 = _t148 + 12;
                 *((intOrPtr*)(_t168 - 4)) = 2048;
                 *_t168 = _t148;
                 *((intOrPtr*)(_t168 + 4)) = 1;
                _pop(caml_exception_pointer);
                __esp = __esp + 4;
                goto L32;
            }
            L25();
            if( *_t97 !=  &caml_exn_Not_found) {
                caml_raise_exn(_t97);
                _push(caml_exception_pointer);
                caml_exception_pointer = __esp;
                _push(_v4);
                caml_c_call();
                __esp = __esp + 4;
                _v12 = unix_gethostbyname;
                _t155 = camlArray__to_list_1121( *((intOrPtr*)(unix_gethostbyname + 12)));
                while(1) {
                    _t121 = caml_young_ptr - 16;
                    caml_young_ptr = _t121;
                    if(_t121 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                _t122 = _t121 + 4;
                 *((intOrPtr*)(_t122 - 4)) = 3319;
                 *_t122 = camlUnix__fun_2833;
                 *((intOrPtr*)(_t122 + 4)) = 3;
                 *((intOrPtr*)(_t122 + 8)) = _v12;
                _t168 = camlList__map_1062(_t122, _t155, __esp);
                _pop(caml_exception_pointer);
                __esp = __esp + 4;
                goto L32;
            }
            _t168 = 1;
        } else {
            if(camlList__mem_1161(5, _v4, __esp) == 1) {
                while(1) {
                    _t127 = caml_young_ptr - 24;
                    caml_young_ptr = _t127;
                    if(_t127 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
            } else {
                while(1) {
                    _t130 = caml_young_ptr - 24;
                    caml_young_ptr = _t130;
                    if(_t130 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                _t158 = _t130 + 4;
                 *((intOrPtr*)(_t158 - 4)) = 2048;
                 *_t158 =  *134668768;
                 *((intOrPtr*)(_t158 + 4)) = "0.0.0.0";
                _t168 = _t158 + 12;
                 *((intOrPtr*)(_t168 - 4)) = 2048;
                 *_t168 = _t158;
                 *((intOrPtr*)(_t168 + 4)) = 1;
                while(1) {
L32:
                    _t104 = caml_young_ptr - 24;
                    caml_young_ptr = _t104;
                    if(_t104 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                _t105 = _t104 + 4;
                 *((intOrPtr*)(_t105 - 4)) = 5367;
                 *_t105 = caml_tuplify2;
                 *((intOrPtr*)(_t105 + 4)) = -3;
                 *((intOrPtr*)(_t105 + 8)) = camlUnix__fun_2836;
                 *((intOrPtr*)(_t105 + 12)) = _v8;
                 *((intOrPtr*)(_t105 + 16)) = _t168;
                _t106 = camlList__map_1062(_t105,  *__esp, __esp);
                __esp = __esp + 20;
                __esp = __esp - 4;
                if(_t106 == 1) {
                    __esp = __esp + 4;
                    return;
                } else {
                     *__esp =  *_t106;
                    L51();
                    _t109 =  *__esp;
                    __esp = __esp + 4;
                    __esp = __esp - 4;
                    if(_t109 == 1) {
                        __esp = __esp + 4;
                        return;
                    } else {
                         *__esp =  *_t109;
                        L45();
                        _t171 =  *((intOrPtr*)(_t109 + 4));
                        while(1) {
                            _t113 = caml_young_ptr - 12;
                            caml_young_ptr = _t113;
                            if(_t113 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                        _t114 = _t113 + 4;
                         *((intOrPtr*)(_t114 - 4)) = 2048;
                         *_t114 =  *__esp;
                         *((intOrPtr*)(_t114 + 4)) = _t171;
                        __esp = __esp + 4;
                        return;
                    }
                }
L54:
            }
            _t157 = _t127 + 4;
             *((intOrPtr*)(_t157 - 4)) = 2048;
             *_t157 =  *134668772;
             *((intOrPtr*)(_t157 + 4)) = "127.0.0.1";
            _t168 = _t157 + 12;
             *((intOrPtr*)(_t168 - 4)) = 2048;
             *_t168 = _t157;
             *((intOrPtr*)(_t168 + 4)) = 1;
        }
        goto L32;
    }
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    _push(_t163);
    caml_c_call(_t84, _t140);
    __esp = __esp + 4;
    camlList__rev_append_1051(unix_getaddrinfo, 1);
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    __esp = __esp + 12;
    return;
    goto L54;
}

L0804C7C0()
{
    _unknown_ _t1;                         // _t1
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4
    _unknown_ _t5;                         // _t5

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    _push(__ecx);
    caml_c_call(_t1, _t4);
    __esp = __esp + 4;
    camlList__rev_append_1051(unix_getaddrinfo, 1);
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    __esp = __esp + 12;
    return;
}

camlUnix__getnameinfo_emulation_1772(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx,                        // r1
    _unknown_ __edi,                       // r4
    _unknown_ __esi,                       // r5
    intOrPtr* __esp                        // r7
)
{// addr = 0x0804C800
    intOrPtr _v0;                          // _cfa_0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _t25;                        // _t25
    intOrPtr _t27;                         // _t27
    intOrPtr* _t28;                        // _t28
    intOrPtr* _t29;                        // _t29
    intOrPtr* _t30;                        // _t30
    _unknown_ _t31;                        // _t31
    _unknown_ _t32;                        // _t32
    _unknown_ _t34;                        // _t34
    char* _t36;                            // _t36
    intOrPtr _t40;                         // _t40
    intOrPtr* _t41;                        // _t41
    intOrPtr _t43;                         // _t43
    intOrPtr* _t44;                        // _t44
    _unknown_ _t45;                        // _t45
    _unknown_ _t47;                        // _t47
    intOrPtr _t51;                         // _t51
    intOrPtr* _t52;                        // _t52
    _unknown_ _t53;                        // _t53
    intOrPtr _t54;                         // _t54
    intOrPtr _t55;                         // _t55
    intOrPtr _t66;                         // _t66
    _unknown_ _t67;                        // _t67
    _unknown_ _t68;                        // _t68
    _unknown_ _t69;                        // _t69
    _unknown_ _t70;                        // _t70
    _unknown_ _t71;                        // _t71

    __esp = __esp;
    _t69 = __esi;
    _t67 = __edi;
    _t54 = __ebx;
    _t25 = __eax;
    if(( *(_t25 - 4) & 255) == 0) {
        _t55 =  *_t25;
        while(1) {
L21:
            _t27 = caml_young_ptr - 12;
            caml_young_ptr = _t27;
            if(_t27 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t28 = _t27 + 4;
         *((intOrPtr*)(_t28 - 4)) = 2048;
         *_t28 =  &camlUnix__192;
         *((intOrPtr*)(_t28 + 4)) = _t55;
        return;
        goto L27;
    } else {
        _v4 = _t54;
        _v8 =  *((intOrPtr*)(_t25 + 4));
        _t29 =  *_t25;
         *__esp = _t29;
        L0804C8B0(_t29);
        if( *_t29 !=  &caml_exn_Not_found) {
            _t30 = caml_raise_exn(_t29);
            _t69 = _t69;
            _t67 = _t67;
        } else {
            if(camlList__mem_1161(5, _v4, __esp) != 1) {
                while(1) {
                    _t51 = caml_young_ptr - 8;
                    caml_young_ptr = _t51;
                    if(_t51 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                _t52 = _t51 + 4;
                 *((intOrPtr*)(_t52 - 4)) = 1024;
                 *_t52 =  &caml_exn_Not_found;
                caml_raise_exn(_t52);
            }
            _push( *__esp);
            _t30 = unix_string_of_inet_addr;
            caml_c_call();
            __esp = __esp + 4;
        }
         *__esp = _t30;
        L11();
        if( *_t30 !=  &caml_exn_Not_found) {
            caml_raise_exn(_t30);
            _push(caml_exception_pointer);
            caml_exception_pointer = __esp;
            if(camlList__mem_1161(7, _v0, __esp) != 1) {
                while(1) {
                    _t43 = caml_young_ptr - 8;
                    caml_young_ptr = _t43;
                    if(_t43 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                _t44 = _t43 + 4;
                 *((intOrPtr*)(_t44 - 4)) = 1024;
                 *_t44 =  &caml_exn_Not_found;
                caml_raise_exn(_t44);
            }
            if(camlList__mem_1161(9, _v0, __esp) == 1) {
                _t36 =  &camlUnix__193;
            } else {
                _t36 =  &camlUnix__194;
            }
            caml_c_call(_v4, _t36);
            _t66 =  *unix_getservbyport;
            _pop(caml_exception_pointer);
            __esp = __esp + 4;
            while(1) {
L18:
                _t40 = caml_young_ptr - 12;
                caml_young_ptr = _t40;
                if(_t40 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t41 = _t40 + 4;
             *((intOrPtr*)(_t41 - 4)) = 2048;
             *_t41 =  *__esp;
             *((intOrPtr*)(_t41 + 4)) = _t66;
            return;
L27:
        }
        camlPervasives__string_of_int_1130();
        _t66 = _v8;
        goto L18;
    }
    goto L21;
}

L0804C8B0(
    _unknown_ __eax,                       // r0
    intOrPtr* _a4,                         // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    intOrPtr _a16                          // _cfa_10
)
{
    _unknown_ _t18;                        // _t18
    _unknown_ _t19;                        // _t19
    intOrPtr _t23;                         // _t23
    _unknown_ _t24;                        // _t24
    _unknown_ _t25;                        // _t25
    _unknown_ _t27;                        // _t27
    char* _t29;                            // _t29
    intOrPtr _t33;                         // _t33
    intOrPtr* _t34;                        // _t34
    intOrPtr _t36;                         // _t36
    intOrPtr* _t37;                        // _t37
    _unknown_ _t38;                        // _t38
    intOrPtr _t41;                         // _t41
    intOrPtr* _t42;                        // _t42
    _unknown_ _t43;                        // _t43
    _unknown_ _t44;                        // _t44
    intOrPtr _t50;                         // _t50
    _unknown_ _t51;                        // _t51
    _unknown_ _t52;                        // _t52
    _unknown_ _t53;                        // _t53
    _unknown_ _t54;                        // _t54
    _unknown_ _t55;                        // _t55

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    if(camlList__mem_1161(3, _t44, __esp) != 1) {
        while(1) {
            _t41 = caml_young_ptr - 8;
            caml_young_ptr = _t41;
            if(_t41 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t42 = _t41 + 4;
         *((intOrPtr*)(_t42 - 4)) = 1024;
         *_t42 =  &caml_exn_Not_found;
        caml_raise_exn(_t42);
        _t53 = _t53;
    }
    _push(_a4);
    caml_c_call();
    __esp = __esp + 4;
    _t23 =  *unix_gethostbyaddr;
    _a4 = unix_gethostbyaddr;
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    L7();
    if( *unix_gethostbyaddr !=  &caml_exn_Not_found) {
        caml_raise_exn(_t23);
        _push(caml_exception_pointer);
        caml_exception_pointer = __esp;
        if(camlList__mem_1161(7, _a16, __esp) != 1) {
            while(1) {
                _t36 = caml_young_ptr - 8;
                caml_young_ptr = _t36;
                if(_t36 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t37 = _t36 + 4;
             *((intOrPtr*)(_t37 - 4)) = 1024;
             *_t37 =  &caml_exn_Not_found;
            caml_raise_exn(_t37);
        }
        if(camlList__mem_1161(9, _a16, __esp) == 1) {
            _t29 =  &camlUnix__193;
        } else {
            _t29 =  &camlUnix__194;
        }
        caml_c_call(_a12, _t29);
        _t50 =  *unix_getservbyport;
        _pop(caml_exception_pointer);
        __esp = __esp + 4;
        while(1) {
L14:
            _t33 = caml_young_ptr - 12;
            caml_young_ptr = _t33;
            if(_t33 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t34 = _t33 + 4;
         *((intOrPtr*)(_t34 - 4)) = 2048;
         *_t34 =  *__esp;
         *((intOrPtr*)(_t34 + 4)) = _t50;
        __esp = __esp + 12;
        return;
    }
    camlPervasives__string_of_int_1130();
    _t50 = _a8;
    goto L14;
}

L0804C960(
    _unknown_ __esi,                       // r5
    intOrPtr* __esp,                       // r7
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{
    _unknown_ _t10;                        // _t10
    _unknown_ _t12;                        // _t12
    char* _t14;                            // _t14
    intOrPtr _t18;                         // _t18
    intOrPtr* _t19;                        // _t19
    intOrPtr _t21;                         // _t21
    intOrPtr* _t22;                        // _t22
    _unknown_ _t23;                        // _t23
    _unknown_ _t27;                        // _t27
    _unknown_ _t28;                        // _t28

    __esp = __esp;
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    if(camlList__mem_1161(7, _a12, __esp) != 1) {
        while(1) {
            _t21 = caml_young_ptr - 8;
            caml_young_ptr = _t21;
            if(_t21 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t22 = _t21 + 4;
         *((intOrPtr*)(_t22 - 4)) = 1024;
         *_t22 =  &caml_exn_Not_found;
        caml_raise_exn(_t22);
    }
    if(camlList__mem_1161(9, _a12, __esp) == 1) {
        _t14 =  &camlUnix__193;
    } else {
        _t14 =  &camlUnix__194;
    }
    caml_c_call(_a8, _t14);
    __ecx =  *unix_getservbyport;
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    while(1) {
L7:
        _t18 = caml_young_ptr - 12;
        caml_young_ptr = _t18;
        if(_t18 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t19 = _t18 + 4;
     *((intOrPtr*)(_t19 - 4)) = 2048;
     *_t19 =  *__esp;
     *((intOrPtr*)(_t19 + 4)) = __ecx;
    __esp = __esp + 12;
    return;
    goto L7;
}

camlUnix__getnameinfo_1781(
    intOrPtr* __esp                        // r7
)
{// addr = 0x0804CA80
    intOrPtr _v0;                          // _cfa_0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _t29;                        // _t29
    _unknown_ _t30;                        // _t30
    _unknown_ _t31;                        // _t31
    intOrPtr _t33;                         // _t33
    intOrPtr* _t34;                        // _t34
    intOrPtr* _t35;                        // _t35
    intOrPtr* _t36;                        // _t36
    _unknown_ _t37;                        // _t37
    _unknown_ _t38;                        // _t38
    _unknown_ _t40;                        // _t40
    char* _t42;                            // _t42
    intOrPtr _t46;                         // _t46
    intOrPtr* _t47;                        // _t47
    intOrPtr _t49;                         // _t49
    intOrPtr* _t50;                        // _t50
    _unknown_ _t51;                        // _t51
    _unknown_ _t53;                        // _t53
    intOrPtr _t57;                         // _t57
    intOrPtr* _t58;                        // _t58
    _unknown_ _t59;                        // _t59
    intOrPtr _t60;                         // _t60
    intOrPtr _t61;                         // _t61
    intOrPtr _t62;                         // _t62
    intOrPtr _t74;                         // _t74
    _unknown_ _t75;                        // _t75
    _unknown_ _t76;                        // _t76
    _unknown_ _t77;                        // _t77
    _unknown_ _t78;                        // _t78
    _unknown_ _t79;                        // _t79
    _unknown_ _t80;                        // _t80
    _unknown_ _t81;                        // _t81

    __esp = __esp;
    __esp = __esp - 8;
     *__esp = _t29;
    _v4 = _t60;
    L30();
    _t61 =  *_t29;
    if(_t61 !=  &caml_exn_Invalid_argument) {
        _t30 = caml_raise_exn(_t29);
    } else {
        __eax =  *__esp;
        __ebx = _v4;
        __esp = __esp + 8;
        __esp = __esp - 12;
        if(( *(_t29 - 4) & 255) == 0) {
            _t62 =  *_t29;
            while(1) {
L22:
                _t33 = caml_young_ptr - 12;
                caml_young_ptr = _t33;
                if(_t33 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t34 = _t33 + 4;
             *((intOrPtr*)(_t34 - 4)) = 2048;
             *_t34 =  &camlUnix__192;
             *((intOrPtr*)(_t34 + 4)) = _t62;
            __esp = __esp + 12;
            return;
            goto L31;
        } else {
            _v4 = _t61;
            _v8 =  *((intOrPtr*)(_t29 + 4));
            _t35 =  *_t29;
             *__esp = _t35;
            L0804C8B0(_t35);
            if( *_t35 !=  &caml_exn_Not_found) {
                _t36 = caml_raise_exn(_t35);
                _t78 = _t78;
                _t75 = _t75;
            } else {
                if(camlList__mem_1161(5, _v4, __esp) != 1) {
                    while(1) {
                        _t57 = caml_young_ptr - 8;
                        caml_young_ptr = _t57;
                        if(_t57 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                    _t58 = _t57 + 4;
                     *((intOrPtr*)(_t58 - 4)) = 1024;
                     *_t58 =  &caml_exn_Not_found;
                    caml_raise_exn(_t58);
                }
                _push( *__esp);
                _t36 = unix_string_of_inet_addr;
                caml_c_call();
                __esp = __esp + 4;
            }
             *__esp = _t36;
            L12();
            if( *_t36 !=  &caml_exn_Not_found) {
                caml_raise_exn(_t36);
                _push(caml_exception_pointer);
                caml_exception_pointer = __esp;
                if(camlList__mem_1161(7, _v0, __esp) != 1) {
                    while(1) {
                        _t49 = caml_young_ptr - 8;
                        caml_young_ptr = _t49;
                        if(_t49 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                    _t50 = _t49 + 4;
                     *((intOrPtr*)(_t50 - 4)) = 1024;
                     *_t50 =  &caml_exn_Not_found;
                    caml_raise_exn(_t50);
                }
                if(camlList__mem_1161(9, _v0, __esp) == 1) {
                    _t42 =  &camlUnix__193;
                } else {
                    _t42 =  &camlUnix__194;
                }
                caml_c_call(_v4, _t42);
                _t74 =  *unix_getservbyport;
                _pop(caml_exception_pointer);
                __esp = __esp + 4;
                while(1) {
L19:
                    _t46 = caml_young_ptr - 12;
                    caml_young_ptr = _t46;
                    if(_t46 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                _t47 = _t46 + 4;
                 *((intOrPtr*)(_t47 - 4)) = 2048;
                 *_t47 =  *__esp;
                 *((intOrPtr*)(_t47 + 4)) = _t74;
                __esp = __esp + 12;
                return;
L31:
            }
            camlPervasives__string_of_int_1130();
            _t74 = _v8;
            goto L19;
        }
        goto L22;
    }
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_c_call(_t30, _t61);
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    __esp = __esp + 8;
    return;
    goto L31;
}

L0804CAC0()
{
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_c_call(_t1, __ebx);
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    __esp = __esp + 8;
    return;
}

camlUnix__system_1891()
{// addr = 0x0804CAF0
    intOrPtr _t1;                          // _t1
    _unknown_ _t3;                         // _t3
    _unknown_ _t5;                         // _t5
    _unknown_ _t7;                         // _t7
    _unknown_ _t10;                        // _t10

     *__esp = _t1;
    _push(1);
    caml_c_call();
    __esp = __esp + 4;
    if(unix_fork == 1) {
        L0804CB50();
        __esp = __esp + 4;
        __esp = __esp - 4;
         *__esp = 255;
         *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *134678880))))))();
        _push( *__esp);
        caml_c_call();
        __esp = __esp + 4;
        return;
L4:
    }
    caml_c_call(1, unix_fork);
    return;
    goto L4;
}

L0804CB50(
    intOrPtr _a4                           // _cfa_4
)
{
    intOrPtr _t7;                          // _t7
    _unknown_ _t9;                         // _t9

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    while(1) {
        _t7 = caml_young_ptr - 16;
        caml_young_ptr = _t7;
        if(_t7 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    __ebx = _t7 + 4;
     *((intOrPtr*)(__ebx - 4)) = 3072;
     *__ebx = "/bin/sh";
     *((intOrPtr*)(__ebx + 4)) =  &camlUnix__191;
     *((intOrPtr*)(__ebx + 8)) = _a4;
    caml_c_call("/bin/sh", __ebx);
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    return;
}

camlUnix__safe_dup_1894(
    intOrPtr __eax,                        // r0
    intOrPtr* __esp                        // r7
)
{// addr = 0x0804CBC0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _t3;                          // _t3
    _unknown_ _t8;                         // _t8

    __esp = __esp;
    _t3 = __eax;
     *__esp = _t3;
    _push(_t3);
    caml_c_call();
    __esp = __esp + 4;
    if(unix_dup < 7) {
        _v4 = unix_dup;
         *__esp = camlUnix__safe_dup_1894( *__esp, __esp);
        _push(_v4);
        caml_c_call();
        return  *__esp;
    } else {
        return unix_dup;
    }
}

camlUnix__safe_close_1898()
{// addr = 0x0804CC10
    intOrPtr* _t3;                         // _t3
    _unknown_ _t4;                         // _t4
    _unknown_ _t5;                         // _t5
    _unknown_ _t6;                         // _t6
    _unknown_ _t7;                         // _t7
    _unknown_ _t8;                         // _t8
    _unknown_ _t9;                         // _t9
    _unknown_ _t10;                        // _t10

    L3();
    if( *_t3 != camlUnix) {
        _t4 = caml_raise_exn(_t3);
        _push(caml_exception_pointer);
        caml_exception_pointer = __esp;
        _push(_t4);
        caml_c_call();
        __esp = __esp + 4;
        _pop(caml_exception_pointer);
        __esp = __esp + 4;
        return;
L4:
    }
    return;
    goto L4;
}

L0804CC40()
{
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    return;
}

camlUnix__perform_redirections_1900(
    intOrPtr* __esp                        // r7
)
{// addr = 0x0804CC70
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _t16;                         // _t16
    _unknown_ _t22;                        // _t22
    _unknown_ _t23;                        // _t23
    _unknown_ _t24;                        // _t24
    _unknown_ _t26;                        // _t26
    _unknown_ _t28;                        // _t28
    _unknown_ _t30;                        // _t30
    _unknown_ _t32;                        // _t32
    _unknown_ _t34;                        // _t34
    _unknown_ _t36;                        // _t36

    __esp = __esp;
     *__esp = _t16;
    _v20 = __ebx;
    _v16 = __ecx;
    _v12 = camlUnix__safe_dup_1894(_t16, __esp);
    _v8 = camlUnix__safe_dup_1894(_v20, __esp);
    _v4 = camlUnix__safe_dup_1894(_v16, __esp);
    camlUnix__safe_close_1898();
    camlUnix__safe_close_1898();
    camlUnix__safe_close_1898();
    caml_c_call(_v12, 1);
    _push(_v12);
    caml_c_call();
    __esp = __esp + 4;
    caml_c_call(_v8, 3);
    _push(_v8);
    caml_c_call();
    __esp = __esp + 4;
    caml_c_call(_v4, 5);
    _push(_v4);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlUnix__create_process_1907(
    intOrPtr* __esp                        // r7
)
{// addr = 0x0804CD40
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _t5;                          // _t5
    _unknown_ _t7;                         // _t7
    _unknown_ _t9;                         // _t9
    _unknown_ _t11;                        // _t11
    intOrPtr _t12;                         // _t12
    intOrPtr _t14;                         // _t14

    __esp = __esp;
    __esp = __esp - 20;
    _v4 = _t5;
    _v8 = _t12;
     *__esp = _t14;
    _v16 = __edx;
    _v12 = __esi;
    _push(1);
    caml_c_call();
    __esp = __esp + 4;
    if(unix_fork == 1) {
        L0804CD90(__esp);
        __esp = __esp + 20;
        __esp = __esp - 4;
         *__esp = 255;
         *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *134678880))))))();
        _push( *__esp);
        caml_c_call();
        __esp = __esp + 4;
        __esp = __esp + 4;
        return;
L4:
    }
    __esp = __esp + 20;
    return;
    goto L4;
}

L0804CD90(
    intOrPtr* __esp,                       // r7
    _unknown_ _a4,                         // _cfa_4
    _unknown_ _a8,                         // _cfa_8
    _unknown_ _a12,                        // _cfa_c
    intOrPtr _a16,                         // _cfa_10
    intOrPtr _a20                          // _cfa_14
)
{
    _unknown_ _t6;                         // _t6
    _unknown_ _t9;                         // _t9

    __esp = __esp;
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    camlUnix__perform_redirections_1900(__esp);
    caml_c_call(_a20, _a16);
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    __esp = __esp + 20;
    return;
}

camlUnix__create_process_env_1914(
    intOrPtr* __esp                        // r7
)
{// addr = 0x0804CDE0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _t6;                          // _t6
    _unknown_ _t8;                         // _t8
    _unknown_ _t10;                        // _t10
    _unknown_ _t12;                        // _t12
    intOrPtr _t13;                         // _t13
    intOrPtr _t15;                         // _t15

    __esp = __esp;
    __esp = __esp - 24;
    _v4 = _t6;
    _v8 = _t13;
    _v12 = _t15;
     *__esp = __edx;
    _v20 = __esi;
    _v16 = __edi;
    _push(1);
    caml_c_call();
    __esp = __esp + 4;
    if(unix_fork == 1) {
        L0804CE40(__esp);
        __esp = __esp + 24;
        __esp = __esp - 4;
         *__esp = 255;
         *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *134678880))))))();
        _push( *__esp);
        caml_c_call();
        __esp = __esp + 4;
        __esp = __esp + 4;
        return;
L4:
    }
    __esp = __esp + 24;
    return;
    goto L4;
}

L0804CE40(
    intOrPtr* __esp,                       // r7
    _unknown_ _a4,                         // _cfa_4
    _unknown_ _a8,                         // _cfa_8
    _unknown_ _a12,                        // _cfa_c
    intOrPtr _a16,                         // _cfa_10
    intOrPtr _a20,                         // _cfa_14
    intOrPtr _a24                          // _cfa_18
)
{
    _unknown_ _t7;                         // _t7
    _unknown_ _t11;                        // _t11

    __esp = __esp;
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    camlUnix__perform_redirections_1900(__esp);
    _push(_a16);
    caml_c_call(_a24, _a20);
    __esp = __esp + 4;
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    __esp = __esp + 24;
    return;
}

camlUnix__open_proc_1949(
    intOrPtr* __esp                        // r7
)
{// addr = 0x0804CE90
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _t105;                        // _t105
    intOrPtr _t109;                        // _t109
    signed int _t110;                      // _t110
    _unknown_ _t112;                       // _t112
    _unknown_ _t114;                       // _t114
    _unknown_ _t116;                       // _t116
    _unknown_ _t118;                       // _t118
    _unknown_ _t119;                       // _t119
    _unknown_ _t121;                       // _t121
    _unknown_ _t122;                       // _t122
    _unknown_ _t124;                       // _t124
    intOrPtr _t125;                        // _t125
    signed int _t126;                      // _t126
    _unknown_ _t129;                       // _t129
    _unknown_ _t130;                       // _t130
    _unknown_ _t132;                       // _t132
    _unknown_ _t133;                       // _t133
    _unknown_ _t135;                       // _t135
    _unknown_ _t137;                       // _t137
    _unknown_ _t139;                       // _t139
    _unknown_ _t140;                       // _t140
    _unknown_ _t142;                       // _t142
    _unknown_ _t144;                       // _t144
    _unknown_ _t147;                       // _t147
    _unknown_ _t149;                       // _t149
    _unknown_ _t156;                       // _t156
    _unknown_ _t157;                       // _t157
    _unknown_ _t158;                       // _t158
    _unknown_ _t161;                       // _t161
    _unknown_ _t163;                       // _t163
    _unknown_ _t164;                       // _t164
    _unknown_ _t167;                       // _t167
    _unknown_ _t173;                       // _t173
    _unknown_ _t175;                       // _t175
    _unknown_ _t177;                       // _t177
    intOrPtr _t178;                        // _t178
    intOrPtr _t182;                        // _t182
    _unknown_ _t185;                       // _t185
    _unknown_ _t186;                       // _t186
    _unknown_ _t192;                       // _t192
    _unknown_ _t193;                       // _t193
    _unknown_ _t194;                       // _t194
    _unknown_ _t195;                       // _t195
    intOrPtr _t199;                        // _t199
    intOrPtr _t200;                        // _t200
    _unknown_ _t202;                       // _t202
    _unknown_ _t203;                       // _t203
    _unknown_ _t206;                       // _t206
    _unknown_ _t209;                       // _t209
    signed int _t213;                      // _t213
    _unknown_ _t216;                       // _t216
    intOrPtr _t217;                        // _t217
    _unknown_ _t218;                       // _t218
    intOrPtr _t219;                        // _t219
    signed int _t221;                      // _t221
    _unknown_ _t222;                       // _t222
    _unknown_ _t224;                       // _t224
    _unknown_ _t225;                       // _t225
    _unknown_ _t226;                       // _t226

    __esp = __esp;
    __esp = __esp - 24;
    _v20 = _t105;
    _v4 = _t178;
    _v8 = _t199;
    _v12 = _t213;
    _v16 = _t219;
     *__esp = camlList__for_all_1137( *134668952, _t219, __esp);
    _push(1);
    caml_c_call();
    __esp = __esp + 4;
    _t200 = unix_fork;
    if(unix_fork == 1) {
        _t109 = _v8;
        if(_t109 != 1) {
            _v8 = _t109;
            caml_c_call(_t109, 1);
            _push(_v8);
            caml_c_call();
            __esp = __esp + 4;
        }
        _t110 = _v12;
        if(_t110 != 3) {
            _v12 = _t110;
            caml_c_call(_t110, 3);
            _push(_v12);
            caml_c_call();
            __esp = __esp + 4;
        }
        if( *__esp == 1) {
            camlList__iter_1074( &camlUnix__188, _v16, __esp);
        }
        L0804CF70();
        __esp = __esp + 24;
        __esp = __esp - 4;
         *__esp = 255;
         *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *134678880))))))();
        _push( *__esp);
        caml_c_call();
        __esp = __esp + 4;
        __esp = __esp + 4;
        return;
    } else {
        _t125 =  *134668984;
        _t182 = _v4;
        __esp = __esp + 24;
        while(1) {
            __esp = __esp - 4;
            _t217 = _t125;
            _t126 =  *(_t217 + 4);
            _t221 =  *(_t126 - 4) >> 10;
            if(_t221 == 0) {
                caml_raise_exn( &caml_bucket_Division_by_zero);
                _t221 = _t221;
            } else {
                 *__esp = _t200;
                caml_hash_univ_param(21, 201, _t182);
                asm("cdq ");
                _t213 = (_t126 >> 1) % _t221;
            }
            _t213 = (_t213 << 1) + 1;
            goto L25;
        }
    }
}

L0804CF70(
    intOrPtr _a8                           // _cfa_8
)
{
    intOrPtr _t7;                          // _t7
    _unknown_ _t9;                         // _t9

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    while(1) {
        _t7 = caml_young_ptr - 16;
        caml_young_ptr = _t7;
        if(_t7 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    __ebx = _t7 + 4;
     *((intOrPtr*)(__ebx - 4)) = 3072;
     *__ebx = "/bin/sh";
     *((intOrPtr*)(__ebx + 4)) =  &camlUnix__187;
     *((intOrPtr*)(__ebx + 8)) = _a8;
    caml_c_call("/bin/sh", __ebx);
    _pop(caml_exception_pointer);
    __esp = __esp + 24;
    return;
}

camlUnix__open_process_in_1957()
{// addr = 0x0804CFE0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _t14;                         // _t14
    intOrPtr _t19;                         // _t19
    _unknown_ _t21;                        // _t21
    _unknown_ _t22;                        // _t22
    _unknown_ _t24;                        // _t24
    intOrPtr* _t27;                        // _t27
    intOrPtr _t28;                         // _t28
    _unknown_ _t29;                        // _t29

    _v12 = _t14;
    _push(1);
    caml_c_call();
    __esp = __esp + 4;
    _v8 =  *((intOrPtr*)(unix_pipe + 4));
     *__esp = unix_pipe;
    _push( *unix_pipe);
    caml_c_call();
    __esp = __esp + 4;
    _t28 = caml_ml_open_descriptor_in;
    _v4 = caml_ml_open_descriptor_in;
    while(1) {
        _t19 = caml_young_ptr - 20;
        caml_young_ptr = _t19;
        if(_t19 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    __esi = _t19 + 4;
     *((intOrPtr*)(__esi - 4)) = 2048;
     *__esi =  *__esp;
     *((intOrPtr*)(__esi + 4)) = 1;
    _t27 = __esi + 12;
     *((intOrPtr*)(_t27 - 4)) = 1025;
     *_t27 = _t28;
    camlUnix__open_proc_1949(__esp);
    _push(_v8);
    caml_c_call();
    __esp = __esp + 4;
    return _v4;
}

camlUnix__open_process_out_1962()
{// addr = 0x0804D080
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _t14;                         // _t14
    intOrPtr _t19;                         // _t19
    _unknown_ _t21;                        // _t21
    _unknown_ _t22;                        // _t22
    _unknown_ _t24;                        // _t24
    intOrPtr _t26;                         // _t26
    intOrPtr* _t27;                        // _t27
    intOrPtr _t28;                         // _t28
    _unknown_ _t29;                        // _t29

    _v12 = _t14;
    _push(1);
    caml_c_call();
    __esp = __esp + 4;
    _t26 =  *((intOrPtr*)(unix_pipe + 4));
     *__esp = _t26;
    _v8 =  *unix_pipe;
    _push(_t26);
    caml_c_call();
    __esp = __esp + 4;
    _t28 = caml_ml_open_descriptor_out;
    _v4 = caml_ml_open_descriptor_out;
    while(1) {
        _t19 = caml_young_ptr - 20;
        caml_young_ptr = _t19;
        if(_t19 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    __esi = _t19 + 4;
     *((intOrPtr*)(__esi - 4)) = 2048;
     *__esi =  *__esp;
     *((intOrPtr*)(__esi + 4)) = 1;
    _t27 = __esi + 12;
     *((intOrPtr*)(_t27 - 4)) = 1026;
     *_t27 = _t28;
    camlUnix__open_proc_1949(__esp);
    _push(_v8);
    caml_c_call();
    __esp = __esp + 4;
    return _v4;
}

camlUnix__open_process_1967()
{// addr = 0x0804D120
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _t31;                         // _t31
    intOrPtr _t41;                         // _t41
    _unknown_ _t45;                        // _t45
    _unknown_ _t46;                        // _t46
    _unknown_ _t48;                        // _t48
    _unknown_ _t50;                        // _t50
    intOrPtr _t52;                         // _t52
    intOrPtr* _t53;                        // _t53
    intOrPtr* _t56;                        // _t56
    intOrPtr* _t57;                        // _t57
    intOrPtr _t60;                         // _t60
    _unknown_ _t61;                        // _t61
    intOrPtr* _t62;                        // _t62
    _unknown_ _t63;                        // _t63

    _v20 = _t31;
    _push(1);
    caml_c_call();
    __esp = __esp + 4;
    _v12 =  *((intOrPtr*)(unix_pipe + 4));
    _v24 =  *unix_pipe;
    _push(1);
    caml_c_call();
    __esp = __esp + 4;
     *__esp =  *((intOrPtr*)(unix_pipe + 4));
    _v16 =  *unix_pipe;
    _push(_v24);
    caml_c_call();
    __esp = __esp + 4;
    _v8 = caml_ml_open_descriptor_in;
    _push( *__esp);
    caml_c_call();
    __esp = __esp + 4;
    _t60 = caml_ml_open_descriptor_out;
    _v4 = caml_ml_open_descriptor_out;
    while(1) {
        _t41 = caml_young_ptr - 36;
        caml_young_ptr = _t41;
        if(_t41 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t62 = _t41 + 4;
     *((intOrPtr*)(_t62 - 4)) = 2048;
     *_t62 =  *__esp;
     *((intOrPtr*)(_t62 + 4)) = 1;
    _t56 = _t62 + 12;
     *__esp = _t56;
     *((intOrPtr*)(_t56 - 4)) = 2048;
     *_t56 = _v24;
     *((intOrPtr*)(_t56 + 4)) = _t62;
    _t57 = _t62 + 24;
     *((intOrPtr*)(_t57 - 4)) = 2048;
     *_t57 = _v8;
     *((intOrPtr*)(_t57 + 4)) = _t60;
    camlUnix__open_proc_1949(__esp);
    _push(_v16);
    caml_c_call();
    __esp = __esp + 4;
    _push(_v12);
    caml_c_call();
    __esp = __esp + 4;
    while(1) {
        _t52 = caml_young_ptr - 12;
        caml_young_ptr = _t52;
        if(_t52 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t53 = _t52 + 4;
     *((intOrPtr*)(_t53 - 4)) = 2048;
     *_t53 = _v8;
     *((intOrPtr*)(_t53 + 4)) = _v4;
    return;
}

camlUnix__open_proc_full_1975(
    signed int* __esp                      // r7
)
{// addr = 0x0804D260
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _v28;                         // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _t107;                        // _t107
    _unknown_ _t112;                       // _t112
    _unknown_ _t114;                       // _t114
    _unknown_ _t116;                       // _t116
    _unknown_ _t118;                       // _t118
    _unknown_ _t120;                       // _t120
    _unknown_ _t122;                       // _t122
    _unknown_ _t124;                       // _t124
    _unknown_ _t126;                       // _t126
    _unknown_ _t128;                       // _t128
    _unknown_ _t130;                       // _t130
    intOrPtr _t131;                        // _t131
    signed int _t132;                      // _t132
    _unknown_ _t135;                       // _t135
    _unknown_ _t136;                       // _t136
    _unknown_ _t138;                       // _t138
    _unknown_ _t139;                       // _t139
    _unknown_ _t141;                       // _t141
    _unknown_ _t143;                       // _t143
    _unknown_ _t145;                       // _t145
    _unknown_ _t146;                       // _t146
    _unknown_ _t148;                       // _t148
    _unknown_ _t150;                       // _t150
    _unknown_ _t153;                       // _t153
    _unknown_ _t155;                       // _t155
    _unknown_ _t162;                       // _t162
    _unknown_ _t163;                       // _t163
    _unknown_ _t164;                       // _t164
    _unknown_ _t167;                       // _t167
    _unknown_ _t169;                       // _t169
    _unknown_ _t170;                       // _t170
    _unknown_ _t173;                       // _t173
    _unknown_ _t179;                       // _t179
    _unknown_ _t181;                       // _t181
    _unknown_ _t183;                       // _t183
    intOrPtr _t184;                        // _t184
    intOrPtr _t188;                        // _t188
    _unknown_ _t191;                       // _t191
    _unknown_ _t192;                       // _t192
    _unknown_ _t198;                       // _t198
    _unknown_ _t199;                       // _t199
    _unknown_ _t200;                       // _t200
    _unknown_ _t201;                       // _t201
    intOrPtr _t205;                        // _t205
    signed int _t206;                      // _t206
    _unknown_ _t208;                       // _t208
    _unknown_ _t209;                       // _t209
    _unknown_ _t212;                       // _t212
    _unknown_ _t215;                       // _t215
    signed int _t219;                      // _t219
    _unknown_ _t222;                       // _t222
    intOrPtr _t223;                        // _t223
    intOrPtr _t224;                        // _t224
    _unknown_ _t225;                       // _t225
    intOrPtr _t226;                        // _t226
    signed int _t228;                      // _t228
    _unknown_ _t229;                       // _t229
    _unknown_ _t231;                       // _t231
    _unknown_ _t232;                       // _t232
    _unknown_ _t233;                       // _t233

    __esp = __esp;
    __esp = __esp - 32;
    _v16 = _t107;
    _v12 = _t184;
    _v4 = _t205;
     *__esp = _t219;
    _v28 = _t226;
    _v24 = _t223;
    _v8 = caml_extra_params;
    _v20 = camlList__for_all_1137( *134668952, caml_extra_params, __esp);
    _push(1);
    caml_c_call();
    __esp =  &((__esp)[1]);
    _t206 = unix_fork;
    if(unix_fork == 1) {
        caml_c_call(_v32, 1);
        _push( *__esp);
        caml_c_call();
        __esp =  &((__esp)[1]);
        caml_c_call(_v28, 3);
        _push(_v28);
        caml_c_call();
        __esp =  &((__esp)[1]);
        caml_c_call(_v24, 5);
        _push(_v24);
        caml_c_call();
        __esp =  &((__esp)[1]);
        if(_v20 == 1) {
            camlList__iter_1074( &camlUnix__184, _v8, __esp);
        }
        L0804D360();
        __esp =  &((__esp)[8]);
        __esp = __esp - 4;
         *__esp = 255;
         *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *134678880))))))();
        _push( *__esp);
        caml_c_call();
        __esp =  &((__esp)[1]);
        __esp =  &((__esp)[1]);
        return;
    } else {
        _t131 =  *134668984;
        _t188 = _v4;
        __esp =  &((__esp)[8]);
        while(1) {
            __esp = __esp - 4;
            _t224 = _t131;
            _t132 =  *(_t224 + 4);
            _t228 =  *(_t132 - 4) >> 10;
            if(_t228 == 0) {
                caml_raise_exn( &caml_bucket_Division_by_zero);
                _t228 = _t228;
            } else {
                 *__esp = _t206;
                caml_hash_univ_param(21, 201, _t188);
                asm("cdq ");
                _t219 = (_t132 >> 1) % _t228;
            }
            _t219 = (_t219 << 1) + 1;
            goto L21;
        }
    }
}

L0804D360(
    intOrPtr _a20,                         // _cfa_14
    intOrPtr _a24                          // _cfa_18
)
{
    intOrPtr _t8;                          // _t8
    _unknown_ _t11;                        // _t11

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    while(1) {
        _t8 = caml_young_ptr - 16;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    __ebx = _t8 + 4;
     *((intOrPtr*)(__ebx - 4)) = 3072;
     *__ebx = "/bin/sh";
     *((intOrPtr*)(__ebx + 4)) =  &camlUnix__183;
     *((intOrPtr*)(__ebx + 8)) = _a20;
    _push(_a24);
    caml_c_call("/bin/sh", __ebx);
    __esp = __esp + 4;
    _pop(caml_exception_pointer);
    __esp = __esp + 32;
    return;
}

camlUnix__open_process_full_1985(
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804D3D0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _v28;                         // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _t48;                         // _t48
    intOrPtr _t62;                         // _t62
    _unknown_ _t68;                        // _t68
    _unknown_ _t69;                        // _t69
    _unknown_ _t71;                        // _t71
    _unknown_ _t73;                        // _t73
    _unknown_ _t75;                        // _t75
    intOrPtr _t77;                         // _t77
    intOrPtr* _t78;                        // _t78
    intOrPtr _t83;                         // _t83
    _unknown_ _t84;                        // _t84
    intOrPtr* _t88;                        // _t88
    intOrPtr* _t89;                        // _t89
    intOrPtr* _t90;                        // _t90
    _unknown_ _t91;                        // _t91
    intOrPtr* _t92;                        // _t92
    _unknown_ _t93;                        // _t93

    _v32 = _t48;
    _v28 = __ebx;
    _push(1);
    caml_c_call();
    __esp = __esp + 4;
    _v20 =  *((intOrPtr*)(unix_pipe + 4));
    _v36 =  *unix_pipe;
    _push(1);
    caml_c_call();
    __esp = __esp + 4;
    _v40 =  *((intOrPtr*)(unix_pipe + 4));
    _v24 =  *unix_pipe;
    _push(1);
    caml_c_call();
    __esp = __esp + 4;
    _v16 =  *((intOrPtr*)(unix_pipe + 4));
     *__esp =  *unix_pipe;
    _push(_v36);
    caml_c_call();
    __esp = __esp + 4;
    _v12 = caml_ml_open_descriptor_in;
    _push(_v40);
    caml_c_call();
    __esp = __esp + 4;
    _v8 = caml_ml_open_descriptor_out;
    _push( *__esp);
    caml_c_call();
    __esp = __esp + 4;
    _t83 = caml_ml_open_descriptor_in;
    _v4 = caml_ml_open_descriptor_in;
    while(1) {
        _t62 = caml_young_ptr - 52;
        caml_young_ptr = _t62;
        if(_t62 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t92 = _t62 + 4;
     *((intOrPtr*)(_t92 - 4)) = 2048;
     *_t92 =  *__esp;
     *((intOrPtr*)(_t92 + 4)) = 1;
    _t90 = _t92 + 12;
     *((intOrPtr*)(_t90 - 4)) = 2048;
     *_t90 = _v40;
     *((intOrPtr*)(_t90 + 4)) = _t92;
    _t88 = _t92 + 24;
     *__esp = _t88;
     *((intOrPtr*)(_t88 - 4)) = 2048;
     *_t88 = _v36;
     *((intOrPtr*)(_t88 + 4)) = _t90;
    _t89 = _t92 + 36;
     *((intOrPtr*)(_t89 - 4)) = 3075;
     *_t89 = _v12;
     *((intOrPtr*)(_t89 + 4)) = _v8;
     *((intOrPtr*)(_t89 + 8)) = _t83;
    caml_extra_params =  *__esp;
    camlUnix__open_proc_full_1975(__esp);
    _push(_v24);
    caml_c_call();
    __esp = __esp + 4;
    _push(_v20);
    caml_c_call();
    __esp = __esp + 4;
    _push(_v16);
    caml_c_call();
    __esp = __esp + 4;
    while(1) {
        _t77 = caml_young_ptr - 16;
        caml_young_ptr = _t77;
        if(_t77 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t78 = _t77 + 4;
     *((intOrPtr*)(_t78 - 4)) = 3072;
     *_t78 = _v12;
     *((intOrPtr*)(_t78 + 4)) = _v8;
     *((intOrPtr*)(_t78 + 8)) = _v4;
    return;
}

camlUnix__find_proc_id_1997(
    _unknown_ __edi                        // r4
)
{// addr = 0x0804D590
    intOrPtr _v0;                          // _cfa_0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _v8;                         // _cfa_fffffff8
    intOrPtr* _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    intOrPtr _t16;                         // _t16
    _unknown_ _t18;                        // _t18
    intOrPtr _t21;                         // _t21
    intOrPtr* _t22;                        // _t22
    intOrPtr _t23;                         // _t23
    _unknown_ _t28;                        // _t28
    _unknown_ _t29;                        // _t29
    _unknown_ _t30;                        // _t30
    _unknown_ _t31;                        // _t31

    _v8 = _t14;
    _v4 = _t23;
    L4();
    if( *_t14 ==  &caml_exn_Not_found) {
        while(1) {
            _t21 = caml_young_ptr - 20;
            caml_young_ptr = _t21;
            if(_t21 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t22 = _t21 + 4;
         *((intOrPtr*)(_t22 - 4)) = 4096;
         *_t22 = camlUnix;
         *((intOrPtr*)(_t22 + 4)) = 7;
         *((intOrPtr*)(_t22 + 8)) = _v8;
         *((intOrPtr*)(_t22 + 12)) =  &camlUnix__180;
        _t14 = caml_raise_exn(_t22);
        _t30 = _t30;
    }
    caml_raise_exn(_t14);
    _t31 = _t30;
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    _t16 =  *134668984;
    camlHashtbl__find_1093(_t16, _t31);
    _v8 = _t16;
    camlHashtbl__remove_1080( *134668984, _v0, __esp);
    _pop(caml_exception_pointer);
    return  *__esp;
}

L0804D600(
    intOrPtr* __esp,                       // r7
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a12                          // _cfa_c
)
{
    intOrPtr _t3;                          // _t3
    _unknown_ _t5;                         // _t5
    intOrPtr _t6;                          // _t6

    __esp = __esp;
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    _t3 =  *134668984;
    camlHashtbl__find_1093(_t3, __esi);
    _a4 = _t3;
    __ebx = _a12;
    camlHashtbl__remove_1080( *134668984, _a12, __esp);
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    _t6 =  *__esp;
    __esp = __esp + 12;
    return _t6;
}

camlUnix__waitpid_non_intr_2001()
{// addr = 0x0804D650
    intOrPtr* _t6;                         // _t6
    _unknown_ _t7;                         // _t7
    _unknown_ _t8;                         // _t8
    signed int _t10;                       // _t10
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14

    while(1) {
         *__esp = _t6;
        L6();
        if( *_t6 != camlUnix) {
            break;
        }
        _t10 =  *(_t6 + 4);
        if((_t10 & 1) == 0 || _t10 != 23) {
        } else {
            _t6 =  *__esp;
            continue;
        }
        break;
L7:
    }
    _t7 = caml_raise_exn(_t6);
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_c_call(1, _t7);
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    return;
    goto L7;
}

L0804D690()
{
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_c_call(1, _t1);
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    __esp = __esp + 4;
    return;
}

camlUnix__close_process_in_2003(
    intOrPtr __eax                         // r0
)
{// addr = 0x0804D6C0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _t7;                          // _t7
    _unknown_ _t8;                         // _t8
    _unknown_ _t11;                        // _t11

    __ecx = __eax;
     *__esp = __ecx;
    while(1) {
        _t7 = caml_young_ptr - 8;
        caml_young_ptr = _t7;
        if(_t7 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    __ebx = _t7 + 4;
     *((intOrPtr*)(__ebx - 4)) = 1025;
     *__ebx = __ecx;
    _v4 = camlUnix__find_proc_id_1997(__edi);
    _push( *__esp);
    caml_c_call();
    __esp = __esp + 4;
    camlUnix__waitpid_non_intr_2001();
    return  *((intOrPtr*)(_v4 + 4));
}

camlUnix__close_process_out_2006(
    intOrPtr __eax                         // r0
)
{// addr = 0x0804D730
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _t7;                          // _t7
    _unknown_ _t8;                         // _t8
    _unknown_ _t10;                        // _t10

    __ecx = __eax;
     *__esp = __ecx;
    while(1) {
        _t7 = caml_young_ptr - 8;
        caml_young_ptr = _t7;
        if(_t7 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    __ebx = _t7 + 4;
     *((intOrPtr*)(__ebx - 4)) = 1026;
     *__ebx = __ecx;
    _v4 = camlUnix__find_proc_id_1997(__edi);
    camlPervasives__close_out_1209();
    camlUnix__waitpid_non_intr_2001();
    return  *((intOrPtr*)(_v4 + 4));
}

camlUnix__close_process_2009(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx,                        // r1
    _unknown_ __edi,                       // r4
    _unknown_ __esi                        // r5
)
{// addr = 0x0804D790
    _unknown_ _v0;                         // _cfa_0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _t12;                         // _t12
    _unknown_ _t13;                        // _t13
    _unknown_ _t20;                        // _t20
    _unknown_ _t21;                        // _t21
    intOrPtr* _t23;                        // _t23
    intOrPtr _t25;                         // _t25
    _unknown_ _t27;                        // _t27
    _unknown_ _t28;                        // _t28
    _unknown_ _t29;                        // _t29
    _unknown_ _t30;                        // _t30

    _t27 = __edi;
    __edx = __ebx;
    _v4 = __edx;
    _t25 = __eax;
     *__esp = _t25;
    while(1) {
        _t12 = caml_young_ptr - 12;
        caml_young_ptr = _t12;
        if(_t12 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t23 = _t12 + 4;
     *((intOrPtr*)(_t23 - 4)) = 2048;
     *_t23 = _t25;
     *((intOrPtr*)(_t23 + 4)) = __edx;
    _v8 = camlUnix__find_proc_id_1997(_t27);
    _push( *__esp);
    caml_c_call();
    __esp = __esp + 4;
    L4();
    if( *caml_ml_close_channel !=  &caml_exn_Sys_error) {
        caml_raise_exn(caml_ml_close_channel);
        _push(caml_exception_pointer);
        caml_exception_pointer = __esp;
        camlPervasives__close_out_1209();
        _pop(caml_exception_pointer);
        __esp = __esp + 4;
    }
    camlUnix__waitpid_non_intr_2001();
    return  *((intOrPtr*)(_v8 + 4));
}

L0804D800(
    intOrPtr __esp,                        // r7
    intOrPtr _a8,                          // _cfa_8
    _unknown_ _a12                         // _cfa_c
)
{
    _unknown_ _t3;                         // _t3

    __esp = __esp;
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    camlPervasives__close_out_1209();
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    camlUnix__waitpid_non_intr_2001();
    __esp = __esp + 12;
    return  *((intOrPtr*)(_a8 + 4));
}

camlUnix__close_process_full_2013(
    intOrPtr __eax                         // r0
)
{// addr = 0x0804D840
    _unknown_ _v0;                         // _cfa_0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _t13;                         // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t19;                        // _t19
    _unknown_ _t23;                        // _t23
    _unknown_ _t24;                        // _t24
    intOrPtr _t25;                         // _t25
    intOrPtr* _t26;                        // _t26
    intOrPtr _t28;                         // _t28

    _v12 = _t28;
    __esi = _t25;
    _v4 = __esi;
    __edx = __eax;
     *__esp = __edx;
    while(1) {
        _t13 = caml_young_ptr - 16;
        caml_young_ptr = _t13;
        if(_t13 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t26 = _t13 + 4;
     *((intOrPtr*)(_t26 - 4)) = 3075;
     *_t26 = __edx;
     *((intOrPtr*)(_t26 + 4)) = __esi;
     *((intOrPtr*)(_t26 + 8)) = _t28;
    _v8 = camlUnix__find_proc_id_1997(__edi);
    _push( *__esp);
    caml_c_call();
    __esp = __esp + 4;
    L4();
    if( *caml_ml_close_channel !=  &caml_exn_Sys_error) {
        caml_raise_exn(caml_ml_close_channel);
        _push(caml_exception_pointer);
        caml_exception_pointer = __esp;
        camlPervasives__close_out_1209();
        _pop(caml_exception_pointer);
        __esp = __esp + 4;
    }
    _push(_v12);
    caml_c_call();
    __esp = __esp + 4;
    camlUnix__waitpid_non_intr_2001();
    return  *((intOrPtr*)(_v8 + 4));
}

L0804D8C0(
    intOrPtr __esp,                        // r7
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    _unknown_ _a16                         // _cfa_10
)
{
    _unknown_ _t4;                         // _t4
    _unknown_ _t6;                         // _t6

    __esp = __esp;
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    camlPervasives__close_out_1209();
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    _push(_a8);
    caml_c_call();
    __esp = __esp + 4;
    camlUnix__waitpid_non_intr_2001();
    __esp = __esp + 16;
    return  *((intOrPtr*)(_a12 + 4));
}

camlUnix__open_connection_2018()
{// addr = 0x0804D910
    intOrPtr _v0;                          // _cfa_0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    _unknown_ _t18;                        // _t18
    _unknown_ _t20;                        // _t20
    _unknown_ _t21;                        // _t21
    _unknown_ _t23;                        // _t23
    intOrPtr _t29;                         // _t29
    intOrPtr* _t30;                        // _t30
    intOrPtr _t32;                         // _t32
    _unknown_ _t34;                        // _t34
    _unknown_ _t35;                        // _t35
    _unknown_ _t36;                        // _t36
    _unknown_ _t37;                        // _t37

     *__esp = _t14;
    _t15 = camlUnix__domain_of_sockaddr_1529(_t14);
    _push(1);
    caml_c_call(_t15, 1);
    __esp = __esp + 4;
    _v4 = unix_socket;
    L1();
     *__esp = unix_socket;
    _push(_v4);
    caml_c_call();
    __esp = __esp + 4;
    _t20 = caml_raise_exn( *__esp);
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_c_call(_t20, _v4);
    camlUnix__try_set_close_on_exec_1366(_v0);
    _push(_v0);
    caml_c_call();
    __esp = __esp + 4;
    _v4 = caml_ml_open_descriptor_out;
    _push(_v0);
    caml_c_call();
    __esp = __esp + 4;
    _t32 = caml_ml_open_descriptor_in;
    while(1) {
        _t29 = caml_young_ptr - 12;
        caml_young_ptr = _t29;
        if(_t29 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t30 = _t29 + 4;
     *((intOrPtr*)(_t30 - 4)) = 2048;
     *_t30 = _t32;
     *((intOrPtr*)(_t30 + 4)) = _v4;
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    return;
}

L0804D960(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{
    _unknown_ _t10;                        // _t10
    _unknown_ _t11;                        // _t11
    _unknown_ _t13;                        // _t13
    intOrPtr _t19;                         // _t19
    intOrPtr* _t20;                        // _t20
    intOrPtr _t22;                         // _t22

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_c_call(_t10, _a4);
    camlUnix__try_set_close_on_exec_1366(_a8);
    _push(_a8);
    caml_c_call();
    __esp = __esp + 4;
    _a4 = caml_ml_open_descriptor_out;
    _push(_a8);
    caml_c_call();
    __esp = __esp + 4;
    _t22 = caml_ml_open_descriptor_in;
    while(1) {
        _t19 = caml_young_ptr - 12;
        caml_young_ptr = _t19;
        if(_t19 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t20 = _t19 + 4;
     *((intOrPtr*)(_t20 - 4)) = 2048;
     *_t20 = _t22;
     *((intOrPtr*)(_t20 + 4)) = _a4;
    _pop(caml_exception_pointer);
    __esp = __esp + 8;
    return;
}

camlUnix__shutdown_connection_2022()
{// addr = 0x0804D9F0
    _unknown_ _t1;                         // _t1
    _unknown_ _t3;                         // _t3

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    caml_c_call(caml_channel_descriptor, 3);
    return;
}

camlUnix__accept_non_intr_2024()
{// addr = 0x0804DA10
    intOrPtr* _t6;                         // _t6
    _unknown_ _t7;                         // _t7
    _unknown_ _t8;                         // _t8
    signed int _t10;                       // _t10
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14

    while(1) {
         *__esp = _t6;
        L6();
        if( *_t6 != camlUnix) {
            break;
        }
        _t10 =  *(_t6 + 4);
        if((_t10 & 1) == 0 || _t10 != 23) {
        } else {
            _t6 =  *__esp;
            continue;
        }
        break;
L7:
    }
    _t7 = caml_raise_exn(_t6);
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    _push(_t7);
    caml_c_call();
    __esp = __esp + 4;
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    return;
    goto L7;
}

L0804DA50()
{
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    __esp = __esp + 4;
    return;
}

camlUnix__establish_server_2026()
{// addr = 0x0804DA80
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _v12;                        // _cfa_fffffff4
    intOrPtr _t13;                         // _t13
    _unknown_ _t15;                        // _t15
    _unknown_ _t19;                        // _t19
    _unknown_ _t21;                        // _t21
    _unknown_ _t27;                        // _t27
    _unknown_ _t29;                        // _t29
    _unknown_ _t34;                        // _t34
    _unknown_ _t35;                        // _t35
    _unknown_ _t36;                        // _t36
    _unknown_ _t38;                        // _t38
    _unknown_ _t39;                        // _t39
    intOrPtr* _t40;                        // _t40
    _unknown_ _t41;                        // _t41
    _unknown_ _t42;                        // _t42
    _unknown_ _t43;                        // _t43
    _unknown_ _t44;                        // _t44

    _v8 = _t13;
     *__esp = _t40;
    _t15 = camlUnix__domain_of_sockaddr_1529(_t40);
    _push(1);
    caml_c_call(_t15, 1);
    __esp = __esp + 4;
    _v12 = unix_socket;
    camlUnix__setsockopt_1646();
    caml_c_call(_v12,  *__esp);
    caml_c_call(_v12, 11);
    while(1) {
L1:
        camlUnix__accept_non_intr_2024();
        _v4 =  *_v12;
        _push(1);
        caml_c_call();
        __esp = __esp + 4;
         *__esp = unix_fork;
        if(unix_fork == 1) {
            break;
        }
        _push(_v4);
        caml_c_call();
        __esp = __esp + 4;
        camlUnix__waitpid_non_intr_2001();
    }
    _push(1);
    caml_c_call();
    __esp = __esp + 4;
    if(unix_fork != 1) {
        camlPervasives__exit_1326();
    }
    _push(_v12);
    caml_c_call();
    __esp = __esp + 4;
    camlUnix__try_set_close_on_exec_1366(_v4);
    _push(_v4);
    caml_c_call();
    __esp = __esp + 4;
     *__esp = caml_ml_open_descriptor_in;
    _push(_v4);
    caml_c_call();
    __esp = __esp + 4;
    caml_apply2();
    camlPervasives__exit_1326();
    goto L1;
}

camlUnix__entry(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804DBC0
    _unknown_ _t23;                        // _t23
    _unknown_ _t24;                        // _t24
    intOrPtr* _t25;                        // _t25
    _unknown_ _t27;                        // _t27
    _unknown_ _t32;                        // _t32
    _unknown_ _t33;                        // _t33
    intOrPtr* _t34;                        // _t34
    _unknown_ _t40;                        // _t40
    intOrPtr* _t41;                        // _t41
    _unknown_ _t42;                        // _t42
    intOrPtr _t43;                         // _t43
    _unknown_ _t49;                        // _t49
    intOrPtr* _t50;                        // _t50
    _unknown_ _t70;                        // _t70
    _unknown_ _t87;                        // _t87
    intOrPtr* _t88;                        // _t88

     *134668948 =  &camlUnix__175;
     *134668944 =  &camlUnix__174;
     *134668940 =  &camlUnix__173;
     *134668936 =  &camlUnix__172;
     *134668932 =  &camlUnix__171;
     *134668928 =  &camlUnix__170;
     *134668924 =  &camlUnix__169;
     *134668912 =  &camlUnix__168;
     *134668908 =  &camlUnix__167;
     *134668904 =  &camlUnix__166;
     *134668900 =  &camlUnix__165;
     *134668896 =  &camlUnix__164;
     *134668892 =  &camlUnix__163;
     *134668888 =  &camlUnix__162;
     *134668820 =  &camlUnix__161;
     *134668816 =  &camlUnix__160;
     *134668812 =  &camlUnix__159;
     *134668808 =  &camlUnix__158;
     *134668804 =  &camlUnix__157;
     *134668800 =  &camlUnix__156;
     *134668796 =  &camlUnix__155;
     *134668792 =  &camlUnix__154;
     *134668784 =  &camlUnix__153;
     *134668764 =  &camlUnix__152;
     *134668760 =  &camlUnix__151;
     *134668756 =  &camlUnix__150;
     *134668752 =  &camlUnix__149;
     *134668748 =  &camlUnix__148;
     *134668744 =  &camlUnix__147;
     *134668740 =  &camlUnix__146;
     *134668736 =  &camlUnix__145;
     *134668732 =  &camlUnix__144;
     *134668728 =  &camlUnix__143;
     *134668724 =  &camlUnix__142;
     *134668720 =  &camlUnix__141;
     *134668716 =  &camlUnix__140;
     *134668712 =  &camlUnix__139;
     *134668708 =  &camlUnix__138;
     *134668704 =  &camlUnix__137;
     *134668700 =  &camlUnix__136;
     *134668696 =  &camlUnix__135;
     *134668692 =  &camlUnix__134;
     *134668688 =  &camlUnix__133;
     *134668684 =  &camlUnix__132;
     *134668680 =  &camlUnix__131;
     *134668676 =  &camlUnix__130;
     *134668672 =  &camlUnix__129;
     *134668668 =  &camlUnix__128;
     *134668664 =  &camlUnix__127;
     *134668660 =  &camlUnix__126;
     *134668652 =  &camlUnix__125;
     *134668648 =  &camlUnix__124;
     *134668644 =  &camlUnix__123;
     *134668640 =  &camlUnix__122;
     *134668636 =  &camlUnix__121;
     *134668632 =  &camlUnix__120;
     *134668628 =  &camlUnix__119;
     *134668624 =  &camlUnix__118;
     *134668580 =  &camlUnix__117;
     *134668576 =  &camlUnix__116;
     *134668572 =  &camlUnix__115;
     *134668568 =  &camlUnix__114;
     *134668564 =  &camlUnix__113;
     *134668560 =  &camlUnix__112;
     *134668556 =  &camlUnix__111;
     *134668552 =  &camlUnix__110;
     *134668548 =  &camlUnix__109;
     *134668544 =  &camlUnix__108;
     *134668540 =  &camlUnix__107;
     *134668536 =  &camlUnix__106;
     *134668532 =  &camlUnix__105;
     *134668528 =  &camlUnix__104;
     *134668524 =  &camlUnix__103;
     *134668520 =  &camlUnix__102;
     *134668516 =  &camlUnix__101;
     *134668512 =  &camlUnix__100;
     *134668508 =  &camlUnix__99;
     *134668504 =  &camlUnix__98;
     *134668500 =  &camlUnix__97;
     *134668496 =  &camlUnix__96;
     *134668492 =  &camlUnix__95;
     *134668488 =  &camlUnix__94;
     *134668484 =  &camlUnix__93;
     *134668480 =  &camlUnix__92;
     *134668472 =  &camlUnix__91;
     *134668468 =  &camlUnix__90;
     *134668464 =  &camlUnix__89;
     *134668460 =  &camlUnix__88;
     *134668456 =  &camlUnix__87;
     *134668452 =  &camlUnix__86;
     *134668448 =  &camlUnix__85;
     *134668444 =  &camlUnix__84;
     *134668440 =  &camlUnix__83;
     *134668436 =  &camlUnix__82;
     *134668432 =  &camlUnix__81;
     *134668416 =  &camlUnix__80;
     *134668412 =  &camlUnix__79;
     *134668396 =  &camlUnix__78;
     *134668392 =  &camlUnix__77;
     *134668388 =  &camlUnix__76;
     *134668380 =  &camlUnix__75;
     *134668376 =  &camlUnix__74;
     *134668372 =  &camlUnix__73;
     *134668368 =  &camlUnix__72;
     *134668364 =  &camlUnix__71;
     *134668360 =  &camlUnix__70;
     *134668356 =  &camlUnix__69;
     *134668352 =  &camlUnix__68;
     *134668348 =  &camlUnix__67;
     *134668344 =  &camlUnix__66;
     *134668336 =  &camlUnix__65;
    caml_allocN(28, __esp);
    _t25 = 0x20;
     *((intOrPtr*)(_t25 - 4)) = 1024;
     *_t25 = "Unix.Unix_error";
    camlUnix = _t25;
    _t88 = _t25 + 8;
     *((intOrPtr*)(_t88 - 4)) = 4096;
     *_t88 = camlUnix;
     *((intOrPtr*)(_t88 + 4)) = 1;
     *((intOrPtr*)(_t88 + 8)) =  &camlUnix__62;
     *((intOrPtr*)(_t88 + 12)) =  &camlUnix__63;
    camlCallback__register_exception_1034();
     *134668340 =  &camlUnix__60;
     *134668400 = 1;
     *134668404 = 3;
     *134668408 = 5;
     *134668420 =  &camlUnix__59;
     *134668424 =  &camlUnix__58;
     *134668428 =  &camlUnix__57;
    caml_allocN(28, __esp);
    _t34 = 0x20;
     *((intOrPtr*)(_t34 - 4)) = 6144;
     *_t34 =  &camlUnix__50;
     *((intOrPtr*)(_t34 + 4)) =  &camlUnix__51;
     *((intOrPtr*)(_t34 + 8)) =  &camlUnix__52;
     *((intOrPtr*)(_t34 + 12)) =  &camlUnix__53;
     *((intOrPtr*)(_t34 + 16)) =  &camlUnix__54;
     *((intOrPtr*)(_t34 + 20)) =  &camlUnix__55;
     *134668476 = _t34;
     *134668952 =  &camlUnix__49;
     *134668656 =  &camlUnix__48;
     *134668956 =  &camlUnix__47;
    _push("0.0.0.0");
    caml_c_call();
    __esp = __esp + 4;
     *134668768 = unix_inet_addr_of_string;
    _push("127.0.0.1");
    caml_c_call();
    __esp = __esp + 4;
     *134668772 = unix_inet_addr_of_string;
    L3();
    if( *unix_inet_addr_of_string !=  &caml_exn_Failure) {
        caml_raise_exn(unix_inet_addr_of_string);
        _push(caml_exception_pointer);
        caml_exception_pointer = __esp;
        _push( &camlUnix__44);
        _t41 = unix_inet_addr_of_string;
        caml_c_call();
        __esp = __esp + 4;
        _pop(caml_exception_pointer);
        __esp = __esp + 4;
L4:
         *134668776 = _t41;
        L7();
        if( *_t41 !=  &caml_exn_Failure) {
            caml_raise_exn(_t41);
            _push(caml_exception_pointer);
            caml_exception_pointer = __esp;
            _push( &camlUnix__43);
            _t43 = unix_inet_addr_of_string;
            caml_c_call();
            __esp = __esp + 4;
            _pop(caml_exception_pointer);
            __esp = __esp + 4;
L8:
             *134668780 = _t43;
             *134668788 =  &camlUnix__42;
             *134668824 =  &camlUnix__41;
             *134668828 =  &camlUnix__40;
             *134668832 =  &camlUnix__39;
             *134668836 =  &camlUnix__38;
            caml_allocN(32, __esp);
            _t50 = 0x24;
             *((intOrPtr*)(_t50 - 4)) = 7168;
             *_t50 = 1;
             *((intOrPtr*)(_t50 + 4)) = 3;
             *((intOrPtr*)(_t50 + 8)) = 5;
             *((intOrPtr*)(_t50 + 12)) = 7;
             *((intOrPtr*)(_t50 + 16)) = 9;
             *((intOrPtr*)(_t50 + 20)) =  &camlUnix__36;
             *((intOrPtr*)(_t50 + 24)) =  &camlUnix__37;
             *134668960 = _t50;
             *134668840 =  &camlUnix__35;
             *134668844 =  &camlUnix__34;
             *134668848 =  &camlUnix__33;
             *134668852 =  &camlUnix__32;
             *134668856 =  &camlUnix__31;
             *134668860 =  &camlUnix__30;
             *134668864 =  &camlUnix__29;
             *134668868 =  &camlUnix__28;
             *134668872 =  &camlUnix__27;
             *134668964 =  &camlUnix__26;
             *134668916 =  &camlUnix__25;
             *134668968 =  &camlUnix__24;
             *134668920 =  &camlUnix__23;
             *134668384 =  &camlUnix__22;
             *134668972 =  &camlUnix__21;
             *134668976 =  &camlUnix__20;
             *134668980 =  &camlUnix__19;
             *134668584 =  &camlUnix__18;
             *134668588 =  &camlUnix__17;
            camlHashtbl__create_1051(15);
             *134668984 = 15;
             *134668988 =  &camlUnix__16;
             *134668592 =  &camlUnix__15;
             *134668596 =  &camlUnix__14;
             *134668600 =  &camlUnix__13;
             *134668992 =  &camlUnix__12;
             *134668604 =  &camlUnix__11;
             *134668996 =  &camlUnix__10;
             *134669000 =  &camlUnix__9;
             *134668608 =  &camlUnix__8;
             *134668612 =  &camlUnix__7;
             *134668616 =  &camlUnix__6;
             *134668620 =  &camlUnix__5;
             *134668876 =  &camlUnix__4;
             *134668880 =  &camlUnix__3;
             *134669004 =  &camlUnix__2;
             *134668884 =  &camlUnix__1;
            return 1;
        }
        _t43 =  *134668772;
        goto L8;
    }
    _t41 =  *134668768;
    goto L4;
}

L0804E15A(
    _unknown_ __eax                        // r0
)
{
    _unknown_ _t9;                         // _t9
    _unknown_ _t11;                        // _t11
    intOrPtr _t12;                         // _t12
    _unknown_ _t18;                        // _t18
    intOrPtr* _t19;                        // _t19
    _unknown_ _t39;                        // _t39
    _unknown_ _t56;                        // _t56

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    _push( &camlUnix__44);
    caml_c_call();
    __esp = __esp + 4;
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
     *134668776 = unix_inet_addr_of_string;
    L4();
    if( *unix_inet_addr_of_string !=  &caml_exn_Failure) {
        caml_raise_exn(unix_inet_addr_of_string);
        _push(caml_exception_pointer);
        caml_exception_pointer = __esp;
        _push( &camlUnix__43);
        _t12 = unix_inet_addr_of_string;
        caml_c_call();
        __esp = __esp + 4;
        _pop(caml_exception_pointer);
        __esp = __esp + 4;
L5:
         *134668780 = _t12;
         *134668788 =  &camlUnix__42;
         *134668824 =  &camlUnix__41;
         *134668828 =  &camlUnix__40;
         *134668832 =  &camlUnix__39;
         *134668836 =  &camlUnix__38;
        caml_allocN(32, __esp);
        _t19 = 0x24;
         *((intOrPtr*)(_t19 - 4)) = 7168;
         *_t19 = 1;
         *((intOrPtr*)(_t19 + 4)) = 3;
         *((intOrPtr*)(_t19 + 8)) = 5;
         *((intOrPtr*)(_t19 + 12)) = 7;
         *((intOrPtr*)(_t19 + 16)) = 9;
         *((intOrPtr*)(_t19 + 20)) =  &camlUnix__36;
         *((intOrPtr*)(_t19 + 24)) =  &camlUnix__37;
         *134668960 = _t19;
         *134668840 =  &camlUnix__35;
         *134668844 =  &camlUnix__34;
         *134668848 =  &camlUnix__33;
         *134668852 =  &camlUnix__32;
         *134668856 =  &camlUnix__31;
         *134668860 =  &camlUnix__30;
         *134668864 =  &camlUnix__29;
         *134668868 =  &camlUnix__28;
         *134668872 =  &camlUnix__27;
         *134668964 =  &camlUnix__26;
         *134668916 =  &camlUnix__25;
         *134668968 =  &camlUnix__24;
         *134668920 =  &camlUnix__23;
         *134668384 =  &camlUnix__22;
         *134668972 =  &camlUnix__21;
         *134668976 =  &camlUnix__20;
         *134668980 =  &camlUnix__19;
         *134668584 =  &camlUnix__18;
         *134668588 =  &camlUnix__17;
        camlHashtbl__create_1051(15);
         *134668984 = 15;
         *134668988 =  &camlUnix__16;
         *134668592 =  &camlUnix__15;
         *134668596 =  &camlUnix__14;
         *134668600 =  &camlUnix__13;
         *134668992 =  &camlUnix__12;
         *134668604 =  &camlUnix__11;
         *134668996 =  &camlUnix__10;
         *134669000 =  &camlUnix__9;
         *134668608 =  &camlUnix__8;
         *134668612 =  &camlUnix__7;
         *134668616 =  &camlUnix__6;
         *134668620 =  &camlUnix__5;
         *134668876 =  &camlUnix__4;
         *134668880 =  &camlUnix__3;
         *134669004 =  &camlUnix__2;
         *134668884 =  &camlUnix__1;
        return 1;
    }
    _t12 =  *134668772;
    goto L5;
}

L0804E1A2(
    _unknown_ __eax                        // r0
)
{
    _unknown_ _t9;                         // _t9
    _unknown_ _t16;                        // _t16
    intOrPtr* _t17;                        // _t17
    _unknown_ _t37;                        // _t37
    _unknown_ _t54;                        // _t54

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    _push( &camlUnix__43);
    caml_c_call();
    __esp = __esp + 4;
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
     *134668780 = unix_inet_addr_of_string;
     *134668788 =  &camlUnix__42;
     *134668824 =  &camlUnix__41;
     *134668828 =  &camlUnix__40;
     *134668832 =  &camlUnix__39;
     *134668836 =  &camlUnix__38;
    caml_allocN(32, __esp);
    _t17 = 0x24;
     *((intOrPtr*)(_t17 - 4)) = 7168;
     *_t17 = 1;
     *((intOrPtr*)(_t17 + 4)) = 3;
     *((intOrPtr*)(_t17 + 8)) = 5;
     *((intOrPtr*)(_t17 + 12)) = 7;
     *((intOrPtr*)(_t17 + 16)) = 9;
     *((intOrPtr*)(_t17 + 20)) =  &camlUnix__36;
     *((intOrPtr*)(_t17 + 24)) =  &camlUnix__37;
     *134668960 = _t17;
     *134668840 =  &camlUnix__35;
     *134668844 =  &camlUnix__34;
     *134668848 =  &camlUnix__33;
     *134668852 =  &camlUnix__32;
     *134668856 =  &camlUnix__31;
     *134668860 =  &camlUnix__30;
     *134668864 =  &camlUnix__29;
     *134668868 =  &camlUnix__28;
     *134668872 =  &camlUnix__27;
     *134668964 =  &camlUnix__26;
     *134668916 =  &camlUnix__25;
     *134668968 =  &camlUnix__24;
     *134668920 =  &camlUnix__23;
     *134668384 =  &camlUnix__22;
     *134668972 =  &camlUnix__21;
     *134668976 =  &camlUnix__20;
     *134668980 =  &camlUnix__19;
     *134668584 =  &camlUnix__18;
     *134668588 =  &camlUnix__17;
    camlHashtbl__create_1051(15);
     *134668984 = 15;
     *134668988 =  &camlUnix__16;
     *134668592 =  &camlUnix__15;
     *134668596 =  &camlUnix__14;
     *134668600 =  &camlUnix__13;
     *134668992 =  &camlUnix__12;
     *134668604 =  &camlUnix__11;
     *134668996 =  &camlUnix__10;
     *134669000 =  &camlUnix__9;
     *134668608 =  &camlUnix__8;
     *134668612 =  &camlUnix__7;
     *134668616 =  &camlUnix__6;
     *134668620 =  &camlUnix__5;
     *134668876 =  &camlUnix__4;
     *134668880 =  &camlUnix__3;
     *134669004 =  &camlUnix__2;
     *134668884 =  &camlUnix__1;
    return 1;
}

camlUnixLabels__code_begin()
{// addr = 0x0804E3C0
    intOrPtr* _t152;                       // _t152
    _unknown_ _t154;                       // _t154

    _t152 =  &camlUnix;
    camlUnixLabels =  *_t152;
     *134677924 =  *((intOrPtr*)(_t152 + 4));
     *134677928 =  *((intOrPtr*)(_t152 + 8));
     *134677932 =  *((intOrPtr*)(_t152 + 12));
     *134677936 =  *((intOrPtr*)(_t152 + 16));
     *134677940 =  *((intOrPtr*)(_t152 + 20));
     *134677944 =  *((intOrPtr*)(_t152 + 24));
     *134677948 =  *((intOrPtr*)(_t152 + 28));
     *134677952 =  *((intOrPtr*)(_t152 + 32));
     *134677956 =  *((intOrPtr*)(_t152 + 36));
     *134677960 =  *((intOrPtr*)(_t152 + 40));
     *134677964 =  *((intOrPtr*)(_t152 + 44));
     *134677968 =  *((intOrPtr*)(_t152 + 48));
     *134677972 =  *((intOrPtr*)(_t152 + 52));
     *134677976 =  *((intOrPtr*)(_t152 + 56));
     *134677980 =  *((intOrPtr*)(_t152 + 60));
     *134677984 =  *((intOrPtr*)(_t152 + 64));
     *134677988 = 1;
     *134677992 = 3;
     *134677996 = 5;
     *134678000 =  *((intOrPtr*)(_t152 + 80));
     *134678004 =  *((intOrPtr*)(_t152 + 84));
     *134678008 =  *((intOrPtr*)(_t152 + 88));
     *134678012 =  *((intOrPtr*)(_t152 + 92));
     *134678016 =  *((intOrPtr*)(_t152 + 96));
     *134678020 =  *((intOrPtr*)(_t152 + 100));
     *134678024 =  *((intOrPtr*)(_t152 + 104));
     *134678028 =  *((intOrPtr*)(_t152 + 108));
     *134678032 =  *((intOrPtr*)(_t152 + 112));
     *134678036 =  *((intOrPtr*)(_t152 + 116));
     *134678040 =  *((intOrPtr*)(_t152 + 120));
     *134678044 =  *((intOrPtr*)(_t152 + 124));
     *134678048 =  *((intOrPtr*)(_t152 + 128));
     *134678052 =  *((intOrPtr*)(_t152 + 132));
     *134678056 =  *((intOrPtr*)(_t152 + 136));
     *134678060 =  *((intOrPtr*)(_t152 + 140));
     *134678064 =  *((intOrPtr*)(_t152 + 144));
     *134678068 =  *((intOrPtr*)(_t152 + 148));
     *134678072 =  *((intOrPtr*)(_t152 + 152));
     *134678076 =  *((intOrPtr*)(_t152 + 156));
     *134678080 =  *((intOrPtr*)(_t152 + 160));
     *134678084 =  *((intOrPtr*)(_t152 + 164));
     *134678088 =  *((intOrPtr*)(_t152 + 168));
     *134678092 =  *((intOrPtr*)(_t152 + 172));
     *134678096 =  *((intOrPtr*)(_t152 + 176));
     *134678100 =  *((intOrPtr*)(_t152 + 180));
     *134678104 =  *((intOrPtr*)(_t152 + 184));
     *134678108 =  *((intOrPtr*)(_t152 + 188));
     *134678112 =  *((intOrPtr*)(_t152 + 192));
     *134678116 =  *((intOrPtr*)(_t152 + 196));
     *134678120 =  *((intOrPtr*)(_t152 + 200));
     *134678124 =  *((intOrPtr*)(_t152 + 204));
     *134678128 =  *((intOrPtr*)(_t152 + 208));
     *134678132 =  *((intOrPtr*)(_t152 + 212));
     *134678136 =  *((intOrPtr*)(_t152 + 216));
     *134678140 =  *((intOrPtr*)(_t152 + 220));
     *134678144 =  *((intOrPtr*)(_t152 + 224));
     *134678148 =  *((intOrPtr*)(_t152 + 228));
     *134678152 =  *((intOrPtr*)(_t152 + 232));
     *134678156 =  *((intOrPtr*)(_t152 + 236));
     *134678160 =  *((intOrPtr*)(_t152 + 240));
     *134678164 =  *((intOrPtr*)(_t152 + 244));
     *134678168 =  *((intOrPtr*)(_t152 + 248));
     *134678172 =  *((intOrPtr*)(_t152 + 252));
     *134678176 =  *((intOrPtr*)(_t152 + 256));
     *134678180 =  *((intOrPtr*)(_t152 + 260));
     *134678184 =  *((intOrPtr*)(_t152 + 264));
     *134678188 =  *((intOrPtr*)(_t152 + 268));
     *134678192 =  *((intOrPtr*)(_t152 + 272));
     *134678196 =  *((intOrPtr*)(_t152 + 276));
     *134678200 =  *((intOrPtr*)(_t152 + 280));
     *134678204 =  *((intOrPtr*)(_t152 + 284));
     *134678208 =  *((intOrPtr*)(_t152 + 288));
     *134678212 =  *((intOrPtr*)(_t152 + 292));
     *134678216 =  *((intOrPtr*)(_t152 + 296));
     *134678220 =  *((intOrPtr*)(_t152 + 300));
     *134678224 =  *((intOrPtr*)(_t152 + 304));
     *134678228 =  *((intOrPtr*)(_t152 + 308));
     *134678232 =  *((intOrPtr*)(_t152 + 312));
     *134678236 =  *((intOrPtr*)(_t152 + 316));
     *134678240 =  *((intOrPtr*)(_t152 + 320));
     *134678244 =  *((intOrPtr*)(_t152 + 324));
     *134678248 =  *((intOrPtr*)(_t152 + 328));
     *134678252 =  *((intOrPtr*)(_t152 + 332));
     *134678256 =  *((intOrPtr*)(_t152 + 336));
     *134678260 =  *((intOrPtr*)(_t152 + 340));
     *134678264 =  *((intOrPtr*)(_t152 + 344));
     *134678268 =  *((intOrPtr*)(_t152 + 348));
     *134678272 =  *((intOrPtr*)(_t152 + 352));
     *134678276 =  *((intOrPtr*)(_t152 + 356));
     *134678280 =  *((intOrPtr*)(_t152 + 360));
     *134678284 =  *((intOrPtr*)(_t152 + 364));
     *134678288 =  *((intOrPtr*)(_t152 + 368));
     *134678292 =  *((intOrPtr*)(_t152 + 372));
     *134678296 =  *((intOrPtr*)(_t152 + 376));
     *134678300 =  *((intOrPtr*)(_t152 + 380));
     *134678304 =  *((intOrPtr*)(_t152 + 384));
     *134678308 =  *((intOrPtr*)(_t152 + 388));
     *134678312 =  *((intOrPtr*)(_t152 + 392));
     *134678316 =  *((intOrPtr*)(_t152 + 396));
     *134678320 =  *((intOrPtr*)(_t152 + 400));
     *134678324 =  *((intOrPtr*)(_t152 + 404));
     *134678328 =  *((intOrPtr*)(_t152 + 408));
     *134678332 =  *((intOrPtr*)(_t152 + 412));
     *134678336 =  *((intOrPtr*)(_t152 + 416));
     *134678340 =  *((intOrPtr*)(_t152 + 420));
     *134678344 =  *((intOrPtr*)(_t152 + 424));
     *134678348 =  *((intOrPtr*)(_t152 + 428));
     *134678352 =  *((intOrPtr*)(_t152 + 432));
     *134678356 =  *((intOrPtr*)(_t152 + 436));
     *134678360 =  *((intOrPtr*)(_t152 + 440));
     *134678364 =  *((intOrPtr*)(_t152 + 444));
     *134678368 =  *((intOrPtr*)(_t152 + 448));
     *134678372 =  *((intOrPtr*)(_t152 + 452));
     *134678376 =  *((intOrPtr*)(_t152 + 456));
     *134678380 =  *((intOrPtr*)(_t152 + 460));
     *134678384 =  *((intOrPtr*)(_t152 + 464));
     *134678388 =  *((intOrPtr*)(_t152 + 468));
     *134678392 =  *((intOrPtr*)(_t152 + 472));
     *134678396 =  *((intOrPtr*)(_t152 + 476));
     *134678400 =  *((intOrPtr*)(_t152 + 480));
     *134678404 =  *((intOrPtr*)(_t152 + 484));
     *134678408 =  *((intOrPtr*)(_t152 + 488));
     *134678412 =  *((intOrPtr*)(_t152 + 492));
     *134678416 =  *((intOrPtr*)(_t152 + 496));
     *134678420 =  *((intOrPtr*)(_t152 + 500));
     *134678424 =  *((intOrPtr*)(_t152 + 504));
     *134678428 =  *((intOrPtr*)(_t152 + 508));
     *134678432 =  *((intOrPtr*)(_t152 + 512));
     *134678436 =  *((intOrPtr*)(_t152 + 516));
     *134678440 =  *((intOrPtr*)(_t152 + 520));
     *134678444 =  *((intOrPtr*)(_t152 + 524));
     *134678448 =  *((intOrPtr*)(_t152 + 528));
     *134678452 =  *((intOrPtr*)(_t152 + 532));
     *134678456 =  *((intOrPtr*)(_t152 + 536));
     *134678460 =  *((intOrPtr*)(_t152 + 540));
     *134678464 =  *((intOrPtr*)(_t152 + 544));
     *134678468 =  *((intOrPtr*)(_t152 + 548));
     *134678472 =  *((intOrPtr*)(_t152 + 552));
     *134678476 =  *((intOrPtr*)(_t152 + 556));
     *134678480 =  *((intOrPtr*)(_t152 + 560));
     *134678484 =  *((intOrPtr*)(_t152 + 564));
     *134678488 =  *((intOrPtr*)(_t152 + 568));
     *134678492 =  *((intOrPtr*)(_t152 + 572));
     *134678496 =  *((intOrPtr*)(_t152 + 576));
     *134678500 =  *((intOrPtr*)(_t152 + 580));
     *134678504 =  *((intOrPtr*)(_t152 + 584));
     *134678508 =  *((intOrPtr*)(_t152 + 588));
     *134678512 =  *((intOrPtr*)(_t152 + 592));
     *134678516 =  *((intOrPtr*)(_t152 + 596));
     *134678520 =  *((intOrPtr*)(_t152 + 600));
     *134678524 =  *((intOrPtr*)(_t152 + 604));
     *134678528 =  *((intOrPtr*)(_t152 + 608));
     *134678532 =  *((intOrPtr*)(_t152 + 612));
     *134678536 =  *((intOrPtr*)(_t152 + 616));
    return 1;
}

camlPervasives__iter_1186(
    intOrPtr* __eax                        // r0
)
{// addr = 0x0804EB30
    intOrPtr* _t2;                         // _t2
    _unknown_ _t3;                         // _t3
    _unknown_ _t5;                         // _t5

    _t2 = __eax;
    while(_t2 != 1) {
         *__esp =  *((intOrPtr*)(_t2 + 4));
        L0804EB50( *_t2);
        _t2 =  *__esp;
    }
    return 1;
}

L0804EB50(
    _unknown_ __eax                        // r0
)
{
    intOrPtr _t3;                          // _t3
    _unknown_ _t4;                         // _t4
    _unknown_ _t6;                         // _t6

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    _push(__eax);
    _t3 = caml_ml_flush;
    caml_c_call();
    __esp = __esp + 4;
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    while(1) {
        _t3 =  *__esp;
        goto L1;
    }
}

camlPervasives__build_result_1243(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    intOrPtr* __ecx                        // r2
)
{// addr = 0x0804EB90
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13
    _unknown_ _t15;                        // _t15
    intOrPtr* _t16;                        // _t16
    _unknown_ _t24;                        // _t24

L0:
    while(1) {
L0:
        _t16 = __ecx;
        _t13 = __ebx;
        __edi = __eax;
        if(_t16 == 1) {
            break;
        }
L1:
        caml_blit_string( *_t16, 1, __edi, _t13 - -1 + ( *( *_t16 - 4) >> 10) * 4 - ( *(_t10 + -1 + ( *( *_t16 - 4) >> 10) * 4) & 255) + -1 + ( *( *_t16 - 4) >> 10) * 4 - ( *(_t10 + -1 + ( *( *_t16 - 4) >> 10) * 4) & 255) + 1 + 1, -1 + ( *( *_t16 - 4) >> 10) * 4 - ( *(_t10 + -1 + ( *( *_t16 - 4) >> 10) * 4) & 255) + -1 + ( *( *_t16 - 4) >> 10) * 4 - ( *(_t10 + -1 + ( *( *_t16 - 4) >> 10) * 4) & 255) + 1);
    }
    return __edi;
}

camlPervasives__scan_1249(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    intOrPtr* __ecx,                       // r2
    signed int* __esp                      // r7
)
{// addr = 0x0804EBE0
    signed int _v4;                        // _cfa_fffffffc
    signed int _v8;                        // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ _t47;                        // _t47
    intOrPtr _t49;                         // _t49
    _unknown_ _t50;                        // _t50
    _unknown_ _t51;                        // _t51
    intOrPtr* _t53;                        // _t53
    _unknown_ _t56;                        // _t56

    __esp = __esp;
    _t53 = __ecx;
    _t51 = __ebx;
    _t47 = __eax;
    __esp = __esp - 20;
    while(1) {
        _v4 = __eax;
        _v8 = __ebx;
        _v16 = __ecx;
        _push( *((intOrPtr*)(__ecx + 12)));
        __eax = caml_ml_input_scan_line;
        caml_c_call();
        __esp =  &((__esp)[1]);
        if(caml_ml_input_scan_line == 1) {
            break;
        }
L9:
        _v12 = __eax;
        if(__eax <= 1) {
            2 = 2 - __eax;
            _push(2 - __eax);
            __eax = caml_create_string;
            caml_c_call();
            __esp =  &((__esp)[1]);
             *__esp = caml_create_string;
            __ecx = 2;
            __ebx = _v12;
            __ecx = 2 - _v12;
            _push(2 - _v12);
            _push(1);
            _push(caml_create_string);
            __eax = _v16;
            _push( *((intOrPtr*)(_v16 + 12)));
            __eax = caml_ml_input;
            caml_c_call();
            __esp =  &((__esp)[4]);
            while(1) {
L16:
                __eax = caml_young_ptr;
                __eax = caml_young_ptr - 12;
                caml_young_ptr = __eax;
                if(__eax >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            __eax = __eax + 4;
             *((intOrPtr*)(__eax - 4)) = 2048;
            __ebx =  *__esp;
             *__eax =  *__esp;
            __ebx = _v4;
             *(__eax + 4) = _v4;
            __ebx = _v8;
            __ecx = _v12;
            __ebx = _v8 - _v12;
            __ebx = _v8 - _v12 + 1;
            __ecx = _v16;
            continue;
        } else {
            _push(__eax);
            __eax = caml_create_string;
            caml_c_call();
            __esp =  &((__esp)[1]);
             *__esp = caml_create_string;
            _v12 = _v12 + -2;
            _push(_v12 + -2);
            _push(1);
            _push(caml_create_string);
            __eax = _v16;
            _push( *((intOrPtr*)(_v16 + 12)));
            __eax = caml_ml_input;
            caml_c_call();
            __esp =  &((__esp)[4]);
            __eax = _v16;
            _push( *((intOrPtr*)(_v16 + 12)));
            __eax = caml_ml_input_char;
            caml_c_call();
            __esp =  &((__esp)[1]);
            __ecx = _v4;
            if(__ecx == 1) {
                __eax =  *__esp;
                __esp =  &((__esp)[5]);
                return __eax;
            } else {
                __ebx = _v12;
                __eax = _v8;
                __edx = _v8 + _v12 - 3;
                _v16 = __edx;
                while(1) {
                    __eax = caml_young_ptr;
                    __eax = caml_young_ptr - 12;
                    caml_young_ptr = __eax;
                    if(__eax >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                __ebx = __eax + 4;
                _v12 = __ebx;
                 *((intOrPtr*)(__ebx - 4)) = 2048;
                __eax =  *__esp;
                 *__ebx =  *__esp;
                 *(__ebx + 4) = __ecx;
                _push(__edx);
                __eax = caml_create_string;
                caml_c_call();
                __esp =  &((__esp)[1]);
                __ebx = _v16;
                __ecx = _v12;
                __esp =  &((__esp)[5]);
                while(1) {
L1:
                    __edi = _t47;
                    if(_t53 == 1) {
                        break;
                    }
                    _t49 =  *_t53;
                    _t56 = -1 + ( *(_t49 - 4) >> 10) * 4;
                    __edx =  *(_t49 + _t56) & 255;
                    __esi = _t56 - ( *(_t49 + _t56) & 255) + _t56 - ( *(_t49 + _t56) & 255) + 1;
                    caml_blit_string(_t49, 1, __edi, _t51 - __esi + 1, __esi);
                    _t51 = _t51 - __esi + 1;
                    _t47 = __edi;
                    _t53 =  *((intOrPtr*)(_t53 + 4));
                }
                return __edi;
            }
        }
        goto L16;
    }
    __eax = _v4;
    if(__eax == 1) {
        while(1) {
            __eax = caml_young_ptr;
            __eax = caml_young_ptr - 8;
            caml_young_ptr = __eax;
            if(__eax >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        __eax = __eax + 4;
         *((intOrPtr*)(__eax - 4)) = 1024;
         *__eax =  &caml_exn_End_of_file;
        __eax = caml_raise_exn(__eax);
        asm("o16 nop ");
        goto L9;
    }
    _v4 = __eax;
    __eax = _v8;
    _push(_v8);
    __eax = caml_create_string;
    caml_c_call();
    __esp =  &((__esp)[1]);
    __ebx = _v8;
    __ecx = _v4;
    __esp =  &((__esp)[5]);
    goto L1;
}

camlPervasives__fun_1500()
{// addr = 0x0804EDE0
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4
    _unknown_ _t5;                         // _t5
    intOrPtr _t6;                          // _t6
    _unknown_ _t10;                        // _t10

     *__esp = _t6;
     *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t6 + 8))))))();
    __esp = __esp + 4;
    goto __ecx;
}

camlPervasives__fun_1392()
{// addr = 0x0804EE10
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlPervasives__fun_1394()
{// addr = 0x0804EE20
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlPervasives__fun_1396()
{// addr = 0x0804EE30
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlPervasives__fun_1398()
{// addr = 0x0804EE40
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlPervasives__fun_1400()
{// addr = 0x0804EE50
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlPervasives__fun_1402()
{// addr = 0x0804EE60
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlPervasives__fun_1404()
{// addr = 0x0804EE70
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlPervasives__fun_1406()
{// addr = 0x0804EE80
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlPervasives__fun_1408()
{// addr = 0x0804EE90
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlPervasives__fun_1410()
{// addr = 0x0804EEA0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlPervasives__fun_1412()
{// addr = 0x0804EEB0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlPervasives__fun_1414()
{// addr = 0x0804EEC0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlPervasives__fun_1416()
{// addr = 0x0804EED0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlPervasives__fun_1418()
{// addr = 0x0804EEE0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlPervasives__fun_1420()
{// addr = 0x0804EEF0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlPervasives__fun_1422()
{// addr = 0x0804EF00
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlPervasives__fun_1424()
{// addr = 0x0804EF10
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlPervasives__failwith_1010()
{// addr = 0x0804EF20
    _unknown_ _t4;                         // _t4
    intOrPtr _t6;                          // _t6
    _unknown_ _t7;                         // _t7
    _unknown_ _t8;                         // _t8

    __ebx = _t4;
    while(1) {
        _t6 = caml_young_ptr - 12;
        caml_young_ptr = _t6;
        if(_t6 >= caml_young_limit) {
            _t7 = _t6 + 4;
             *((intOrPtr*)(_t7 - 4)) = 2048;
            caml_raise_exn(_t7, __ebx,  &caml_exn_Failure);
        }
        caml_call_gc(__esp);
    }
}

camlPervasives__invalid_arg_1012()
{// addr = 0x0804EF60
    _unknown_ _t4;                         // _t4
    intOrPtr _t6;                          // _t6
    _unknown_ _t7;                         // _t7
    _unknown_ _t8;                         // _t8

    __ebx = _t4;
    while(1) {
        _t6 = caml_young_ptr - 12;
        caml_young_ptr = _t6;
        if(_t6 >= caml_young_limit) {
            _t7 = _t6 + 4;
             *((intOrPtr*)(_t7 - 4)) = 2048;
            caml_raise_exn(_t7, __ebx,  &caml_exn_Invalid_argument);
        }
        caml_call_gc(__esp);
    }
}

camlPervasives__min_1022(
    intOrPtr __eax,                        // r0
    intOrPtr* __esp                        // r7
)
{// addr = 0x0804EFA0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _t3;                          // _t3

    __esp = __esp;
    _t3 = __eax;
    _v4 = _t3;
     *__esp = __ebx;
    caml_c_call(_t3, __ebx);
    if(caml_lessequal == 1) {
        return  *__esp;
    } else {
        return _v4;
    }
}

camlPervasives__max_1025(
    intOrPtr __eax,                        // r0
    intOrPtr* __esp                        // r7
)
{// addr = 0x0804EFE0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _t3;                          // _t3

    __esp = __esp;
    _t3 = __eax;
    _v4 = _t3;
     *__esp = __ebx;
    caml_c_call(_t3, __ebx);
    if(caml_greaterequal == 1) {
        return  *__esp;
    } else {
        return _v4;
    }
}

camlPervasives__abs_1044(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F020
    _unknown_ _t1;                         // _t1
    _unknown_ _t3;                         // _t3

    _t1 = __eax;
    if(_t1 < 1) {
        return 2 - _t1;
    } else {
        return _t1;
    }
}

camlPervasives__lnot_1049(
    signed int __eax                       // r0
)
{// addr = 0x0804F040
    return __eax ^ 255 | 1;
}

camlPervasives__$5e_1112(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx,                        // r1
    intOrPtr* __esp                        // r7
)
{// addr = 0x0804F050
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _t24;                         // _t24
    _unknown_ _t28;                        // _t28
    _unknown_ _t31;                        // _t31
    intOrPtr _t33;                         // _t33
    intOrPtr _t35;                         // _t35

    __esp = __esp;
    _t33 = __ebx;
    __edx = __eax;
    _v12 = __edx;
    _v4 = _t33;
    _t24 = -1 + ( *(__edx - 4) >> 10) * 4 - ( *(__edx + -1 + ( *(__edx - 4) >> 10) * 4) & 255) + -1 + ( *(__edx - 4) >> 10) * 4 - ( *(__edx + -1 + ( *(__edx - 4) >> 10) * 4) & 255) + 1;
     *__esp = _t24;
    _t35 = -1 + ( *(_t33 - 4) >> 10) * 4 - ( *(_t33 + -1 + ( *(_t33 - 4) >> 10) * 4) & 255) + -1 + ( *(_t33 - 4) >> 10) * 4 - ( *(_t33 + -1 + ( *(_t33 - 4) >> 10) * 4) & 255) + 1;
    _v8 = _t35;
    _push(_t24 + _t35 - 1);
    caml_c_call();
    __esp = __esp + 4;
    __esi =  *__esp;
    caml_blit_string(_v12, 1, caml_create_string, 1,  *__esp);
    caml_blit_string(_v4, 1, caml_create_string, __esi, _v8);
    return caml_create_string;
}

camlPervasives__char_of_int_1120(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F0E0
    intOrPtr _t6;                          // _t6
    _unknown_ _t8;                         // _t8

    if(__eax < 1 || __eax > 511) {
        __ebx = "char_of_int";
        while(1) {
            _t6 = caml_young_ptr - 12;
            caml_young_ptr = _t6;
            if(_t6 >= caml_young_limit) {
                _t7 = _t6 + 4;
                 *((intOrPtr*)(_t6 + 4 - 4)) = 2048;
                caml_raise_exn(_t7, __ebx,  &caml_exn_Invalid_argument);
            }
            caml_call_gc(__esp);
        }
    }
    return;
}

camlPervasives__string_of_bool_1127(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F100
    if(__eax == 1) {
        return  &camlPervasives__100;
    } else {
        return  &camlPervasives__101;
    }
}

camlPervasives__bool_of_string_1129(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F120
    intOrPtr _t5;                          // _t5
    _unknown_ _t6;                         // _t6
    intOrPtr _t8;                          // _t8
    intOrPtr* _t9;                         // _t9
    _unknown_ _t10;                        // _t10
    intOrPtr _t12;                         // _t12

    _t5 = caml_string_notequal(__eax, __eax,  &camlPervasives__99);
    if(_t5 == 1) {
        return 1;
    } else {
        if(__eax != 1) {
            __eax = "bool_of_string";
            _t12 = _t5;
            while(1) {
                _t8 = caml_young_ptr - 12;
                caml_young_ptr = _t8;
                if(_t8 >= caml_young_limit) {
                    _t9 = _t8 + 4;
                     *((intOrPtr*)(_t9 - 4)) = 2048;
                     *_t9 =  &caml_exn_Invalid_argument;
                     *((intOrPtr*)(_t9 + 4)) = _t12;
                    caml_raise_exn(_t9);
                }
                caml_call_gc(__esp);
            }
        }
        __eax = 3;
        return 3;
    }
}

camlPervasives__string_of_int_1130()
{// addr = 0x0804F180
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call( &camlPervasives__96, _t1);
    return;
}

camlPervasives__valid_float_lexem_1135(
    _unknown_ __eax,                       // r0
    intOrPtr* __esp                        // r7
)
{// addr = 0x0804F1A0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    _unknown_ _t48;                        // _t48
    signed int _t49;                       // _t49
    intOrPtr* _t50;                        // _t50
    _unknown_ _t51;                        // _t51
    _unknown_ _t53;                        // _t53
    intOrPtr _t55;                         // _t55
    intOrPtr _t58;                         // _t58
    _unknown_ _t62;                        // _t62
    _unknown_ _t65;                        // _t65
    signed int _t67;                       // _t67
    char* _t69;                            // _t69
    intOrPtr _t71;                         // _t71
    _unknown_ _t73;                        // _t73
    signed int _t76;                       // _t76
    _unknown_ _t78;                        // _t78
    _unknown_ _t87;                        // _t87
    intOrPtr _t88;                         // _t88
    intOrPtr _t89;                         // _t89
    _unknown_ _t94;                        // _t94

    __esp = __esp;
    _t73 = __eax;
    _t48 = -1 + ( *(_t73 - 4) >> 10) * 4;
    _t67 =  *(_t73 + _t48) & 255;
    _t49 = _t48 - _t67;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 20;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    __ebx = __eax + 4;
     *((intOrPtr*)(__ebx - 4)) = 4343;
     *__ebx =  &camlPervasives__code_begin;
     *((intOrPtr*)(__ebx + 4)) = 3;
     *((intOrPtr*)(__ebx + 8)) = __ecx;
     *((intOrPtr*)(__ebx + 12)) = __edx;
    __eax = 1;
    while(_t49 <  *((intOrPtr*)(_t67 + 12))) {
        _t88 =  *((intOrPtr*)(_t67 + 8));
        _t76 = _t49 >> 1;
        if(-1 + ( *(_t88 - 4) >> 10) * 4 - ( *(_t88 + -1 + ( *(_t88 - 4) >> 10) * 4) & 255) <= _t76) {
            _t50 = caml_ml_array_bound_error();
            __esp = __esp - 4;
            while(_t50 != 1) {
                 *__esp =  *((intOrPtr*)(_t50 + 4));
                L0804EB50( *_t50);
                _t50 =  *__esp;
            }
            __esp = __esp + 4;
            return 1;
L20:
        }
        _t78 = ( *(_t88 + _t76) & 255) + ( *(_t88 + _t76) & 255) + 1;
        if(_t78 < 97) {
            if(_t78 == 91) {
                goto L9;
            }
            goto L8;
        } else {
            if(_t78 < 117) {
L9:
                _t49 = _t49 + 2;
                continue;
            }
L8:
            return  *((intOrPtr*)(_t67 + 8));
        }
        goto L20;
    }
    _t55 =  *((intOrPtr*)(_t67 + 8));
    _t69 =  &camlPervasives__103;
    __esp = __esp - 16;
    _t89 = _t55;
    _v12 = _t89;
    _v4 = _t69;
    _t58 = -1 + ( *(_t89 - 4) >> 10) * 4 - ( *(_t89 + -1 + ( *(_t89 - 4) >> 10) * 4) & 255) + -1 + ( *(_t89 - 4) >> 10) * 4 - ( *(_t89 + -1 + ( *(_t89 - 4) >> 10) * 4) & 255) + 1;
     *__esp = _t58;
    _t71 = -1 + ( *(_t69 - 4) >> 10) * 4 - ( *(_t69 + -1 + ( *(_t69 - 4) >> 10) * 4) & 255) + -1 + ( *(_t69 - 4) >> 10) * 4 - ( *(_t69 + -1 + ( *(_t69 - 4) >> 10) * 4) & 255) + 1;
    _v8 = _t71;
    _push(_t58 + _t71 - 1);
    caml_c_call();
    __esp = __esp + 4;
    _t95 =  *__esp;
    caml_blit_string(_v12, 1, caml_create_string, 1,  *__esp);
    caml_blit_string(_v4, 1, caml_create_string, _t95, _v8);
    __esp = __esp + 16;
    return caml_create_string;
    goto L20;
}

camlPervasives__string_of_float_1140()
{// addr = 0x0804F200
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    _unknown_ _t45;                        // _t45
    intOrPtr _t52;                         // _t52
    signed int _t53;                       // _t53
    intOrPtr* _t54;                        // _t54
    _unknown_ _t55;                        // _t55
    _unknown_ _t57;                        // _t57
    intOrPtr _t59;                         // _t59
    intOrPtr _t62;                         // _t62
    _unknown_ _t66;                        // _t66
    _unknown_ _t69;                        // _t69
    intOrPtr* _t72;                        // _t72
    char* _t74;                            // _t74
    intOrPtr _t76;                         // _t76
    intOrPtr _t78;                         // _t78
    signed int _t81;                       // _t81
    _unknown_ _t83;                        // _t83
    intOrPtr _t92;                         // _t92
    intOrPtr _t93;                         // _t93
    intOrPtr _t94;                         // _t94
    _unknown_ _t99;                        // _t99

    caml_c_call( &camlPervasives__95, _t45);
    _t78 = caml_format_float;
    _t92 = -1 + ( *(caml_format_float - 4) >> 10) * 4 - ( *(caml_format_float + -1 + ( *(caml_format_float - 4) >> 10) * 4) & 255) + -1 + ( *(caml_format_float - 4) >> 10) * 4 - ( *(caml_format_float + -1 + ( *(caml_format_float - 4) >> 10) * 4) & 255) + 1;
    while(1) {
        _t52 = caml_young_ptr - 20;
        caml_young_ptr = _t52;
        if(_t52 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t72 = _t52 + 4;
     *((intOrPtr*)(_t72 - 4)) = 4343;
     *_t72 =  &camlPervasives__code_begin;
     *((intOrPtr*)(_t72 + 4)) = 3;
     *((intOrPtr*)(_t72 + 8)) = _t78;
     *((intOrPtr*)(_t72 + 12)) = _t92;
    _t53 = 1;
    while(_t53 <  *((intOrPtr*)(_t72 + 12))) {
        _t93 =  *((intOrPtr*)(_t72 + 8));
        _t81 = _t53 >> 1;
        if(-1 + ( *(_t93 - 4) >> 10) * 4 - ( *(_t93 + -1 + ( *(_t93 - 4) >> 10) * 4) & 255) <= _t81) {
            _t54 = caml_ml_array_bound_error();
            __esp = __esp - 4;
            while(_t54 != 1) {
                 *__esp =  *((intOrPtr*)(_t54 + 4));
                L0804EB50( *_t54);
                _t54 =  *__esp;
            }
            __esp = __esp + 4;
            return 1;
L21:
        }
        _t83 = ( *(_t93 + _t81) & 255) + ( *(_t93 + _t81) & 255) + 1;
        if(_t83 < 97) {
            if(_t83 == 91) {
                goto L9;
            }
            goto L8;
        } else {
            if(_t83 < 117) {
L9:
                _t53 = _t53 + 2;
                continue;
            }
L8:
            return  *((intOrPtr*)(_t72 + 8));
        }
        goto L21;
    }
    _t59 =  *((intOrPtr*)(_t72 + 8));
    _t74 =  &camlPervasives__103;
    __esp = __esp - 16;
    _t94 = _t59;
    _v12 = _t94;
    _v4 = _t74;
    _t62 = -1 + ( *(_t94 - 4) >> 10) * 4 - ( *(_t94 + -1 + ( *(_t94 - 4) >> 10) * 4) & 255) + -1 + ( *(_t94 - 4) >> 10) * 4 - ( *(_t94 + -1 + ( *(_t94 - 4) >> 10) * 4) & 255) + 1;
     *__esp = _t62;
    _t76 = -1 + ( *(_t74 - 4) >> 10) * 4 - ( *(_t74 + -1 + ( *(_t74 - 4) >> 10) * 4) & 255) + -1 + ( *(_t74 - 4) >> 10) * 4 - ( *(_t74 + -1 + ( *(_t74 - 4) >> 10) * 4) & 255) + 1;
    _v8 = _t76;
    _push(_t62 + _t76 - 1);
    caml_c_call();
    __esp = __esp + 4;
    _t100 =  *__esp;
    caml_blit_string(_v12, 1, caml_create_string, 1,  *__esp);
    caml_blit_string(_v4, 1, caml_create_string, _t100, _v8);
    __esp = __esp + 16;
    return caml_create_string;
    goto L21;
}

camlPervasives__$40_1143(
    intOrPtr* __eax                        // r0
)
{// addr = 0x0804F220
    intOrPtr* _t5;                         // _t5
    intOrPtr _t10;                         // _t10
    intOrPtr* _t11;                        // _t11
    _unknown_ _t12;                        // _t12
    intOrPtr _t15;                         // _t15

    _t5 = __eax;
    if(_t5 == 1) {
        return _t12;
    } else {
         *__esp =  *_t5;
        _t15 = camlPervasives__$40_1143( *((intOrPtr*)(_t5 + 4)));
        while(1) {
            _t10 = caml_young_ptr - 12;
            caml_young_ptr = _t10;
            if(_t10 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t11 = _t10 + 4;
         *((intOrPtr*)(_t11 - 4)) = 2048;
         *_t11 =  *__esp;
         *((intOrPtr*)(_t11 + 4)) = _t15;
        return _t11;
    }
}

camlPervasives__open_out_gen_1175(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    _unknown_ __ecx                        // r2
)
{// addr = 0x0804F280
    __ecx = __ecx;
    __ebx = __ebx;
    _push(__ebx);
    caml_c_call(__ecx, __eax);
    __esp = __esp + 4;
    _push(caml_sys_open);
    caml_c_call();
    __esp = __esp + 4;
    return caml_ml_open_descriptor_out;
}

camlPervasives__open_out_1179(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F2A0
    __ecx = __eax;
    _push(877);
    caml_c_call(__ecx,  &camlPervasives__94);
    __esp = __esp + 4;
    _push(caml_sys_open);
    caml_c_call();
    __esp = __esp + 4;
    return caml_ml_open_descriptor_out;
}

camlPervasives__open_out_bin_1181()
{// addr = 0x0804F2C0
    _unknown_ _t1;                         // _t1
    _unknown_ _t4;                         // _t4

    __ecx = _t1;
    _push(877);
    caml_c_call(__ecx,  &camlPervasives__93);
    __esp = __esp + 4;
    _push(caml_sys_open);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlPervasives__flush_all_1185()
{// addr = 0x0804F2E0
    _unknown_ _t2;                         // _t2
    intOrPtr* _t3;                         // _t3
    _unknown_ _t4;                         // _t4
    _unknown_ _t6;                         // _t6

    _push(1);
    _t3 = caml_ml_out_channels_list;
    caml_c_call();
    __esp = __esp + 4;
    __esp = __esp - 4;
    while(_t3 != 1) {
         *__esp =  *((intOrPtr*)(_t3 + 4));
        L0804EB50( *_t3);
        _t3 =  *__esp;
    }
    __esp = __esp + 4;
    return 1;
}

camlPervasives__output_string_1191(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx                        // r1
)
{// addr = 0x0804F300
    caml_c_call(1, -1 + ( *(__ebx - 4) >> 10) * 4 - ( *(__ebx + -1 + ( *(__ebx - 4) >> 10) * 4) & 255) + -1 + ( *(__ebx - 4) >> 10) * 4 - ( *(__ebx + -1 + ( *(__ebx - 4) >> 10) * 4) & 255) + 1);
    return caml_ml_output;
}

camlPervasives__output_1194()
{// addr = 0x0804F330
    intOrPtr _t10;                         // _t10
    intOrPtr* _t11;                        // _t11
    _unknown_ _t12;                        // _t12

    if(__ecx < 1 || __edx < 1) {
L8:
        __ebx = "output";
        while(1) {
            _t10 = caml_young_ptr - 12;
            caml_young_ptr = _t10;
            if(_t10 >= caml_young_limit) {
                _t11 = _t10 + 4;
                 *((intOrPtr*)(_t11 - 4)) = 2048;
                 *_t11 =  &caml_exn_Invalid_argument;
                 *((intOrPtr*)(_t11 + 4)) = __ebx;
                caml_raise_exn(_t11);
            }
            caml_call_gc(__esp);
        }
    }
    __esi =  *(__ebx - 4);
    __esi =  *(__ebx - 4) >> 10;
    __esi = -1 + ( *(__ebx - 4) >> 10) * 4;
    __esi = -1 + ( *(__ebx - 4) >> 10) * 4 - ( *(__ebx + __esi) & 255);
    __esi = __esi << 1;
    __esi = __esi - __edx;
    if(__ecx > __esi) {
        goto L8;
    }
    _push(__edx);
    _push(__ecx);
    _push(__ebx);
    _push(__eax);
    __eax = caml_ml_output;
    caml_c_call();
    __esp = __esp + 16;
    return;
}

camlPervasives__output_value_1202()
{// addr = 0x0804F380
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(1);
    caml_c_call(_t1, __ebx);
    __esp = __esp + 4;
    return;
}

camlPervasives__close_out_1209()
{// addr = 0x0804F3A0
    intOrPtr _t1;                          // _t1
    _unknown_ _t2;                         // _t2
    _unknown_ _t4;                         // _t4

     *__esp = _t1;
    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    _push( *__esp);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlPervasives__close_out_noerr_1211()
{// addr = 0x0804F3D0
    intOrPtr _t1;                          // _t1
    _unknown_ _t2;                         // _t2
    _unknown_ _t3;                         // _t3

     *__esp = _t1;
    L0804F3E0(_t1);
    L0804F420(__esp);
    return 1;
}

L0804F3E0(
    _unknown_ __eax                        // r0
)
{
    _unknown_ _t2;                         // _t2
    _unknown_ _t3;                         // _t3

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    _push(__eax);
    caml_c_call();
    __esp = __esp + 4;
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    L0804F420(__esp);
    __esp = __esp + 4;
    return 1;
}

L0804F420(
    intOrPtr __esp,                        // r7
    intOrPtr _a4                           // _cfa_4
)
{
    _unknown_ _t3;                         // _t3

    __esp = __esp;
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    _push(_a4);
    caml_c_call();
    __esp = __esp + 4;
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    __esp = __esp + 4;
    return;
}

camlPervasives__open_in_gen_1214(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    _unknown_ __ecx                        // r2
)
{// addr = 0x0804F450
    __ecx = __ecx;
    __ebx = __ebx;
    _push(__ebx);
    caml_c_call(__ecx, __eax);
    __esp = __esp + 4;
    _push(caml_sys_open);
    caml_c_call();
    __esp = __esp + 4;
    return caml_ml_open_descriptor_in;
}

camlPervasives__open_in_1218(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F470
    __ecx = __eax;
    _push(1);
    caml_c_call(__ecx,  &camlPervasives__90);
    __esp = __esp + 4;
    _push(caml_sys_open);
    caml_c_call();
    __esp = __esp + 4;
    return caml_ml_open_descriptor_in;
}

camlPervasives__open_in_bin_1220()
{// addr = 0x0804F490
    _unknown_ _t1;                         // _t1
    _unknown_ _t4;                         // _t4

    __ecx = _t1;
    _push(1);
    caml_c_call(__ecx,  &camlPervasives__89);
    __esp = __esp + 4;
    _push(caml_sys_open);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlPervasives__input_1224()
{// addr = 0x0804F4B0
    intOrPtr _t10;                         // _t10
    intOrPtr* _t11;                        // _t11
    _unknown_ _t12;                        // _t12

    if(__ecx < 1 || __edx < 1) {
L8:
        __ebx =  &camlPervasives__88;
        while(1) {
            _t10 = caml_young_ptr - 12;
            caml_young_ptr = _t10;
            if(_t10 >= caml_young_limit) {
                _t11 = _t10 + 4;
                 *((intOrPtr*)(_t11 - 4)) = 2048;
                 *_t11 =  &caml_exn_Invalid_argument;
                 *((intOrPtr*)(_t11 + 4)) = __ebx;
                caml_raise_exn(_t11);
            }
            caml_call_gc(__esp);
        }
    }
    __esi =  *(__ebx - 4);
    __esi =  *(__ebx - 4) >> 10;
    __esi = -1 + ( *(__ebx - 4) >> 10) * 4;
    __esi = -1 + ( *(__ebx - 4) >> 10) * 4 - ( *(__ebx + __esi) & 255);
    __esi = __esi << 1;
    __esi = __esi - __edx;
    if(__ecx > __esi) {
        goto L8;
    }
    _push(__edx);
    _push(__ecx);
    _push(__ebx);
    _push(__eax);
    __eax = caml_ml_input;
    caml_c_call();
    __esp = __esp + 16;
    return;
}

camlPervasives__unsafe_really_input_1229(
    intOrPtr __ebx,                        // r1
    intOrPtr __ecx,                        // r2
    intOrPtr __edx,                        // r3
    intOrPtr* __esp                        // r7
)
{// addr = 0x0804F500
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _t11;                         // _t11
    signed int _t12;                       // _t12
    _unknown_ _t13;                        // _t13
    intOrPtr _t15;                         // _t15
    intOrPtr* _t16;                        // _t16
    intOrPtr _t17;                         // _t17
    intOrPtr _t19;                         // _t19

    __esp = __esp;
    _t19 = __edx;
    __ecx = __ecx;
    _t17 = __ebx;
    while(_t19 > 1) {
         *__esp = _t19;
        _v12 = __ecx;
        _v4 = _t17;
        _v8 = _t11;
        _push(_t19);
        _push(__ecx);
        _push(_t17);
        _push(_t11);
        _t12 = caml_ml_input;
        caml_c_call();
        __esp = __esp + 16;
        if(caml_ml_input == 1) {
            goto L4;
        }
L6:
        _t19 =  *__esp - _t12 + 1;
        __ecx = _v12 + _t12 - 1;
        _t11 = _v8;
        _t17 = _v4;
        continue;
        while(1) {
L4:
            _t15 = caml_young_ptr - 8;
            caml_young_ptr = _t15;
            if(_t15 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t16 = _t15 + 4;
         *((intOrPtr*)(_t16 - 4)) = 1024;
         *_t16 =  &caml_exn_End_of_file;
        _t12 = caml_raise_exn(_t16);
        goto L6;
    }
    return 1;
}

camlPervasives__really_input_1235(
    _unknown_ __ebx,                       // r1
    intOrPtr __ecx,                        // r2
    intOrPtr __edx                         // r3
)
{// addr = 0x0804F5A0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _v8;                         // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _t20;                         // _t20
    intOrPtr* _t21;                        // _t21
    _unknown_ _t22;                        // _t22
    _unknown_ _t23;                        // _t23
    char* _t24;                            // _t24

    __edx = __edx;
    __ecx = __ecx;
    if(__ecx < 1 || __edx < 1) {
L16:
        _t24 = "really_input";
        while(1) {
            _t20 = caml_young_ptr - 12;
            caml_young_ptr = _t20;
            if(_t20 >= caml_young_limit) {
                _t21 = _t20 + 4;
                 *((intOrPtr*)(_t21 - 4)) = 2048;
                 *_t21 =  &caml_exn_Invalid_argument;
                 *((intOrPtr*)(_t21 + 4)) = _t24;
                caml_raise_exn(_t21);
            }
            caml_call_gc(__esp);
        }
    } else {
        __esi =  *(__ebx - 4);
        __esi =  *(__ebx - 4) >> 10;
        __esi = -1 + ( *(__ebx - 4) >> 10) * 4;
        __esi = -1 + ( *(__ebx - 4) >> 10) * 4 - ( *(__ebx + __esi) & 255);
        __esi = __esi << 1;
        __esi = __esi - __edx;
        if(__ecx > __esi) {
            goto L16;
        }
        __esp = __esp - 16;
        while(__edx > 1) {
             *__esp = __edx;
            _v12 = __ecx;
            _v4 = __ebx;
            _v8 = __eax;
            _push(__edx);
            _push(__ecx);
            _push(__ebx);
            _push(__eax);
            __eax = caml_ml_input;
            caml_c_call();
            __esp = __esp + 16;
            if(caml_ml_input != 1) {
L11:
                 *__esp =  *__esp - __eax;
                __edx =  *__esp - __eax + 1;
                __ebx = _v12;
                __ecx = _v12 + __eax - 1;
                __eax = _v8;
                __ebx = _v4;
                continue;
            } else {
                goto L9;
            }
            while(1) {
L9:
                __eax = caml_young_ptr;
                __eax = caml_young_ptr - 8;
                caml_young_ptr = __eax;
                if(__eax >= caml_young_limit) {
                    break;
                }
                goto L12;
            }
            __eax = __eax + 4;
             *((intOrPtr*)(__eax - 4)) = 1024;
             *__eax =  &caml_exn_End_of_file;
            __eax = caml_raise_exn(__eax);
            goto L11;
L12:
            caml_call_gc(__esp);
            goto L9;
        }
        __eax = 1;
        __esp = __esp + 16;
        return 1;
    }
}

camlPervasives__input_line_1241(
    _unknown_ __eax,                       // r0
    intOrPtr* __esp                        // r7
)
{// addr = 0x0804F5E0
    _unknown_ _v4;                         // _cfa_fffffffc
    _unknown_ _v8;                         // _cfa_fffffff8
    intOrPtr* _v12;                        // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ _t53;                        // _t53
    _unknown_ _t56;                        // _t56
    char* _t57;                            // _t57
    intOrPtr* _t59;                        // _t59
    _unknown_ _t67;                        // _t67

    __esp = __esp;
    _t53 = __eax;
    _t57 =  &camlPervasives__86;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 24;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    __ecx = __eax + 4;
     *((intOrPtr*)(__ecx - 4)) = 5367;
     *__ecx = caml_curry2;
     *((intOrPtr*)(__ecx + 4)) = 5;
     *((intOrPtr*)(__ecx + 8)) = camlPervasives__scan_1249;
     *((intOrPtr*)(__ecx + 12)) = __edx;
     *((intOrPtr*)(__ecx + 16)) = __ebx;
    __ebx = 1;
    __eax = 1;
    __esp = __esp - 20;
    while(1) {
        _v4 = __eax;
        _v8 = __ebx;
        _v16 = __ecx;
        _push( *((intOrPtr*)(__ecx + 12)));
        __eax = caml_ml_input_scan_line;
        caml_c_call();
        __esp = __esp + 4;
        if(caml_ml_input_scan_line == 1) {
            break;
        }
L10:
        _v12 = __eax;
        if(__eax <= 1) {
            2 = 2 - __eax;
            _push(2 - __eax);
            __eax = caml_create_string;
            caml_c_call();
            __esp = __esp + 4;
             *__esp = caml_create_string;
            __ecx = 2;
            __ebx = _v12;
            __ecx = 2 - _v12;
            _push(2 - _v12);
            _push(1);
            _push(caml_create_string);
            __eax = _v16;
            _push( *((intOrPtr*)(_v16 + 12)));
            __eax = caml_ml_input;
            caml_c_call();
            __esp = __esp + 16;
            while(1) {
L17:
                __eax = caml_young_ptr;
                __eax = caml_young_ptr - 12;
                caml_young_ptr = __eax;
                if(__eax >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            __eax = __eax + 4;
             *((intOrPtr*)(__eax - 4)) = 2048;
            __ebx =  *__esp;
             *__eax =  *__esp;
            __ebx = _v4;
             *((intOrPtr*)(__eax + 4)) = _v4;
            __ebx = _v8;
            __ecx = _v12;
            __ebx = _v8 - _v12;
            __ebx = _v8 - _v12 + 1;
            __ecx = _v16;
            continue;
        } else {
            _push(__eax);
            __eax = caml_create_string;
            caml_c_call();
            __esp = __esp + 4;
             *__esp = caml_create_string;
            _v12 = _v12 + -2;
            _push(_v12 + -2);
            _push(1);
            _push(caml_create_string);
            __eax = _v16;
            _push( *((intOrPtr*)(_v16 + 12)));
            __eax = caml_ml_input;
            caml_c_call();
            __esp = __esp + 16;
            __eax = _v16;
            _push( *((intOrPtr*)(_v16 + 12)));
            __eax = caml_ml_input_char;
            caml_c_call();
            __esp = __esp + 4;
            __ecx = _v4;
            if(__ecx == 1) {
                __eax =  *__esp;
                __esp = __esp + 20;
                return __eax;
            } else {
                __ebx = _v12;
                __eax = _v8;
                __edx = _v8 + _v12 - 3;
                _v16 = __edx;
                while(1) {
                    __eax = caml_young_ptr;
                    __eax = caml_young_ptr - 12;
                    caml_young_ptr = __eax;
                    if(__eax >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                __ebx = __eax + 4;
                _v12 = __ebx;
                 *((intOrPtr*)(__ebx - 4)) = 2048;
                __eax =  *__esp;
                 *__ebx =  *__esp;
                 *((intOrPtr*)(__ebx + 4)) = __ecx;
                _push(__edx);
                __eax = caml_create_string;
                caml_c_call();
                __esp = __esp + 4;
                __ebx = _v16;
                __ecx = _v12;
                __esp = __esp + 20;
                while(1) {
L1:
                    __edi = _t53;
                    if(_t59 == 1) {
                        break;
                    }
                    __esi = -1 + ( *( *_t59 - 4) >> 10) * 4 - ( *( *_t59 + -1 + ( *( *_t59 - 4) >> 10) * 4) & 255) + -1 + ( *( *_t59 - 4) >> 10) * 4 - ( *( *_t59 + -1 + ( *( *_t59 - 4) >> 10) * 4) & 255) + 1;
                    caml_blit_string(_t55, 1, __edi, _t57 - __esi + 1, __esi);
                    _t57 = _t57 - __esi + 1;
                    _t53 = __edi;
                    _t59 =  *((intOrPtr*)(_t59 + 4));
                }
                return __edi;
            }
        }
        goto L17;
    }
    __eax = _v4;
    if(__eax == 1) {
        while(1) {
            __eax = caml_young_ptr;
            __eax = caml_young_ptr - 8;
            caml_young_ptr = __eax;
            if(__eax >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        __eax = __eax + 4;
         *((intOrPtr*)(__eax - 4)) = 1024;
         *__eax =  &caml_exn_End_of_file;
        __eax = caml_raise_exn(__eax);
        asm("o16 nop ");
        goto L10;
    }
    _v4 = __eax;
    __eax = _v8;
    _push(_v8);
    __eax = caml_create_string;
    caml_c_call();
    __esp = __esp + 4;
    __ebx = _v8;
    __ecx = _v4;
    __esp = __esp + 20;
    goto L1;
}

camlPervasives__close_in_noerr_1263()
{// addr = 0x0804F640
    L0804F650();
    return 1;
}

L0804F650()
{
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    return;
}

camlPervasives__print_char_1266()
{// addr = 0x0804F680
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call( *134678644, _t1);
    return;
}

camlPervasives__print_string_1268(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F6A0
    intOrPtr _t8;                          // _t8

    __ebx = __eax;
    _t8 =  *134678644;
    caml_c_call(1, -1 + ( *(__ebx - 4) >> 10) * 4 - ( *(__ebx + -1 + ( *(__ebx - 4) >> 10) * 4) & 255) + -1 + ( *(__ebx - 4) >> 10) * 4 - ( *(__ebx + -1 + ( *(__ebx - 4) >> 10) * 4) & 255) + 1);
    return caml_ml_output;
}

camlPervasives__print_int_1270()
{// addr = 0x0804F6B0
    _unknown_ _t7;                         // _t7
    intOrPtr _t8;                          // _t8
    _unknown_ _t9;                         // _t9

    camlPervasives__string_of_int_1130();
    __ebx = _t7;
    _t8 =  *134678644;
    caml_c_call(1, -1 + ( *(__ebx - 4) >> 10) * 4 - ( *(__ebx + -1 + ( *(__ebx - 4) >> 10) * 4) & 255) + -1 + ( *(__ebx - 4) >> 10) * 4 - ( *(__ebx + -1 + ( *(__ebx - 4) >> 10) * 4) & 255) + 1);
    return;
}

camlPervasives__print_float_1272()
{// addr = 0x0804F6D0
    intOrPtr _t8;                          // _t8
    _unknown_ _t9;                         // _t9

    __ebx = camlPervasives__string_of_float_1140();
    _t8 =  *134678644;
    caml_c_call(1, -1 + ( *(__ebx - 4) >> 10) * 4 - ( *(__ebx + -1 + ( *(__ebx - 4) >> 10) * 4) & 255) + -1 + ( *(__ebx - 4) >> 10) * 4 - ( *(__ebx + -1 + ( *(__ebx - 4) >> 10) * 4) & 255) + 1);
    return;
}

camlPervasives__print_endline_1274()
{// addr = 0x0804F6F0
    _unknown_ _t1;                         // _t1
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4
    _unknown_ _t5;                         // _t5

    __ebx = _t1;
    camlPervasives__output_string_1191( *134678644, _t1);
    caml_c_call( *134678644, 21);
    _push( *134678644);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlPervasives__print_newline_1276()
{// addr = 0x0804F730
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call( *134678644, 21);
    _push( *134678644);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlPervasives__prerr_char_1277()
{// addr = 0x0804F760
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call( *134678648, _t1);
    return;
}

camlPervasives__prerr_string_1279(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F780
    intOrPtr _t8;                          // _t8

    __ebx = __eax;
    _t8 =  *134678648;
    caml_c_call(1, -1 + ( *(__ebx - 4) >> 10) * 4 - ( *(__ebx + -1 + ( *(__ebx - 4) >> 10) * 4) & 255) + -1 + ( *(__ebx - 4) >> 10) * 4 - ( *(__ebx + -1 + ( *(__ebx - 4) >> 10) * 4) & 255) + 1);
    return caml_ml_output;
}

camlPervasives__prerr_int_1281()
{// addr = 0x0804F790
    _unknown_ _t7;                         // _t7
    intOrPtr _t8;                          // _t8
    _unknown_ _t9;                         // _t9

    camlPervasives__string_of_int_1130();
    __ebx = _t7;
    _t8 =  *134678648;
    caml_c_call(1, -1 + ( *(__ebx - 4) >> 10) * 4 - ( *(__ebx + -1 + ( *(__ebx - 4) >> 10) * 4) & 255) + -1 + ( *(__ebx - 4) >> 10) * 4 - ( *(__ebx + -1 + ( *(__ebx - 4) >> 10) * 4) & 255) + 1);
    return;
}

camlPervasives__prerr_float_1283()
{// addr = 0x0804F7B0
    intOrPtr _t8;                          // _t8
    _unknown_ _t9;                         // _t9

    __ebx = camlPervasives__string_of_float_1140();
    _t8 =  *134678648;
    caml_c_call(1, -1 + ( *(__ebx - 4) >> 10) * 4 - ( *(__ebx + -1 + ( *(__ebx - 4) >> 10) * 4) & 255) + -1 + ( *(__ebx - 4) >> 10) * 4 - ( *(__ebx + -1 + ( *(__ebx - 4) >> 10) * 4) & 255) + 1);
    return;
}

camlPervasives__prerr_endline_1285()
{// addr = 0x0804F7D0
    _unknown_ _t1;                         // _t1
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4
    _unknown_ _t5;                         // _t5

    __ebx = _t1;
    camlPervasives__output_string_1191( *134678648, _t1);
    caml_c_call( *134678648, 21);
    _push( *134678648);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlPervasives__prerr_newline_1287()
{// addr = 0x0804F810
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call( *134678648, 21);
    _push( *134678648);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlPervasives__read_line_1288()
{// addr = 0x0804F840
    intOrPtr* _v4;                         // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _v12;                        // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ _t53;                        // _t53
    intOrPtr _t54;                         // _t54
    intOrPtr _t56;                         // _t56
    intOrPtr* _t57;                        // _t57
    _unknown_ _t58;                        // _t58
    _unknown_ _t61;                        // _t61
    intOrPtr _t63;                         // _t63
    _unknown_ _t67;                        // _t67
    _unknown_ _t69;                        // _t69
    intOrPtr _t70;                         // _t70
    intOrPtr _t73;                         // _t73
    signed int _t75;                       // _t75
    _unknown_ _t78;                        // _t78
    intOrPtr _t79;                         // _t79
    intOrPtr _t81;                         // _t81
    intOrPtr* _t82;                        // _t82
    char* _t84;                            // _t84
    intOrPtr* _t85;                        // _t85
    _unknown_ _t86;                        // _t86
    intOrPtr* _t96;                        // _t96
    intOrPtr _t97;                         // _t97
    intOrPtr* _t99;                        // _t99
    _unknown_ _t100;                       // _t100
    intOrPtr _t103;                        // _t103
    intOrPtr* _t104;                       // _t104
    intOrPtr _t112;                        // _t112
    intOrPtr _t113;                        // _t113

    _push( *134678644);
    caml_c_call();
    __esp = __esp + 4;
    _t54 =  *134678640;
    _t112 = _t54;
    _t84 =  &camlPervasives__86;
    while(1) {
        _t56 = caml_young_ptr - 24;
        caml_young_ptr = _t56;
        if(_t56 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t99 = _t56 + 4;
     *((intOrPtr*)(_t99 - 4)) = 5367;
     *_t99 = caml_curry2;
     *((intOrPtr*)(_t99 + 4)) = 5;
     *((intOrPtr*)(_t99 + 8)) = camlPervasives__scan_1249;
     *((intOrPtr*)(_t99 + 12)) = _t112;
     *((intOrPtr*)(_t99 + 16)) = _t84;
    _t85 = 1;
    _t57 = 1;
    __esp = __esp - 20;
    while(1) {
        _v4 = _t57;
        _v8 = _t85;
        _v16 = _t99;
        _push( *((intOrPtr*)(_t99 + 12)));
        _t58 = caml_ml_input_scan_line;
        caml_c_call();
        __esp = __esp + 4;
        if(caml_ml_input_scan_line == 1) {
            break;
        }
L10:
        _v12 = _t58;
        if(_t58 <= 1) {
            _push(2 - _t58);
            caml_c_call();
            __esp = __esp + 4;
             *__esp = caml_create_string;
            caml_c_call(1, 2 - _v12);
            while(1) {
L17:
                _t63 = caml_young_ptr - 12;
                caml_young_ptr = _t63;
                if(_t63 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t57 = _t63 + 4;
             *((intOrPtr*)(_t57 - 4)) = 2048;
             *_t57 =  *__esp;
             *((intOrPtr*)(_t57 + 4)) = _v4;
            _t85 = _v8 - _v12 + 1;
            _t99 = _v16;
            continue;
        } else {
            _push(_t58 + -2);
            caml_c_call();
            __esp = __esp + 4;
             *__esp = caml_create_string;
            caml_c_call(1, _v12 + -2);
            _push( *((intOrPtr*)(_v16 + 12)));
            caml_c_call();
            __esp = __esp + 4;
            _t103 = _v4;
            if(_t103 == 1) {
                _t70 =  *__esp;
                __esp = __esp + 20;
                return _t70;
            } else {
                _t113 = _v8 + _v12 - 3;
                _v16 = _t113;
                while(1) {
                    _t73 = caml_young_ptr - 12;
                    caml_young_ptr = _t73;
                    if(_t73 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                _t96 = _t73 + 4;
                _v12 = _t96;
                 *((intOrPtr*)(_t96 - 4)) = 2048;
                 *_t96 =  *__esp;
                 *((intOrPtr*)(_t96 + 4)) = _t103;
                _push(_t113);
                _t75 = caml_create_string;
                caml_c_call();
                __esp = __esp + 4;
                _t97 = _v16;
                _t104 = _v12;
                __esp = __esp + 20;
                while(1) {
L1:
                    __edi = _t75;
                    if(_t104 == 1) {
                        break;
                    }
                    __esi = -1 + ( *( *_t104 - 4) >> 10) * 4 - ( *( *_t104 + -1 + ( *( *_t104 - 4) >> 10) * 4) & 255) + -1 + ( *( *_t104 - 4) >> 10) * 4 - ( *( *_t104 + -1 + ( *( *_t104 - 4) >> 10) * 4) & 255) + 1;
                    caml_blit_string(_t77, 1, __edi, _t97 - __esi + 1, __esi);
                    _t97 = _t97 - __esi + 1;
                    _t75 = __edi;
                    _t104 =  *((intOrPtr*)(_t104 + 4));
                }
                return __edi;
            }
        }
        goto L17;
    }
    _t79 = _v4;
    if(_t79 == 1) {
        while(1) {
            _t81 = caml_young_ptr - 8;
            caml_young_ptr = _t81;
            if(_t81 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t82 = _t81 + 4;
         *((intOrPtr*)(_t82 - 4)) = 1024;
         *_t82 =  &caml_exn_End_of_file;
        _t58 = caml_raise_exn(_t82);
        asm("o16 nop ");
        goto L10;
    }
    _v4 = _t79;
    _push(_v8);
    _t75 = caml_create_string;
    caml_c_call();
    __esp = __esp + 4;
    _t97 = _v8;
    _t104 = _v4;
    __esp = __esp + 20;
    goto L1;
}

camlPervasives__read_int_1289()
{// addr = 0x0804F860
    _unknown_ _t1;                         // _t1
    _unknown_ _t3;                         // _t3

    _push(camlPervasives__read_line_1288());
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlPervasives__read_float_1290()
{// addr = 0x0804F880
    _unknown_ _t1;                         // _t1
    _unknown_ _t3;                         // _t3

    _push(camlPervasives__read_line_1288());
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlPervasives__fun_1495()
{// addr = 0x0804F8A0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlPervasives__fun_1493()
{// addr = 0x0804F8B0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlPervasives__fun_1491()
{// addr = 0x0804F8C0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlPervasives__fun_1489()
{// addr = 0x0804F8D0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlPervasives__fun_1487()
{// addr = 0x0804F8E0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _push(_t1);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlPervasives__fun_1485()
{// addr = 0x0804F8F0
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    caml_c_call(_t1, __ebx);
    return;
}

camlPervasives__$5e$5e_1312(
    intOrPtr* __esp                        // r7
)
{// addr = 0x0804F900
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _t21;                         // _t21
    intOrPtr _t23;                         // _t23
    intOrPtr _t26;                         // _t26
    _unknown_ _t30;                        // _t30
    _unknown_ _t33;                        // _t33
    char* _t35;                            // _t35
    intOrPtr _t37;                         // _t37

    __esp = __esp;
    __esp = __esp - 4;
     *__esp = _t21;
    L1();
    _t35 =  &camlPervasives__85;
    _t23 =  *__esp;
    __esp = __esp + 4;
    __esp = __esp - 16;
    __edx = _t23;
    _v12 = __edx;
    _v4 = _t35;
    _t26 = -1 + ( *(__edx - 4) >> 10) * 4 - ( *(__edx + -1 + ( *(__edx - 4) >> 10) * 4) & 255) + -1 + ( *(__edx - 4) >> 10) * 4 - ( *(__edx + -1 + ( *(__edx - 4) >> 10) * 4) & 255) + 1;
     *__esp = _t26;
    _t37 = -1 + ( *(_t35 - 4) >> 10) * 4 - ( *(_t35 + -1 + ( *(_t35 - 4) >> 10) * 4) & 255) + -1 + ( *(_t35 - 4) >> 10) * 4 - ( *(_t35 + -1 + ( *(_t35 - 4) >> 10) * 4) & 255) + 1;
    _v8 = _t37;
    _push(_t26 + _t37 - 1);
    caml_c_call();
    __esp = __esp + 4;
    __esi =  *__esp;
    caml_blit_string(_v12, 1, caml_create_string, 1,  *__esp);
    caml_blit_string(_v4, 1, caml_create_string, __esi, _v8);
    __esp = __esp + 16;
    return caml_create_string;
}

camlPervasives__string_of_format_1315(
    intOrPtr* __esp                        // r7
)
{// addr = 0x0804F920
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _t9;                          // _t9
    intOrPtr _t12;                         // _t12
    _unknown_ _t16;                        // _t16

    __esp = __esp;
    __ecx = _t9;
    _v4 = __ecx;
    _t12 = -1 + ( *(__ecx - 4) >> 10) * 4 - ( *(__ecx + -1 + ( *(__ecx - 4) >> 10) * 4) & 255) + -1 + ( *(__ecx - 4) >> 10) * 4 - ( *(__ecx + -1 + ( *(__ecx - 4) >> 10) * 4) & 255) + 1;
     *__esp = _t12;
    _push(_t12);
    caml_c_call();
    caml_blit_string(_v4, 1, caml_create_string, 1,  *__esp);
    return caml_create_string;
}

camlPervasives__at_exit_1322(
    intOrPtr __eax                         // r0
)
{// addr = 0x0804F970
    intOrPtr _t9;                          // _t9
    intOrPtr* _t10;                        // _t10
    _unknown_ _t11;                        // _t11

    __ecx = __eax;
    __ebx =  *((intOrPtr*)( *134678880));
    while(1) {
        _t9 = caml_young_ptr - 20;
        caml_young_ptr = _t9;
        if(_t9 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t10 = _t9 + 4;
     *((intOrPtr*)(_t10 - 4)) = 4343;
     *_t10 = camlPervasives__fun_1500;
     *((intOrPtr*)(_t10 + 4)) = 3;
     *((intOrPtr*)(_t10 + 8)) = __ecx;
     *((intOrPtr*)(_t10 + 12)) = __ebx;
    caml_modify(__ebx,  *134678880, _t10);
    return 1;
}

camlPervasives__do_at_exit_1325()
{// addr = 0x0804F9D0
    _unknown_ _t2;                         // _t2

    goto ( *((intOrPtr*)( *((intOrPtr*)( *134678880)))));
}

camlPervasives__exit_1326()
{// addr = 0x0804F9E0
    intOrPtr _t1;                          // _t1
    _unknown_ _t3;                         // _t3
    _unknown_ _t5;                         // _t5

     *__esp = _t1;
     *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *134678880))))))();
    _push( *__esp);
    caml_c_call();
    __esp = __esp + 4;
    return;
}

camlPervasives__entry()
{// addr = 0x0804FA10
    char* _t12;                            // _t12
    intOrPtr* _t13;                        // _t13
    _unknown_ _t18;                        // _t18
    _unknown_ _t69;                        // _t69
    _unknown_ _t70;                        // _t70
    _unknown_ _t77;                        // _t77
    _unknown_ _t78;                        // _t78
    intOrPtr* _t79;                        // _t79
    intOrPtr* _t80;                        // _t80

     *134678840 =  &camlPervasives__84;
     *134678832 =  &camlPervasives__83;
     *134678828 =  &camlPervasives__82;
     *134678824 =  &camlPervasives__81;
     *134678820 =  &camlPervasives__80;
     *134678816 =  &camlPervasives__79;
     *134678812 =  &camlPervasives__78;
     *134678808 =  &camlPervasives__77;
     *134678792 =  &camlPervasives__76;
     *134678776 =  &camlPervasives__75;
     *134678764 =  &camlPervasives__74;
     *134678760 =  &camlPervasives__73;
     *134678756 =  &camlPervasives__72;
     *134678748 =  &camlPervasives__71;
     *134678744 =  &camlPervasives__70;
     *134678732 =  &camlPervasives__69;
     *134678724 =  &camlPervasives__68;
     *134678556 =  &camlPervasives__67;
    _t12 =  &camlPervasives__66;
    camlPervasives = _t12;
    caml_alloc1(__esp);
    _t13 = _t12 + 4;
     *((intOrPtr*)(_t13 - 4)) = 1024;
     *_t13 = "Pervasives.Exit";
     *134678560 = _t13;
     *134678564 =  &camlPervasives__64;
     *134678568 =  &camlPervasives__63;
     *134678572 =  &camlPervasives__62;
     *134678584 =  &camlPervasives__61;
     *134678580 = -2147483647;
     *134678576 = 2147483647;
    _push( &camlPervasives__60);
    caml_c_call();
    __esp = __esp + 4;
     *134678588 = caml_int64_float_of_bits;
    _push( &camlPervasives__59);
    caml_c_call();
    __esp = __esp + 4;
     *134678592 = caml_int64_float_of_bits;
    _push( &camlPervasives__58);
    caml_c_call();
    __esp = __esp + 4;
     *134678596 = caml_int64_float_of_bits;
    _push( &camlPervasives__57);
    caml_c_call();
    __esp = __esp + 4;
     *134678600 = caml_int64_float_of_bits;
    _push( &camlPervasives__56);
    caml_c_call();
    __esp = __esp + 4;
     *134678604 = caml_int64_float_of_bits;
    _push( &camlPervasives__55);
    caml_c_call();
    __esp = __esp + 4;
     *134678608 = caml_int64_float_of_bits;
     *134678612 =  &camlPervasives__54;
     *134678616 =  &camlPervasives__53;
     *134678620 =  &camlPervasives__52;
     *134678624 =  &camlPervasives__51;
     *134678628 =  &camlPervasives__50;
     *134678876 =  &camlPervasives__49;
     *134678864 =  &camlPervasives__48;
     *134678632 =  &camlPervasives__47;
     *134678636 =  &camlPervasives__46;
    _push(1);
    caml_c_call();
    __esp = __esp + 4;
     *134678640 = caml_ml_open_descriptor_in;
    _push(3);
    caml_c_call();
    __esp = __esp + 4;
     *134678644 = caml_ml_open_descriptor_out;
    _push(5);
    caml_c_call();
    __esp = __esp + 4;
     *134678648 = caml_ml_open_descriptor_out;
     *134678720 =  &camlPervasives__45;
     *134678712 =  &camlPervasives__44;
     *134678716 =  &camlPervasives__43;
     *134678728 =  &camlPervasives__42;
     *134678736 =  &camlPervasives__41;
     *134678740 =  &camlPervasives__40;
     *134678752 =  &camlPervasives__39;
     *134678768 =  &camlPervasives__38;
     *134678772 =  &camlPervasives__37;
     *134678788 =  &camlPervasives__36;
     *134678780 =  &camlPervasives__35;
     *134678784 =  &camlPervasives__34;
     *134678800 =  &camlPervasives__33;
     *134678868 =  &camlPervasives__32;
     *134678804 =  &camlPervasives__31;
     *134678796 =  &camlPervasives__30;
     *134678836 =  &camlPervasives__29;
     *134678652 =  &camlPervasives__28;
     *134678656 =  &camlPervasives__27;
     *134678660 =  &camlPervasives__26;
     *134678664 =  &camlPervasives__25;
     *134678668 =  &camlPervasives__24;
     *134678672 =  &camlPervasives__23;
     *134678676 =  &camlPervasives__22;
     *134678680 =  &camlPervasives__21;
     *134678684 =  &camlPervasives__20;
     *134678688 =  &camlPervasives__19;
     *134678692 =  &camlPervasives__18;
     *134678696 =  &camlPervasives__17;
     *134678700 =  &camlPervasives__16;
     *134678704 =  &camlPervasives__15;
     *134678708 =  &camlPervasives__14;
    caml_allocN(36, __esp);
    _t79 = 0x28;
     *((intOrPtr*)(_t79 - 4)) = 6144;
     *_t79 =  &camlPervasives__7;
     *((intOrPtr*)(_t79 + 4)) =  &camlPervasives__8;
     *((intOrPtr*)(_t79 + 8)) =  &camlPervasives__9;
     *((intOrPtr*)(_t79 + 12)) =  &camlPervasives__10;
     *((intOrPtr*)(_t79 + 16)) =  &camlPervasives__11;
     *((intOrPtr*)(_t79 + 20)) =  &camlPervasives__12;
     *134678844 = _t79;
     *134678852 =  &camlPervasives__6;
     *134678848 =  &camlPervasives__5;
    _t80 = _t79 + 28;
     *((intOrPtr*)(_t80 - 4)) = 1024;
     *_t80 =  *134678728;
     *134678880 = _t80;
     *134678860 =  &camlPervasives__4;
     *134678872 =  &camlPervasives__3;
     *134678856 =  &camlPervasives__2;
    caml_c_call("Pervasives.do_at_exit",  *134678872);
    return 1;
}

camlArray__size_1065(
    _unknown_ __eax,                       // r0
    intOrPtr* __ebx                        // r1
)
{// addr = 0x080500A0
    _unknown_ _t3;                         // _t3
    intOrPtr* _t5;                         // _t5
    unsigned int _t7;                      // _t7
    signed int _t8;                        // _t8
    _unknown_ _t10;                        // _t10

L0:
    while(1) {
L0:
        _t5 = __ebx;
        _t3 = __eax;
        if(_t5 == 1) {
            break;
        }
L1:
        _t7 =  *( *_t5 - 4);
        if((_t7 & 255) == 254) {
            _t8 = _t7 >> 10;
        } else {
            _t8 = _t7 >> 9;
        }
        _t3 = _t3 + (_t8 | 1) - 1;
    }
    return _t3;
}

camlArray__fill_1070(
    intOrPtr __eax,                        // r0
    intOrPtr* __ebx,                       // r1
    _unknown_ __ecx,                       // r2
    intOrPtr* __esp                        // r7
)
{// addr = 0x080500F0
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _t23;                         // _t23
    _unknown_ _t24;                        // _t24
    intOrPtr _t26;                         // _t26
    intOrPtr _t36;                         // _t36
    intOrPtr* _t40;                        // _t40
    signed int _t41;                       // _t41
    unsigned int _t42;                     // _t42
    signed int _t43;                       // _t43
    _unknown_ _t45;                        // _t45
    intOrPtr _t46;                         // _t46
    unsigned int _t49;                     // _t49
    signed int _t50;                       // _t50
    _unknown_ _t52;                        // _t52

    __esp = __esp;
    _t45 = __ecx;
    _t40 = __ebx;
    _t23 = __eax;
    while(1) {
        __edi = _t45;
        if(_t40 == 1) {
            break;
        }
        _v12 = _t23;
         *__esp =  *((intOrPtr*)(_t40 + 4));
        _t26 =  *_t40;
        _v16 = _t26;
        _t41 = 1;
        _t49 =  *(_t26 - 4);
        if((_t49 & 255) == 254) {
            _t50 = _t49 >> 10;
        } else {
            _t50 = _t49 >> 9;
        }
        _t52 = (_t50 | 1) + -2;
        if(_t41 <= _t52) {
            goto L6;
            do {
L6:
                _t46 = _v16;
                if(( *(_t46 - 4) & 255) == 254) {
                    while(1) {
                        _t36 = caml_young_ptr - 12;
                        caml_young_ptr = _t36;
                        if(_t36 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                    _t37 = _t36 + 4;
                     *((intOrPtr*)(_t36 + 4 - 4)) = 2301;
                    asm("fld qword [ecx+ebx*4-0x4]");
                    asm("fstp qword [eax]");
                    goto L10;
                }
                _t37 =  *((intOrPtr*)(_t46 + _t41 * 2 - 2));
L10:
                __ebp = _v12 + _t41 - 1;
                __edx =  *((intOrPtr*)(__edi + 12));
                if(( *( *((intOrPtr*)(__edi + 12)) - 4) & 255) == 254) {
                    asm("fld qword [eax]");
                    asm("fstp qword [edx+ebp*4-0x4]");
                } else {
                    caml_modify(_t41, __edx + __ebp * 2 - 2, _t37);
                }
                _t41 = _t41 + 2;
            } while(_t41 != _t52);
        }
        _t42 =  *(_v16 - 4);
        if((_t42 & 255) == 254) {
            _t43 = _t42 >> 10;
        } else {
            _t43 = _t42 >> 9;
        }
        _t23 = _v12 + (_t43 | 1) - 1;
        _t40 =  *__esp;
        _t45 = __edi;
L20:
    }
    return 1;
    goto L20;
}

camlArray__find_init_1077(
    intOrPtr* __eax,                       // r0
    intOrPtr* __esp                        // r7
)
{// addr = 0x08050220
    intOrPtr* _v4;                         // _cfa_fffffffc
    intOrPtr* _t13;                        // _t13
    intOrPtr _t17;                         // _t17
    intOrPtr _t18;                         // _t18
    _unknown_ _t19;                        // _t19
    _unknown_ _t20;                        // _t20
    intOrPtr _t24;                         // _t24
    _unknown_ _t25;                        // _t25
    _unknown_ _t26;                        // _t26
    intOrPtr* _t28;                        // _t28
    intOrPtr _t30;                         // _t30
    intOrPtr* _t32;                        // _t32
    intOrPtr* _t33;                        // _t33
    unsigned int _t34;                     // _t34
    signed int _t35;                       // _t35

    __esp = __esp;
    _t13 = __eax;
    while(1) {
        _t28 = _t13;
        if(_t28 == 1) {
            break;
        }
        _t13 =  *((intOrPtr*)(_t28 + 4));
        _t32 =  *_t28;
        _t34 =  *(_t32 - 4);
        if((_t34 & 255) == 254) {
            _t35 = _t34 >> 10;
        } else {
            _t35 = _t34 >> 9;
        }
        if((_t35 | 1) <= 1) {
            continue;
        }
        if(( *(_t32 - 4) & 255) == 254) {
            while(1) {
                _t17 = caml_young_ptr - 12;
                caml_young_ptr = _t17;
                if(_t17 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t18 = _t17 + 4;
             *((intOrPtr*)(_t18 - 4)) = 2301;
            asm("fld qword [ecx]");
            asm("fstp qword [eax]");
L10:
            __esp = __esp + 8;
            __esp = __esp - 8;
             *__esp = _t18;
            _v4 = _t28;
            caml_c_call(camlArray__size_1065(1, _t28),  *__esp);
            _t30 = caml_make_vect;
             *__esp = caml_make_vect;
            while(1) {
                _t24 = caml_young_ptr - 20;
                caml_young_ptr = _t24;
                if(_t24 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t33 = _t24 + 4;
             *((intOrPtr*)(_t33 - 4)) = 4343;
             *_t33 = caml_curry2;
             *((intOrPtr*)(_t33 + 4)) = 5;
             *((intOrPtr*)(_t33 + 8)) = camlArray__fill_1070;
             *((intOrPtr*)(_t33 + 12)) = _t30;
            camlArray__fill_1070(1, _v4, _t33, __esp);
            return  *__esp;
L18:
        }
        _t18 =  *_t32;
        goto L10;
    }
    return  &camlArray__36;
    goto L18;
}

camlArray__tolist_1123(
    signed int __eax,                      // r0
    intOrPtr* __ebx,                       // r1
    _unknown_ __ecx                        // r2
)
{// addr = 0x080502C0
    signed int _t11;                       // _t11
    intOrPtr _t14;                         // _t14
    intOrPtr _t16;                         // _t16
    intOrPtr _t19;                         // _t19
    intOrPtr* _t20;                        // _t20

    __ecx = __ecx;
    __ebx = __ebx;
    _t11 = __eax;
    while(1) {
        __edx = _t11;
        if(__edx < 1) {
            break;
        }
        _t19 =  *((intOrPtr*)(__ecx + 12));
        if(( *(_t19 - 4) & 255) == 254) {
            while(1) {
                _t14 = caml_young_ptr - 12;
                caml_young_ptr = _t14;
                if(_t14 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            __edi = _t14 + 4;
             *((intOrPtr*)(__edi - 4)) = 2301;
            asm("fld qword [esi+edx*4-0x4]");
            asm("fstp qword [edi]");
            while(1) {
L7:
                _t16 = caml_young_ptr - 12;
                caml_young_ptr = _t16;
                if(_t16 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t20 = _t16 + 4;
             *((intOrPtr*)(_t20 - 4)) = 2048;
             *_t20 = __edi;
             *((intOrPtr*)(_t20 + 4)) = __ebx;
            _t11 = __edx + -2;
            __ebx = _t20;
            continue;
        }
        __edi =  *((intOrPtr*)(_t19 + __edx * 2 - 2));
        goto L7;
    }
    return __ebx;
}

camlArray__fill_1135(
    signed int __eax,                      // r0
    intOrPtr* __ebx,                       // r1
    _unknown_ __ecx                        // r2
)
{// addr = 0x08050350
    signed int _t8;                        // _t8
    intOrPtr* _t13;                        // _t13
    intOrPtr _t14;                         // _t14
    _unknown_ _t15;                        // _t15
    intOrPtr _t16;                         // _t16

    _t15 = __ecx;
    _t13 = __ebx;
    _t8 = __eax;
    while(1) {
        __edi = _t8;
        __esi = _t15;
        if(_t13 == 1) {
            break;
        }
        __ebp =  *((intOrPtr*)(_t13 + 4));
        _t16 =  *_t13;
        _t14 =  *((intOrPtr*)(__esi + 12));
        if(( *(_t14 - 4) & 255) == 254) {
            asm("fld qword [ecx]");
            asm("fstp qword [ebx+edi*4-0x4]");
        } else {
            caml_modify(_t14, _t14 + __edi * 2 - 2, _t16);
        }
        _t8 = __edi + 2;
        _t13 = __ebp;
        _t15 = __esi;
    }
    return  *((intOrPtr*)(__esi + 12));
}

camlArray__maxson_1155(
    signed int __eax,                      // r0
    signed int* __ebx,                     // r1
    signed int __ecx                       // r2
)
{// addr = 0x080503B0
    signed int _v12;                       // _cfa_fffffff4
    signed int* _v16;                      // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ _v76;                        // _cfa_ffffffb4
    _unknown_ _v80;                        // _cfa_ffffffb0
    intOrPtr _t149;                        // _t149
    intOrPtr _t156;                        // _t156
    intOrPtr* _t157;                       // _t157
    _unknown_ _t158;                       // _t158
    _unknown_ _t163;                       // _t163
    _unknown_ _t164;                       // _t164
    _unknown_ _t165;                       // _t165
    _unknown_ _t166;                       // _t166
    _unknown_ _t167;                       // _t167
    _unknown_ _t168;                       // _t168
    _unknown_ _t169;                       // _t169
    _unknown_ _t170;                       // _t170
    _unknown_ _t171;                       // _t171
    intOrPtr _t172;                        // _t172
    signed int _t173;                      // _t173
    _unknown_ _t175;                       // _t175
    _unknown_ _t176;                       // _t176
    _unknown_ _t177;                       // _t177
    _unknown_ _t180;                       // _t180
    _unknown_ _t181;                       // _t181
    _unknown_ _t182;                       // _t182
    _unknown_ _t184;                       // _t184
    _unknown_ _t185;                       // _t185
    _unknown_ _t186;                       // _t186
    _unknown_ _t187;                       // _t187
    _unknown_ _t189;                       // _t189
    _unknown_ _t191;                       // _t191
    _unknown_ _t192;                       // _t192
    _unknown_ _t195;                       // _t195
    _unknown_ _t198;                       // _t198
    _unknown_ _t199;                       // _t199
    _unknown_ _t202;                       // _t202
    _unknown_ _t203;                       // _t203
    _unknown_ _t204;                       // _t204
    _unknown_ _t205;                       // _t205
    _unknown_ _t206;                       // _t206
    _unknown_ _t207;                       // _t207
    _unknown_ _t208;                       // _t208
    _unknown_ _t210;                       // _t210
    _unknown_ _t213;                       // _t213
    intOrPtr _t219;                        // _t219
    signed int _t220;                      // _t220
    _unknown_ _t225;                       // _t225
    _unknown_ _t226;                       // _t226
    intOrPtr _t228;                        // _t228
    intOrPtr _t229;                        // _t229
    _unknown_ _t231;                       // _t231
    unsigned int _t236;                    // _t236
    intOrPtr _t239;                        // _t239
    unsigned int _t240;                    // _t240
    intOrPtr _t243;                        // _t243
    intOrPtr _t244;                        // _t244
    unsigned int _t245;                    // _t245
    intOrPtr _t248;                        // _t248
    unsigned int _t250;                    // _t250
    intOrPtr _t253;                        // _t253
    intOrPtr _t254;                        // _t254
    _unknown_ _t256;                       // _t256
    signed int* _t263;                     // _t263
    signed int _t268;                      // _t268
    intOrPtr _t269;                        // _t269
    _unknown_ _t271;                       // _t271
    _unknown_ _t273;                       // _t273
    _unknown_ _t274;                       // _t274
    _unknown_ _t276;                       // _t276
    signed int _t287;                      // _t287
    intOrPtr _t289;                        // _t289
    _unknown_ _t291;                       // _t291
    _unknown_ _t292;                       // _t292
    _unknown_ _t294;                       // _t294
    _unknown_ _t296;                       // _t296
    _unknown_ _t301;                       // _t301
    _unknown_ _t303;                       // _t303
    _unknown_ _t308;                       // _t308
    _unknown_ _t309;                       // _t309
    _unknown_ _t311;                       // _t311
    signed int _t312;                      // _t312
    signed int _t313;                      // _t313
    signed int _t314;                      // _t314
    _unknown_ _t315;                       // _t315
    signed int* _t322;                     // _t322
    _unknown_ _t324;                       // _t324
    _unknown_ _t325;                       // _t325
    _unknown_ _t326;                       // _t326
    _unknown_ _t327;                       // _t327
    signed int _t331;                      // _t331
    _unknown_ _t332;                       // _t332
    _unknown_ _t335;                       // _t335
    _unknown_ _t336;                       // _t336
    _unknown_ _t337;                       // _t337
    _unknown_ _t338;                       // _t338
    _unknown_ _t339;                       // _t339
    _unknown_ _t340;                       // _t340

    _t287 = __ecx;
    _t263 = __ebx;
    __esp = __esp - 20;
    _t312 = __eax;
    _t331 = _t263 + _t263 +  &(_t263[0]) + -3;
    _v12 = _t331;
    while(1) {
        _t149 = caml_young_ptr - 8;
        caml_young_ptr = _t149;
        if(_t149 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t322 = _t149 + 4;
     *((intOrPtr*)(_t322 - 4)) = 1024;
     *_t322 = _t331;
    if(_t331 + 4 >= _t312) {
        _v16 = _t263;
         *__esp = _t312;
        if(_t331 + 2 >= _t312) {
L47:
            if(_v12 >=  *__esp) {
                while(1) {
                    _t156 = caml_young_ptr - 12;
                    caml_young_ptr = _t156;
                    if(_t156 >= caml_young_limit) {
                        _t157 = _t156 + 4;
                         *((intOrPtr*)(_t157 - 4)) = 2048;
                         *_t157 =  *134682296;
                         *(_t157 + 4) = _v16;
                        caml_raise_exn(_t157);
                    }
                    caml_call_gc(__esp);
                }
            }
            __esp =  &((__esp)[5]);
            return;
            goto L140;
        }
        _t268 = _t331 + 2;
        _t313 =  *(_t287 + 16);
        _t323 =  *(_t313 - 4);
        if((_t323 & 255) == 254) {
            if(_t323 >> 10 <= _t268) {
                goto L61;
            } else {
                while(1) {
                    _t219 = caml_young_ptr - 12;
                    caml_young_ptr = _t219;
                    if(_t219 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                _t220 = _t219 + 4;
                 *((intOrPtr*)(_t220 - 4)) = 2301;
                asm("fld qword [edx+ebx*4-0x4]");
                asm("fstp qword [eax]");
                _t268 = _t220;
                goto L39;
            }
            goto L62;
        } else {
            if(_t323 >> 9 <= _t268) {
L62:
                caml_ml_array_bound_error();
            } else {
                _t268 =  *(_t313 + _t268 * 2 - 2);
L39:
                _t313 =  *(_t287 + 16);
                _t323 =  *(_t313 - 4);
                if((_t323 & 255) == 254) {
                    if(_t323 >> 10 <= _t331) {
                        caml_ml_array_bound_error();
                    } else {
                        while(1) {
                            _t228 = caml_young_ptr - 12;
                            caml_young_ptr = _t228;
                            if(_t228 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                        _t229 = _t228 + 4;
                         *((intOrPtr*)(_t229 - 4)) = 2301;
                        asm("fld qword [edx+esi*4-0x4]");
                        asm("fstp qword [eax]");
                        goto L45;
                    }
                    goto L60;
                } else {
                    if(_t323 >> 9 <= _t331) {
L60:
                        caml_ml_array_bound_error();
                    } else {
                        _t229 =  *((intOrPtr*)(_t313 + _t331 * 2 - 2));
L45:
                        caml_apply2();
                        if(_t229 >= 1) {
                            goto L47;
                        }
                        __esp =  &((__esp)[5]);
                        return;
                        goto L140;
                    }
L61:
                    caml_ml_array_bound_error();
                    goto L62;
                }
                goto L140;
            }
            goto L63;
        }
    } else {
        _v16 = _t322;
         *__esp = _t287;
        _t313 = _t331 + 2;
        _t323 =  *(_t287 + 16);
        _t236 =  *(_t323 - 4);
        _t268 = _t236 & 255;
        if(_t268 == 254) {
            if(_t236 >> 10 <= _t313) {
                goto L69;
            } else {
                while(1) {
                    _t239 = caml_young_ptr - 12;
                    caml_young_ptr = _t239;
                    if(_t239 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                _t268 = _t239 + 4;
                 *((intOrPtr*)(_t268 - 4)) = 2301;
                asm("fld qword [edi+edx*4-0x4]");
                asm("fstp qword [ebx]");
                goto L9;
            }
            goto L70;
        } else {
            if(_t236 >> 9 <= _t313) {
L70:
                _t172 = caml_ml_array_bound_error();
            } else {
                _t268 =  *(_t323 + _t313 * 2 - 2);
L9:
                _t313 =  *(_t287 + 16);
                _t240 =  *(_t313 - 4);
                _t323 = _t240 & 255;
                if((_t240 & 255) == 254) {
                    if(_t240 >> 10 <= _t331) {
                        goto L67;
                    } else {
                        while(1) {
                            _t243 = caml_young_ptr - 12;
                            caml_young_ptr = _t243;
                            if(_t243 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                        _t244 = _t243 + 4;
                         *((intOrPtr*)(_t244 - 4)) = 2301;
                        asm("fld qword [edx+esi*4-0x4]");
                        asm("fstp qword [eax]");
                        goto L15;
                    }
                    goto L68;
                } else {
                    if(_t240 >> 9 <= _t331) {
L68:
                        caml_ml_array_bound_error();
                    } else {
                        _t244 =  *((intOrPtr*)(_t313 + _t331 * 2 - 2));
L15:
                        caml_apply2();
                        if(_t244 < 1) {
                             *_v16 = _v12 + 2;
                        }
                        _t287 = _v12 + 4;
                        _t331 =  *__esp;
                        _t313 =  *(_t331 + 16);
                        _t245 =  *(_t313 - 4);
                        _t268 = _t245 & 255;
                        if(_t268 == 254) {
                            if(_t245 >> 10 <= _t287) {
                                goto L65;
                            } else {
                                while(1) {
                                    _t248 = caml_young_ptr - 12;
                                    caml_young_ptr = _t248;
                                    if(_t248 >= caml_young_limit) {
                                        break;
                                    }
                                    caml_call_gc(__esp);
                                }
                                _t268 = _t248 + 4;
                                 *((intOrPtr*)(_t268 - 4)) = 2301;
                                asm("fld qword [edx+ecx*4-0x4]");
                                asm("fstp qword [ebx]");
                                goto L23;
                            }
                            goto L66;
                        } else {
                            if(_t245 >> 9 <= _t287) {
L66:
                                caml_ml_array_bound_error();
                            } else {
                                _t268 =  *(_t313 + _t287 * 2 - 2);
L23:
                                _t313 =  *_v16;
                                _t287 =  *(_t331 + 16);
                                _t250 =  *(_t287 - 4);
                                _t323 = _t250 & 255;
                                if((_t250 & 255) == 254) {
                                    if(_t250 >> 10 <= _t313) {
L63:
                                        caml_ml_array_bound_error();
                                    } else {
                                        while(1) {
                                            _t253 = caml_young_ptr - 12;
                                            caml_young_ptr = _t253;
                                            if(_t253 >= caml_young_limit) {
                                                break;
                                            }
                                            caml_call_gc(__esp);
                                        }
                                        _t254 = _t253 + 4;
                                         *((intOrPtr*)(_t254 - 4)) = 2301;
                                        asm("fld qword [ecx+edx*4-0x4]");
                                        asm("fstp qword [eax]");
                                        goto L29;
                                    }
                                    goto L64;
                                } else {
                                    if(_t250 >> 9 <= _t313) {
L64:
                                        caml_ml_array_bound_error();
                                    } else {
                                        _t254 =  *((intOrPtr*)(_t287 + _t313 * 2 - 2));
L29:
                                        caml_apply2();
                                        if(_t254 < 1) {
                                             *_v16 = _v12 + 4;
                                        }
                                        __esp =  &((__esp)[5]);
                                        return;
                                        goto L140;
                                    }
L65:
                                    caml_ml_array_bound_error();
                                    goto L66;
                                }
                                goto L140;
                            }
L67:
                            caml_ml_array_bound_error();
                            goto L68;
                        }
                        goto L140;
                    }
L69:
                    caml_ml_array_bound_error();
                    goto L70;
                }
                goto L140;
            }
            __esp = __esp - 28;
            while(1) {
                _v44 = _t172;
                _v36 = _t268;
                _v40 = _t287;
                 *__esp = _t313;
                camlArray__maxson_1155(_t172, _t268,  *((intOrPtr*)(_t313 + 20)));
                _t269 = _t172;
                _v32 = _t269;
                _t314 =  *__esp;
                _t289 =  *((intOrPtr*)(_t314 + 16));
                _t173 =  *(_t289 - 4);
                _t334 = _t173 & 255;
                if((_t173 & 255) == 254) {
                    goto L75;
                } else {
                    goto L73;
                }
            }
        }
    }
L140:
}

camlArray__trickledown_1160(
    signed int __eax,                      // r0
    intOrPtr __edx                         // r3
)
{// addr = 0x080507A0
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int* _v16;                      // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ _v60;                        // _cfa_ffffffc4
    signed int _t79;                       // _t79
    signed int _t80;                       // _t80
    _unknown_ _t82;                        // _t82
    _unknown_ _t83;                        // _t83
    _unknown_ _t84;                        // _t84
    _unknown_ _t87;                        // _t87
    _unknown_ _t88;                        // _t88
    _unknown_ _t89;                        // _t89
    _unknown_ _t91;                        // _t91
    _unknown_ _t92;                        // _t92
    _unknown_ _t93;                        // _t93
    _unknown_ _t94;                        // _t94
    _unknown_ _t96;                        // _t96
    _unknown_ _t98;                        // _t98
    _unknown_ _t99;                        // _t99
    _unknown_ _t102;                       // _t102
    _unknown_ _t105;                       // _t105
    _unknown_ _t106;                       // _t106
    _unknown_ _t109;                       // _t109
    _unknown_ _t110;                       // _t110
    _unknown_ _t111;                       // _t111
    _unknown_ _t112;                       // _t112
    _unknown_ _t113;                       // _t113
    _unknown_ _t114;                       // _t114
    _unknown_ _t115;                       // _t115
    _unknown_ _t117;                       // _t117
    _unknown_ _t120;                       // _t120
    signed int* _t125;                     // _t125
    intOrPtr _t126;                        // _t126
    _unknown_ _t128;                       // _t128
    _unknown_ _t130;                       // _t130
    _unknown_ _t131;                       // _t131
    _unknown_ _t133;                       // _t133
    intOrPtr _t138;                        // _t138
    intOrPtr _t140;                        // _t140
    _unknown_ _t142;                       // _t142
    _unknown_ _t143;                       // _t143
    _unknown_ _t145;                       // _t145
    _unknown_ _t147;                       // _t147
    _unknown_ _t152;                       // _t152
    _unknown_ _t154;                       // _t154
    intOrPtr _t159;                        // _t159
    intOrPtr _t160;                        // _t160
    _unknown_ _t168;                       // _t168
    _unknown_ _t169;                       // _t169
    _unknown_ _t170;                       // _t170
    _unknown_ _t171;                       // _t171
    _unknown_ _t174;                       // _t174
    _unknown_ _t175;                       // _t175
    _unknown_ _t176;                       // _t176
    _unknown_ _t177;                       // _t177
    _unknown_ _t178;                       // _t178
    _unknown_ _t179;                       // _t179

    _t159 = __edx;
    _t79 = __eax;
    __esp = __esp - 28;
    while(1) {
        _v24 = _t79;
        _v16 = _t125;
        _v20 = _t138;
         *__esp = _t159;
        camlArray__maxson_1155(_t79, _t125,  *((intOrPtr*)(_t159 + 20)));
        _t126 = _t79;
        _v12 = _t126;
        _t160 =  *__esp;
        _t140 =  *((intOrPtr*)(_t160 + 16));
        _t80 =  *(_t140 - 4);
        _t173 = _t80 & 255;
        if((_t80 & 255) == 254) {
            goto L4;
        } else {
            goto L2;
        }
    }
}

camlArray__trickle_1165(
    unsigned int* __esp                    // r7
)
{// addr = 0x080509B0
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int _v28;                       // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    intOrPtr* _t37;                        // _t37
    signed int _t38;                       // _t38
    _unknown_ _t41;                        // _t41
    signed int _t42;                       // _t42
    signed int _t43;                       // _t43
    _unknown_ _t45;                        // _t45
    _unknown_ _t46;                        // _t46
    _unknown_ _t47;                        // _t47
    _unknown_ _t48;                        // _t48
    _unknown_ _t50;                        // _t50
    _unknown_ _t52;                        // _t52
    _unknown_ _t53;                        // _t53
    _unknown_ _t56;                        // _t56
    signed int _t59;                       // _t59
    intOrPtr _t61;                         // _t61
    unsigned int _t63;                     // _t63
    unsigned int _t64;                     // _t64
    intOrPtr _t66;                         // _t66
    _unknown_ _t68;                        // _t68
    _unknown_ _t73;                        // _t73
    unsigned int _t75;                     // _t75
    _unknown_ _t83;                        // _t83
    _unknown_ _t84;                        // _t84
    _unknown_ _t85;                        // _t85
    _unknown_ _t86;                        // _t86
    _unknown_ _t87;                        // _t87
    _unknown_ _t88;                        // _t88
    unsigned int _t89;                     // _t89
    _unknown_ _t90;                        // _t90
    _unknown_ _t91;                        // _t91

    __esp = __esp;
    __esp = __esp - 16;
    _v12 = _t61;
     *__esp = _t75;
    L8();
    if( *_t37 !=  *134682296) {
        _t38 = caml_raise_exn(_t37);
        _push(caml_exception_pointer);
        caml_exception_pointer = __esp;
        camlArray__trickledown_1160(_t38,  *((intOrPtr*)(_t75 + 16)));
        _pop(caml_exception_pointer);
        __esp =  &((__esp)[1]);
        __esp =  &((__esp)[4]);
        return;
L33:
    }
    _t59 =  *(_t37 + 4);
    _t40 =  *((intOrPtr*)( *__esp + 12));
    _t63 =  *( *((intOrPtr*)( *__esp + 12)) - 4);
    if((_t63 & 255) == 254) {
        _t64 = _t63 >> 10;
        if(_t64 <= _t59) {
            caml_ml_array_bound_error();
        } else {
            asm("fld qword [ecx]");
            asm("fstp qword [eax+ebx*4-0x4]");
            goto L6;
        }
        goto L10;
    } else {
        _t64 = _t63 >> 9;
        if(_t64 <= _t59) {
L10:
            _t42 = caml_ml_array_bound_error();
        } else {
            caml_modify(_t59, _t40 + _t59 * 2 - 2, _v12);
L6:
            __esp =  &((__esp)[4]);
            return;
            goto L33;
        }
        __esp = __esp - 20;
        while(1) {
            _v32 = _t42;
            _v28 = _t59;
             *__esp = _t64;
            camlArray__maxson_1155(_t42, _t59,  *((intOrPtr*)(_t64 + 16)));
            _t59 = _t42;
            _t89 =  *__esp;
            _t66 =  *((intOrPtr*)(_t89 + 12));
            _t43 =  *(_t66 - 4);
            if((_t43 & 255) == 254) {
                goto L15;
            } else {
                goto L13;
            }
        }
    }
    goto L33;
}

L08050A40()
{
    _unknown_ _t2;                         // _t2

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    camlArray__trickledown_1160(__eax,  *((intOrPtr*)(_t2 + 16)));
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    __esp = __esp + 16;
    return;
}

camlArray__bubbledown_1170(
    signed int __eax                       // r0
)
{// addr = 0x08050A70
    signed int* _v12;                      // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    signed int _t24;                       // _t24
    signed int _t25;                       // _t25
    _unknown_ _t27;                        // _t27
    _unknown_ _t28;                        // _t28
    _unknown_ _t29;                        // _t29
    _unknown_ _t30;                        // _t30
    _unknown_ _t32;                        // _t32
    _unknown_ _t34;                        // _t34
    _unknown_ _t35;                        // _t35
    signed int* _t38;                      // _t38
    intOrPtr _t40;                         // _t40
    intOrPtr _t42;                         // _t42
    _unknown_ _t44;                        // _t44
    _unknown_ _t53;                        // _t53
    _unknown_ _t54;                        // _t54
    intOrPtr _t55;                         // _t55
    _unknown_ _t56;                        // _t56
    _unknown_ _t57;                        // _t57

    _t24 = __eax;
    __esp = __esp - 20;
    while(1) {
        _v16 = _t24;
        _v12 = _t38;
         *__esp = _t40;
        camlArray__maxson_1155(_t24, _t38,  *((intOrPtr*)(_t40 + 16)));
        _t38 = _t24;
        _t55 =  *__esp;
        _t42 =  *((intOrPtr*)(_t55 + 12));
        _t25 =  *(_t42 - 4);
        if((_t25 & 255) == 254) {
            goto L4;
        } else {
            goto L2;
        }
    }
}

camlArray__bubble_1174()
{// addr = 0x08050B70
    intOrPtr* _t5;                         // _t5
    signed int _t6;                        // _t6
    _unknown_ _t7;                         // _t7
    _unknown_ _t9;                         // _t9
    _unknown_ _t10;                        // _t10
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13

    L3();
    if( *_t5 !=  *134682296) {
        _t6 = caml_raise_exn(_t5);
        _push(caml_exception_pointer);
        caml_exception_pointer = __esp;
        camlArray__bubbledown_1170(_t6);
        _pop(caml_exception_pointer);
        __esp = __esp + 4;
        return;
L4:
    }
    return;
    goto L4;
}

L08050BA0()
{
    _unknown_ _t2;                         // _t2
    _unknown_ _t3;                         // _t3

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    camlArray__bubbledown_1170(__eax);
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    return;
}

camlArray__trickleup_1178(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    signed int __ecx                       // r2
)
{// addr = 0x08050BC0
    _unknown_ _t297;                       // _t297
    _unknown_ _t299;                       // _t299
    _unknown_ _t300;                       // _t300
    _unknown_ _t301;                       // _t301
    _unknown_ _t302;                       // _t302
    _unknown_ _t303;                       // _t303

    __ecx = __ecx;
    _t297 = __eax;
    __esp = __esp - 24;
    while(1) {
        __esi = __eax;
        __edi = __ecx;
        __ecx = 3;
        __esi = __esi + -2;
        __eax = __esi + -2 >> 1;
        asm("cdq ");
        _t62 = __eax % __ecx;
        __eax = __eax / __ecx;
        __edx = _t62;
        __ecx = __eax + __eax + 1;
        if(__esi == __ecx) {
            goto L53;
        } else {
            goto L52;
        }
    }
}

camlArray__merge_1191(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    _unknown_ __ecx,                       // r2
    _unknown_ __edx,                       // r3
    _unknown_ __edi,                       // r4
    _unknown_ __esi                        // r5
)
{// addr = 0x08050E90
    _unknown_ _t247;                       // _t247
    _unknown_ _t249;                       // _t249
    _unknown_ _t250;                       // _t250
    _unknown_ _t251;                       // _t251
    _unknown_ _t252;                       // _t252
    _unknown_ _t253;                       // _t253
    _unknown_ _t255;                       // _t255
    _unknown_ _t257;                       // _t257
    _unknown_ _t258;                       // _t258
    _unknown_ _t259;                       // _t259


}

camlArray__isortto_1209(
    intOrPtr __eax,                        // r0
    _unknown_ __ebx,                       // r1
    signed int __ecx,                      // r2
    _unknown_ __edx,                       // r3
    unsigned int __esi                     // r5
)
{// addr = 0x08051020
    intOrPtr _t245;                        // _t245
    _unknown_ _t246;                       // _t246
    signed int _t248;                      // _t248
    intOrPtr* _t249;                       // _t249
    _unknown_ _t250;                       // _t250
    _unknown_ _t251;                       // _t251
    intOrPtr _t252;                        // _t252

L0:
    while(1) {
L0:
        __esi = __esi;
        __ecx = __ecx;
        _t245 = __eax;
        __esp = __esp - 40;
        __edi = 1;
        if(__edi > __edx + -2) {
            break;
        }
L73:
        (__esp)[4] = __edx;
        (__esp)[3] = __edi;
        (__esp)[6] = __esi;
        (__esp)[5] = __ecx;
        (__esp)[7] = __ebx;
         *__esp = __eax;
        goto L74;
        do {
L74:
            __eax =  *__esp;
            __eax =  *__esp + __edi - 1;
            (__esp)[1] = __eax;
            __ecx = (__esp)[6];
            __ecx =  *((__esp)[6] + 16);
            __edx =  *(__ecx - 4);
            (__esp)[2] =  *(__ecx - 4);
            (__esp)[2] = (__esp)[2] & 255;
            if(((__esp)[2] & 255) == 254) {
L77:
                (__esp)[2] = (__esp)[2] >> 10;
                if((__esp)[2] >> 10 <= __eax) {
                    goto L121;
                } else {
                    while(1) {
L78:
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 12;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
L112:
                        caml_call_gc(__esp);
                    }
                    __edx = __eax + 4;
                     *(__edx - 4) = 2301;
                    __eax = (__esp)[1];
                    asm("fld qword [ecx+eax*4-0x4]");
                    asm("fstp qword [edx]");
                    (__esp)[1] = __edx;
                    goto L80;
                }
                goto L122;
            } else {
L75:
                (__esp)[2] = (__esp)[2] >> 9;
                if((__esp)[2] >> 9 <= __eax) {
L122:
                    __eax = caml_ml_array_bound_error();
                    __esi = __esi;
                    __esp = __esp - 24;
                    if(__edx > 11) {
L125:
                         *__esp = __esi;
                        (__esp)[2] = __ecx;
                        (__esp)[5] = __ebx;
                        (__esp)[4] = __eax;
                        __esi = __edx;
                        __esi = __edx >> 1;
                        if(__esi < 0) {
                            __esi = __esi + 1;
                        }
                        __esi = __esi >> 1;
                        __esi = __esi + __esi + 1;
                        (__esp)[1] = __esi;
                        __edx = __edx - __esi;
                        (__esp)[3] = __edx;
                        __ecx = __ecx + __esi - 1;
                        __eax = __eax + __esi - 1;
                        __edx = (__esp)[3];
                        __esi =  *__esp;
                        L123();
                        __ebx = (__esp)[3];
                        __eax = (__esp)[4];
                        __ecx = (__esp)[4] + (__esp)[3] - 1;
                        __esi =  *__esp;
                        __ebx =  *( *__esp + 12);
                        __edx = (__esp)[1];
                        L123();
                        __eax =  *__esp;
                        __eax =  *( *__esp + 16);
                         *__esp =  *( *__esp + 16);
                        __ebx = (__esp)[1];
                        __ebp = (__esp)[2];
                        __edx = __ebp + __ebx - 1;
                        __esi = (__esp)[3];
                        __eax = (__esp)[4];
                        __eax = (__esp)[4] + __esi - 1;
                        __ecx = (__esp)[5];
                        __edi = __ecx;
                        caml_extra_params = __ebp;
                        __ebp =  *__esp;
                         *134693344 =  *__esp;
                        __esp =  &((__esp)[6]);
                        __esp = __esp - 28;
                         *__esp = __eax;
                        (__esp)[1] = __ecx;
                        (__esp)[4] = __edx;
                        (__esp)[2] = __edi;
                        __eax = caml_extra_params;
                        (__esp)[3] = caml_extra_params;
                        __ebp =  *134693344;
                        __ecx =  *__esp;
                        __edx = __ecx + __ebx - 1;
                        __eax = (__esp)[4];
                        __esi = (__esp)[4] + __esi - 1;
                        while(1) {
L52:
                            __eax = caml_young_ptr;
                            __eax = caml_young_ptr - 40;
                            caml_young_ptr = __eax;
                            if(__eax >= caml_young_limit) {
                                break;
                            }
L68:
                            caml_call_gc(__esp);
                        }
                        __edi = __eax + 4;
                         *(__edi - 4) = 9463;
                         *__edi = caml_curry5;
                         *((intOrPtr*)(__edi + 4)) = 11;
                         *((intOrPtr*)(__edi + 8)) =  &camlArray__code_begin;
                        __eax =  *(__ebp + 12);
                         *(__edi + 12) =  *(__ebp + 12);
                        __eax =  *(__ebp + 16);
                         *(__edi + 16) =  *(__ebp + 16);
                        __ebx = (__esp)[1];
                         *(__edi + 20) = __ebx;
                        __eax = (__esp)[2];
                         *(__edi + 24) = (__esp)[2];
                         *(__edi + 28) = __edx;
                         *(__edi + 32) = __esi;
                        __eax =  *(__ebx - 4);
                        __eax = __eax & 255;
                        if((__eax & 255) == 254) {
L56:
                            if(__eax <= (__esp)[4]) {
                                goto L71;
                            } else {
                                while(1) {
L57:
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 12;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        break;
                                    }
L67:
                                    caml_call_gc(__esp);
                                }
                                __edx = __eax + 4;
                                 *(__edx - 4) = 2301;
                                __eax = (__esp)[4];
                                asm("fld qword [ebx+eax*4-0x4]");
                                asm("fstp qword [edx]");
                                goto L59;
                            }
                            goto L72;
                        } else {
L54:
                            if(__eax <= (__esp)[4]) {
L72:
                                __eax = caml_ml_array_bound_error();
                                __esi = __esi;
                                goto L0;
                            }
L55:
                            __eax = (__esp)[4];
                            __edx =  *(__ebx + (__esp)[4] * 2 - 2);
L59:
                            __esi =  *(__ebp + 16);
                            __eax =  *(__esi - 4);
                            __ebx = __eax;
                            __ebx = __eax & 255;
                            if(__ebx == 254) {
L62:
                                if(__eax <= __ecx) {
L69:
                                    __eax = caml_ml_array_bound_error();
                                } else {
                                    while(1) {
L63:
                                        __eax = caml_young_ptr;
                                        __eax = caml_young_ptr - 12;
                                        caml_young_ptr = __eax;
                                        if(__eax >= caml_young_limit) {
                                            break;
                                        }
L66:
                                        caml_call_gc(__esp);
                                    }
                                    __ebx = __eax + 4;
                                     *(__ebx - 4) = 2301;
                                    asm("fld qword [esi+ecx*4-0x4]");
                                    asm("fstp qword [ebx]");
                                    goto L65;
                                }
                                goto L70;
                            } else {
L60:
                                if(__eax <= __ecx) {
L70:
                                    __eax = caml_ml_array_bound_error();
                                } else {
L61:
                                    __ebx =  *(__esi + __ecx * 2 - 2);
L65:
                                    __eax = __ecx;
                                    __ecx = (__esp)[4];
                                    __esi = (__esp)[3];
                                    __esp =  &((__esp)[7]);
                                    __esp = __esp - 32;
                                    while(1) {
L6:
                                        (__esp)[1] = __eax;
                                        __eax = __ebx;
                                        (__esp)[5] = __eax;
                                        (__esp)[2] = __ecx;
                                        (__esp)[3] = __edx;
                                        (__esp)[4] = __esi;
                                         *__esp = __edi;
                                        __ecx =  *(__edi + 12);
                                        __ebx = __edx;
                                        caml_apply2();
                                        if(__eax > 1) {
                                            break;
                                        }
L7:
                                        __edi =  *__esp;
                                        __eax =  *(__edi + 24);
                                        __ebx =  *(__eax - 4);
                                        __ebx = __ebx & 255;
                                        if((__ebx & 255) == 254) {
L10:
                                            __ebx = __ebx >> 10;
                                            __esi = (__esp)[4];
                                            if(__ebx <= __esi) {
                                                goto L43;
                                            } else {
L11:
                                                __ebx = (__esp)[5];
                                                asm("fld qword [ebx]");
                                                asm("fstp qword [eax+esi*4-0x4]");
                                                goto L12;
                                            }
                                            goto L44;
                                        } else {
L8:
                                            __ebx = __ebx >> 9;
                                            __esi = (__esp)[4];
                                            if(__ebx <= __esi) {
L44:
                                                __eax = caml_ml_array_bound_error();
                                                __esi = __esi;
L45:
                                                while(__ebx != 1) {
                                                    __ecx =  *(__ebx + 4);
                                                    __ebx =  *__ebx;
                                                    __ebx =  *(__ebx - 4);
                                                    __ebx = __ebx & 255;
                                                    if((__ebx & 255) == 254) {
                                                        __ebx = __ebx >> 10;
                                                    } else {
                                                        __ebx = __ebx >> 9;
                                                    }
                                                    __eax = __eax + __ebx;
                                                    __eax = __eax - 1;
                                                    __ebx = __ecx;
                                                }
                                                return __eax;
                                            } else {
L9:
                                                __ebx = (__esp)[5];
                                                caml_modify(__eax, __ebx);
L12:
                                                __ecx = (__esp)[1];
                                                __ecx = (__esp)[1] + 2;
                                                __eax =  *(__edi + 28);
                                                if(__ecx >=  *(__edi + 28)) {
L20:
                                                    __ebp =  *(__edi + 32);
                                                    __ebx = (__esp)[2];
                                                     *(__edi + 32) - __ebx =  *(__edi + 32) - __ebx + 1;
                                                    __esi = __esi + 2;
                                                    __ecx =  *(__edi + 24);
                                                    __eax =  *(__edi + 20);
                                                    __edx = __esi;
                                                    __esi =  *(__edi + 32) - __ebx + 1;
                                                    __esp =  &((__esp)[8]);
L128:
                                                    __esp = __esp - 24;
                                                    __edi = __eax;
                                                    (__esp)[2] = __ecx;
                                                    __ebp = __edx;
                                                    if(__esi < 1 || __ebx < 1) {
L162:
                                                        __eax = "Array.blit";
                                                        __esp =  &((__esp)[6]);
L1:
                                                        _t252 = _t245;
                                                        while(1) {
L2:
                                                            _t248 = caml_young_ptr - 12;
                                                            caml_young_ptr = _t248;
                                                            if(_t248 >= caml_young_limit) {
                                                                _t249 = _t248 + 4;
                                                                 *((intOrPtr*)(_t249 - 4)) = 2048;
                                                                 *_t249 =  &caml_exn_Invalid_argument;
                                                                 *((intOrPtr*)(_t249 + 4)) = _t252;
                                                                caml_raise_exn(_t249);
                                                            }
                                                            caml_call_gc(__esp);
                                                        }
                                                    }
L130:
                                                    __ecx =  *(__edi - 4);
                                                    __ecx = __ecx & 255;
                                                    if((__ecx & 255) == 254) {
                                                        __eax = __ecx;
                                                        __eax = __ecx >> 10;
                                                    } else {
                                                        __eax = __ecx;
                                                        __eax = __ecx >> 9;
                                                    }
                                                    __eax = __eax | 1;
                                                    __eax = __eax - __esi;
                                                    if(__ebx > __eax || __ebp < 1) {
                                                        goto L162;
                                                    }
L135:
                                                    __eax = (__esp)[2];
                                                    __ecx =  *((__esp)[2] - 4);
                                                    __ecx = __ecx & 255;
                                                    if((__ecx & 255) == 254) {
                                                        __eax = __ecx;
                                                        __eax = __ecx >> 10;
                                                    } else {
                                                        __eax = __ecx;
                                                        __eax = __ecx >> 9;
                                                    }
                                                    __eax = __eax | 1;
                                                    __eax = __eax - __esi;
                                                    if(__ebp > __eax) {
                                                        goto L162;
                                                    }
L139:
                                                    if(__ebx >= __ebp) {
L151:
                                                        __eax = 1;
                                                        (__esp)[3] = 1;
                                                        __esi = __esi + -2;
                                                        if((__esp)[3] <= __esi) {
L152:
                                                            (__esp)[1] = __ebx;
                                                             *__esp = __edi;
                                                            goto L153;
                                                            do {
L153:
                                                                __ebx = (__esp)[1];
                                                                __eax = (__esp)[3];
                                                                __ebx = (__esp)[1] + (__esp)[3] - 1;
                                                                __eax =  *__esp;
                                                                __ecx =  *(__eax - 4) & 255;
                                                                if(( *(__eax - 4) & 255) == 254) {
                                                                    while(1) {
L155:
                                                                        __eax = caml_young_ptr;
                                                                        __eax = caml_young_ptr - 12;
                                                                        caml_young_ptr = __eax;
                                                                        if(__eax >= caml_young_limit) {
                                                                            break;
                                                                        }
L163:
                                                                        caml_call_gc(__esp);
                                                                    }
                                                                    __ecx = __eax + 4;
                                                                     *(__ecx - 4) = 2301;
                                                                    __eax =  *__esp;
                                                                    asm("fld qword [eax+ebx*4-0x4]");
                                                                    asm("fstp qword [ecx]");
                                                                    __ebx = __ecx;
L157:
                                                                    __ecx = (__esp)[3];
                                                                    __eax = __ebp;
                                                                    __eax = __ebp + (__esp)[3] - 1;
                                                                    __ecx = (__esp)[2];
                                                                    __ecx =  *((__esp)[2] - 4) & 255;
                                                                    if(( *((__esp)[2] - 4) & 255) == 254) {
                                                                        asm("fld qword [ebx]");
                                                                        __ebx = (__esp)[2];
                                                                        asm("fstp qword [ebx+eax*4-0x4]");
                                                                    } else {
                                                                        _push(__ebx);
                                                                        __ebx = (__esp)[3];
                                                                        _push(__eax);
                                                                        caml_modify(__ebx);
                                                                        __esp =  &((__esp)[2]);
                                                                    }
                                                                    goto L160;
                                                                }
L154:
                                                                __ebx =  *(__eax + __ebx * 2 - 2);
                                                                goto L157;
L160:
                                                                __ebx = (__esp)[3];
                                                                (__esp)[3] = (__esp)[3] + 2;
                                                                (__esp)[3] = (__esp)[3] + 2;
                                                            } while((__esp)[3] != __esi);
                                                        }
                                                    } else {
L140:
                                                        __esi = __esi + -2;
                                                        if(__esi >= 1) {
L141:
                                                            (__esp)[1] = __ebx;
                                                            goto L142;
                                                            do {
L142:
                                                                __eax = (__esp)[1];
                                                                __ebx = (__esp)[1] + __esi - 1;
                                                                __eax =  *(__edi - 4) & 255;
                                                                if(( *(__edi - 4) & 255) == 254) {
                                                                    while(1) {
L144:
                                                                        __eax = caml_young_ptr;
                                                                        __eax = caml_young_ptr - 12;
                                                                        caml_young_ptr = __eax;
                                                                        if(__eax >= caml_young_limit) {
                                                                            break;
                                                                        }
                                                                        goto L164;
                                                                    }
                                                                    __eax = __eax + 4;
                                                                     *(__eax - 4) = 2301;
                                                                    asm("fld qword [edi+ebx*4-0x4]");
                                                                    asm("fstp qword [eax]");
                                                                    __ebx = __eax;
                                                                    goto L146;
                                                                }
L143:
                                                                __ebx =  *(__edi + __ebx * 2 - 2);
L146:
                                                                __eax = __ebp;
                                                                __eax = __ebp + __esi - 1;
                                                                __ecx = (__esp)[2];
                                                                __ecx =  *((__esp)[2] - 4) & 255;
                                                                if(( *((__esp)[2] - 4) & 255) == 254) {
                                                                    asm("fld qword [ebx]");
                                                                    __ebx = (__esp)[2];
                                                                    asm("fstp qword [ebx+eax*4-0x4]");
                                                                } else {
                                                                    _push(__ebx);
                                                                    __ebx = (__esp)[3];
                                                                    _push(__eax);
                                                                    caml_modify(__ebx);
                                                                    __esp =  &((__esp)[2]);
                                                                }
                                                                __ebx = __esi;
                                                                __esi = __esi - 2;
                                                                __esi = __esi - 2;
                                                            } while(__ebx != 1);
                                                        }
L150:
                                                        __eax = 1;
                                                        __esp =  &((__esp)[6]);
                                                        return 1;
                                                    }
L161:
                                                    __eax = 1;
                                                    __esp =  &((__esp)[6]);
                                                    return 1;
L164:
                                                    caml_call_gc(__esp);
                                                    goto L144;
                                                }
L13:
                                                __ebx =  *(__edi + 16);
                                                __edx =  *(__ebx - 4);
                                                __edx = __edx & 255;
                                                if((__edx & 255) == 254) {
L16:
                                                    if(__edx >> 10 <= __ecx) {
L41:
                                                        __eax = caml_ml_array_bound_error();
                                                    } else {
                                                        while(1) {
L17:
                                                            __eax = caml_young_ptr;
                                                            __eax = caml_young_ptr - 12;
                                                            caml_young_ptr = __eax;
                                                            if(__eax >= caml_young_limit) {
                                                                break;
                                                            }
L36:
                                                            caml_call_gc(__esp);
                                                        }
                                                        __edx = __eax + 4;
                                                         *(__edx - 4) = 2301;
                                                        asm("fld qword [ebx+ecx*4-0x4]");
                                                        asm("fstp qword [edx]");
                                                        __ebx = __edx;
                                                        goto L19;
                                                    }
                                                    goto L42;
                                                } else {
L14:
                                                    if(__edx >> 9 <= __ecx) {
L42:
                                                        __eax = caml_ml_array_bound_error();
                                                    } else {
L15:
                                                        __ebx =  *(__ebx + __ecx * 2 - 2);
L19:
                                                        __esi = __esi + 2;
                                                        __eax = __ecx;
                                                        __ecx = (__esp)[2];
                                                        __edx = (__esp)[3];
                                                        continue;
                                                    }
L43:
                                                    __eax = caml_ml_array_bound_error();
                                                    goto L44;
                                                }
                                            }
                                        }
                                        goto L165;
                                    }
                                    __edi =  *__esp;
                                    __eax =  *(__edi + 24);
                                    __ebx =  *(__eax - 4);
                                    __ebx = __ebx & 255;
                                    if((__ebx & 255) == 254) {
L24:
                                        __ebx = __ebx >> 10;
                                        __esi = (__esp)[4];
                                        if(__ebx <= __esi) {
                                            goto L39;
                                        } else {
L25:
                                            __ebx = (__esp)[3];
                                            asm("fld qword [ebx]");
                                            asm("fstp qword [eax+esi*4-0x4]");
                                            goto L26;
                                        }
                                        goto L40;
                                    } else {
L22:
                                        __ebx = __ebx >> 9;
                                        __esi = (__esp)[4];
                                        if(__ebx <= __esi) {
L40:
                                            __eax = caml_ml_array_bound_error();
                                        } else {
L23:
                                            __ebx = (__esp)[3];
                                            caml_modify(__eax, __ebx);
L26:
                                            __ecx = (__esp)[2];
                                            __ecx = (__esp)[2] + 2;
                                            __eax =  *(__edi + 32);
                                            if(__ecx >=  *(__edi + 32)) {
L34:
                                                __ebp =  *(__edi + 28);
                                                __ebx = (__esp)[1];
                                                 *(__edi + 28) - __ebx =  *(__edi + 28) - __ebx + 1;
                                                __esi = __esi + 2;
                                                __ecx =  *(__edi + 24);
                                                __eax =  *(__edi + 16);
                                                __edx = __esi;
                                                __esi =  *(__edi + 28) - __ebx + 1;
                                                __esp =  &((__esp)[8]);
                                                goto L128;
                                            }
L27:
                                            __ebx =  *(__edi + 20);
                                            __edx =  *(__ebx - 4);
                                            __edx = __edx & 255;
                                            if((__edx & 255) == 254) {
L30:
                                                if(__edx >> 10 <= __ecx) {
L37:
                                                    __eax = caml_ml_array_bound_error();
                                                } else {
                                                    while(1) {
L31:
                                                        __eax = caml_young_ptr;
                                                        __eax = caml_young_ptr - 12;
                                                        caml_young_ptr = __eax;
                                                        if(__eax >= caml_young_limit) {
                                                            break;
                                                        }
L35:
                                                        caml_call_gc(__esp);
                                                    }
                                                    __edx = __eax + 4;
                                                     *(__edx - 4) = 2301;
                                                    asm("fld qword [ebx+ecx*4-0x4]");
                                                    asm("fstp qword [edx]");
                                                    goto L33;
                                                }
                                                goto L38;
                                            } else {
L28:
                                                if(__edx >> 9 <= __ecx) {
L38:
                                                    __eax = caml_ml_array_bound_error();
                                                } else {
L29:
                                                    __edx =  *(__ebx + __ecx * 2 - 2);
L33:
                                                    __esi = __esi + 2;
                                                    __eax = (__esp)[1];
                                                    __ebx = (__esp)[5];
                                                    goto L6;
                                                }
L39:
                                                __eax = caml_ml_array_bound_error();
                                                goto L40;
                                            }
                                            goto L165;
                                        }
                                        goto L41;
                                    }
                                    goto L165;
                                }
L71:
                                __eax = caml_ml_array_bound_error();
                                goto L72;
                            }
                        }
                    } else {
L124:
                        __esi =  *(__esi + 20);
                        __esp =  &((__esp)[6]);
                        goto L0;
                    }
                } else {
L76:
                    __edx =  *(__ecx + __eax * 2 - 2);
                    (__esp)[1] =  *(__ecx + __eax * 2 - 2);
                    while(1) {
L80:
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 8;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
L111:
                        caml_call_gc(__esp);
                    }
                    __esi = __eax + 4;
                    (__esp)[2] = __esi;
                     *(__esi - 4) = 1024;
                    __eax = (__esp)[5];
                    __eax = (__esp)[5] + __edi - 3;
                     *__esi = (__esp)[5] + __edi - 3;
                    while(1) {
L82:
                        __ecx =  *__esi;
                        __eax = (__esp)[5];
                        if( *__esi < (__esp)[5]) {
                            break;
                        }
L83:
                        __ecx =  *__esi;
                        __eax =  *(__ebx - 4);
                        __eax = __eax & 255;
                        if((__eax & 255) == 254) {
L86:
                            if(__eax <= __ecx) {
                                goto L119;
                            } else {
                                while(1) {
L87:
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 12;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        break;
                                    }
L110:
                                    caml_call_gc(__esp);
                                }
                                __eax = __eax + 4;
                                 *(__eax - 4) = 2301;
                                asm("fld qword [ebx+ecx*4-0x4]");
                                asm("fstp qword [eax]");
                                goto L89;
                            }
                            goto L120;
                        } else {
L84:
                            if(__eax <= __ecx) {
L120:
                                __eax = caml_ml_array_bound_error();
                            } else {
L85:
                                __eax =  *(__ebx + __ecx * 2 - 2);
L89:
                                __ebx = (__esp)[6];
                                __ecx =  *((__esp)[6] + 12);
                                __ebx = (__esp)[1];
                                caml_apply2();
                                if(__eax <= 1) {
                                    break;
                                } else {
L90:
                                    __esi = (__esp)[2];
                                    __ecx =  *__esi;
                                    __ebx = (__esp)[7];
                                    __eax =  *(__ebx - 4);
                                    __eax = __eax & 255;
                                    if((__eax & 255) == 254) {
L93:
                                        if(__eax <= __ecx) {
                                            goto L117;
                                        } else {
                                            while(1) {
L94:
                                                __eax = caml_young_ptr;
                                                __eax = caml_young_ptr - 12;
                                                caml_young_ptr = __eax;
                                                if(__eax >= caml_young_limit) {
                                                    break;
                                                }
L109:
                                                caml_call_gc(__esp);
                                            }
                                            __edx = __eax + 4;
                                             *(__edx - 4) = 2301;
                                            asm("fld qword [ebx+ecx*4-0x4]");
                                            asm("fstp qword [edx]");
                                            goto L96;
                                        }
                                        goto L118;
                                    } else {
L91:
                                        if(__eax <= __ecx) {
L118:
                                            __eax = caml_ml_array_bound_error();
                                        } else {
L92:
                                            __edx =  *(__ebx + __ecx * 2 - 2);
L96:
                                            __eax =  *__esi;
                                            __eax =  *__esi + 2;
                                            __ecx =  *(__ebx - 4);
                                            __ecx = __ecx & 255;
                                            if((__ecx & 255) == 254) {
L99:
                                                if(__ecx <= __eax) {
L115:
                                                    __eax = caml_ml_array_bound_error();
                                                } else {
L100:
                                                    asm("fld qword [edx]");
                                                    asm("fstp qword [ebx+eax*4-0x4]");
                                                    goto L101;
                                                }
                                                goto L116;
                                            } else {
L97:
                                                if(__ecx <= __eax) {
L116:
                                                    __eax = caml_ml_array_bound_error();
                                                } else {
L98:
                                                    caml_modify(__eax, __edx);
L101:
                                                     *__esi =  *__esi + -2;
                                                    continue;
                                                }
L117:
                                                __eax = caml_ml_array_bound_error();
                                                goto L118;
                                            }
                                            goto L165;
                                        }
L119:
                                        __eax = caml_ml_array_bound_error();
                                        goto L120;
                                    }
                                }
                                goto L165;
                            }
L121:
                            __eax = caml_ml_array_bound_error();
                            goto L122;
                        }
                        goto L165;
                    }
L102:
                    (__esp)[2] =  *((__esp)[2]);
                    __eax =  *((__esp)[2]) + 2;
                    __ebx = (__esp)[7];
                    __ecx =  *(__ebx - 4);
                    __ecx = __ecx & 255;
                    if((__ecx & 255) == 254) {
L105:
                        if(__ecx <= __eax) {
L113:
                            __eax = caml_ml_array_bound_error();
                        } else {
L106:
                            __ecx = (__esp)[1];
                            asm("fld qword [ecx]");
                            asm("fstp qword [ebx+eax*4-0x4]");
                            goto L107;
                        }
                        goto L114;
                    } else {
L103:
                        if(__ecx <= __eax) {
L114:
                            __eax = caml_ml_array_bound_error();
                        } else {
L104:
                            __ecx = (__esp)[1];
                            caml_modify(__eax, (__esp)[1]);
                            goto L107;
                        }
                        goto L115;
                    }
                }
            }
L165:
L107:
            __edi = (__esp)[3];
            __ecx = __edi;
            __edi = __edi + 2;
            (__esp)[3] = __edi;
            __eax = (__esp)[4];
        } while(__ecx != (__esp)[4]);
        break;
    }
L108:
    __esp =  &((__esp)[0xa]);
    return 1;
    goto L165;
}

camlArray__sortto_1217(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    _unknown_ __ecx,                       // r2
    _unknown_ __edx,                       // r3
    _unknown_ __esi                        // r5
)
{// addr = 0x08051320
    _unknown_ _t247;                       // _t247
    _unknown_ _t249;                       // _t249
    _unknown_ _t253;                       // _t253
    _unknown_ _t257;                       // _t257
    _unknown_ _t261;                       // _t261
    _unknown_ _t263;                       // _t263
    _unknown_ _t264;                       // _t264
    _unknown_ _t265;                       // _t265
    _unknown_ _t267;                       // _t267
    _unknown_ _t268;                       // _t268
    _unknown_ _t270;                       // _t270
    _unknown_ _t271;                       // _t271
    _unknown_ _t273;                       // _t273
    _unknown_ _t279;                       // _t279
    _unknown_ _t280;                       // _t280
    _unknown_ _t281;                       // _t281
    _unknown_ _t282;                       // _t282
    _unknown_ _t283;                       // _t283
    _unknown_ _t284;                       // _t284
    _unknown_ _t285;                       // _t285
    _unknown_ _t286;                       // _t286
    _unknown_ _t287;                       // _t287
    _unknown_ _t290;                       // _t290
    _unknown_ _t293;                       // _t293
    _unknown_ _t294;                       // _t294
    _unknown_ _t295;                       // _t295
    _unknown_ _t298;                       // _t298
    _unknown_ _t300;                       // _t300
    _unknown_ _t305;                       // _t305
    _unknown_ _t306;                       // _t306
    _unknown_ _t307;                       // _t307
    _unknown_ _t309;                       // _t309
    _unknown_ _t310;                       // _t310
    _unknown_ _t312;                       // _t312
    _unknown_ _t313;                       // _t313
    _unknown_ _t314;                       // _t314
    _unknown_ _t316;                       // _t316
    _unknown_ _t317;                       // _t317
    _unknown_ _t318;                       // _t318
    _unknown_ _t319;                       // _t319
    _unknown_ _t320;                       // _t320
    _unknown_ _t321;                       // _t321
    _unknown_ _t324;                       // _t324
    _unknown_ _t326;                       // _t326
    _unknown_ _t327;                       // _t327
    _unknown_ _t328;                       // _t328
    _unknown_ _t332;                       // _t332
    _unknown_ _t340;                       // _t340
    _unknown_ _t344;                       // _t344
    _unknown_ _t345;                       // _t345
    _unknown_ _t347;                       // _t347
    _unknown_ _t349;                       // _t349
    _unknown_ _t350;                       // _t350
    _unknown_ _t352;                       // _t352
    _unknown_ _t356;                       // _t356
    _unknown_ _t360;                       // _t360
    _unknown_ _t361;                       // _t361
    _unknown_ _t363;                       // _t363
    _unknown_ _t373;                       // _t373
    _unknown_ _t374;                       // _t374
    _unknown_ _t376;                       // _t376
    _unknown_ _t387;                       // _t387
    _unknown_ _t394;                       // _t394
    _unknown_ _t397;                       // _t397
    _unknown_ _t398;                       // _t398
    _unknown_ _t399;                       // _t399
    _unknown_ _t400;                       // _t400
    _unknown_ _t402;                       // _t402
    _unknown_ _t403;                       // _t403
    _unknown_ _t404;                       // _t404
    _unknown_ _t405;                       // _t405
    _unknown_ _t407;                       // _t407
    _unknown_ _t408;                       // _t408
    _unknown_ _t410;                       // _t410
    _unknown_ _t411;                       // _t411
    _unknown_ _t412;                       // _t412
    _unknown_ _t414;                       // _t414
    _unknown_ _t415;                       // _t415
    _unknown_ _t416;                       // _t416
    _unknown_ _t419;                       // _t419
    _unknown_ _t420;                       // _t420
    _unknown_ _t421;                       // _t421
    _unknown_ _t425;                       // _t425
    _unknown_ _t426;                       // _t426
    _unknown_ _t428;                       // _t428
    _unknown_ _t431;                       // _t431
    _unknown_ _t432;                       // _t432
    _unknown_ _t435;                       // _t435
    _unknown_ _t436;                       // _t436
    _unknown_ _t439;                       // _t439
    _unknown_ _t440;                       // _t440
    _unknown_ _t441;                       // _t441
    _unknown_ _t442;                       // _t442
    _unknown_ _t445;                       // _t445
    _unknown_ _t447;                       // _t447
    _unknown_ _t448;                       // _t448
    _unknown_ _t449;                       // _t449
    _unknown_ _t451;                       // _t451
    _unknown_ _t460;                       // _t460
    _unknown_ _t461;                       // _t461
    _unknown_ _t466;                       // _t466
    _unknown_ _t467;                       // _t467
    _unknown_ _t469;                       // _t469
    _unknown_ _t470;                       // _t470
    _unknown_ _t475;                       // _t475
    _unknown_ _t483;                       // _t483
    _unknown_ _t484;                       // _t484
    _unknown_ _t485;                       // _t485
    _unknown_ _t486;                       // _t486
    _unknown_ _t487;                       // _t487
    _unknown_ _t488;                       // _t488
    _unknown_ _t489;                       // _t489
    _unknown_ _t490;                       // _t490
    _unknown_ _t493;                       // _t493
    _unknown_ _t494;                       // _t494
    _unknown_ _t496;                       // _t496
    _unknown_ _t498;                       // _t498
    _unknown_ _t501;                       // _t501
    _unknown_ _t502;                       // _t502
    _unknown_ _t503;                       // _t503
    _unknown_ _t504;                       // _t504
    _unknown_ _t505;                       // _t505
    _unknown_ _t506;                       // _t506
    _unknown_ _t507;                       // _t507
    _unknown_ _t509;                       // _t509
    _unknown_ _t510;                       // _t510
    _unknown_ _t511;                       // _t511
    _unknown_ _t513;                       // _t513
    _unknown_ _t515;                       // _t515
    _unknown_ _t519;                       // _t519


}

camlArray__init_1037(
    intOrPtr __eax,                        // r0
    intOrPtr* __ebx,                       // r1
    intOrPtr* __esp                        // r7
)
{// addr = 0x080513E0
    signed int _v12;                       // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr* _v20;                        // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _t14;                         // _t14
    _unknown_ _t15;                        // _t15
    intOrPtr _t19;                         // _t19
    _unknown_ _t20;                        // _t20
    signed int _t21;                       // _t21
    intOrPtr* _t25;                        // _t25
    signed int _t32;                       // _t32
    signed int _t33;                       // _t33

    __esp = __esp;
    _t25 = __ebx;
    _t14 = __eax;
    if(_t14 != 1) {
        _v20 = _t25;
         *__esp = _t14;
         *((intOrPtr*)( *_t25))();
        caml_c_call(_v24, 1);
        _t26 = caml_make_vect;
        _t32 = 3;
        _t19 =  *__esp + -2;
        if(_t32 <= _t19) {
            _v16 = _t19;
            _v12 = _t32;
             *__esp = caml_make_vect;
            while(1) {
                _t21 = _t32;
                 *((intOrPtr*)( *_v20))();
                _t26 =  *__esp;
                if(( *(_t26 - 4) & 255) == 254) {
                    asm("fld qword [eax]");
                    _t33 = _v12;
                    asm("fstp qword [ebx+esi*4-0x4]");
                } else {
                    _push(_t21);
                    _t33 = _v12;
                    _push(_t26 + _t33 * 2 - 2);
                    caml_modify(_t26);
                    __esp = __esp + 8;
                }
                _t32 = _t33 + 2;
                _v12 = _t32;
                if(_t33 == _v16) {
                    break;
                }
            }
        }
        return;
L9:
    }
    return  &camlArray__34;
    goto L9;
}

camlArray__make_matrix_1042(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __ecx,                        // r2
    intOrPtr* __esp                        // r7
)
{// addr = 0x080514A0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    intOrPtr _t13;                         // _t13
    intOrPtr _t16;                         // _t16
    _unknown_ _t26;                        // _t26
    signed int _t28;                       // _t28

    __esp = __esp;
    _t13 = __eax;
     *__esp = _t13;
    _v12 = __ebx;
    _v16 = __ecx;
    caml_c_call(_t13,  &camlArray__33);
    _t24 = caml_make_vect;
    _t16 =  *__esp + -2;
    if(1 <= _t16) {
        _v4 = _t16;
         *__esp = 1;
        _v8 = caml_make_vect;
        while(1) {
            caml_c_call(_v12, _v16);
            _push(caml_make_vect);
            _t28 = _v20;
            _t24 = _v8;
            _push(_t24 + _t28 * 2 - 2);
            caml_modify(_t24);
            __esp = __esp + 8;
             *__esp = _t28 + 2;
            if(_t28 == _v4) {
                break;
            }
        }
    }
    return _t24;
}

camlArray__copy_1049(
    intOrPtr* __eax                        // r0
)
{// addr = 0x08051520
    intOrPtr* _v12;                        // _cfa_fffffff4
    intOrPtr _t22;                         // _t22
    intOrPtr _t23;                         // _t23
    intOrPtr _t28;                         // _t28
    intOrPtr* _t33;                        // _t33
    signed int _t34;                       // _t34
    unsigned int _t35;                     // _t35
    signed int _t36;                       // _t36
    signed int _t37;                       // _t37
    intOrPtr _t38;                         // _t38
    _unknown_ _t40;                        // _t40

    _t33 = __eax;
    _t35 =  *(_t33 - 4);
    if((_t35 & 255) == 254) {
        _t36 = _t35 >> 10;
    } else {
        _t36 = _t35 >> 9;
    }
    _t37 = _t36 | 1;
    if(_t37 != 1) {
         *__esp = _t37;
        _v12 = _t33;
        if(( *(_t33 - 4) & 255) == 254) {
            while(1) {
                _t22 = caml_young_ptr - 12;
                caml_young_ptr = _t22;
                if(_t22 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t23 = _t22 + 4;
             *((intOrPtr*)(_t23 - 4)) = 2301;
            asm("fld qword [ebx]");
            asm("fstp qword [eax]");
L9:
            caml_c_call(_t37, _t23);
            __esi = caml_make_vect;
            _t34 = 3;
            _t40 =  *__esp + -2;
            if(_t34 <= _t40) {
                goto L10;
                do {
L10:
                    _t38 = _v12;
                    if(( *(_t38 - 4) & 255) == 254) {
                        while(1) {
                            _t28 = caml_young_ptr - 12;
                            caml_young_ptr = _t28;
                            if(_t28 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                        __edx = _t28 + 4;
                         *((intOrPtr*)(__edx - 4)) = 2301;
                        asm("fld qword [ecx+ebx*4-0x4]");
                        asm("fstp qword [edx]");
                        goto L14;
                    }
                    __edx =  *((intOrPtr*)(_t38 + _t34 * 2 - 2));
L14:
                    if(( *(__esi - 4) & 255) == 254) {
                        asm("fld qword [edx]");
                        asm("fstp qword [esi+ebx*4-0x4]");
                    } else {
                        caml_modify(_t34, __esi + _t34 * 2 - 2, __edx);
                    }
                    _t34 = _t34 + 2;
                } while(_t34 != _t40);
            }
            return __esi;
L21:
        }
        _t23 =  *_t33;
        goto L9;
    }
    return  &camlArray__32;
    goto L21;
}

camlArray__append_1054(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx,                       // r1
    signed int* __esp                      // r7
)
{// addr = 0x08051650
    intOrPtr* _v12;                        // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    intOrPtr* _v20;                        // _cfa_ffffffec
    intOrPtr* _t40;                        // _t40
    intOrPtr _t42;                         // _t42
    signed int _t46;                       // _t46
    intOrPtr _t50;                         // _t50
    intOrPtr _t57;                         // _t57
    intOrPtr* _t62;                        // _t62
    signed int _t63;                       // _t63
    signed int _t64;                       // _t64
    unsigned int _t67;                     // _t67
    signed int _t68;                       // _t68
    signed int _t69;                       // _t69
    intOrPtr _t70;                         // _t70
    signed int _t71;                       // _t71
    intOrPtr _t73;                         // _t73
    unsigned int _t74;                     // _t74
    signed int _t75;                       // _t75
    signed int _t76;                       // _t76
    _unknown_ _t80;                        // _t80
    intOrPtr _t85;                         // _t85

    __esp = __esp;
    _t62 = __ebx;
    _t40 = __eax;
    _t74 =  *(_t40 - 4);
    if((_t74 & 255) == 254) {
        _t75 = _t74 >> 10;
    } else {
        _t75 = _t74 >> 9;
    }
    _t76 = _t75 | 1;
    _t67 =  *(_t62 - 4);
    if((_t67 & 255) == 254) {
        _t68 = _t67 >> 10;
    } else {
        _t68 = _t67 >> 9;
    }
    _t69 = _t68 | 1;
    if(_t76 != 1) {
         *__esp = _t69;
        _v16 = _t76;
        _v20 = _t62;
        _v12 = _t40;
L11:
        if(_t76 > 1) {
            _t62 = _t40;
        }
        if(( *(_t62 - 4) & 255) == 254) {
            while(1) {
                _t42 = caml_young_ptr - 12;
                caml_young_ptr = _t42;
                if(_t42 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t84 = _t42 + 4;
             *((intOrPtr*)(_t42 + 4 - 4)) = 2301;
            asm("fld qword [ebx]");
            asm("fstp qword [esi]");
L17:
            caml_c_call(_t76 + _t69 - 1, _t84);
            _t85 = caml_make_vect;
            _t63 = 1;
            _t80 = _v16 + -2;
            if(_t63 <= _t80) {
                goto L18;
                do {
L18:
                    _t73 = _v12;
                    if(( *(_t73 - 4) & 255) == 254) {
                        while(1) {
                            _t57 = caml_young_ptr - 12;
                            caml_young_ptr = _t57;
                            if(_t57 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                        _t78 = _t57 + 4;
                         *((intOrPtr*)(_t57 + 4 - 4)) = 2301;
                        asm("fld qword [ecx+ebx*4-0x4]");
                        asm("fstp qword [edx]");
                        goto L22;
                    }
                    _t78 =  *((intOrPtr*)(_t73 + _t63 * 2 - 2));
L22:
                    if(( *(_t85 - 4) & 255) == 254) {
                        asm("fld qword [edx]");
                        asm("fstp qword [esi+ebx*4-0x4]");
                    } else {
                        caml_modify(_t63, _t85 + _t63 * 2 - 2, _t78);
                    }
                    _t63 = _t63 + 2;
                } while(_t63 != _t80);
            }
            _t64 = 1;
            _t46 =  *__esp + -2;
            if(_t64 > _t46) {
            } else {
                 *__esp = _t46;
                goto L28;
                do {
L28:
                    _t70 = _v20;
                    if(( *(_t70 - 4) & 255) == 254) {
                        while(1) {
                            _t50 = caml_young_ptr - 12;
                            caml_young_ptr = _t50;
                            if(_t50 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                        _t77 = _t50 + 4;
                         *((intOrPtr*)(_t50 + 4 - 4)) = 2301;
                        asm("fld qword [ecx+ebx*4-0x4]");
                        asm("fstp qword [edx]");
                        goto L32;
                    }
                    _t77 =  *((intOrPtr*)(_t70 + _t64 * 2 - 2));
L32:
                    _t71 = _t64 + _v16 - 1;
                    if(( *(_t85 - 4) & 255) == 254) {
                        asm("fld qword [edx]");
                        asm("fstp qword [esi+ecx*4-0x4]");
                    } else {
                        caml_modify(_t64, _t85 + _t71 * 2 - 2, _t77);
                    }
                    _t64 = _t64 + 2;
                } while(_t64 !=  *__esp);
            }
            goto L36;
L40:
L36:
            return _t85;
            goto L40;
        }
        _t84 =  *_t62;
        goto L17;
    }
    if(_t69 != 1) {
         *__esp = _t69;
        _v16 = _t76;
        _v20 = _t62;
        _v12 = _t40;
        goto L11;
    }
    return  &camlArray__31;
    goto L40;
}

camlArray__concat_aux_1062(
    intOrPtr __eax,                        // r0
    intOrPtr* __esp                        // r7
)
{// addr = 0x08051890
    intOrPtr* _v4;                         // _cfa_fffffffc
    _unknown_ _t9;                         // _t9
    _unknown_ _t10;                        // _t10
    intOrPtr _t14;                         // _t14
    _unknown_ _t15;                        // _t15
    _unknown_ _t16;                        // _t16
    intOrPtr* _t18;                        // _t18
    intOrPtr _t20;                         // _t20

    __esp = __esp;
     *__esp = __eax;
    _v4 = _t18;
    caml_c_call(camlArray__size_1065(1, _t18),  *__esp);
    _t20 = caml_make_vect;
     *__esp = caml_make_vect;
    while(1) {
        _t14 = caml_young_ptr - 20;
        caml_young_ptr = _t14;
        if(_t14 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    __ecx = _t14 + 4;
     *((intOrPtr*)(__ecx - 4)) = 4343;
     *__ecx = caml_curry2;
     *((intOrPtr*)(__ecx + 4)) = 5;
     *((intOrPtr*)(__ecx + 8)) = camlArray__fill_1070;
     *((intOrPtr*)(__ecx + 12)) = _t20;
    camlArray__fill_1070(1, _v4, __ecx, __esp);
    return  *__esp;
}

camlArray__concat_1075(
    intOrPtr* __esp                        // r7
)
{// addr = 0x08051920
    intOrPtr* _v4;                         // _cfa_fffffffc
    intOrPtr* _t13;                        // _t13
    intOrPtr _t17;                         // _t17
    intOrPtr _t18;                         // _t18
    _unknown_ _t19;                        // _t19
    _unknown_ _t20;                        // _t20
    intOrPtr _t24;                         // _t24
    _unknown_ _t25;                        // _t25
    _unknown_ _t26;                        // _t26
    intOrPtr _t27;                         // _t27
    _unknown_ _t28;                        // _t28
    intOrPtr* _t29;                        // _t29
    intOrPtr _t31;                         // _t31
    intOrPtr* _t33;                        // _t33
    intOrPtr* _t34;                        // _t34
    unsigned int _t35;                     // _t35
    signed int _t36;                       // _t36

    __esp = __esp;
    __esp = __esp - 8;
    while(1) {
        _t29 = _t13;
        if(_t29 == 1) {
            break;
        }
        _t13 =  *((intOrPtr*)(_t29 + 4));
        _t33 =  *_t29;
        _t35 =  *(_t33 - 4);
        if((_t35 & 255) == 254) {
            _t36 = _t35 >> 10;
        } else {
            _t36 = _t35 >> 9;
        }
        if((_t36 | 1) <= 1) {
            continue;
        }
        if(( *(_t33 - 4) & 255) == 254) {
            while(1) {
                _t17 = caml_young_ptr - 12;
                caml_young_ptr = _t17;
                if(_t17 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t18 = _t17 + 4;
             *((intOrPtr*)(_t18 - 4)) = 2301;
            asm("fld qword [ecx]");
            asm("fstp qword [eax]");
L11:
            __esp = __esp + 8;
            __esp = __esp - 8;
             *__esp = _t18;
            _v4 = _t29;
            caml_c_call(camlArray__size_1065(1, _t29),  *__esp);
            _t31 = caml_make_vect;
             *__esp = caml_make_vect;
            while(1) {
                _t24 = caml_young_ptr - 20;
                caml_young_ptr = _t24;
                if(_t24 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t34 = _t24 + 4;
             *((intOrPtr*)(_t34 - 4)) = 4343;
             *_t34 = caml_curry2;
             *((intOrPtr*)(_t34 + 4)) = 5;
             *((intOrPtr*)(_t34 + 8)) = camlArray__fill_1070;
             *((intOrPtr*)(_t34 + 12)) = _t31;
            camlArray__fill_1070(1, _v4, _t34, __esp);
            _t27 =  *__esp;
            __esp = __esp + 8;
            return _t27;
L19:
        }
        _t18 =  *_t33;
        goto L11;
    }
    __esp = __esp + 8;
    return  &camlArray__36;
    goto L19;
}

camlArray__sub_1081(
    signed int __eax,                      // r0
    _unknown_ __ebx,                       // r1
    signed int __ecx                       // r2
)
{// addr = 0x08051930
    signed int _v12;                       // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _t31;                       // _t31
    intOrPtr* _t32;                        // _t32
    _unknown_ _t33;                        // _t33
    char* _t35;                            // _t35

    __ecx = __ecx;
    __edx = __eax;
    if(__ebx < 1 || __ecx < 1) {
L27:
        __esp =  &((__esp)[6]);
        _t35 = "Array.sub";
        while(1) {
            _t31 = caml_young_ptr - 12;
            caml_young_ptr = _t31;
            if(_t31 >= caml_young_limit) {
                _t32 = _t31 + 4;
                 *((intOrPtr*)(_t32 - 4)) = 2048;
                 *_t32 =  &caml_exn_Invalid_argument;
                 *((intOrPtr*)(_t32 + 4)) = _t35;
                caml_raise_exn(_t32);
            }
            caml_call_gc(__esp);
        }
    }
    __esi =  *(__edx - 4);
    __esi = __esi & 255;
    if((__esi & 255) == 254) {
        __eax = __esi;
        __eax = __esi >> 10;
    } else {
        __eax = __esi;
        __eax = __esi >> 9;
    }
    __eax = __eax | 1;
    __eax = __eax - __ecx;
    __eax = __eax + 1;
    if(__ebx > __eax) {
        goto L27;
    }
    if(__ecx != 1) {
         *__esp = __ecx;
        _v20 = __ebx;
        _v16 = __edx;
        __eax =  *(__edx - 4) & 255;
        if(( *(__edx - 4) & 255) == 254) {
            while(1) {
L14:
                __eax = caml_young_ptr;
                __eax = caml_young_ptr - 12;
                caml_young_ptr = __eax;
                if(__eax >= caml_young_limit) {
                    break;
                }
                goto L29;
            }
            __eax = __eax + 4;
             *((intOrPtr*)(__eax - 4)) = 2301;
            asm("fld qword [edx+ebx*4-0x4]");
            asm("fstp qword [eax]");
L16:
            _push(__eax);
            _push(__ecx);
            __eax = caml_make_vect;
            caml_c_call();
            __esp =  &((__esp)[2]);
            __esi = caml_make_vect;
            __ebx = 3;
            __eax =  *__esp;
            __eax =  *__esp + -2;
            if(__ebx <= __eax) {
                _v12 = __eax;
                 *__esp = caml_make_vect;
                goto L18;
                do {
L18:
                    __eax = _v20;
                    __edx = _v20 + __ebx - 1;
                    __ecx = _v16;
                    __eax =  *(__ecx - 4) & 255;
                    if(( *(__ecx - 4) & 255) == 254) {
                        while(1) {
                            __eax = caml_young_ptr;
                            __eax = caml_young_ptr - 12;
                            caml_young_ptr = __eax;
                            if(__eax >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                        __eax = __eax + 4;
                         *((intOrPtr*)(__eax - 4)) = 2301;
                        asm("fld qword [ecx+edx*4-0x4]");
                        asm("fstp qword [eax]");
                        __ecx = __eax;
                        goto L22;
                    }
                    __ecx =  *(__ecx + __edx * 2 - 2);
L22:
                    __esi =  *__esp;
                    __eax =  *(__esi - 4) & 255;
                    if(( *(__esi - 4) & 255) == 254) {
                        asm("fld qword [ecx]");
                        asm("fstp qword [esi+ebx*4-0x4]");
                    } else {
                        _push(__ecx);
                        __eax = __esi + __ebx * 2 - 2;
                        _push(__esi + __ebx * 2 - 2);
                        caml_modify(__ebx);
                        __esp =  &((__esp)[2]);
                    }
                    __ecx = __ebx;
                    __ebx = __ebx + 2;
                    __ebx = __ebx + 2;
                    __eax = _v12;
                } while(__ecx != _v12);
            }
            __eax = __esi;
            return __esi;
L30:
        }
        __eax =  *(__edx + __ebx * 2 - 2);
        goto L16;
    }
    __eax =  ?_? ( &camlArray__28);
    return  &camlArray__28;
    goto L30;
L29:
    caml_call_gc(__esp);
    goto L14;
}

camlArray__fill_1087(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    signed int __ecx,                      // r2
    unsigned int __edx                     // r3
)
{// addr = 0x08051AE0
    intOrPtr _t13;                         // _t13
    intOrPtr* _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    char* _t17;                            // _t17

    __edx = __edx;
    __ecx = __ecx;
    __esi = __eax;
    __edi = __edx;
    if(__ebx < 1 || __ecx < 1) {
L16:
        __esp = __esp + 8;
        _t17 = "Array.fill";
        while(1) {
            _t13 = caml_young_ptr - 12;
            caml_young_ptr = _t13;
            if(_t13 >= caml_young_limit) {
                _t14 = _t13 + 4;
                 *((intOrPtr*)(_t14 - 4)) = 2048;
                 *_t14 =  &caml_exn_Invalid_argument;
                 *((intOrPtr*)(_t14 + 4)) = _t17;
                caml_raise_exn(_t14);
            }
            caml_call_gc(__esp);
        }
    } else {
        __edx =  *(__esi - 4);
        __edx = __edx & 255;
        if((__edx & 255) == 254) {
            __eax = __edx;
            __eax = __edx >> 10;
        } else {
            __eax = __edx;
            __eax = __edx >> 9;
        }
        __eax = __eax | 1;
        __eax = __eax - __ecx;
        __eax = __eax + 1;
        if(__ebx > __eax) {
            goto L16;
        }
        __ebp = __ebx;
        __ebx = __ebx + __ecx - 3;
        if(__ebp > __ebx) {
L15:
            __eax = 1;
            return 1;
        } else {
            goto L11;
        }
        while(1) {
L11:
            __eax =  *(__esi - 4) & 255;
            if(( *(__esi - 4) & 255) == 254) {
                asm("fld qword [edi]");
                asm("fstp qword [esi+ebp*4-0x4]");
            } else {
                _push(__edi);
                __eax = __esi + __ebp * 2 - 2;
                _push(__esi + __ebp * 2 - 2);
                caml_modify(__ebx);
                __esp = __esp + 8;
            }
            __ecx = __ebp;
            __ebp = __ebp + 2;
            __ebp = __ebp + 2;
            if(__ecx == __ebx) {
                break;
            }
        }
        goto L15;
    }
}

camlArray__blit_1093(
    signed int __eax,                      // r0
    _unknown_ __ebx,                       // r1
    signed int __ecx,                      // r2
    signed int __edx,                      // r3
    signed int __esi,                      // r5
    signed int* __esp                      // r7
)
{// addr = 0x08051B80
    signed int _v12;                       // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _t55;                       // _t55
    intOrPtr* _t56;                        // _t56
    _unknown_ _t57;                        // _t57
    _unknown_ _t58;                        // _t58
    char* _t59;                            // _t59

    __esp = __esp;
    __esi = __esi;
    __edx = __edx;
    __ecx = __ecx;
    __edi = __eax;
    _v16 = __ecx;
    __ebp = __edx;
    if(__esi < 1 || __ebx < 1) {
L38:
        __esp =  &((__esp)[6]);
        _t59 = "Array.blit";
        while(1) {
            _t55 = caml_young_ptr - 12;
            caml_young_ptr = _t55;
            if(_t55 >= caml_young_limit) {
                _t56 = _t55 + 4;
                 *((intOrPtr*)(_t56 - 4)) = 2048;
                 *_t56 =  &caml_exn_Invalid_argument;
                 *((intOrPtr*)(_t56 + 4)) = _t59;
                caml_raise_exn(_t56);
            }
            goto L4;
        }
    }
    __ecx =  *(__edi - 4);
    __ecx = __ecx & 255;
    if((__ecx & 255) == 254) {
        __eax = __ecx;
        __eax = __ecx >> 10;
    } else {
        __eax = __ecx;
        __eax = __ecx >> 9;
    }
    __eax = __eax | 1;
    __eax = __eax - __esi;
    __eax = __eax + 1;
    if(__ebx > __eax || __ebp < 1) {
        goto L38;
    }
    __eax = _v16;
    __ecx =  *(_v16 - 4);
    __ecx = __ecx & 255;
    if((__ecx & 255) == 254) {
        __eax = __ecx;
        __eax = __ecx >> 10;
    } else {
        __eax = __ecx;
        __eax = __ecx >> 9;
    }
    __eax = __eax | 1;
    __eax = __eax - __esi;
    __eax = __eax + 1;
    if(__ebp > __eax) {
        goto L38;
    }
    if(__ebx >= __ebp) {
        __eax = 1;
        _v12 = 1;
        __esi = __esi + -2;
        if(_v12 > __esi) {
        } else {
            _v20 = __ebx;
             *__esp = __edi;
            goto L29;
            do {
L29:
                __ebx = _v20;
                __eax = _v12;
                __ebx = _v20 + _v12 - 1;
                __eax =  *__esp;
                __ecx =  *(__eax - 4) & 255;
                if(( *(__eax - 4) & 255) == 254) {
                    while(1) {
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 12;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                    __ecx = __eax + 4;
                     *(__ecx - 4) = 2301;
                    __eax =  *__esp;
                    asm("fld qword [eax+ebx*4-0x4]");
                    asm("fstp qword [ecx]");
                    __ebx = __ecx;
                    goto L33;
                }
                __ebx =  *(__eax + __ebx * 2 - 2);
L33:
                __ecx = _v12;
                __eax = __ebp;
                __eax = __ebp + _v12 - 1;
                _v16 =  *(_v16 - 4) & 255;
                if(( *(_v16 - 4) & 255) == 254) {
                    asm("fld qword [ebx]");
                    __ebx = _v16;
                    asm("fstp qword [ebx+eax*4-0x4]");
                } else {
                    _push(__ebx);
                    __ebx = _v16;
                    _push(__eax);
                    caml_modify(__ebx);
                    __esp =  &((__esp)[2]);
                }
                __ebx = _v12;
                _v12 = _v12 + 2;
                _v12 = _v12 + 2;
            } while(_v12 != __esi);
        }
    } else {
        __esi = __esi + -2;
        if(__esi >= 1) {
            _v20 = __ebx;
            goto L18;
            do {
L18:
                __eax = _v20;
                __ebx = _v20 + __esi - 1;
                __eax =  *(__edi - 4) & 255;
                if(( *(__edi - 4) & 255) == 254) {
                    while(1) {
L20:
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 12;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        goto L40;
                    }
                    __eax = __eax + 4;
                     *(__eax - 4) = 2301;
                    asm("fld qword [edi+ebx*4-0x4]");
                    asm("fstp qword [eax]");
                    __ebx = __eax;
                    goto L22;
                }
                __ebx =  *(__edi + __ebx * 2 - 2);
L22:
                __eax = __ebp;
                __eax = __ebp + __esi - 1;
                _v16 =  *(_v16 - 4) & 255;
                if(( *(_v16 - 4) & 255) == 254) {
                    asm("fld qword [ebx]");
                    __ebx = _v16;
                    asm("fstp qword [ebx+eax*4-0x4]");
                } else {
                    _push(__ebx);
                    __ebx = _v16;
                    _push(__eax);
                    caml_modify(__ebx);
                    __esp =  &((__esp)[2]);
                }
                __ebx = __esi;
                __esi = __esi - 2;
                __esi = __esi - 2;
            } while(__ebx != 1);
        }
        __eax = 1;
        return 1;
L41:
    }
    __eax = 1;
    return 1;
    goto L41;
L40:
    caml_call_gc(__esp);
    goto L20;
}

camlArray__iter_1101(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x08051DE0
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr* _v20;                        // _cfa_ffffffec
    intOrPtr* _t15;                        // _t15
    _unknown_ _t16;                        // _t16
    intOrPtr _t19;                         // _t19
    _unknown_ _t22;                        // _t22
    intOrPtr _t23;                         // _t23
    intOrPtr _t29;                         // _t29
    unsigned int _t30;                     // _t30
    signed int _t31;                       // _t31
    intOrPtr _t33;                         // _t33

    _t23 = __ebx;
    _t15 = __eax;
    _t27 = 1;
    _t30 =  *(_t23 - 4);
    if((_t30 & 255) == 254) {
        _t31 = _t30 >> 10;
    } else {
        _t31 = _t30 >> 9;
    }
    _t33 = (_t31 | 1) + -2;
    if(_t27 <= _t33) {
        _v12 = _t33;
        _v16 = _t27;
         *__esp = _t23;
        _v20 = _t15;
        goto L5;
        do {
L5:
            if(( *( *__esp - 4) & 255) == 254) {
                while(1) {
                    _t19 = caml_young_ptr - 12;
                    caml_young_ptr = _t19;
                    if(_t19 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                 *((intOrPtr*)(_t19 + 4 - 4)) = 2301;
                asm("fld qword [ebx+ecx*4-0x4]");
                asm("fstp qword [eax]");
                goto L9;
            }
L9:
             *((intOrPtr*)( *_v20))();
            _t29 = _v16;
            _t27 = _t29 + 2;
            _v16 = _t29 + 2;
        } while(_t29 != _v12);
    }
    return;
}

camlArray__map_1105(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx                        // r1
)
{// addr = 0x08051E90
    signed int _v12;                       // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr* _v20;                        // _cfa_ffffffec
    intOrPtr* _v24;                        // _cfa_ffffffe8
    intOrPtr _v28;                         // _cfa_ffffffe4
    unsigned int _t27;                     // _t27
    signed int _t28;                       // _t28
    signed int _t29;                       // _t29
    intOrPtr _t32;                         // _t32
    intOrPtr _t33;                         // _t33
    intOrPtr _t37;                         // _t37
    _unknown_ _t38;                        // _t38
    intOrPtr _t41;                         // _t41
    intOrPtr _t42;                         // _t42
    intOrPtr* _t46;                        // _t46
    _unknown_ _t47;                        // _t47
    signed int _t48;                       // _t48
    signed int _t51;                       // _t51
    intOrPtr* _t52;                        // _t52
    intOrPtr _t53;                         // _t53

    _t46 = __ebx;
    _t52 = __eax;
    _t27 =  *(_t46 - 4);
    if((_t27 & 255) == 254) {
        _t28 = _t27 >> 10;
    } else {
        _t28 = _t27 >> 9;
    }
    _t29 = _t28 | 1;
    if(_t29 != 1) {
         *__esp = _t29;
        _v24 = _t46;
        _v20 = _t52;
        if(( *(_t46 - 4) & 255) == 254) {
            while(1) {
                _t32 = caml_young_ptr - 12;
                caml_young_ptr = _t32;
                if(_t32 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t33 = _t32 + 4;
             *((intOrPtr*)(_t33 - 4)) = 2301;
            asm("fld qword [ebx]");
            asm("fstp qword [eax]");
L9:
             *((intOrPtr*)( *_t52))();
            caml_c_call(_v28, _t33);
            __esi = caml_make_vect;
            _t48 = 3;
            _t37 =  *__esp + -2;
            if(_t48 <= _t37) {
                _v16 = _t37;
                _v12 = _t48;
                 *__esp = caml_make_vect;
                goto L11;
                do {
L11:
                    _t53 = _v24;
                    if(( *(_t53 - 4) & 255) == 254) {
                        while(1) {
                            _t41 = caml_young_ptr - 12;
                            caml_young_ptr = _t41;
                            if(_t41 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                        _t42 = _t41 + 4;
                         *((intOrPtr*)(_t42 - 4)) = 2301;
                        asm("fld qword [ecx+ebx*4-0x4]");
                        asm("fstp qword [eax]");
                        goto L15;
                    }
                    _t42 =  *((intOrPtr*)(_t53 + _t48 * 2 - 2));
L15:
                     *((intOrPtr*)( *_v20))();
                    __esi =  *__esp;
                    if(( *(__esi - 4) & 255) == 254) {
                        asm("fld qword [eax]");
                        _t51 = _v12;
                        asm("fstp qword [esi+ebx*4-0x4]");
                    } else {
                        _push(_t42);
                        _t51 = _v12;
                        _push(__esi + _t51 * 2 - 2);
                        caml_modify(_t51);
                        __esp =  &((__esp)[2]);
                    }
                    _t48 = _t51 + 2;
                    _v12 = _t48;
                } while(_t51 != _v16);
            }
            return;
L22:
        }
        _t33 =  *_t46;
        goto L9;
    }
    return  &camlArray__24;
    goto L22;
}

camlArray__iteri_1111(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x08052000
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _t15;                         // _t15
    _unknown_ _t16;                        // _t16
    intOrPtr _t19;                         // _t19
    _unknown_ _t20;                        // _t20
    intOrPtr _t22;                         // _t22
    _unknown_ _t25;                        // _t25
    _unknown_ _t27;                        // _t27
    intOrPtr _t28;                         // _t28
    unsigned int _t29;                     // _t29
    signed int _t30;                       // _t30
    intOrPtr _t32;                         // _t32

    _t22 = __ebx;
    _t15 = __eax;
    _t26 = 1;
    _t29 =  *(_t22 - 4);
    if((_t29 & 255) == 254) {
        _t30 = _t29 >> 10;
    } else {
        _t30 = _t29 >> 9;
    }
    _t32 = (_t30 | 1) + -2;
    if(_t26 <= _t32) {
        _v12 = _t32;
        _v16 = _t26;
         *__esp = _t22;
        _v20 = _t15;
        goto L5;
        do {
L5:
            if(( *( *__esp - 4) & 255) == 254) {
                while(1) {
                    _t19 = caml_young_ptr - 12;
                    caml_young_ptr = _t19;
                    if(_t19 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                 *((intOrPtr*)(_t19 + 4 - 4)) = 2301;
                asm("fld qword [edx+ecx*4-0x4]");
                asm("fstp qword [ebx]");
                goto L9;
            }
L9:
            caml_apply2();
            _t28 = _v16;
            _t26 = _t28 + 2;
            _v16 = _t28 + 2;
        } while(_t28 != _v12);
    }
    return 1;
}

camlArray__mapi_1115(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x080520B0
    signed int _v12;                       // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _v28;                         // _cfa_ffffffe4
    unsigned int _t27;                     // _t27
    signed int _t28;                       // _t28
    signed int _t29;                       // _t29
    intOrPtr _t32;                         // _t32
    _unknown_ _t33;                        // _t33
    intOrPtr _t37;                         // _t37
    intOrPtr _t41;                         // _t41
    signed int _t42;                       // _t42
    intOrPtr _t46;                         // _t46
    _unknown_ _t47;                        // _t47
    _unknown_ _t50;                        // _t50
    _unknown_ _t51;                        // _t51
    intOrPtr _t52;                         // _t52
    _unknown_ _t54;                        // _t54
    signed int _t60;                       // _t60
    signed int _t61;                       // _t61

    _t46 = __ebx;
    _t52 = __eax;
    _t27 =  *(_t46 - 4);
    if((_t27 & 255) == 254) {
        _t28 = _t27 >> 10;
    } else {
        _t28 = _t27 >> 9;
    }
    _t29 = _t28 | 1;
    if(_t29 != 1) {
         *__esp = _t29;
        _v24 = _t46;
        _v20 = _t52;
        if(( *(_t46 - 4) & 255) == 254) {
            while(1) {
                _t32 = caml_young_ptr - 12;
                caml_young_ptr = _t32;
                if(_t32 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
             *((intOrPtr*)(_t32 + 4 - 4)) = 2301;
            asm("fld qword [ebx]");
            asm("fstp qword [edx]");
L9:
            caml_apply2();
            caml_c_call(_v28, 1);
            _t48 = caml_make_vect;
            _t60 = 3;
            _t37 =  *__esp + -2;
            if(_t60 <= _t37) {
                _v16 = _t37;
                _v12 = _t60;
                 *__esp = caml_make_vect;
                goto L11;
                do {
L11:
                    if(( *(_v24 - 4) & 255) == 254) {
                        while(1) {
                            _t41 = caml_young_ptr - 12;
                            caml_young_ptr = _t41;
                            if(_t41 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                         *((intOrPtr*)(_t41 + 4 - 4)) = 2301;
                        asm("fld qword [ecx+esi*4-0x4]");
                        asm("fstp qword [ebx]");
                        goto L15;
                    }
L15:
                    _t42 = _t60;
                    caml_apply2();
                    _t48 =  *__esp;
                    if(( *(_t48 - 4) & 255) == 254) {
                        asm("fld qword [eax]");
                        _t61 = _v12;
                        asm("fstp qword [ebx+esi*4-0x4]");
                    } else {
                        _push(_t42);
                        _t61 = _v12;
                        _push(_t48 + _t61 * 2 - 2);
                        caml_modify(_t48);
                        __esp =  &((__esp)[2]);
                    }
                    _t60 = _t61 + 2;
                    _v12 = _t60;
                } while(_t61 != _v16);
            }
            return _t48;
L22:
        }
        goto L9;
    }
    return  &camlArray__23;
    goto L22;
}

camlArray__to_list_1121(
    signed int __eax                       // r0
)
{// addr = 0x08052230
    signed int _t17;                       // _t17
    unsigned int _t20;                     // _t20
    unsigned int _t22;                     // _t22
    signed int _t25;                       // _t25
    signed int _t26;                       // _t26

    _t17 = __eax;
    __ebx = _t17;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 20;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    __ecx = __eax + 4;
     *((intOrPtr*)(__ecx - 4)) = 4343;
     *__ecx = caml_curry2;
     *((intOrPtr*)(__ecx + 4)) = 5;
     *((intOrPtr*)(__ecx + 8)) = camlArray__tolist_1123;
     *(__ecx + 12) = __ebx;
    __eax =  *(__ebx - 4);
    __eax = __eax & 255;
    if((__eax & 255) == 254) {
        __eax = __eax >> 10;
    } else {
        __eax = __eax >> 9;
    }
    __eax = __eax + -2;
    __ebx = 1;
    __esp = __esp - 8;
    while(1) {
        __edx = _t17;
        if(__edx < 1) {
            break;
        }
        _t25 =  *(__ecx + 12);
        if(( *(_t25 - 4) & 255) == 254) {
            while(1) {
                _t20 = caml_young_ptr - 12;
                caml_young_ptr = _t20;
                if(_t20 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            goto L7;
        }
        __edi =  *((intOrPtr*)(_t25 + __edx * 2 - 2));
        while(1) {
L8:
            _t22 = caml_young_ptr - 12;
            caml_young_ptr = _t22;
            if(_t22 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t26 = _t22 + 4;
         *((intOrPtr*)(_t26 - 4)) = 2048;
         *_t26 = __edi;
         *(_t26 + 4) = __ebx;
        _t17 = __edx + -2;
        __ebx = _t26;
        continue;
L7:
        __edi = _t20 + 4;
         *((intOrPtr*)(__edi - 4)) = 2301;
        asm("fld qword [esi+edx*4-0x4]");
        asm("fstp qword [edi]");
        goto L8;
    }
    __esp = __esp + 8;
    return __ebx;
}

camlArray__list_length_1126(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx                        // r1
)
{// addr = 0x080522A0
    _unknown_ _t3;                         // _t3

L0:
    while(1) {
L0:
        __eax = __eax;
        if(__ebx == 1) {
            break;
        }
L1:
        __eax = __eax + 2;
    }
    return __eax;
}

camlArray__of_list_1130(
    signed int __eax,                      // r0
    intOrPtr* __esp                        // r7
)
{// addr = 0x080522C0
    intOrPtr _v4;                          // _cfa_fffffffc
    signed int _t16;                       // _t16
    signed int _t22;                       // _t22
    intOrPtr _t23;                         // _t23
    _unknown_ _t24;                        // _t24
    _unknown_ _t25;                        // _t25

    __esp = __esp;
    _t16 = __eax;
    _t22 = _t16;
    if(_t22 == 1) {
        return  &camlArray__22;
    } else {
        __eax =  *((intOrPtr*)(__ebx + 4));
        _v4 =  *((intOrPtr*)(__ebx + 4));
        __eax =  *__ebx;
         *__esp =  *__ebx;
        __eax = 1;
        __eax = camlArray__list_length_1126(1, __ebx);
        __ebx =  *__esp;
        _push( *__esp);
        _push(__eax);
        __eax = caml_make_vect;
        caml_c_call();
        __esp = __esp + 8;
        __ebx = caml_make_vect;
        while(1) {
            __eax = caml_young_ptr;
            __eax = caml_young_ptr - 20;
            caml_young_ptr = __eax;
            if(__eax >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        __ecx = __eax + 4;
         *((intOrPtr*)(__ecx - 4)) = 4343;
         *__ecx = caml_curry2;
         *((intOrPtr*)(__ecx + 4)) = 5;
         *((intOrPtr*)(__ecx + 8)) = camlArray__fill_1135;
         *((intOrPtr*)(__ecx + 12)) = __ebx;
        __eax = 3;
        __ebx = _v4;
        __esp = __esp + 8;
        __esp = __esp - 8;
        while(1) {
            __edi = _t16;
            __esi = _t24;
            if(_t22 == 1) {
                break;
            }
            __ebp =  *(_t22 + 4);
            _t25 =  *_t22;
            _t23 =  *((intOrPtr*)(__esi + 12));
            if(( *(_t23 - 4) & 255) == 254) {
                asm("fld qword [ecx]");
                asm("fstp qword [ebx+edi*4-0x4]");
            } else {
                caml_modify(_t23, _t23 + __edi * 2 - 2, _t25);
            }
            _t16 = __edi + 2;
            _t22 = __ebp;
            _t24 = __esi;
        }
        return  *((intOrPtr*)(__esi + 12));
    }
}

camlArray__fold_left_1139(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __ecx                         // r2
)
{// addr = 0x08052350
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    intOrPtr* _v20;                        // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _t21;                         // _t21
    unsigned int _t22;                     // _t22
    signed int _t23;                       // _t23
    intOrPtr _t25;                         // _t25
    intOrPtr _t29;                         // _t29
    intOrPtr _t32;                         // _t32
    intOrPtr _t37;                         // _t37
    intOrPtr _t38;                         // _t38
    _unknown_ _t39;                        // _t39
    signed int _t40;                       // _t40
    signed int _t41;                       // _t41

    _t37 = __ecx;
    _t32 = __ebx;
    __edi = __eax;
    while(1) {
        _t21 = caml_young_ptr - 8;
        caml_young_ptr = _t21;
        if(_t21 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    __esi = _t21 + 4;
     *((intOrPtr*)(__esi - 4)) = 1024;
     *__esi = _t32;
    _t40 = 1;
    _t22 =  *(_t37 - 4);
    if((_t22 & 255) == 254) {
        _t23 = _t22 >> 10;
    } else {
        _t23 = _t22 >> 9;
    }
    _t25 = (_t23 | 1) + -2;
    if(_t40 <= _t25) {
        _v12 = _t25;
        _v16 = _t40;
        _v20 = __esi;
         *__esp = _t37;
        _v24 = __edi;
        goto L7;
        do {
L7:
            _t38 =  *__esp;
            if(( *(_t38 - 4) & 255) == 254) {
                while(1) {
                    _t29 = caml_young_ptr - 12;
                    caml_young_ptr = _t29;
                    if(_t29 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                _t35 = _t29 + 4;
                 *((intOrPtr*)(_t29 + 4 - 4)) = 2301;
                asm("fld qword [ecx+edx*4-0x4]");
                asm("fstp qword [ebx]");
                goto L11;
            }
            _t35 =  *((intOrPtr*)(_t38 + _t40 * 2 - 2));
L11:
            caml_apply2();
            _push( *__esi);
            __esi = _v20;
            _push(_v20);
            caml_modify(_t35);
            __esp = __esp + 8;
            _t41 = _v16;
            _t40 = _t41 + 2;
            _v16 = _t40;
        } while(_t41 != _v12);
    }
    return  *__esi;
}

camlArray__fold_right_1145(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __ecx                         // r2
)
{// addr = 0x08052450
    signed int _v12;                       // _cfa_fffffff4
    intOrPtr* _v16;                        // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _t19;                         // _t19
    intOrPtr _t25;                         // _t25
    intOrPtr _t26;                         // _t26
    intOrPtr _t28;                         // _t28
    intOrPtr _t29;                         // _t29
    intOrPtr _t30;                         // _t30
    intOrPtr _t31;                         // _t31
    unsigned int _t32;                     // _t32
    signed int _t33;                       // _t33
    signed int _t35;                       // _t35
    _unknown_ _t36;                        // _t36
    signed int _t37;                       // _t37

    _t31 = __ecx;
    _t28 = __ebx;
    __edx = __eax;
    while(1) {
        _t19 = caml_young_ptr - 8;
        caml_young_ptr = _t19;
        if(_t19 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    __esi = _t19 + 4;
     *((intOrPtr*)(__esi - 4)) = 1024;
     *__esi = _t31;
    _t32 =  *(_t28 - 4);
    if((_t32 & 255) == 254) {
        _t33 = _t32 >> 10;
    } else {
        _t33 = _t32 >> 9;
    }
    _t35 = (_t33 | 1) + -2;
    if(_t35 >= 1) {
        _v12 = _t35;
        _v16 = __esi;
         *__esp = _t28;
        _v20 = __edx;
        goto L7;
        do {
L7:
            _t29 =  *__esp;
            if(( *(_t29 - 4) & 255) == 254) {
                while(1) {
                    _t25 = caml_young_ptr - 12;
                    caml_young_ptr = _t25;
                    if(_t25 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                _t26 = _t25 + 4;
                 *((intOrPtr*)(_t26 - 4)) = 2301;
                asm("fld qword [ebx+ecx*4-0x4]");
                asm("fstp qword [eax]");
                goto L11;
            }
            _t26 =  *((intOrPtr*)(_t29 + _t35 * 2 - 2));
L11:
            _t30 =  *__esi;
            caml_apply2();
            _push(_t26);
            __esi = _v16;
            _push(_v16);
            caml_modify(_t30);
            __esp = __esp + 8;
            _t37 = _v12;
            _t35 = _t37 - 2;
            _v12 = _t35;
        } while(_t37 != 1);
    }
    return  *__esi;
}

camlArray__sort_1152(
    signed int __edi                       // r4
)
{// addr = 0x08052540
    signed int _t382;                      // _t382
    signed int _t384;                      // _t384
    intOrPtr* _t385;                       // _t385
    _unknown_ _t386;                       // _t386
    unsigned int _t387;                    // _t387
    signed int _t388;                      // _t388

    __edi = __edi;
    __esp = __esp - 32;
    __ecx = _t382;
    (__esp)[4] = _t387;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 144;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    __esi = __eax + 4;
     *(__esi - 4) = 5367;
     *__esi = caml_curry2;
     *((intOrPtr*)(__esi + 4)) = 5;
     *((intOrPtr*)(__esi + 8)) = camlArray__maxson_1155;
     *(__esi + 12) = __ecx;
     *(__esi + 16) = __ebx;
    __edx = __esi + 24;
     *(__edx - 4) = 6391;
     *__edx = caml_curry3;
     *((intOrPtr*)(__edx + 4)) = 7;
     *((intOrPtr*)(__edx + 8)) = camlArray__trickledown_1160;
     *(__edx + 12) = __ecx;
     *(__edx + 16) = __ebx;
     *(__edx + 20) = __esi;
    __eax = __esi + 52;
    (__esp)[1] = __eax;
     *(__eax - 4) = 5367;
     *__eax = caml_curry3;
     *(__eax + 4) = 7;
     *((intOrPtr*)(__eax + 8)) = camlArray__trickle_1165;
     *(__eax + 12) = __ebx;
     *(__eax + 16) = __edx;
    __edx = __esi + 76;
     *(__edx - 4) = 5367;
     *__edx = caml_curry2;
     *((intOrPtr*)(__edx + 4)) = 5;
     *((intOrPtr*)(__edx + 8)) = camlArray__bubbledown_1170;
     *(__edx + 12) = __ebx;
     *(__edx + 16) = __esi;
    __eax = __esi + 100;
     *__esp = __eax;
     *(__eax - 4) = 4343;
     *__eax = caml_curry2;
     *(__eax + 4) = 5;
     *((intOrPtr*)(__eax + 8)) = camlArray__bubble_1174;
     *(__eax + 12) = __edx;
    __eax = __esi + 120;
    (__esp)[2] = __eax;
     *(__eax - 4) = 5367;
     *__eax = caml_curry2;
     *(__eax + 4) = 5;
     *((intOrPtr*)(__eax + 8)) = camlArray__trickleup_1178;
     *(__eax + 12) = __ecx;
     *(__eax + 16) = __ebx;
    __eax =  *(__ebx - 4);
    __eax = __eax & 255;
    if((__eax & 255) == 254) {
        __eax = __eax >> 10;
    } else {
        __eax = __eax >> 9;
    }
    __eax = __eax | 1;
    (__esp)[5] = __eax;
    __ecx = 3;
    __eax = __eax + 2;
    __eax = __eax >> 1;
    asm("cdq ");
    _t287 = __eax % __ecx;
    __eax = __eax / __ecx;
    __edx = _t287;
    __ebx = __eax + __eax - 1;
    if(__ebx < 1) {
L179:
        __esi = (__esp)[5];
        __esi = (__esp)[5] + -2;
        if(__esi < 5) {
L199:
            __eax = (__esp)[5];
            if((__esp)[5] <= 3) {
                __eax = 1;
                __esp =  &((__esp)[8]);
                return 1;
            } else {
                __ebx = (__esp)[4];
                __eax =  *(__ebx - 4);
                __eax = __eax & 255;
                if((__eax & 255) == 254) {
                    if(__eax <= 3) {
                        goto L236;
                    } else {
                        while(1) {
                            __eax = caml_young_ptr;
                            __eax = caml_young_ptr - 12;
                            caml_young_ptr = __eax;
                            if(__eax >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                        __esi = __eax + 4;
                         *(__esi - 4) = 2301;
                        asm("fld qword [ebx+0x8]");
                        asm("fstp qword [esi]");
                        goto L206;
                    }
                    goto L237;
                } else {
                    if(__eax <= 3) {
L237:
                        __eax = caml_ml_array_bound_error();
                    } else {
                        __esi =  *(__ebx + 4);
L206:
                        __eax =  *(__ebx - 4);
                        __eax = __eax & 255;
                        if((__eax & 255) == 254) {
                            if(__eax <= 1) {
                                goto L234;
                            } else {
                                while(1) {
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 12;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        break;
                                    }
                                    caml_call_gc(__esp);
                                }
                                __edx = __eax + 4;
                                 *(__edx - 4) = 2301;
                                asm("fld qword [ebx]");
                                asm("fstp qword [edx]");
                                goto L212;
                            }
                            goto L235;
                        } else {
                            if(__eax <= 1) {
L235:
                                __eax = caml_ml_array_bound_error();
                            } else {
                                __edx =  *__ebx;
L212:
                                __eax =  *(__ebx - 4);
                                __eax = __eax & 255;
                                if((__eax & 255) == 254) {
                                    if(__eax <= 3) {
                                        goto L232;
                                    } else {
                                        asm("fld qword [edx]");
                                        asm("fstp qword [ebx+0x8]");
                                        goto L217;
                                    }
                                    goto L233;
                                } else {
                                    if(__eax <= 3) {
L233:
                                        __eax = caml_ml_array_bound_error();
                                    } else {
                                        _push(__edx);
                                        __ebx = __ebx + 4;
                                        _push(__ebx + 4);
                                        caml_modify(__ebx);
                                        __esp =  &((__esp)[2]);
L217:
                                        __eax =  *(__ebx - 4);
                                        __eax = __eax & 255;
                                        if((__eax & 255) == 254) {
                                            if(__eax <= 1) {
                                                __eax = caml_ml_array_bound_error();
                                            } else {
                                                asm("fld qword [esi]");
                                                asm("fstp qword [ebx]");
                                                goto L222;
                                            }
                                            goto L231;
                                        } else {
                                            if(__eax <= 1) {
L231:
                                                __eax = caml_ml_array_bound_error();
                                            } else {
                                                caml_modify(__ebx, __ebx, __esi);
L222:
                                                __eax = 1;
                                                __esp =  &((__esp)[8]);
                                                return 1;
                                                goto L267;
                                            }
L232:
                                            __eax = caml_ml_array_bound_error();
                                            goto L233;
                                        }
                                        goto L267;
                                    }
L234:
                                    __eax = caml_ml_array_bound_error();
                                    goto L235;
                                }
                                goto L267;
                            }
L236:
                            __eax = caml_ml_array_bound_error();
                            goto L237;
                        }
                        goto L267;
                    }
                    goto L238;
                }
            }
        } else {
            (__esp)[3] = __esi;
            goto L181;
            do {
L181:
                __ebx = (__esp)[4];
                __eax =  *(__ebx - 4);
                __eax = __eax & 255;
                if((__eax & 255) == 254) {
                    if(__eax <= __esi) {
                        goto L242;
                    } else {
                        while(1) {
                            __eax = caml_young_ptr;
                            __eax = caml_young_ptr - 12;
                            caml_young_ptr = __eax;
                            if(__eax >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                        __eax = __eax + 4;
                         *(__eax - 4) = 2301;
                        asm("fld qword [ebx+esi*4-0x4]");
                        asm("fstp qword [eax]");
                        (__esp)[1] = __eax;
                        goto L187;
                    }
                    goto L243;
                } else {
                    if(__eax <= __esi) {
L243:
                        __eax = caml_ml_array_bound_error();
                    } else {
                        __eax =  *(__ebx + __esi * 2 - 2);
                        (__esp)[1] =  *(__ebx + __esi * 2 - 2);
L187:
                        __eax =  *(__ebx - 4);
                        __eax = __eax & 255;
                        if((__eax & 255) == 254) {
                            if(__eax <= 1) {
                                goto L240;
                            } else {
                                while(1) {
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 12;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        break;
                                    }
                                    caml_call_gc(__esp);
                                }
                                __edx = __eax + 4;
                                 *(__edx - 4) = 2301;
                                asm("fld qword [ebx]");
                                asm("fstp qword [edx]");
                                goto L193;
                            }
                            goto L241;
                        } else {
                            if(__eax <= 1) {
L241:
                                __eax = caml_ml_array_bound_error();
                            } else {
                                __edx =  *__ebx;
L193:
                                __eax =  *(__ebx - 4);
                                __eax = __eax & 255;
                                if((__eax & 255) == 254) {
                                    if(__eax <= __esi) {
L238:
                                        __eax = caml_ml_array_bound_error();
                                    } else {
                                        asm("fld qword [edx]");
                                        asm("fstp qword [ebx+esi*4-0x4]");
                                        goto L198;
                                    }
                                    goto L239;
                                } else {
                                    if(__eax <= __esi) {
L239:
                                        __eax = caml_ml_array_bound_error();
                                    } else {
                                        _push(__edx);
                                        __eax = __ebx + __esi * 2 - 2;
                                        _push(__ebx + __esi * 2 - 2);
                                        caml_modify(__ebx);
                                        __esp =  &((__esp)[2]);
                                        goto L198;
                                    }
L240:
                                    __eax = caml_ml_array_bound_error();
                                    goto L241;
                                }
                                goto L267;
                            }
L242:
                            __eax = caml_ml_array_bound_error();
                            goto L243;
                        }
                        goto L267;
                    }
                    goto L244;
                }
                goto L267;
L198:
                __ebx = 1;
                __eax = __esi;
                __ecx =  *__esp;
                camlArray__bubble_1174();
                __ebx = (__esp)[1];
                __ecx = (__esp)[2];
                __eax = camlArray__trickleup_1178(__esi, (__esp)[1], (__esp)[2]);
                __esi = (__esp)[3];
                __eax = __esi;
                __esi = __esi - 2;
                (__esp)[3] = __esi;
            } while(__eax != 5);
            goto L199;
        }
    } else {
        (__esp)[3] = __ebx;
        goto L172;
        do {
L172:
            __edx = (__esp)[4];
            __eax =  *(__edx - 4);
            __eax = __eax & 255;
            if((__eax & 255) == 254) {
                if(__eax <= __ebx) {
L244:
                    __eax = caml_ml_array_bound_error();
                } else {
                    while(1) {
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 12;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                    __ecx = __eax + 4;
                     *(__eax + 4 - 4) = 2301;
                    asm("fld qword [edx+ebx*4-0x4]");
                    asm("fstp qword [ecx]");
                    goto L178;
                }
                goto L245;
            } else {
                if(__eax <= __ebx) {
L245:
                    __eax = caml_ml_array_bound_error();
                    __esi = __esi;
                    __edi = __edi;
                    __esp = __esp - 32;
                    __ecx = __eax;
                    while(1) {
L247:
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 76;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                    __eax = __eax + 4;
                     *(__eax - 4) = 5367;
                     *__eax = caml_curry7;
                     *(__eax + 4) = 15;
                     *((intOrPtr*)(__eax + 8)) = camlArray__merge_1191;
                     *(__eax + 12) = __ecx;
                     *(__eax + 16) = __ebx;
                    __esi = __eax + 24;
                     *(__esi - 4) = 5367;
                     *__esi = caml_curry4;
                     *((intOrPtr*)(__esi + 4)) = 9;
                     *((intOrPtr*)(__esi + 8)) = camlArray__isortto_1209;
                     *(__esi + 12) = __ecx;
                     *(__esi + 16) = __ebx;
                    __ecx = __eax + 48;
                     *(__ecx - 4) = 6391;
                     *__ecx = caml_curry4;
                     *((intOrPtr*)(__ecx + 4)) = 9;
                     *((intOrPtr*)(__ecx + 8)) = camlArray__sortto_1217;
                     *(__ecx + 12) = __ebx;
                     *(__ecx + 16) = __eax;
                     *(__ecx + 20) = __esi;
                    __edx =  *(__ebx - 4);
                    __edx = __edx & 255;
                    if((__edx & 255) == 254) {
                        __edx = __edx >> 10;
                    } else {
                        __edx = __edx >> 9;
                    }
                    __edx = __edx | 1;
                    if(__edx > 11) {
                         *__esp = __ecx;
                        (__esp)[5] = __eax;
                        (__esp)[4] = __ebx;
                        __eax = __edx;
                        __eax = __edx >> 1;
                        if(__eax < 0) {
                            __eax = __eax + 1;
                        }
                        __eax = __eax >> 1;
                        __eax = __eax + __eax + 1;
                        (__esp)[2] = __eax;
                        __edx = __edx - __eax;
                        __edx = __edx + 1;
                        (__esp)[1] = __edx;
                        __eax =  *(__ebx - 4);
                        __eax = __eax & 255;
                        if((__eax & 255) == 254) {
                            if(__eax <= 1) {
                                __eax = caml_ml_array_bound_error();
                            } else {
                                while(1) {
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 12;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        break;
                                    }
                                    caml_call_gc(__esp);
                                }
                                __eax = __eax + 4;
                                 *(__eax - 4) = 2301;
                                asm("fld qword [ebx]");
                                asm("fstp qword [eax]");
                                goto L261;
                            }
                            goto L265;
                        } else {
                            if(__eax <= 1) {
L265:
                                __eax = caml_ml_array_bound_error();
                                __esi = __esi;
                            } else {
                                __eax =  *__ebx;
L261:
                                _push(__eax);
                                _push(__edx);
                                __eax = caml_make_vect;
                                caml_c_call();
                                __esp =  &((__esp)[2]);
                                __ebx = caml_make_vect;
                                (__esp)[3] = caml_make_vect;
                                __ecx = 1;
                                __eax = (__esp)[2];
                                __edx = (__esp)[1];
                                __esi =  *__esp;
                                L124();
                                __eax = 1;
                                __ebx = (__esp)[4];
                                __ecx = (__esp)[1];
                                __edx = (__esp)[2];
                                __esi =  *__esp;
                                L124();
                                __ebp = 1;
                                __edx = 1;
                                __eax = (__esp)[1];
                                __ebx = (__esp)[2];
                                __ecx = (__esp)[3];
                                __esi = __eax;
                                __edi = (__esp)[4];
                                caml_extra_params = 1;
                                __ebp = (__esp)[5];
                                 *134693344 = (__esp)[5];
                                __esp =  &((__esp)[8]);
L51:
                                __esp = __esp - 28;
                                 *__esp = __eax;
                                (__esp)[1] = __ecx;
                                (__esp)[4] = __edx;
                                (__esp)[2] = __edi;
                                __eax = caml_extra_params;
                                (__esp)[3] = caml_extra_params;
                                __ebp =  *134693344;
                                __ecx =  *__esp;
                                __edx = __ecx + __ebx - 1;
                                __eax = (__esp)[4];
                                __esi = (__esp)[4] + __esi - 1;
                                while(1) {
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 40;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        break;
                                    }
                                    caml_call_gc(__esp);
                                }
                                __edi = __eax + 4;
                                 *(__edi - 4) = 9463;
                                 *__edi = caml_curry5;
                                 *((intOrPtr*)(__edi + 4)) = 11;
                                 *((intOrPtr*)(__edi + 8)) =  &camlArray__code_begin;
                                __eax =  *(__ebp + 12);
                                 *(__edi + 12) =  *(__ebp + 12);
                                __eax =  *(__ebp + 16);
                                 *(__edi + 16) =  *(__ebp + 16);
                                __ebx = (__esp)[1];
                                 *(__edi + 20) = __ebx;
                                __eax = (__esp)[2];
                                 *(__edi + 24) = (__esp)[2];
                                 *(__edi + 28) = __edx;
                                 *(__edi + 32) = __esi;
                                __eax =  *(__ebx - 4);
                                __eax = __eax & 255;
                                if((__eax & 255) == 254) {
                                    if(__eax <= (__esp)[4]) {
                                        goto L71;
                                    } else {
                                        while(1) {
                                            __eax = caml_young_ptr;
                                            __eax = caml_young_ptr - 12;
                                            caml_young_ptr = __eax;
                                            if(__eax >= caml_young_limit) {
                                                break;
                                            }
                                            caml_call_gc(__esp);
                                        }
                                        __edx = __eax + 4;
                                         *(__edx - 4) = 2301;
                                        __eax = (__esp)[4];
                                        asm("fld qword [ebx+eax*4-0x4]");
                                        asm("fstp qword [edx]");
                                        goto L59;
                                    }
                                    goto L72;
                                } else {
                                    if(__eax <= (__esp)[4]) {
L72:
                                        __eax = caml_ml_array_bound_error();
                                        __esi = __esi;
                                        while(1) {
L73:
                                            __esp = __esp - 40;
                                            __edi = 1;
                                            __edx = __edx + -2;
                                            if(__edi > __edx) {
                                                break;
                                            }
                                            (__esp)[4] = __edx;
                                            (__esp)[3] = __edi;
                                            (__esp)[6] = __esi;
                                            (__esp)[5] = __ecx;
                                            (__esp)[7] = __ebx;
                                             *__esp = __eax;
                                            goto L75;
                                            do {
L75:
                                                __eax =  *__esp;
                                                __eax =  *__esp + __edi - 1;
                                                (__esp)[1] = __eax;
                                                __ecx = (__esp)[6];
                                                __ecx =  *((__esp)[6] + 16);
                                                __edx =  *(__ecx - 4);
                                                (__esp)[2] =  *(__ecx - 4);
                                                (__esp)[2] = (__esp)[2] & 255;
                                                if(((__esp)[2] & 255) == 254) {
                                                    (__esp)[2] = (__esp)[2] >> 10;
                                                    if((__esp)[2] >> 10 <= __eax) {
                                                        goto L122;
                                                    } else {
                                                        while(1) {
                                                            __eax = caml_young_ptr;
                                                            __eax = caml_young_ptr - 12;
                                                            caml_young_ptr = __eax;
                                                            if(__eax >= caml_young_limit) {
                                                                break;
                                                            }
                                                            caml_call_gc(__esp);
                                                        }
                                                        __edx = __eax + 4;
                                                         *(__edx - 4) = 2301;
                                                        __eax = (__esp)[1];
                                                        asm("fld qword [ecx+eax*4-0x4]");
                                                        asm("fstp qword [edx]");
                                                        (__esp)[1] = __edx;
                                                        goto L81;
                                                    }
                                                    goto L123;
                                                } else {
                                                    (__esp)[2] = (__esp)[2] >> 9;
                                                    if((__esp)[2] >> 9 <= __eax) {
L123:
                                                        __eax = caml_ml_array_bound_error();
                                                        __esi = __esi;
                                                        __esp = __esp - 24;
                                                        if(__edx > 11) {
                                                             *__esp = __esi;
                                                            (__esp)[2] = __ecx;
                                                            (__esp)[5] = __ebx;
                                                            (__esp)[4] = __eax;
                                                            __esi = __edx;
                                                            __esi = __edx >> 1;
                                                            if(__esi < 0) {
                                                                __esi = __esi + 1;
                                                            }
                                                            __esi = __esi >> 1;
                                                            __esi = __esi + __esi + 1;
                                                            (__esp)[1] = __esi;
                                                            __edx = __edx - __esi;
                                                            (__esp)[3] = __edx;
                                                            __ecx = __ecx + __esi - 1;
                                                            __eax = __eax + __esi - 1;
                                                            __edx = (__esp)[3];
                                                            __esi =  *__esp;
                                                            L124();
                                                            __ebx = (__esp)[3];
                                                            __eax = (__esp)[4];
                                                            __ecx = (__esp)[4] + (__esp)[3] - 1;
                                                            __esi =  *__esp;
                                                            __ebx =  *( *__esp + 12);
                                                            __edx = (__esp)[1];
                                                            L124();
                                                            __eax =  *__esp;
                                                            __eax =  *( *__esp + 16);
                                                             *__esp =  *( *__esp + 16);
                                                            __ebx = (__esp)[1];
                                                            __ebp = (__esp)[2];
                                                            __edx = __ebp + __ebx - 1;
                                                            __esi = (__esp)[3];
                                                            __eax = (__esp)[4];
                                                            __eax = (__esp)[4] + __esi - 1;
                                                            __ecx = (__esp)[5];
                                                            __edi = __ecx;
                                                            caml_extra_params = __ebp;
                                                            __ebp =  *__esp;
                                                             *134693344 =  *__esp;
                                                            __esp =  &((__esp)[6]);
                                                            goto L51;
                                                        }
                                                        __esi =  *(__esi + 20);
                                                        __esp =  &((__esp)[6]);
                                                        goto L73;
                                                    } else {
                                                        __edx =  *(__ecx + __eax * 2 - 2);
                                                        (__esp)[1] =  *(__ecx + __eax * 2 - 2);
                                                        while(1) {
L81:
                                                            __eax = caml_young_ptr;
                                                            __eax = caml_young_ptr - 8;
                                                            caml_young_ptr = __eax;
                                                            if(__eax >= caml_young_limit) {
                                                                break;
                                                            }
                                                            caml_call_gc(__esp);
                                                        }
                                                        __esi = __eax + 4;
                                                        (__esp)[2] = __esi;
                                                         *(__esi - 4) = 1024;
                                                        __eax = (__esp)[5];
                                                        __eax = (__esp)[5] + __edi - 3;
                                                         *__esi = (__esp)[5] + __edi - 3;
                                                        while(1) {
                                                            __ecx =  *__esi;
                                                            __eax = (__esp)[5];
                                                            if( *__esi < (__esp)[5]) {
                                                                break;
                                                            }
                                                            __ecx =  *__esi;
                                                            __eax =  *(__ebx - 4);
                                                            __eax = __eax & 255;
                                                            if((__eax & 255) == 254) {
                                                                if(__eax <= __ecx) {
                                                                    goto L120;
                                                                } else {
                                                                    while(1) {
                                                                        __eax = caml_young_ptr;
                                                                        __eax = caml_young_ptr - 12;
                                                                        caml_young_ptr = __eax;
                                                                        if(__eax >= caml_young_limit) {
                                                                            break;
                                                                        }
                                                                        caml_call_gc(__esp);
                                                                    }
                                                                    __eax = __eax + 4;
                                                                     *(__eax - 4) = 2301;
                                                                    asm("fld qword [ebx+ecx*4-0x4]");
                                                                    asm("fstp qword [eax]");
                                                                    goto L90;
                                                                }
                                                                goto L121;
                                                            } else {
                                                                if(__eax <= __ecx) {
L121:
                                                                    __eax = caml_ml_array_bound_error();
                                                                } else {
                                                                    __eax =  *(__ebx + __ecx * 2 - 2);
L90:
                                                                    __ebx = (__esp)[6];
                                                                    __ecx =  *((__esp)[6] + 12);
                                                                    __ebx = (__esp)[1];
                                                                    caml_apply2();
                                                                    if(__eax <= 1) {
                                                                        break;
                                                                    } else {
                                                                        __esi = (__esp)[2];
                                                                        __ecx =  *__esi;
                                                                        __ebx = (__esp)[7];
                                                                        __eax =  *(__ebx - 4);
                                                                        __eax = __eax & 255;
                                                                        if((__eax & 255) == 254) {
                                                                            if(__eax <= __ecx) {
                                                                                goto L118;
                                                                            } else {
                                                                                while(1) {
                                                                                    __eax = caml_young_ptr;
                                                                                    __eax = caml_young_ptr - 12;
                                                                                    caml_young_ptr = __eax;
                                                                                    if(__eax >= caml_young_limit) {
                                                                                        break;
                                                                                    }
                                                                                    caml_call_gc(__esp);
                                                                                }
                                                                                __edx = __eax + 4;
                                                                                 *(__edx - 4) = 2301;
                                                                                asm("fld qword [ebx+ecx*4-0x4]");
                                                                                asm("fstp qword [edx]");
                                                                                goto L97;
                                                                            }
                                                                            goto L119;
                                                                        } else {
                                                                            if(__eax <= __ecx) {
L119:
                                                                                __eax = caml_ml_array_bound_error();
                                                                            } else {
                                                                                __edx =  *(__ebx + __ecx * 2 - 2);
L97:
                                                                                __eax =  *__esi;
                                                                                __eax =  *__esi + 2;
                                                                                __ecx =  *(__ebx - 4);
                                                                                __ecx = __ecx & 255;
                                                                                if((__ecx & 255) == 254) {
                                                                                    if(__ecx <= __eax) {
L116:
                                                                                        __eax = caml_ml_array_bound_error();
                                                                                    } else {
                                                                                        asm("fld qword [edx]");
                                                                                        asm("fstp qword [ebx+eax*4-0x4]");
                                                                                        goto L102;
                                                                                    }
                                                                                    goto L117;
                                                                                } else {
                                                                                    if(__ecx <= __eax) {
L117:
                                                                                        __eax = caml_ml_array_bound_error();
                                                                                    } else {
                                                                                        caml_modify(__eax, __edx);
L102:
                                                                                         *__esi =  *__esi + -2;
                                                                                        continue;
                                                                                    }
L118:
                                                                                    __eax = caml_ml_array_bound_error();
                                                                                    goto L119;
                                                                                }
                                                                                goto L267;
                                                                            }
L120:
                                                                            __eax = caml_ml_array_bound_error();
                                                                            goto L121;
                                                                        }
                                                                    }
                                                                    goto L267;
                                                                }
L122:
                                                                __eax = caml_ml_array_bound_error();
                                                                goto L123;
                                                            }
                                                            goto L267;
                                                        }
                                                        (__esp)[2] =  *((__esp)[2]);
                                                        __eax =  *((__esp)[2]) + 2;
                                                        __ebx = (__esp)[7];
                                                        __ecx =  *(__ebx - 4);
                                                        __ecx = __ecx & 255;
                                                        if((__ecx & 255) == 254) {
                                                            if(__ecx <= __eax) {
                                                                __eax = caml_ml_array_bound_error();
                                                            } else {
                                                                __ecx = (__esp)[1];
                                                                asm("fld qword [ecx]");
                                                                asm("fstp qword [ebx+eax*4-0x4]");
                                                                goto L108;
                                                            }
                                                            goto L115;
                                                        } else {
                                                            if(__ecx <= __eax) {
L115:
                                                                __eax = caml_ml_array_bound_error();
                                                            } else {
                                                                __ecx = (__esp)[1];
                                                                caml_modify(__eax, (__esp)[1]);
                                                                goto L108;
                                                            }
                                                            goto L116;
                                                        }
                                                    }
                                                }
                                                goto L267;
L108:
                                                __edi = (__esp)[3];
                                                __ecx = __edi;
                                                __edi = __edi + 2;
                                                (__esp)[3] = __edi;
                                                __eax = (__esp)[4];
                                            } while(__ecx != (__esp)[4]);
                                            break;
                                        }
                                        __eax = 1;
                                        __esp =  &((__esp)[0xa]);
                                        return 1;
                                    } else {
                                        __eax = (__esp)[4];
                                        __edx =  *(__ebx + (__esp)[4] * 2 - 2);
L59:
                                        __esi =  *(__ebp + 16);
                                        __eax =  *(__esi - 4);
                                        __ebx = __eax;
                                        __ebx = __eax & 255;
                                        if(__ebx == 254) {
                                            if(__eax <= __ecx) {
                                                __eax = caml_ml_array_bound_error();
                                            } else {
                                                while(1) {
                                                    __eax = caml_young_ptr;
                                                    __eax = caml_young_ptr - 12;
                                                    caml_young_ptr = __eax;
                                                    if(__eax >= caml_young_limit) {
                                                        break;
                                                    }
                                                    caml_call_gc(__esp);
                                                }
                                                __ebx = __eax + 4;
                                                 *(__ebx - 4) = 2301;
                                                asm("fld qword [esi+ecx*4-0x4]");
                                                asm("fstp qword [ebx]");
                                                goto L65;
                                            }
                                            goto L70;
                                        } else {
                                            if(__eax <= __ecx) {
L70:
                                                __eax = caml_ml_array_bound_error();
                                            } else {
                                                __ebx =  *(__esi + __ecx * 2 - 2);
L65:
                                                __eax = __ecx;
                                                __ecx = (__esp)[4];
                                                __esi = (__esp)[3];
                                                __esp =  &((__esp)[7]);
                                                __esp = __esp - 32;
                                                while(1) {
L6:
                                                    (__esp)[1] = __eax;
                                                    __eax = __ebx;
                                                    (__esp)[5] = __eax;
                                                    (__esp)[2] = __ecx;
                                                    (__esp)[3] = __edx;
                                                    (__esp)[4] = __esi;
                                                     *__esp = __edi;
                                                    __ecx =  *(__edi + 12);
                                                    __ebx = __edx;
                                                    caml_apply2();
                                                    if(__eax > 1) {
                                                        break;
                                                    }
                                                    __edi =  *__esp;
                                                    __eax =  *(__edi + 24);
                                                    __ebx =  *(__eax - 4);
                                                    __ebx = __ebx & 255;
                                                    if((__ebx & 255) == 254) {
                                                        __ebx = __ebx >> 10;
                                                        __esi = (__esp)[4];
                                                        if(__ebx <= __esi) {
                                                            goto L43;
                                                        } else {
                                                            __ebx = (__esp)[5];
                                                            asm("fld qword [ebx]");
                                                            asm("fstp qword [eax+esi*4-0x4]");
                                                            goto L12;
                                                        }
                                                        goto L44;
                                                    } else {
                                                        __ebx = __ebx >> 9;
                                                        __esi = (__esp)[4];
                                                        if(__ebx <= __esi) {
L44:
                                                            __eax = caml_ml_array_bound_error();
                                                            __esi = __esi;
L45:
                                                            while(__ebx != 1) {
                                                                __ecx =  *(__ebx + 4);
                                                                __ebx =  *__ebx;
                                                                __ebx =  *(__ebx - 4);
                                                                __ebx = __ebx & 255;
                                                                if((__ebx & 255) == 254) {
                                                                    __ebx = __ebx >> 10;
                                                                } else {
                                                                    __ebx = __ebx >> 9;
                                                                }
                                                                __eax = __eax + __ebx;
                                                                __eax = __eax - 1;
                                                                __ebx = __ecx;
                                                            }
                                                            return __eax;
                                                        } else {
                                                            __ebx = (__esp)[5];
                                                            caml_modify(__eax, __ebx);
L12:
                                                            __ecx = (__esp)[1];
                                                            __ecx = (__esp)[1] + 2;
                                                            __eax =  *(__edi + 28);
                                                            if(__ecx >=  *(__edi + 28)) {
                                                                __ebp =  *(__edi + 32);
                                                                __ebx = (__esp)[2];
                                                                 *(__edi + 32) - __ebx =  *(__edi + 32) - __ebx + 1;
                                                                __esi = __esi + 2;
                                                                __ecx =  *(__edi + 24);
                                                                __eax =  *(__edi + 20);
                                                                __edx = __esi;
                                                                __esi =  *(__edi + 32) - __ebx + 1;
                                                                __esp =  &((__esp)[8]);
L129:
                                                                __esp = __esp - 24;
                                                                __edi = __eax;
                                                                (__esp)[2] = __ecx;
                                                                __ebp = __edx;
                                                                if(__esi < 1 || __ebx < 1) {
L163:
                                                                    __eax = "Array.blit";
                                                                    __esp =  &((__esp)[6]);
                                                                    _t388 = _t382;
                                                                    while(1) {
                                                                        _t384 = caml_young_ptr - 12;
                                                                        caml_young_ptr = _t384;
                                                                        if(_t384 >= caml_young_limit) {
                                                                            _t385 = _t384 + 4;
                                                                             *((intOrPtr*)(_t385 - 4)) = 2048;
                                                                             *_t385 =  &caml_exn_Invalid_argument;
                                                                             *(_t385 + 4) = _t388;
                                                                            caml_raise_exn(_t385);
                                                                        }
                                                                        caml_call_gc(__esp);
                                                                    }
                                                                }
                                                                __ecx =  *(__edi - 4);
                                                                __ecx = __ecx & 255;
                                                                if((__ecx & 255) == 254) {
                                                                    __eax = __ecx;
                                                                    __eax = __ecx >> 10;
                                                                } else {
                                                                    __eax = __ecx;
                                                                    __eax = __ecx >> 9;
                                                                }
                                                                __eax = __eax | 1;
                                                                __eax = __eax - __esi;
                                                                if(__ebx > __eax || __ebp < 1) {
                                                                    goto L163;
                                                                }
                                                                __eax = (__esp)[2];
                                                                __ecx =  *((__esp)[2] - 4);
                                                                __ecx = __ecx & 255;
                                                                if((__ecx & 255) == 254) {
                                                                    __eax = __ecx;
                                                                    __eax = __ecx >> 10;
                                                                } else {
                                                                    __eax = __ecx;
                                                                    __eax = __ecx >> 9;
                                                                }
                                                                __eax = __eax | 1;
                                                                __eax = __eax - __esi;
                                                                if(__ebp > __eax) {
                                                                    goto L163;
                                                                }
                                                                if(__ebx >= __ebp) {
                                                                    __eax = 1;
                                                                    (__esp)[3] = 1;
                                                                    __esi = __esi + -2;
                                                                    if((__esp)[3] > __esi) {
                                                                    } else {
                                                                        (__esp)[1] = __ebx;
                                                                         *__esp = __edi;
                                                                        goto L154;
                                                                        do {
L154:
                                                                            __ebx = (__esp)[1];
                                                                            __eax = (__esp)[3];
                                                                            __ebx = (__esp)[1] + (__esp)[3] - 1;
                                                                            __eax =  *__esp;
                                                                            __ecx =  *(__eax - 4) & 255;
                                                                            if(( *(__eax - 4) & 255) == 254) {
                                                                                while(1) {
                                                                                    __eax = caml_young_ptr;
                                                                                    __eax = caml_young_ptr - 12;
                                                                                    caml_young_ptr = __eax;
                                                                                    if(__eax >= caml_young_limit) {
                                                                                        break;
                                                                                    }
                                                                                    caml_call_gc(__esp);
                                                                                }
                                                                                __ecx = __eax + 4;
                                                                                 *(__ecx - 4) = 2301;
                                                                                __eax =  *__esp;
                                                                                asm("fld qword [eax+ebx*4-0x4]");
                                                                                asm("fstp qword [ecx]");
                                                                                __ebx = __ecx;
                                                                                goto L158;
                                                                            }
                                                                            __ebx =  *(__eax + __ebx * 2 - 2);
L158:
                                                                            __ecx = (__esp)[3];
                                                                            __eax = __ebp;
                                                                            __eax = __ebp + (__esp)[3] - 1;
                                                                            __ecx = (__esp)[2];
                                                                            __ecx =  *((__esp)[2] - 4) & 255;
                                                                            if(( *((__esp)[2] - 4) & 255) == 254) {
                                                                                asm("fld qword [ebx]");
                                                                                __ebx = (__esp)[2];
                                                                                asm("fstp qword [ebx+eax*4-0x4]");
                                                                            } else {
                                                                                _push(__ebx);
                                                                                __ebx = (__esp)[3];
                                                                                _push(__eax);
                                                                                caml_modify(__ebx);
                                                                                __esp =  &((__esp)[2]);
                                                                            }
                                                                            __ebx = (__esp)[3];
                                                                            (__esp)[3] = (__esp)[3] + 2;
                                                                            (__esp)[3] = (__esp)[3] + 2;
                                                                        } while((__esp)[3] != __esi);
                                                                    }
                                                                } else {
                                                                    __esi = __esi + -2;
                                                                    if(__esi >= 1) {
                                                                        (__esp)[1] = __ebx;
                                                                        goto L143;
                                                                        do {
L143:
                                                                            __eax = (__esp)[1];
                                                                            __ebx = (__esp)[1] + __esi - 1;
                                                                            __eax =  *(__edi - 4) & 255;
                                                                            if(( *(__edi - 4) & 255) == 254) {
                                                                                while(1) {
                                                                                    __eax = caml_young_ptr;
                                                                                    __eax = caml_young_ptr - 12;
                                                                                    caml_young_ptr = __eax;
                                                                                    if(__eax >= caml_young_limit) {
                                                                                        break;
                                                                                    }
                                                                                    caml_call_gc(__esp);
                                                                                }
                                                                                __eax = __eax + 4;
                                                                                 *(__eax - 4) = 2301;
                                                                                asm("fld qword [edi+ebx*4-0x4]");
                                                                                asm("fstp qword [eax]");
                                                                                __ebx = __eax;
                                                                                goto L147;
                                                                            }
                                                                            __ebx =  *(__edi + __ebx * 2 - 2);
L147:
                                                                            __eax = __ebp;
                                                                            __eax = __ebp + __esi - 1;
                                                                            __ecx = (__esp)[2];
                                                                            __ecx =  *((__esp)[2] - 4) & 255;
                                                                            if(( *((__esp)[2] - 4) & 255) == 254) {
                                                                                asm("fld qword [ebx]");
                                                                                __ebx = (__esp)[2];
                                                                                asm("fstp qword [ebx+eax*4-0x4]");
                                                                            } else {
                                                                                _push(__ebx);
                                                                                __ebx = (__esp)[3];
                                                                                _push(__eax);
                                                                                caml_modify(__ebx);
                                                                                __esp =  &((__esp)[2]);
                                                                            }
                                                                            __ebx = __esi;
                                                                            __esi = __esi - 2;
                                                                            __esi = __esi - 2;
                                                                        } while(__ebx != 1);
                                                                    }
                                                                    __eax = 1;
                                                                    __esp =  &((__esp)[6]);
                                                                    return 1;
                                                                    goto L267;
                                                                }
                                                                __eax = 1;
                                                                __esp =  &((__esp)[6]);
                                                                return 1;
                                                                goto L267;
                                                            }
                                                            __ebx =  *(__edi + 16);
                                                            __edx =  *(__ebx - 4);
                                                            __edx = __edx & 255;
                                                            if((__edx & 255) == 254) {
                                                                if(__edx >> 10 <= __ecx) {
L41:
                                                                    __eax = caml_ml_array_bound_error();
                                                                } else {
                                                                    while(1) {
                                                                        __eax = caml_young_ptr;
                                                                        __eax = caml_young_ptr - 12;
                                                                        caml_young_ptr = __eax;
                                                                        if(__eax >= caml_young_limit) {
                                                                            break;
                                                                        }
                                                                        caml_call_gc(__esp);
                                                                    }
                                                                    __edx = __eax + 4;
                                                                     *(__edx - 4) = 2301;
                                                                    asm("fld qword [ebx+ecx*4-0x4]");
                                                                    asm("fstp qword [edx]");
                                                                    __ebx = __edx;
                                                                    goto L19;
                                                                }
                                                                goto L42;
                                                            } else {
                                                                if(__edx >> 9 <= __ecx) {
L42:
                                                                    __eax = caml_ml_array_bound_error();
                                                                } else {
                                                                    __ebx =  *(__ebx + __ecx * 2 - 2);
L19:
                                                                    __esi = __esi + 2;
                                                                    __eax = __ecx;
                                                                    __ecx = (__esp)[2];
                                                                    __edx = (__esp)[3];
                                                                    continue;
                                                                }
L43:
                                                                __eax = caml_ml_array_bound_error();
                                                                goto L44;
                                                            }
                                                        }
                                                    }
                                                    goto L267;
                                                }
                                                __edi =  *__esp;
                                                __eax =  *(__edi + 24);
                                                __ebx =  *(__eax - 4);
                                                __ebx = __ebx & 255;
                                                if((__ebx & 255) == 254) {
                                                    __ebx = __ebx >> 10;
                                                    __esi = (__esp)[4];
                                                    if(__ebx <= __esi) {
                                                        goto L39;
                                                    } else {
                                                        __ebx = (__esp)[3];
                                                        asm("fld qword [ebx]");
                                                        asm("fstp qword [eax+esi*4-0x4]");
                                                        goto L26;
                                                    }
                                                    goto L40;
                                                } else {
                                                    __ebx = __ebx >> 9;
                                                    __esi = (__esp)[4];
                                                    if(__ebx <= __esi) {
L40:
                                                        __eax = caml_ml_array_bound_error();
                                                    } else {
                                                        __ebx = (__esp)[3];
                                                        caml_modify(__eax, __ebx);
L26:
                                                        __ecx = (__esp)[2];
                                                        __ecx = (__esp)[2] + 2;
                                                        __eax =  *(__edi + 32);
                                                        if(__ecx >=  *(__edi + 32)) {
                                                            __ebp =  *(__edi + 28);
                                                            __ebx = (__esp)[1];
                                                             *(__edi + 28) - __ebx =  *(__edi + 28) - __ebx + 1;
                                                            __esi = __esi + 2;
                                                            __ecx =  *(__edi + 24);
                                                            __eax =  *(__edi + 16);
                                                            __edx = __esi;
                                                            __esi =  *(__edi + 28) - __ebx + 1;
                                                            __esp =  &((__esp)[8]);
                                                            goto L129;
                                                        }
                                                        __ebx =  *(__edi + 20);
                                                        __edx =  *(__ebx - 4);
                                                        __edx = __edx & 255;
                                                        if((__edx & 255) == 254) {
                                                            if(__edx >> 10 <= __ecx) {
                                                                __eax = caml_ml_array_bound_error();
                                                            } else {
                                                                while(1) {
                                                                    __eax = caml_young_ptr;
                                                                    __eax = caml_young_ptr - 12;
                                                                    caml_young_ptr = __eax;
                                                                    if(__eax >= caml_young_limit) {
                                                                        break;
                                                                    }
                                                                    caml_call_gc(__esp);
                                                                }
                                                                __edx = __eax + 4;
                                                                 *(__edx - 4) = 2301;
                                                                asm("fld qword [ebx+ecx*4-0x4]");
                                                                asm("fstp qword [edx]");
                                                                goto L33;
                                                            }
                                                            goto L38;
                                                        } else {
                                                            if(__edx >> 9 <= __ecx) {
L38:
                                                                __eax = caml_ml_array_bound_error();
                                                            } else {
                                                                __edx =  *(__ebx + __ecx * 2 - 2);
L33:
                                                                __esi = __esi + 2;
                                                                __eax = (__esp)[1];
                                                                __ebx = (__esp)[5];
                                                                goto L6;
                                                            }
L39:
                                                            __eax = caml_ml_array_bound_error();
                                                            goto L40;
                                                        }
                                                        goto L267;
                                                    }
                                                    goto L41;
                                                }
                                                goto L267;
                                            }
L71:
                                            __eax = caml_ml_array_bound_error();
                                            goto L72;
                                        }
                                    }
                                }
                                goto L267;
                            }
                            __eax =  ?_? ( &camlArray__21);
                            camlArray =  &camlArray__21;
                            __eax =  ?_? ( &camlArray__20);
                             *134682212 =  &camlArray__20;
                            __eax =  *134682212;
                             *134682216 =  *134682212;
                            __eax =  ?_? ( &camlArray__19);
                             *134682232 =  &camlArray__19;
                            __eax =  ?_? ( &camlArray__18);
                             *134682220 =  &camlArray__18;
                            __eax =  ?_? ( &camlArray__17);
                             *134682288 =  &camlArray__17;
                            __eax =  ?_? ( &camlArray__16);
                             *134682224 =  &camlArray__16;
                            __eax =  ?_? ( &camlArray__15);
                             *134682228 =  &camlArray__15;
                            __eax =  ?_? ( &camlArray__14);
                             *134682236 =  &camlArray__14;
                            __eax =  ?_? ( &camlArray__13);
                             *134682240 =  &camlArray__13;
                            __eax =  ?_? ( &camlArray__12);
                             *134682252 =  &camlArray__12;
                            __eax =  ?_? ( &camlArray__11);
                             *134682256 =  &camlArray__11;
                            __eax =  ?_? ( &camlArray__10);
                             *134682260 =  &camlArray__10;
                            __eax =  ?_? ( &camlArray__9);
                             *134682264 =  &camlArray__9;
                            __eax =  ?_? ( &camlArray__8);
                             *134682244 =  &camlArray__8;
                            __eax =  ?_? ( &camlArray__7);
                             *134682292 =  &camlArray__7;
                            __eax =  ?_? ( &camlArray__6);
                             *134682248 =  &camlArray__6;
                            __eax =  ?_? ( &camlArray__5);
                             *134682268 =  &camlArray__5;
                            __eax =  ?_? ( &camlArray__4);
                             *134682272 =  &camlArray__4;
                            caml_alloc1(__esp);
                            __eax = __eax + 4;
                             *(__eax - 4) = 1024;
                             *__eax = "Array.Bottom";
                             *134682296 = __eax;
                            __eax =  ?_? ( &camlArray__2);
                             *134682276 =  &camlArray__2;
                             *134682300 = 11;
                            __eax =  ?_? ( &camlArray__1);
                             *134682280 =  &camlArray__1;
                            __eax =  *134682280;
                             *134682284 =  *134682280;
                            __eax = 1;
                            return 1;
                        }
                        goto L267;
                    }
                    __ecx = 1;
                    __eax = 1;
                    __esp =  &((__esp)[8]);
                    goto L73;
                } else {
                    __ecx =  *(__edx + __ebx * 2 - 2);
                    goto L178;
                }
                goto L247;
            }
            goto L267;
L178:
            __eax = (__esp)[5];
            __edx = (__esp)[1];
            camlArray__trickle_1165(__esp);
            __ebx = (__esp)[3];
            __eax = __ebx;
            __ebx = __ebx - 2;
            (__esp)[3] = __ebx;
        } while(__eax != 1);
        goto L179;
    }
L267:
}

camlArray__stable_sort_1188(
    signed int __eax,                      // r0
    _unknown_ __ebx                        // r1
)
{// addr = 0x08052A70
    signed int _t288;                      // _t288
    signed int _t290;                      // _t290
    intOrPtr* _t291;                       // _t291
    _unknown_ _t292;                       // _t292
    _unknown_ _t293;                       // _t293
    signed int _t294;                      // _t294

    _t288 = __eax;
    __esp = __esp - 32;
    __ecx = _t288;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 76;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    __eax = __eax + 4;
     *(__eax - 4) = 5367;
     *__eax = caml_curry7;
     *(__eax + 4) = 15;
     *((intOrPtr*)(__eax + 8)) = camlArray__merge_1191;
     *(__eax + 12) = __ecx;
     *(__eax + 16) = __ebx;
    __esi = __eax + 24;
     *(__esi - 4) = 5367;
     *__esi = caml_curry4;
     *((intOrPtr*)(__esi + 4)) = 9;
     *((intOrPtr*)(__esi + 8)) = camlArray__isortto_1209;
     *(__esi + 12) = __ecx;
     *(__esi + 16) = __ebx;
    __ecx = __eax + 48;
     *(__ecx - 4) = 6391;
     *__ecx = caml_curry4;
     *((intOrPtr*)(__ecx + 4)) = 9;
     *((intOrPtr*)(__ecx + 8)) = camlArray__sortto_1217;
     *(__ecx + 12) = __ebx;
     *(__ecx + 16) = __eax;
     *(__ecx + 20) = __esi;
    __edx =  *(__ebx - 4);
    __edx = __edx & 255;
    if((__edx & 255) == 254) {
        __edx = __edx >> 10;
    } else {
        __edx = __edx >> 9;
    }
    __edx = __edx | 1;
    if(__edx > 11) {
         *__esp = __ecx;
        (__esp)[5] = __eax;
        (__esp)[4] = __ebx;
        __eax = __edx;
        __eax = __edx >> 1;
        if(__eax < 0) {
            __eax = __eax + 1;
        }
        __eax = __eax >> 1;
        __eax = __eax + __eax + 1;
        (__esp)[2] = __eax;
        __edx = __edx - __eax;
        __edx = __edx + 1;
        (__esp)[1] = __edx;
        __eax =  *(__ebx - 4);
        __eax = __eax & 255;
        if((__eax & 255) == 254) {
            if(__eax <= 1) {
                __eax = caml_ml_array_bound_error();
            } else {
                while(1) {
                    __eax = caml_young_ptr;
                    __eax = caml_young_ptr - 12;
                    caml_young_ptr = __eax;
                    if(__eax >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                __eax = __eax + 4;
                 *(__eax - 4) = 2301;
                asm("fld qword [ebx]");
                asm("fstp qword [eax]");
                goto L180;
            }
            goto L184;
        } else {
            if(__eax <= 1) {
L184:
                __eax = caml_ml_array_bound_error();
                __esi = __esi;
            } else {
                __eax =  *__ebx;
L180:
                _push(__eax);
                _push(__edx);
                __eax = caml_make_vect;
                caml_c_call();
                __esp =  &((__esp)[2]);
                __ebx = caml_make_vect;
                (__esp)[3] = caml_make_vect;
                __ecx = 1;
                __eax = (__esp)[2];
                __edx = (__esp)[1];
                __esi =  *__esp;
                L124();
                __eax = 1;
                __ebx = (__esp)[4];
                __ecx = (__esp)[1];
                __edx = (__esp)[2];
                __esi =  *__esp;
                L124();
                __ebp = 1;
                __edx = 1;
                __eax = (__esp)[1];
                __ebx = (__esp)[2];
                __ecx = (__esp)[3];
                __esi = __eax;
                __edi = (__esp)[4];
                caml_extra_params = 1;
                __ebp = (__esp)[5];
                 *134693344 = (__esp)[5];
                __esp =  &((__esp)[8]);
L51:
                __esp = __esp - 28;
                 *__esp = __eax;
                (__esp)[1] = __ecx;
                (__esp)[4] = __edx;
                (__esp)[2] = __edi;
                __eax = caml_extra_params;
                (__esp)[3] = caml_extra_params;
                __ebp =  *134693344;
                __ecx =  *__esp;
                __edx = __ecx + __ebx - 1;
                __eax = (__esp)[4];
                __esi = (__esp)[4] + __esi - 1;
                while(1) {
                    __eax = caml_young_ptr;
                    __eax = caml_young_ptr - 40;
                    caml_young_ptr = __eax;
                    if(__eax >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                __edi = __eax + 4;
                 *(__edi - 4) = 9463;
                 *__edi = caml_curry5;
                 *((intOrPtr*)(__edi + 4)) = 11;
                 *((intOrPtr*)(__edi + 8)) =  &camlArray__code_begin;
                __eax =  *(__ebp + 12);
                 *(__edi + 12) =  *(__ebp + 12);
                __eax =  *(__ebp + 16);
                 *(__edi + 16) =  *(__ebp + 16);
                __ebx = (__esp)[1];
                 *(__edi + 20) = __ebx;
                __eax = (__esp)[2];
                 *(__edi + 24) = (__esp)[2];
                 *(__edi + 28) = __edx;
                 *(__edi + 32) = __esi;
                __eax =  *(__ebx - 4);
                __eax = __eax & 255;
                if((__eax & 255) == 254) {
                    if(__eax <= (__esp)[4]) {
                        goto L71;
                    } else {
                        while(1) {
                            __eax = caml_young_ptr;
                            __eax = caml_young_ptr - 12;
                            caml_young_ptr = __eax;
                            if(__eax >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                        __edx = __eax + 4;
                         *(__edx - 4) = 2301;
                        __eax = (__esp)[4];
                        asm("fld qword [ebx+eax*4-0x4]");
                        asm("fstp qword [edx]");
                        goto L59;
                    }
                    goto L72;
                } else {
                    if(__eax <= (__esp)[4]) {
L72:
                        __eax = caml_ml_array_bound_error();
                        __esi = __esi;
                        while(1) {
L73:
                            __esp = __esp - 40;
                            __edi = 1;
                            __edx = __edx + -2;
                            if(__edi > __edx) {
                                break;
                            }
                            (__esp)[4] = __edx;
                            (__esp)[3] = __edi;
                            (__esp)[6] = __esi;
                            (__esp)[5] = __ecx;
                            (__esp)[7] = __ebx;
                             *__esp = __eax;
                            goto L75;
                            do {
L75:
                                __eax =  *__esp;
                                __eax =  *__esp + __edi - 1;
                                (__esp)[1] = __eax;
                                __ecx = (__esp)[6];
                                __ecx =  *((__esp)[6] + 16);
                                __edx =  *(__ecx - 4);
                                (__esp)[2] =  *(__ecx - 4);
                                (__esp)[2] = (__esp)[2] & 255;
                                if(((__esp)[2] & 255) == 254) {
                                    (__esp)[2] = (__esp)[2] >> 10;
                                    if((__esp)[2] >> 10 <= __eax) {
                                        goto L122;
                                    } else {
                                        while(1) {
                                            __eax = caml_young_ptr;
                                            __eax = caml_young_ptr - 12;
                                            caml_young_ptr = __eax;
                                            if(__eax >= caml_young_limit) {
                                                break;
                                            }
                                            caml_call_gc(__esp);
                                        }
                                        __edx = __eax + 4;
                                         *(__edx - 4) = 2301;
                                        __eax = (__esp)[1];
                                        asm("fld qword [ecx+eax*4-0x4]");
                                        asm("fstp qword [edx]");
                                        (__esp)[1] = __edx;
                                        goto L81;
                                    }
                                    goto L123;
                                } else {
                                    (__esp)[2] = (__esp)[2] >> 9;
                                    if((__esp)[2] >> 9 <= __eax) {
L123:
                                        __eax = caml_ml_array_bound_error();
                                        __esi = __esi;
                                        __esp = __esp - 24;
                                        if(__edx > 11) {
                                             *__esp = __esi;
                                            (__esp)[2] = __ecx;
                                            (__esp)[5] = __ebx;
                                            (__esp)[4] = __eax;
                                            __esi = __edx;
                                            __esi = __edx >> 1;
                                            if(__esi < 0) {
                                                __esi = __esi + 1;
                                            }
                                            __esi = __esi >> 1;
                                            __esi = __esi + __esi + 1;
                                            (__esp)[1] = __esi;
                                            __edx = __edx - __esi;
                                            (__esp)[3] = __edx;
                                            __ecx = __ecx + __esi - 1;
                                            __eax = __eax + __esi - 1;
                                            __edx = (__esp)[3];
                                            __esi =  *__esp;
                                            L124();
                                            __ebx = (__esp)[3];
                                            __eax = (__esp)[4];
                                            __ecx = (__esp)[4] + (__esp)[3] - 1;
                                            __esi =  *__esp;
                                            __ebx =  *( *__esp + 12);
                                            __edx = (__esp)[1];
                                            L124();
                                            __eax =  *__esp;
                                            __eax =  *( *__esp + 16);
                                             *__esp =  *( *__esp + 16);
                                            __ebx = (__esp)[1];
                                            __ebp = (__esp)[2];
                                            __edx = __ebp + __ebx - 1;
                                            __esi = (__esp)[3];
                                            __eax = (__esp)[4];
                                            __eax = (__esp)[4] + __esi - 1;
                                            __ecx = (__esp)[5];
                                            __edi = __ecx;
                                            caml_extra_params = __ebp;
                                            __ebp =  *__esp;
                                             *134693344 =  *__esp;
                                            __esp =  &((__esp)[6]);
                                            goto L51;
                                        }
                                        __esi =  *(__esi + 20);
                                        __esp =  &((__esp)[6]);
                                        goto L73;
                                    } else {
                                        __edx =  *(__ecx + __eax * 2 - 2);
                                        (__esp)[1] =  *(__ecx + __eax * 2 - 2);
                                        while(1) {
L81:
                                            __eax = caml_young_ptr;
                                            __eax = caml_young_ptr - 8;
                                            caml_young_ptr = __eax;
                                            if(__eax >= caml_young_limit) {
                                                break;
                                            }
                                            caml_call_gc(__esp);
                                        }
                                        __esi = __eax + 4;
                                        (__esp)[2] = __esi;
                                         *(__esi - 4) = 1024;
                                        __eax = (__esp)[5];
                                        __eax = (__esp)[5] + __edi - 3;
                                         *__esi = (__esp)[5] + __edi - 3;
                                        while(1) {
                                            __ecx =  *__esi;
                                            __eax = (__esp)[5];
                                            if( *__esi < (__esp)[5]) {
                                                break;
                                            }
                                            __ecx =  *__esi;
                                            __eax =  *(__ebx - 4);
                                            __eax = __eax & 255;
                                            if((__eax & 255) == 254) {
                                                if(__eax <= __ecx) {
                                                    goto L120;
                                                } else {
                                                    while(1) {
                                                        __eax = caml_young_ptr;
                                                        __eax = caml_young_ptr - 12;
                                                        caml_young_ptr = __eax;
                                                        if(__eax >= caml_young_limit) {
                                                            break;
                                                        }
                                                        caml_call_gc(__esp);
                                                    }
                                                    __eax = __eax + 4;
                                                     *(__eax - 4) = 2301;
                                                    asm("fld qword [ebx+ecx*4-0x4]");
                                                    asm("fstp qword [eax]");
                                                    goto L90;
                                                }
                                                goto L121;
                                            } else {
                                                if(__eax <= __ecx) {
L121:
                                                    __eax = caml_ml_array_bound_error();
                                                } else {
                                                    __eax =  *(__ebx + __ecx * 2 - 2);
L90:
                                                    __ebx = (__esp)[6];
                                                    __ecx =  *((__esp)[6] + 12);
                                                    __ebx = (__esp)[1];
                                                    caml_apply2();
                                                    if(__eax <= 1) {
                                                        break;
                                                    } else {
                                                        __esi = (__esp)[2];
                                                        __ecx =  *__esi;
                                                        __ebx = (__esp)[7];
                                                        __eax =  *(__ebx - 4);
                                                        __eax = __eax & 255;
                                                        if((__eax & 255) == 254) {
                                                            if(__eax <= __ecx) {
                                                                goto L118;
                                                            } else {
                                                                while(1) {
                                                                    __eax = caml_young_ptr;
                                                                    __eax = caml_young_ptr - 12;
                                                                    caml_young_ptr = __eax;
                                                                    if(__eax >= caml_young_limit) {
                                                                        break;
                                                                    }
                                                                    caml_call_gc(__esp);
                                                                }
                                                                __edx = __eax + 4;
                                                                 *(__edx - 4) = 2301;
                                                                asm("fld qword [ebx+ecx*4-0x4]");
                                                                asm("fstp qword [edx]");
                                                                goto L97;
                                                            }
                                                            goto L119;
                                                        } else {
                                                            if(__eax <= __ecx) {
L119:
                                                                __eax = caml_ml_array_bound_error();
                                                            } else {
                                                                __edx =  *(__ebx + __ecx * 2 - 2);
L97:
                                                                __eax =  *__esi;
                                                                __eax =  *__esi + 2;
                                                                __ecx =  *(__ebx - 4);
                                                                __ecx = __ecx & 255;
                                                                if((__ecx & 255) == 254) {
                                                                    if(__ecx <= __eax) {
L116:
                                                                        __eax = caml_ml_array_bound_error();
                                                                    } else {
                                                                        asm("fld qword [edx]");
                                                                        asm("fstp qword [ebx+eax*4-0x4]");
                                                                        goto L102;
                                                                    }
                                                                    goto L117;
                                                                } else {
                                                                    if(__ecx <= __eax) {
L117:
                                                                        __eax = caml_ml_array_bound_error();
                                                                    } else {
                                                                        caml_modify(__eax, __edx);
L102:
                                                                         *__esi =  *__esi + -2;
                                                                        continue;
                                                                    }
L118:
                                                                    __eax = caml_ml_array_bound_error();
                                                                    goto L119;
                                                                }
                                                                goto L186;
                                                            }
L120:
                                                            __eax = caml_ml_array_bound_error();
                                                            goto L121;
                                                        }
                                                    }
                                                    goto L186;
                                                }
L122:
                                                __eax = caml_ml_array_bound_error();
                                                goto L123;
                                            }
                                            goto L186;
                                        }
                                        (__esp)[2] =  *((__esp)[2]);
                                        __eax =  *((__esp)[2]) + 2;
                                        __ebx = (__esp)[7];
                                        __ecx =  *(__ebx - 4);
                                        __ecx = __ecx & 255;
                                        if((__ecx & 255) == 254) {
                                            if(__ecx <= __eax) {
                                                __eax = caml_ml_array_bound_error();
                                            } else {
                                                __ecx = (__esp)[1];
                                                asm("fld qword [ecx]");
                                                asm("fstp qword [ebx+eax*4-0x4]");
                                                goto L108;
                                            }
                                            goto L115;
                                        } else {
                                            if(__ecx <= __eax) {
L115:
                                                __eax = caml_ml_array_bound_error();
                                            } else {
                                                __ecx = (__esp)[1];
                                                caml_modify(__eax, (__esp)[1]);
                                                goto L108;
                                            }
                                            goto L116;
                                        }
                                    }
                                }
                                goto L186;
L108:
                                __edi = (__esp)[3];
                                __ecx = __edi;
                                __edi = __edi + 2;
                                (__esp)[3] = __edi;
                                __eax = (__esp)[4];
                            } while(__ecx != (__esp)[4]);
                            break;
                        }
                        __eax = 1;
                        __esp =  &((__esp)[0xa]);
                        return 1;
                    } else {
                        __eax = (__esp)[4];
                        __edx =  *(__ebx + (__esp)[4] * 2 - 2);
L59:
                        __esi =  *(__ebp + 16);
                        __eax =  *(__esi - 4);
                        __ebx = __eax;
                        __ebx = __eax & 255;
                        if(__ebx == 254) {
                            if(__eax <= __ecx) {
                                __eax = caml_ml_array_bound_error();
                            } else {
                                while(1) {
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 12;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        break;
                                    }
                                    caml_call_gc(__esp);
                                }
                                __ebx = __eax + 4;
                                 *(__ebx - 4) = 2301;
                                asm("fld qword [esi+ecx*4-0x4]");
                                asm("fstp qword [ebx]");
                                goto L65;
                            }
                            goto L70;
                        } else {
                            if(__eax <= __ecx) {
L70:
                                __eax = caml_ml_array_bound_error();
                            } else {
                                __ebx =  *(__esi + __ecx * 2 - 2);
L65:
                                __eax = __ecx;
                                __ecx = (__esp)[4];
                                __esi = (__esp)[3];
                                __esp =  &((__esp)[7]);
                                __esp = __esp - 32;
                                while(1) {
L6:
                                    (__esp)[1] = __eax;
                                    __eax = __ebx;
                                    (__esp)[5] = __eax;
                                    (__esp)[2] = __ecx;
                                    (__esp)[3] = __edx;
                                    (__esp)[4] = __esi;
                                     *__esp = __edi;
                                    __ecx =  *(__edi + 12);
                                    __ebx = __edx;
                                    caml_apply2();
                                    if(__eax > 1) {
                                        break;
                                    }
                                    __edi =  *__esp;
                                    __eax =  *(__edi + 24);
                                    __ebx =  *(__eax - 4);
                                    __ebx = __ebx & 255;
                                    if((__ebx & 255) == 254) {
                                        __ebx = __ebx >> 10;
                                        __esi = (__esp)[4];
                                        if(__ebx <= __esi) {
                                            goto L43;
                                        } else {
                                            __ebx = (__esp)[5];
                                            asm("fld qword [ebx]");
                                            asm("fstp qword [eax+esi*4-0x4]");
                                            goto L12;
                                        }
                                        goto L44;
                                    } else {
                                        __ebx = __ebx >> 9;
                                        __esi = (__esp)[4];
                                        if(__ebx <= __esi) {
L44:
                                            __eax = caml_ml_array_bound_error();
                                            __esi = __esi;
L45:
                                            while(__ebx != 1) {
                                                __ecx =  *(__ebx + 4);
                                                __ebx =  *__ebx;
                                                __ebx =  *(__ebx - 4);
                                                __ebx = __ebx & 255;
                                                if((__ebx & 255) == 254) {
                                                    __ebx = __ebx >> 10;
                                                } else {
                                                    __ebx = __ebx >> 9;
                                                }
                                                __eax = __eax + __ebx;
                                                __eax = __eax - 1;
                                                __ebx = __ecx;
                                            }
                                            return __eax;
                                        } else {
                                            __ebx = (__esp)[5];
                                            caml_modify(__eax, __ebx);
L12:
                                            __ecx = (__esp)[1];
                                            __ecx = (__esp)[1] + 2;
                                            __eax =  *(__edi + 28);
                                            if(__ecx >=  *(__edi + 28)) {
                                                __ebp =  *(__edi + 32);
                                                __ebx = (__esp)[2];
                                                 *(__edi + 32) - __ebx =  *(__edi + 32) - __ebx + 1;
                                                __esi = __esi + 2;
                                                __ecx =  *(__edi + 24);
                                                __eax =  *(__edi + 20);
                                                __edx = __esi;
                                                __esi =  *(__edi + 32) - __ebx + 1;
                                                __esp =  &((__esp)[8]);
L129:
                                                __esp = __esp - 24;
                                                __edi = __eax;
                                                (__esp)[2] = __ecx;
                                                __ebp = __edx;
                                                if(__esi < 1 || __ebx < 1) {
L163:
                                                    __eax = "Array.blit";
                                                    __esp =  &((__esp)[6]);
                                                    _t294 = _t288;
                                                    while(1) {
                                                        _t290 = caml_young_ptr - 12;
                                                        caml_young_ptr = _t290;
                                                        if(_t290 >= caml_young_limit) {
                                                            _t291 = _t290 + 4;
                                                             *((intOrPtr*)(_t291 - 4)) = 2048;
                                                             *_t291 =  &caml_exn_Invalid_argument;
                                                             *(_t291 + 4) = _t294;
                                                            caml_raise_exn(_t291);
                                                        }
                                                        caml_call_gc(__esp);
                                                    }
                                                }
                                                __ecx =  *(__edi - 4);
                                                __ecx = __ecx & 255;
                                                if((__ecx & 255) == 254) {
                                                    __eax = __ecx;
                                                    __eax = __ecx >> 10;
                                                } else {
                                                    __eax = __ecx;
                                                    __eax = __ecx >> 9;
                                                }
                                                __eax = __eax | 1;
                                                __eax = __eax - __esi;
                                                if(__ebx > __eax || __ebp < 1) {
                                                    goto L163;
                                                }
                                                __eax = (__esp)[2];
                                                __ecx =  *((__esp)[2] - 4);
                                                __ecx = __ecx & 255;
                                                if((__ecx & 255) == 254) {
                                                    __eax = __ecx;
                                                    __eax = __ecx >> 10;
                                                } else {
                                                    __eax = __ecx;
                                                    __eax = __ecx >> 9;
                                                }
                                                __eax = __eax | 1;
                                                __eax = __eax - __esi;
                                                if(__ebp > __eax) {
                                                    goto L163;
                                                }
                                                if(__ebx >= __ebp) {
                                                    __eax = 1;
                                                    (__esp)[3] = 1;
                                                    __esi = __esi + -2;
                                                    if((__esp)[3] > __esi) {
                                                    } else {
                                                        (__esp)[1] = __ebx;
                                                         *__esp = __edi;
                                                        goto L154;
                                                        do {
L154:
                                                            __ebx = (__esp)[1];
                                                            __eax = (__esp)[3];
                                                            __ebx = (__esp)[1] + (__esp)[3] - 1;
                                                            __eax =  *__esp;
                                                            __ecx =  *(__eax - 4) & 255;
                                                            if(( *(__eax - 4) & 255) == 254) {
                                                                while(1) {
                                                                    __eax = caml_young_ptr;
                                                                    __eax = caml_young_ptr - 12;
                                                                    caml_young_ptr = __eax;
                                                                    if(__eax >= caml_young_limit) {
                                                                        break;
                                                                    }
                                                                    caml_call_gc(__esp);
                                                                }
                                                                __ecx = __eax + 4;
                                                                 *(__ecx - 4) = 2301;
                                                                __eax =  *__esp;
                                                                asm("fld qword [eax+ebx*4-0x4]");
                                                                asm("fstp qword [ecx]");
                                                                __ebx = __ecx;
                                                                goto L158;
                                                            }
                                                            __ebx =  *(__eax + __ebx * 2 - 2);
L158:
                                                            __ecx = (__esp)[3];
                                                            __eax = __ebp;
                                                            __eax = __ebp + (__esp)[3] - 1;
                                                            __ecx = (__esp)[2];
                                                            __ecx =  *((__esp)[2] - 4) & 255;
                                                            if(( *((__esp)[2] - 4) & 255) == 254) {
                                                                asm("fld qword [ebx]");
                                                                __ebx = (__esp)[2];
                                                                asm("fstp qword [ebx+eax*4-0x4]");
                                                            } else {
                                                                _push(__ebx);
                                                                __ebx = (__esp)[3];
                                                                _push(__eax);
                                                                caml_modify(__ebx);
                                                                __esp =  &((__esp)[2]);
                                                            }
                                                            __ebx = (__esp)[3];
                                                            (__esp)[3] = (__esp)[3] + 2;
                                                            (__esp)[3] = (__esp)[3] + 2;
                                                        } while((__esp)[3] != __esi);
                                                    }
                                                } else {
                                                    __esi = __esi + -2;
                                                    if(__esi >= 1) {
                                                        (__esp)[1] = __ebx;
                                                        goto L143;
                                                        do {
L143:
                                                            __eax = (__esp)[1];
                                                            __ebx = (__esp)[1] + __esi - 1;
                                                            __eax =  *(__edi - 4) & 255;
                                                            if(( *(__edi - 4) & 255) == 254) {
                                                                while(1) {
                                                                    __eax = caml_young_ptr;
                                                                    __eax = caml_young_ptr - 12;
                                                                    caml_young_ptr = __eax;
                                                                    if(__eax >= caml_young_limit) {
                                                                        break;
                                                                    }
                                                                    caml_call_gc(__esp);
                                                                }
                                                                __eax = __eax + 4;
                                                                 *(__eax - 4) = 2301;
                                                                asm("fld qword [edi+ebx*4-0x4]");
                                                                asm("fstp qword [eax]");
                                                                __ebx = __eax;
                                                                goto L147;
                                                            }
                                                            __ebx =  *(__edi + __ebx * 2 - 2);
L147:
                                                            __eax = __ebp;
                                                            __eax = __ebp + __esi - 1;
                                                            __ecx = (__esp)[2];
                                                            __ecx =  *((__esp)[2] - 4) & 255;
                                                            if(( *((__esp)[2] - 4) & 255) == 254) {
                                                                asm("fld qword [ebx]");
                                                                __ebx = (__esp)[2];
                                                                asm("fstp qword [ebx+eax*4-0x4]");
                                                            } else {
                                                                _push(__ebx);
                                                                __ebx = (__esp)[3];
                                                                _push(__eax);
                                                                caml_modify(__ebx);
                                                                __esp =  &((__esp)[2]);
                                                            }
                                                            __ebx = __esi;
                                                            __esi = __esi - 2;
                                                            __esi = __esi - 2;
                                                        } while(__ebx != 1);
                                                    }
                                                    __eax = 1;
                                                    __esp =  &((__esp)[6]);
                                                    return 1;
                                                    goto L186;
                                                }
                                                __eax = 1;
                                                __esp =  &((__esp)[6]);
                                                return 1;
                                                goto L186;
                                            }
                                            __ebx =  *(__edi + 16);
                                            __edx =  *(__ebx - 4);
                                            __edx = __edx & 255;
                                            if((__edx & 255) == 254) {
                                                if(__edx >> 10 <= __ecx) {
L41:
                                                    __eax = caml_ml_array_bound_error();
                                                } else {
                                                    while(1) {
                                                        __eax = caml_young_ptr;
                                                        __eax = caml_young_ptr - 12;
                                                        caml_young_ptr = __eax;
                                                        if(__eax >= caml_young_limit) {
                                                            break;
                                                        }
                                                        caml_call_gc(__esp);
                                                    }
                                                    __edx = __eax + 4;
                                                     *(__edx - 4) = 2301;
                                                    asm("fld qword [ebx+ecx*4-0x4]");
                                                    asm("fstp qword [edx]");
                                                    __ebx = __edx;
                                                    goto L19;
                                                }
                                                goto L42;
                                            } else {
                                                if(__edx >> 9 <= __ecx) {
L42:
                                                    __eax = caml_ml_array_bound_error();
                                                } else {
                                                    __ebx =  *(__ebx + __ecx * 2 - 2);
L19:
                                                    __esi = __esi + 2;
                                                    __eax = __ecx;
                                                    __ecx = (__esp)[2];
                                                    __edx = (__esp)[3];
                                                    continue;
                                                }
L43:
                                                __eax = caml_ml_array_bound_error();
                                                goto L44;
                                            }
                                        }
                                    }
                                    goto L186;
                                }
                                __edi =  *__esp;
                                __eax =  *(__edi + 24);
                                __ebx =  *(__eax - 4);
                                __ebx = __ebx & 255;
                                if((__ebx & 255) == 254) {
                                    __ebx = __ebx >> 10;
                                    __esi = (__esp)[4];
                                    if(__ebx <= __esi) {
                                        goto L39;
                                    } else {
                                        __ebx = (__esp)[3];
                                        asm("fld qword [ebx]");
                                        asm("fstp qword [eax+esi*4-0x4]");
                                        goto L26;
                                    }
                                    goto L40;
                                } else {
                                    __ebx = __ebx >> 9;
                                    __esi = (__esp)[4];
                                    if(__ebx <= __esi) {
L40:
                                        __eax = caml_ml_array_bound_error();
                                    } else {
                                        __ebx = (__esp)[3];
                                        caml_modify(__eax, __ebx);
L26:
                                        __ecx = (__esp)[2];
                                        __ecx = (__esp)[2] + 2;
                                        __eax =  *(__edi + 32);
                                        if(__ecx >=  *(__edi + 32)) {
                                            __ebp =  *(__edi + 28);
                                            __ebx = (__esp)[1];
                                             *(__edi + 28) - __ebx =  *(__edi + 28) - __ebx + 1;
                                            __esi = __esi + 2;
                                            __ecx =  *(__edi + 24);
                                            __eax =  *(__edi + 16);
                                            __edx = __esi;
                                            __esi =  *(__edi + 28) - __ebx + 1;
                                            __esp =  &((__esp)[8]);
                                            goto L129;
                                        }
                                        __ebx =  *(__edi + 20);
                                        __edx =  *(__ebx - 4);
                                        __edx = __edx & 255;
                                        if((__edx & 255) == 254) {
                                            if(__edx >> 10 <= __ecx) {
                                                __eax = caml_ml_array_bound_error();
                                            } else {
                                                while(1) {
                                                    __eax = caml_young_ptr;
                                                    __eax = caml_young_ptr - 12;
                                                    caml_young_ptr = __eax;
                                                    if(__eax >= caml_young_limit) {
                                                        break;
                                                    }
                                                    caml_call_gc(__esp);
                                                }
                                                __edx = __eax + 4;
                                                 *(__edx - 4) = 2301;
                                                asm("fld qword [ebx+ecx*4-0x4]");
                                                asm("fstp qword [edx]");
                                                goto L33;
                                            }
                                            goto L38;
                                        } else {
                                            if(__edx >> 9 <= __ecx) {
L38:
                                                __eax = caml_ml_array_bound_error();
                                            } else {
                                                __edx =  *(__ebx + __ecx * 2 - 2);
L33:
                                                __esi = __esi + 2;
                                                __eax = (__esp)[1];
                                                __ebx = (__esp)[5];
                                                goto L6;
                                            }
L39:
                                            __eax = caml_ml_array_bound_error();
                                            goto L40;
                                        }
                                        goto L186;
                                    }
                                    goto L41;
                                }
                                goto L186;
                            }
L71:
                            __eax = caml_ml_array_bound_error();
                            goto L72;
                        }
                    }
                }
                goto L186;
            }
            __eax =  ?_? ( &camlArray__21);
            camlArray =  &camlArray__21;
            __eax =  ?_? ( &camlArray__20);
             *134682212 =  &camlArray__20;
            __eax =  *134682212;
             *134682216 =  *134682212;
            __eax =  ?_? ( &camlArray__19);
             *134682232 =  &camlArray__19;
            __eax =  ?_? ( &camlArray__18);
             *134682220 =  &camlArray__18;
            __eax =  ?_? ( &camlArray__17);
             *134682288 =  &camlArray__17;
            __eax =  ?_? ( &camlArray__16);
             *134682224 =  &camlArray__16;
            __eax =  ?_? ( &camlArray__15);
             *134682228 =  &camlArray__15;
            __eax =  ?_? ( &camlArray__14);
             *134682236 =  &camlArray__14;
            __eax =  ?_? ( &camlArray__13);
             *134682240 =  &camlArray__13;
            __eax =  ?_? ( &camlArray__12);
             *134682252 =  &camlArray__12;
            __eax =  ?_? ( &camlArray__11);
             *134682256 =  &camlArray__11;
            __eax =  ?_? ( &camlArray__10);
             *134682260 =  &camlArray__10;
            __eax =  ?_? ( &camlArray__9);
             *134682264 =  &camlArray__9;
            __eax =  ?_? ( &camlArray__8);
             *134682244 =  &camlArray__8;
            __eax =  ?_? ( &camlArray__7);
             *134682292 =  &camlArray__7;
            __eax =  ?_? ( &camlArray__6);
             *134682248 =  &camlArray__6;
            __eax =  ?_? ( &camlArray__5);
             *134682268 =  &camlArray__5;
            __eax =  ?_? ( &camlArray__4);
             *134682272 =  &camlArray__4;
            caml_alloc1(__esp);
            __eax = __eax + 4;
             *(__eax - 4) = 1024;
             *__eax = "Array.Bottom";
             *134682296 = __eax;
            __eax =  ?_? ( &camlArray__2);
             *134682276 =  &camlArray__2;
             *134682300 = 11;
            __eax =  ?_? ( &camlArray__1);
             *134682280 =  &camlArray__1;
            __eax =  *134682280;
             *134682284 =  *134682280;
            __eax = 1;
            return 1;
        }
L186:
    }
    __ecx = 1;
    __eax = 1;
    __esp =  &((__esp)[8]);
    goto L73;
}

camlArray__entry()
{// addr = 0x08052C60
    char* _t21;                            // _t21
    intOrPtr* _t22;                        // _t22
    _unknown_ _t26;                        // _t26

    camlArray =  &camlArray__21;
     *134682212 =  &camlArray__20;
     *134682216 =  *134682212;
     *134682232 =  &camlArray__19;
     *134682220 =  &camlArray__18;
     *134682288 =  &camlArray__17;
     *134682224 =  &camlArray__16;
     *134682228 =  &camlArray__15;
     *134682236 =  &camlArray__14;
     *134682240 =  &camlArray__13;
     *134682252 =  &camlArray__12;
     *134682256 =  &camlArray__11;
     *134682260 =  &camlArray__10;
     *134682264 =  &camlArray__9;
     *134682244 =  &camlArray__8;
     *134682292 =  &camlArray__7;
     *134682248 =  &camlArray__6;
     *134682268 =  &camlArray__5;
    _t21 =  &camlArray__4;
     *134682272 = _t21;
    caml_alloc1(__esp);
    _t22 = _t21 + 4;
     *((intOrPtr*)(_t22 - 4)) = 1024;
     *_t22 = "Array.Bottom";
     *134682296 = _t22;
     *134682276 =  &camlArray__2;
     *134682300 = 11;
     *134682280 =  &camlArray__1;
     *134682284 =  *134682280;
    return 1;
}

camlList__nth_aux_1045(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx                        // r1
)
{// addr = 0x08052D70
    intOrPtr _t7;                          // _t7
    intOrPtr* _t8;                         // _t8
    _unknown_ _t9;                         // _t9
    _unknown_ _t10;                        // _t10
    char* _t11;                            // _t11

    while(__eax != 1) {
        __ecx =  *((intOrPtr*)(__eax + 4));
        __eax =  *__eax;
        if(__ebx != 1) {
            __ebx = __ebx + -2;
            __eax = __ecx;
            continue;
        }
        return __eax;
    }
    _t11 =  &camlList__53;
    while(1) {
        _t7 = caml_young_ptr - 12;
        caml_young_ptr = _t7;
        if(_t7 >= caml_young_limit) {
            _t8 = _t7 + 4;
             *((intOrPtr*)(_t8 - 4)) = 2048;
             *_t8 =  &caml_exn_Failure;
             *((intOrPtr*)(_t8 + 4)) = _t11;
            caml_raise_exn(_t8);
        }
        caml_call_gc(__esp);
    }
}

camlList__rmap_f_1070(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx,                       // r1
    intOrPtr __ecx,                        // r2
    intOrPtr* __esp                        // r7
)
{// addr = 0x08052DA0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _t10;                        // _t10
    intOrPtr _t14;                         // _t14
    intOrPtr* _t15;                        // _t15
    intOrPtr _t17;                         // _t17
    intOrPtr _t19;                         // _t19

    __esp = __esp;
    _t19 = __ecx;
    _t15 = __ebx;
    _t10 = __eax;
    while(_t15 != 1) {
        _v4 = _t19;
         *__esp = _t10;
        _v8 =  *((intOrPtr*)(_t15 + 4));
         *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t19 + 12))))))();
        _t17 =  *_t15;
        while(1) {
            _t14 = caml_young_ptr - 12;
            caml_young_ptr = _t14;
            if(_t14 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t10 = _t14 + 4;
         *((intOrPtr*)(_t10 - 4)) = 2048;
         *_t10 = _t17;
         *((intOrPtr*)(_t10 + 4)) =  *__esp;
        _t15 = _v8;
        _t19 = _v4;
    }
    return;
}

camlList__rmap2_f_1103(
    intOrPtr __eax,                        // r0
    _unknown_ __ebx,                       // r1
    intOrPtr* __ecx,                       // r2
    intOrPtr __edx,                        // r3
    intOrPtr* __esp                        // r7
)
{// addr = 0x08052E10
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _v8;                         // _cfa_fffffff8
    intOrPtr* _v12;                        // _cfa_fffffff4
    intOrPtr _t16;                         // _t16
    intOrPtr _t18;                         // _t18
    intOrPtr* _t19;                        // _t19
    _unknown_ _t20;                        // _t20
    _unknown_ _t21;                        // _t21
    intOrPtr _t22;                         // _t22

    __esp = __esp;
    __edx = __edx;
    __ecx = __ecx;
    _t16 = __eax;
    while(__ebx != 1) {
        if(__ecx == 1) {
L12:
            __eax = "List.rev_map2";
            __esp = __esp + 16;
            _t22 = _t16;
            while(1) {
                _t18 = caml_young_ptr - 12;
                caml_young_ptr = _t18;
                if(_t18 >= caml_young_limit) {
                    _t19 = _t18 + 4;
                     *((intOrPtr*)(_t19 - 4)) = 2048;
                     *_t19 =  &caml_exn_Invalid_argument;
                     *((intOrPtr*)(_t19 + 4)) = _t22;
                    caml_raise_exn(_t19);
                }
                caml_call_gc(__esp);
            }
        }
        _v4 = __edx;
         *__esp = __eax;
        __eax =  *((intOrPtr*)(__ecx + 4));
        _v8 =  *((intOrPtr*)(__ecx + 4));
        __esi =  *__ecx;
        __eax =  *((intOrPtr*)(__ebx + 4));
        _v12 =  *((intOrPtr*)(__ebx + 4));
        __eax =  *__ebx;
        __ecx =  *((intOrPtr*)(__edx + 12));
        __ebx = __esi;
        caml_apply2();
        __ebx = __eax;
        while(1) {
L8:
            __eax = caml_young_ptr;
            __eax = caml_young_ptr - 12;
            caml_young_ptr = __eax;
            if(__eax >= caml_young_limit) {
                break;
            }
            goto L13;
        }
        __eax = __eax + 4;
         *((intOrPtr*)(__eax - 4)) = 2048;
         *__eax = __ebx;
        __ebx =  *__esp;
         *((intOrPtr*)(__eax + 4)) =  *__esp;
        __ebx = _v12;
        __ecx = _v8;
        __edx = _v4;
        continue;
L13:
        caml_call_gc(__esp);
        goto L8;
    }
    if(__ecx != 1) {
        goto L12;
    }
    return;
}

camlList__find_1207(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx,                       // r1
    intOrPtr __ecx                         // r2
)
{// addr = 0x08052EB0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _v12;                        // _cfa_fffffff4
    intOrPtr* _t19;                        // _t19
    _unknown_ _t20;                        // _t20
    intOrPtr _t22;                         // _t22
    intOrPtr _t24;                         // _t24
    intOrPtr _t26;                         // _t26
    intOrPtr* _t27;                        // _t27
    intOrPtr* _t28;                        // _t28
    intOrPtr _t32;                         // _t32
    intOrPtr* _t33;                        // _t33

    _t32 = __ecx;
    _t27 = __ebx;
    _t19 = __eax;
    __esp = __esp - 16;
    while(_t27 != 1) {
        _v4 = _t32;
        _v12 = _t19;
        _v8 =  *((intOrPtr*)(_t27 + 4));
        _t24 =  *_t27;
         *__esp = _t24;
         *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t32 + 12))))))();
        if(_t24 == 1) {
            _t19 = _v12;
            _t27 = _v8;
            _t32 = _v4;
        } else {
            while(1) {
                _t26 = caml_young_ptr - 12;
                caml_young_ptr = _t26;
                if(_t26 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t19 = _t26 + 4;
             *((intOrPtr*)(_t19 - 4)) = 2048;
             *_t19 =  *__esp;
             *((intOrPtr*)(_t19 + 4)) = _v12;
            _t27 = _v8;
            _t32 = _v4;
        }
        continue;
L8:
        while(_t19 != 1) {
            __esi =  *((intOrPtr*)(_t19 + 4));
            __edx =  *_t19;
            while(1) {
                _t22 = caml_young_ptr - 12;
                caml_young_ptr = _t22;
                if(_t22 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t33 = _t22 + 4;
             *((intOrPtr*)(_t33 - 4)) = 2048;
             *_t33 = __edx;
             *((intOrPtr*)(_t33 + 4)) = _t28;
            _t19 = __esi;
            _t28 = _t33;
        }
        return;
    }
    _t28 = 1;
    __esp = __esp + 16;
    goto L8;
}

camlList__part_1215(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx,                       // r1
    intOrPtr* __ecx,                       // r2
    intOrPtr __edx,                        // r3
    intOrPtr* __esp                        // r7
)
{// addr = 0x08052F40
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _v12;                        // _cfa_fffffff4
    intOrPtr* _v16;                        // _cfa_fffffff0
    intOrPtr* _t25;                        // _t25
    intOrPtr _t26;                         // _t26
    intOrPtr _t27;                         // _t27
    intOrPtr _t29;                         // _t29
    intOrPtr* _t30;                        // _t30
    intOrPtr _t32;                         // _t32
    intOrPtr _t34;                         // _t34
    intOrPtr _t38;                         // _t38
    intOrPtr* _t39;                        // _t39
    _unknown_ _t40;                        // _t40
    _unknown_ _t41;                        // _t41
    intOrPtr _t42;                         // _t42
    intOrPtr* _t47;                        // _t47
    _unknown_ _t48;                        // _t48

    __esp = __esp;
    __edx = __edx;
    _t47 = __ecx;
    _t39 = __ebx;
    _t25 = __eax;
    while(1) {
        _v16 = _t25;
        if(_t47 == 1) {
            break;
        }
        _v4 = __edx;
        _v12 = _t39;
        _v8 =  *((intOrPtr*)(_t47 + 4));
        _t32 =  *_t47;
         *__esp = _t32;
         *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(__edx + 12))))))();
        if(_t32 == 1) {
            while(1) {
                _t34 = caml_young_ptr - 12;
                caml_young_ptr = _t34;
                if(_t34 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
        } else {
            while(1) {
                _t38 = caml_young_ptr - 12;
                caml_young_ptr = _t38;
                if(_t38 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t25 = _t38 + 4;
             *((intOrPtr*)(_t25 - 4)) = 2048;
             *_t25 =  *__esp;
             *((intOrPtr*)(_t25 + 4)) = _v16;
            _t39 = _v12;
            _t47 = _v8;
            __edx = _v4;
            continue;
        }
        _t39 = _t34 + 4;
         *((intOrPtr*)(_t39 - 4)) = 2048;
         *_t39 =  *__esp;
         *((intOrPtr*)(_t39 + 4)) = _v12;
        _t25 = _v16;
        _t47 = _v8;
        __edx = _v4;
    }
    _t26 = _t39;
    camlList__rev_append_1051(_t26, 1);
     *__esp = _t26;
    _t27 = _v16;
    camlList__rev_append_1051(_t27, 1);
    _t42 = _t27;
    while(1) {
        _t29 = caml_young_ptr - 12;
        caml_young_ptr = _t29;
        if(_t29 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t30 = _t29 + 4;
     *((intOrPtr*)(_t30 - 4)) = 2048;
     *_t30 = _t42;
     *((intOrPtr*)(_t30 + 4)) =  *__esp;
    return;
}

camlList__rev_merge_1251(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx,                       // r1
    intOrPtr* __ecx,                       // r2
    intOrPtr __edx,                        // r3
    intOrPtr* __esp                        // r7
)
{// addr = 0x08053060
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _v8;                         // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr* _v16;                        // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr* _v28;                        // _cfa_ffffffe4
    intOrPtr* _t30;                        // _t30
    intOrPtr _t33;                         // _t33
    intOrPtr _t34;                         // _t34
    intOrPtr _t36;                         // _t36
    intOrPtr _t40;                         // _t40
    intOrPtr* _t43;                        // _t43
    intOrPtr* _t44;                        // _t44
    intOrPtr* _t46;                        // _t46
    intOrPtr* _t47;                        // _t47
    _unknown_ _t50;                        // _t50
    intOrPtr _t51;                         // _t51
    intOrPtr _t52;                         // _t52

    __esp = __esp;
    _t51 = __edx;
    _t46 = __ecx;
    _t43 = __ebx;
    _t30 = __eax;
    __esp = __esp - 32;
    while(_t30 != 1) {
        if(_t43 == 1) {
            _t44 = _t46;
            __esp = __esp + 32;
L12:
            while(_t30 != 1) {
                __esi =  *((intOrPtr*)(_t30 + 4));
                _t52 =  *_t30;
                while(1) {
                    _t33 = caml_young_ptr - 12;
                    caml_young_ptr = _t33;
                    if(_t33 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                _t47 = _t33 + 4;
                 *((intOrPtr*)(_t47 - 4)) = 2048;
                 *_t47 = _t52;
                 *((intOrPtr*)(_t47 + 4)) = _t44;
                _t30 = __esi;
                _t44 = _t47;
            }
            return _t44;
        }
        _v4 = _t51;
        _v16 = _t46;
        _v8 = _t43;
        _v28 = _t30;
        _v24 =  *((intOrPtr*)(_t43 + 4));
         *__esp =  *_t43;
        _v12 =  *((intOrPtr*)(_t30 + 4));
        _t34 =  *_t30;
        _v20 = _t34;
        caml_apply2();
        if(_t34 > 1) {
            while(1) {
                _t36 = caml_young_ptr - 12;
                caml_young_ptr = _t36;
                if(_t36 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
        } else {
            while(1) {
                _t40 = caml_young_ptr - 12;
                caml_young_ptr = _t40;
                if(_t40 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t46 = _t40 + 4;
             *((intOrPtr*)(_t46 - 4)) = 2048;
             *_t46 = _v20;
             *((intOrPtr*)(_t46 + 4)) = _v16;
            _t30 = _v12;
            _t43 = _v8;
            _t51 = _v4;
            continue;
        }
        _t46 = _t36 + 4;
         *((intOrPtr*)(_t46 - 4)) = 2048;
         *_t46 =  *__esp;
         *((intOrPtr*)(_t46 + 4)) = _v16;
        _t30 = _v28;
        _t43 = _v24;
        _t51 = _v4;
    }
    _t30 = _t43;
    _t44 = _t46;
    __esp = __esp + 32;
    goto L12;
}

camlList__rev_merge_rev_1261(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx,                       // r1
    intOrPtr* __ecx,                       // r2
    intOrPtr __edx,                        // r3
    intOrPtr* __esp                        // r7
)
{// addr = 0x08053160
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _v8;                         // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr* _v16;                        // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr* _v28;                        // _cfa_ffffffe4
    intOrPtr* _t30;                        // _t30
    intOrPtr _t33;                         // _t33
    intOrPtr _t34;                         // _t34
    intOrPtr _t36;                         // _t36
    intOrPtr _t40;                         // _t40
    intOrPtr* _t43;                        // _t43
    intOrPtr* _t44;                        // _t44
    intOrPtr* _t46;                        // _t46
    intOrPtr* _t47;                        // _t47
    _unknown_ _t50;                        // _t50
    intOrPtr _t51;                         // _t51
    intOrPtr _t52;                         // _t52

    __esp = __esp;
    _t51 = __edx;
    _t46 = __ecx;
    _t43 = __ebx;
    _t30 = __eax;
    __esp = __esp - 32;
    while(_t30 != 1) {
        if(_t43 == 1) {
            _t44 = _t46;
            __esp = __esp + 32;
L12:
            while(_t30 != 1) {
                __esi =  *((intOrPtr*)(_t30 + 4));
                _t52 =  *_t30;
                while(1) {
                    _t33 = caml_young_ptr - 12;
                    caml_young_ptr = _t33;
                    if(_t33 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                _t47 = _t33 + 4;
                 *((intOrPtr*)(_t47 - 4)) = 2048;
                 *_t47 = _t52;
                 *((intOrPtr*)(_t47 + 4)) = _t44;
                _t30 = __esi;
                _t44 = _t47;
            }
            return _t44;
        }
        _v4 = _t51;
        _v16 = _t46;
        _v8 = _t43;
        _v28 = _t30;
        _v24 =  *((intOrPtr*)(_t43 + 4));
         *__esp =  *_t43;
        _v12 =  *((intOrPtr*)(_t30 + 4));
        _t34 =  *_t30;
        _v20 = _t34;
        caml_apply2();
        if(_t34 <= 1) {
            while(1) {
                _t36 = caml_young_ptr - 12;
                caml_young_ptr = _t36;
                if(_t36 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
        } else {
            while(1) {
                _t40 = caml_young_ptr - 12;
                caml_young_ptr = _t40;
                if(_t40 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t46 = _t40 + 4;
             *((intOrPtr*)(_t46 - 4)) = 2048;
             *_t46 = _v20;
             *((intOrPtr*)(_t46 + 4)) = _v16;
            _t30 = _v12;
            _t43 = _v8;
            _t51 = _v4;
            continue;
        }
        _t46 = _t36 + 4;
         *((intOrPtr*)(_t46 - 4)) = 2048;
         *_t46 =  *__esp;
         *((intOrPtr*)(_t46 + 4)) = _v16;
        _t30 = _v28;
        _t43 = _v24;
        _t51 = _v4;
    }
    _t30 = _t43;
    _t44 = _t46;
    __esp = __esp + 32;
    goto L12;
}

camlList__rev_sort_1272(
    signed int __eax,                      // r0
    signed int* __esp                      // r7
)
{// addr = 0x08053260
    signed int _v4;                        // _cfa_fffffffc
    signed int _v8;                        // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    signed int _t137;                      // _t137
    signed int _t149;                      // _t149
    intOrPtr _t150;                        // _t150
    signed int _t152;                      // _t152
    signed int _t156;                      // _t156
    signed int _t159;                      // _t159
    signed int _t161;                      // _t161
    signed int _t166;                      // _t166
    signed int _t170;                      // _t170
    signed int _t173;                      // _t173
    _unknown_ _t175;                       // _t175
    signed int* _t176;                     // _t176
    signed int* _t177;                     // _t177
    signed int _t178;                      // _t178
    signed int _t181;                      // _t181
    signed int _t186;                      // _t186
    _unknown_ _t189;                       // _t189
    _unknown_ _t190;                       // _t190
    signed int* _t191;                     // _t191
    signed int* _t192;                     // _t192
    signed int _t193;                      // _t193
    _unknown_ _t194;                       // _t194
    signed int _t195;                      // _t195

    __esp = __esp;
    _t137 = __eax;
    __esp = __esp - 20;
    if(_t137 == 5) {
        if(_t170 == 1) {
            _v4 = _t178;
            goto L43;
        }
        _t195 =  *(_t170 + 4);
        if(_t195 == 1) {
            _v4 = _t178;
            goto L43;
        }
         *__esp =  *_t195;
        _t159 =  *_t170;
        _v16 = _t159;
        caml_apply2();
        if(_t159 <= 1) {
            while(1) {
                _t161 = caml_young_ptr - 24;
                caml_young_ptr = _t161;
                if(_t161 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
        } else {
            while(1) {
                _t166 = caml_young_ptr - 24;
                caml_young_ptr = _t166;
                if(_t166 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t192 = _t166 + 4;
             *((intOrPtr*)(_t192 - 4)) = 2048;
             *_t192 =  *__esp;
            _t192[1] = 1;
            _t177 =  &(_t192[3]);
             *((intOrPtr*)(_t177 - 4)) = 2048;
             *_t177 = _v16;
            _t177[1] = _t192;
            __esp =  &((__esp)[5]);
            return _t177;
            goto L58;
        }
        _t191 = _t161 + 4;
         *((intOrPtr*)(_t191 - 4)) = 2048;
         *_t191 = _v16;
        _t191[1] = 1;
        _t176 =  &(_t191[3]);
         *((intOrPtr*)(_t176 - 4)) = 2048;
         *_t176 =  *__esp;
        _t176[1] = _t191;
        __esp =  &((__esp)[5]);
        return _t176;
    } else {
        _v4 = __ecx;
        if(__eax != 7 || __ebx == 1) {
L43:
            _v16 = _t170;
            _t181 = _t137 >> 1 | 1;
             *__esp = _t181;
            _v12 = _t137 - _t181 + 1;
            _v8 = camlList__chop_1243(_t181, _t170);
             *__esp = camlList__sort_1271( *__esp, _v16, _v4 + -16, __esp);
            _t170 = camlList__sort_1271(_v12, _v8, _v4 + -16, __esp);
            _t193 =  *(_v4 + 16);
            _t178 = 1;
            _t137 =  *__esp;
            __esp =  &((__esp)[5]);
            __esp = __esp - 32;
            while(_t137 != 1) {
                if(_t170 == 1) {
                    _t173 = _t178;
                    __esp =  &((__esp)[8]);
L52:
                    while(_t137 != 1) {
                        __esi =  *(_t137 + 4);
                        _t194 =  *_t137;
                        while(1) {
                            _t149 = caml_young_ptr - 12;
                            caml_young_ptr = _t149;
                            if(_t149 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                        _t186 = _t149 + 4;
                         *((intOrPtr*)(_t186 - 4)) = 2048;
                         *_t186 = _t194;
                         *(_t186 + 4) = _t173;
                        _t137 = __esi;
                        _t173 = _t186;
                    }
                    return _t173;
                    goto L58;
                }
                _v4 = _t193;
                _v16 = _t178;
                _v8 = _t170;
                _v28 = _t137;
                _v24 =  *(_t170 + 4);
                 *__esp =  *_t170;
                _v12 =  *(_t137 + 4);
                _t150 =  *_t137;
                _v20 = _t150;
                caml_apply2();
                if(_t150 > 1) {
                    while(1) {
                        _t152 = caml_young_ptr - 12;
                        caml_young_ptr = _t152;
                        if(_t152 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                } else {
                    while(1) {
                        _t156 = caml_young_ptr - 12;
                        caml_young_ptr = _t156;
                        if(_t156 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                    _t178 = _t156 + 4;
                     *((intOrPtr*)(_t178 - 4)) = 2048;
                     *_t178 = _v20;
                     *(_t178 + 4) = _v16;
                    _t137 = _v12;
                    _t170 = _v8;
                    _t193 = _v4;
                    continue;
                }
                _t178 = _t152 + 4;
                 *((intOrPtr*)(_t178 - 4)) = 2048;
                 *_t178 =  *__esp;
                 *(_t178 + 4) = _v16;
                _t137 = _v28;
                _t170 = _v24;
                _t193 = _v4;
            }
            _t137 = _t170;
            _t173 = _t178;
            __esp =  &((__esp)[8]);
            goto L52;
        }
        __esi =  *(__ebx + 4);
        if(__esi == 1) {
            goto L43;
        }
        __edx =  *(__esi + 4);
        if(__edx == 1) {
            goto L43;
        }
        __eax =  *__edx;
         *__esp =  *__edx;
        __edx =  *__esi;
        _v16 = __edx;
        __eax =  *__ebx;
        _v12 = __eax;
        __ecx =  *(__ecx + 12);
        __ebx = __edx;
        caml_apply2();
        if(__eax <= 1) {
            __eax = _v4;
            __ecx =  *((intOrPtr*)(_v4 + 12));
            __eax = _v12;
            __ebx =  *__esp;
            caml_apply2();
            if(_v12 <= 1) {
                __eax = _v4;
                __ecx =  *((intOrPtr*)(_v4 + 12));
                __eax = _v16;
                __ebx =  *__esp;
                caml_apply2();
                if(_v16 <= 1) {
                    while(1) {
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 36;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                } else {
                    while(1) {
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 36;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                    __ebx = __eax + 4;
                     *((intOrPtr*)(__ebx - 4)) = 2048;
                    __eax = _v12;
                     *__ebx = _v12;
                     *(__ebx + 4) = 1;
                    __ecx = __ebx + 12;
                     *((intOrPtr*)(__ecx - 4)) = 2048;
                    __eax =  *__esp;
                     *__ecx =  *__esp;
                     *(__ecx + 4) = __ebx;
                    __ebx = __ebx + 24;
                     *((intOrPtr*)(__ebx - 4)) = 2048;
                    __eax = _v16;
                     *__ebx = _v16;
                     *(__ebx + 4) = __ecx;
                    __eax = __ebx;
                    __esp =  &((__esp)[5]);
                    return __ebx;
                    goto L58;
                }
                __ebx = __eax + 4;
                 *((intOrPtr*)(__ebx - 4)) = 2048;
                __eax = _v12;
                 *__ebx = _v12;
                 *(__ebx + 4) = 1;
                __ecx = __ebx + 12;
                 *((intOrPtr*)(__ecx - 4)) = 2048;
                __eax = _v16;
                 *__ecx = _v16;
                 *(__ecx + 4) = __ebx;
                __ebx = __ebx + 24;
                 *((intOrPtr*)(__ebx - 4)) = 2048;
                __eax =  *__esp;
                 *__ebx =  *__esp;
                 *(__ebx + 4) = __ecx;
                __eax = __ebx;
                __esp =  &((__esp)[5]);
                return __ebx;
            } else {
                while(1) {
                    __eax = caml_young_ptr;
                    __eax = caml_young_ptr - 36;
                    caml_young_ptr = __eax;
                    if(__eax >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                __ebx = __eax + 4;
                 *((intOrPtr*)(__ebx - 4)) = 2048;
                __eax =  *__esp;
                 *__ebx =  *__esp;
                 *(__ebx + 4) = 1;
                __ecx = __ebx + 12;
                 *((intOrPtr*)(__ecx - 4)) = 2048;
                __eax = _v12;
                 *__ecx = _v12;
                 *(__ecx + 4) = __ebx;
                __ebx = __ebx + 24;
                 *((intOrPtr*)(__ebx - 4)) = 2048;
                __eax = _v16;
                 *__ebx = _v16;
                 *(__ebx + 4) = __ecx;
                __eax = __ebx;
                __esp =  &((__esp)[5]);
                return __ebx;
            }
        } else {
            __eax = _v4;
            __ecx =  *((intOrPtr*)(_v4 + 12));
            __eax = _v16;
            __ebx =  *__esp;
            caml_apply2();
            if(_v16 <= 1) {
                __eax = _v4;
                __ecx =  *(_v4 + 12);
                __eax = _v12;
                __ebx =  *__esp;
                caml_apply2();
                if(_v12 <= 1) {
                    while(1) {
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 36;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                } else {
                    while(1) {
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 36;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                    __ebx = __eax + 4;
                     *((intOrPtr*)(__ebx - 4)) = 2048;
                    __eax = _v16;
                     *__ebx = _v16;
                     *(__ebx + 4) = 1;
                    __ecx = __ebx + 12;
                     *((intOrPtr*)(__ecx - 4)) = 2048;
                    __eax =  *__esp;
                     *__ecx =  *__esp;
                     *(__ecx + 4) = __ebx;
                    __ebx = __ebx + 24;
                     *((intOrPtr*)(__ebx - 4)) = 2048;
                    __eax = _v12;
                     *__ebx = _v12;
                     *(__ebx + 4) = __ecx;
                    __eax = __ebx;
                    __esp =  &((__esp)[5]);
                    return __ebx;
                    goto L58;
                }
                __ebx = __eax + 4;
                 *((intOrPtr*)(__ebx - 4)) = 2048;
                __eax = _v16;
                 *__ebx = _v16;
                 *(__ebx + 4) = 1;
                __ecx = __ebx + 12;
                 *((intOrPtr*)(__ecx - 4)) = 2048;
                __eax = _v12;
                 *__ecx = _v12;
                 *(__ecx + 4) = __ebx;
                __ebx = __ebx + 24;
                 *((intOrPtr*)(__ebx - 4)) = 2048;
                __eax =  *__esp;
                 *__ebx =  *__esp;
                 *(__ebx + 4) = __ecx;
                __eax = __ebx;
                __esp =  &((__esp)[5]);
                return __ebx;
            } else {
                while(1) {
                    __eax = caml_young_ptr;
                    __eax = caml_young_ptr - 36;
                    caml_young_ptr = __eax;
                    if(__eax >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                __ebx = __eax + 4;
                 *((intOrPtr*)(__ebx - 4)) = 2048;
                __eax =  *__esp;
                 *__ebx =  *__esp;
                 *(__ebx + 4) = 1;
                __ecx = __ebx + 12;
                 *((intOrPtr*)(__ecx - 4)) = 2048;
                __eax = _v16;
                 *__ecx = _v16;
                 *(__ecx + 4) = __ebx;
                __ebx = __ebx + 24;
                 *((intOrPtr*)(__ebx - 4)) = 2048;
                __eax = _v12;
                 *__ebx = _v12;
                 *(__ebx + 4) = __ecx;
                __eax = __ebx;
                __esp =  &((__esp)[5]);
                return __ebx;
            }
        }
    }
L58:
}

camlList__sort_1271(
    signed int __eax,                      // r0
    signed int __ebx,                      // r1
    signed int __ecx,                      // r2
    signed int* __esp                      // r7
)
{// addr = 0x08053720
    signed int _v4;                        // _cfa_fffffffc
    signed int _v8;                        // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    signed int _t137;                      // _t137
    signed int _t149;                      // _t149
    intOrPtr _t150;                        // _t150
    signed int _t152;                      // _t152
    signed int _t156;                      // _t156
    signed int _t159;                      // _t159
    signed int _t161;                      // _t161
    signed int _t166;                      // _t166
    signed int _t170;                      // _t170
    _unknown_ _t171;                       // _t171
    _unknown_ _t172;                       // _t172
    signed int _t173;                      // _t173
    _unknown_ _t175;                       // _t175
    signed int* _t176;                     // _t176
    signed int* _t177;                     // _t177
    signed int _t178;                      // _t178
    signed int _t181;                      // _t181
    _unknown_ _t183;                       // _t183
    _unknown_ _t185;                       // _t185
    signed int _t186;                      // _t186
    _unknown_ _t189;                       // _t189
    _unknown_ _t190;                       // _t190
    signed int* _t191;                     // _t191
    signed int* _t192;                     // _t192
    signed int _t193;                      // _t193
    _unknown_ _t194;                       // _t194
    signed int _t195;                      // _t195

    __esp = __esp;
    _t178 = __ecx;
    _t170 = __ebx;
    _t137 = __eax;
    __esp = __esp - 20;
    if(_t137 == 5) {
        if(_t170 == 1) {
            _v4 = _t178;
            goto L43;
        }
        _t195 =  *(_t170 + 4);
        if(_t195 == 1) {
            _v4 = _t178;
            goto L43;
        }
         *__esp =  *_t195;
        _t159 =  *_t170;
        _v16 = _t159;
        caml_apply2();
        if(_t159 > 1) {
            while(1) {
                _t161 = caml_young_ptr - 24;
                caml_young_ptr = _t161;
                if(_t161 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
        } else {
            while(1) {
                _t166 = caml_young_ptr - 24;
                caml_young_ptr = _t166;
                if(_t166 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t192 = _t166 + 4;
             *((intOrPtr*)(_t192 - 4)) = 2048;
             *_t192 =  *__esp;
            _t192[1] = 1;
            _t177 =  &(_t192[3]);
             *((intOrPtr*)(_t177 - 4)) = 2048;
             *_t177 = _v16;
            _t177[1] = _t192;
            __esp =  &((__esp)[5]);
            return _t177;
            goto L58;
        }
        _t191 = _t161 + 4;
         *((intOrPtr*)(_t191 - 4)) = 2048;
         *_t191 = _v16;
        _t191[1] = 1;
        _t176 =  &(_t191[3]);
         *((intOrPtr*)(_t176 - 4)) = 2048;
         *_t176 =  *__esp;
        _t176[1] = _t191;
        __esp =  &((__esp)[5]);
        return _t176;
    } else {
        _v4 = __ecx;
        if(__eax != 7 || __ebx == 1) {
L43:
            _v16 = _t170;
            _t181 = _t137 >> 1 | 1;
             *__esp = _t181;
            _v12 = _t137 - _t181 + 1;
            _v8 = camlList__chop_1243(_t181, _t170);
             *__esp = camlList__rev_sort_1272( *__esp, __esp);
            _t170 = camlList__rev_sort_1272(_v12, __esp);
            _t193 =  *(_v4 + 36);
            _t178 = 1;
            _t137 =  *__esp;
            __esp =  &((__esp)[5]);
            __esp = __esp - 32;
            while(_t137 != 1) {
                if(_t170 == 1) {
                    _t173 = _t178;
                    __esp =  &((__esp)[8]);
L52:
                    while(_t137 != 1) {
                        __esi =  *(_t137 + 4);
                        _t194 =  *_t137;
                        while(1) {
                            _t149 = caml_young_ptr - 12;
                            caml_young_ptr = _t149;
                            if(_t149 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                        _t186 = _t149 + 4;
                         *((intOrPtr*)(_t186 - 4)) = 2048;
                         *_t186 = _t194;
                         *(_t186 + 4) = _t173;
                        _t137 = __esi;
                        _t173 = _t186;
                    }
                    return _t173;
                    goto L58;
                }
                _v4 = _t193;
                _v16 = _t178;
                _v8 = _t170;
                _v28 = _t137;
                _v24 =  *(_t170 + 4);
                 *__esp =  *_t170;
                _v12 =  *(_t137 + 4);
                _t150 =  *_t137;
                _v20 = _t150;
                caml_apply2();
                if(_t150 <= 1) {
                    while(1) {
                        _t152 = caml_young_ptr - 12;
                        caml_young_ptr = _t152;
                        if(_t152 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                } else {
                    while(1) {
                        _t156 = caml_young_ptr - 12;
                        caml_young_ptr = _t156;
                        if(_t156 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                    _t178 = _t156 + 4;
                     *((intOrPtr*)(_t178 - 4)) = 2048;
                     *_t178 = _v20;
                     *(_t178 + 4) = _v16;
                    _t137 = _v12;
                    _t170 = _v8;
                    _t193 = _v4;
                    continue;
                }
                _t178 = _t152 + 4;
                 *((intOrPtr*)(_t178 - 4)) = 2048;
                 *_t178 =  *__esp;
                 *(_t178 + 4) = _v16;
                _t137 = _v28;
                _t170 = _v24;
                _t193 = _v4;
            }
            _t137 = _t170;
            _t173 = _t178;
            __esp =  &((__esp)[8]);
            goto L52;
        }
        __esi =  *(__ebx + 4);
        if(__esi == 1) {
            goto L43;
        }
        __edx =  *(__esi + 4);
        if(__edx == 1) {
            goto L43;
        }
        __eax =  *__edx;
         *__esp =  *__edx;
        __edx =  *__esi;
        _v16 = __edx;
        __eax =  *__ebx;
        _v12 = __eax;
        __ecx =  *(__ecx + 28);
        __ebx = __edx;
        caml_apply2();
        if(__eax > 1) {
            __eax = _v4;
            __ecx =  *((intOrPtr*)(_v4 + 28));
            __eax = _v12;
            __ebx =  *__esp;
            caml_apply2();
            if(_v12 > 1) {
                __eax = _v4;
                __ecx =  *((intOrPtr*)(_v4 + 28));
                __eax = _v16;
                __ebx =  *__esp;
                caml_apply2();
                if(_v16 > 1) {
                    while(1) {
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 36;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                } else {
                    while(1) {
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 36;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                    __ebx = __eax + 4;
                     *((intOrPtr*)(__ebx - 4)) = 2048;
                    __eax = _v12;
                     *__ebx = _v12;
                     *(__ebx + 4) = 1;
                    __ecx = __ebx + 12;
                     *((intOrPtr*)(__ecx - 4)) = 2048;
                    __eax =  *__esp;
                     *__ecx =  *__esp;
                     *(__ecx + 4) = __ebx;
                    __ebx = __ebx + 24;
                     *((intOrPtr*)(__ebx - 4)) = 2048;
                    __eax = _v16;
                     *__ebx = _v16;
                     *(__ebx + 4) = __ecx;
                    __eax = __ebx;
                    __esp =  &((__esp)[5]);
                    return __ebx;
                    goto L58;
                }
                __ebx = __eax + 4;
                 *((intOrPtr*)(__ebx - 4)) = 2048;
                __eax = _v12;
                 *__ebx = _v12;
                 *(__ebx + 4) = 1;
                __ecx = __ebx + 12;
                 *((intOrPtr*)(__ecx - 4)) = 2048;
                __eax = _v16;
                 *__ecx = _v16;
                 *(__ecx + 4) = __ebx;
                __ebx = __ebx + 24;
                 *((intOrPtr*)(__ebx - 4)) = 2048;
                __eax =  *__esp;
                 *__ebx =  *__esp;
                 *(__ebx + 4) = __ecx;
                __eax = __ebx;
                __esp =  &((__esp)[5]);
                return __ebx;
            } else {
                while(1) {
                    __eax = caml_young_ptr;
                    __eax = caml_young_ptr - 36;
                    caml_young_ptr = __eax;
                    if(__eax >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                __ebx = __eax + 4;
                 *((intOrPtr*)(__ebx - 4)) = 2048;
                __eax =  *__esp;
                 *__ebx =  *__esp;
                 *(__ebx + 4) = 1;
                __ecx = __ebx + 12;
                 *((intOrPtr*)(__ecx - 4)) = 2048;
                __eax = _v12;
                 *__ecx = _v12;
                 *(__ecx + 4) = __ebx;
                __ebx = __ebx + 24;
                 *((intOrPtr*)(__ebx - 4)) = 2048;
                __eax = _v16;
                 *__ebx = _v16;
                 *(__ebx + 4) = __ecx;
                __eax = __ebx;
                __esp =  &((__esp)[5]);
                return __ebx;
            }
        } else {
            __eax = _v4;
            __ecx =  *((intOrPtr*)(_v4 + 28));
            __eax = _v16;
            __ebx =  *__esp;
            caml_apply2();
            if(_v16 > 1) {
                __eax = _v4;
                __ecx =  *(_v4 + 28);
                __eax = _v12;
                __ebx =  *__esp;
                caml_apply2();
                if(_v12 > 1) {
                    while(1) {
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 36;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                } else {
                    while(1) {
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 36;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                    __ebx = __eax + 4;
                     *((intOrPtr*)(__ebx - 4)) = 2048;
                    __eax = _v16;
                     *__ebx = _v16;
                     *(__ebx + 4) = 1;
                    __ecx = __ebx + 12;
                     *((intOrPtr*)(__ecx - 4)) = 2048;
                    __eax =  *__esp;
                     *__ecx =  *__esp;
                     *(__ecx + 4) = __ebx;
                    __ebx = __ebx + 24;
                     *((intOrPtr*)(__ebx - 4)) = 2048;
                    __eax = _v12;
                     *__ebx = _v12;
                     *(__ebx + 4) = __ecx;
                    __eax = __ebx;
                    __esp =  &((__esp)[5]);
                    return __ebx;
                    goto L58;
                }
                __ebx = __eax + 4;
                 *((intOrPtr*)(__ebx - 4)) = 2048;
                __eax = _v16;
                 *__ebx = _v16;
                 *(__ebx + 4) = 1;
                __ecx = __ebx + 12;
                 *((intOrPtr*)(__ecx - 4)) = 2048;
                __eax = _v12;
                 *__ecx = _v12;
                 *(__ecx + 4) = __ebx;
                __ebx = __ebx + 24;
                 *((intOrPtr*)(__ebx - 4)) = 2048;
                __eax =  *__esp;
                 *__ebx =  *__esp;
                 *(__ebx + 4) = __ecx;
                __eax = __ebx;
                __esp =  &((__esp)[5]);
                return __ebx;
            } else {
                while(1) {
                    __eax = caml_young_ptr;
                    __eax = caml_young_ptr - 36;
                    caml_young_ptr = __eax;
                    if(__eax >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                __ebx = __eax + 4;
                 *((intOrPtr*)(__ebx - 4)) = 2048;
                __eax =  *__esp;
                 *__ebx =  *__esp;
                 *(__ebx + 4) = 1;
                __ecx = __ebx + 12;
                 *((intOrPtr*)(__ecx - 4)) = 2048;
                __eax = _v16;
                 *__ecx = _v16;
                 *(__ecx + 4) = __ebx;
                __ebx = __ebx + 24;
                 *((intOrPtr*)(__ebx - 4)) = 2048;
                __eax = _v12;
                 *__ebx = _v12;
                 *(__ebx + 4) = __ecx;
                __eax = __ebx;
                __esp =  &((__esp)[5]);
                return __ebx;
            }
        }
    }
L58:
}

camlList__length_aux_1030(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx                        // r1
)
{// addr = 0x08053BE0
    _unknown_ _t3;                         // _t3

L0:
    while(1) {
L0:
        __eax = __eax;
        if(__ebx == 1) {
            break;
        }
L1:
        __eax = __eax + 2;
    }
    return __eax;
}

camlList__length_1034(
    intOrPtr __eax                         // r0
)
{// addr = 0x08053C00
    _unknown_ _t3;                         // _t3

    __ebx = __eax;
    _t3 = 1;
    while(__ebx != 1) {
        __ebx =  *((intOrPtr*)(__ebx + 4));
        _t3 = _t3 + 2;
    }
    return _t3;
}

camlList__hd_1036(
    _unknown_ __eax                        // r0
)
{// addr = 0x08053C10
    intOrPtr _t6;                          // _t6
    _unknown_ _t8;                         // _t8

    if(__eax == 1) {
        __ebx =  &camlList__51;
        while(1) {
            _t6 = caml_young_ptr - 12;
            caml_young_ptr = _t6;
            if(_t6 >= caml_young_limit) {
                _t7 = _t6 + 4;
                 *((intOrPtr*)(_t6 + 4 - 4)) = 2048;
                caml_raise_exn(_t7, __ebx,  &caml_exn_Failure);
            }
            caml_call_gc(__esp);
        }
    }
    return __eax;
}

camlList__tl_1039(
    _unknown_ __eax                        // r0
)
{// addr = 0x08053C30
    intOrPtr _t7;                          // _t7
    intOrPtr* _t8;                         // _t8
    _unknown_ _t9;                         // _t9

    if(__eax == 1) {
        __ebx =  &camlList__50;
        while(1) {
            _t7 = caml_young_ptr - 12;
            caml_young_ptr = _t7;
            if(_t7 >= caml_young_limit) {
                _t8 = _t7 + 4;
                 *((intOrPtr*)(_t8 - 4)) = 2048;
                 *_t8 =  &caml_exn_Failure;
                 *((intOrPtr*)(_t8 + 4)) = __ebx;
                caml_raise_exn(_t8);
            }
            caml_call_gc(__esp);
        }
    }
    return __eax;
}

camlList__nth_1042(
    _unknown_ __ebx                        // r1
)
{// addr = 0x08053C50
    intOrPtr _t10;                         // _t10
    intOrPtr* _t11;                        // _t11
    _unknown_ _t12;                        // _t12
    char _t13;                             // _t13
    _unknown_ _t14;                        // _t14
    char* _t15;                            // _t15
    _unknown_ _t16;                        // _t16
    char* _t17;                            // _t17

    _t14 = __ebx;
    if(_t14 < 1) {
        goto L14;
    }
    while(_t8 != 1) {
        _t17 =  *((intOrPtr*)(_t8 + 4));
        _t13 =  *_t8;
        if(_t14 != 1) {
            _t14 = _t14 + -2;
            _t8 = _t17;
            continue;
        }
        return _t13;
    }
    _t8 =  ?_? ( &camlList__53);
    _t15 =  &camlList__53;
    while(1) {
        _t10 = caml_young_ptr - 12;
        caml_young_ptr = _t10;
        if(_t10 >= caml_young_limit) {
            _t11 = _t10 + 4;
             *((intOrPtr*)(_t11 - 4)) = 2048;
             *_t11 =  &caml_exn_Failure;
             *((intOrPtr*)(_t11 + 4)) = _t15;
            caml_raise_exn(_t11);
        }
        caml_call_gc(__esp);
    }
L14:
    __eax =  ?_? ("List.nth");
    __ebx = "List.nth";
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 12;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            __eax = __eax + 4;
             *((intOrPtr*)(__eax - 4)) = 2048;
            __eax = caml_raise_exn(__eax, __ebx,  &caml_exn_Invalid_argument);
        }
        caml_call_gc(__esp);
    }
}

camlList__rev_append_1051(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx                        // r1
)
{// addr = 0x08053C70
    intOrPtr* _t5;                         // _t5
    intOrPtr _t8;                          // _t8
    _unknown_ _t9;                         // _t9

L0:
    while(1) {
L0:
        __ebx = __ebx;
        _t5 = __eax;
        if(_t5 == 1) {
            break;
        }
L1:
        __edx =  *_t5;
        while(1) {
L2:
            _t8 = caml_young_ptr - 12;
            caml_young_ptr = _t8;
            if(_t8 >= caml_young_limit) {
                break;
            }
L5:
            caml_call_gc(__esp);
        }
        __ecx = _t8 + 4;
         *((intOrPtr*)(__ecx - 4)) = 2048;
         *__ecx = __edx;
         *((intOrPtr*)(__ecx + 4)) = __ebx;
        __ebx = __ecx;
    }
    return __ebx;
}

camlList__rev_1056(
    intOrPtr* __eax                        // r0
)
{// addr = 0x08053CC0
    intOrPtr* _t5;                         // _t5
    intOrPtr _t8;                          // _t8

    _t5 = __eax;
    __ebx = 1;
    while(_t5 != 1) {
        __esi =  *((intOrPtr*)(_t5 + 4));
        __edx =  *_t5;
        while(1) {
            _t8 = caml_young_ptr - 12;
            caml_young_ptr = _t8;
            if(_t8 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        __ecx = _t8 + 4;
         *((intOrPtr*)(__ecx - 4)) = 2048;
         *__ecx = __edx;
         *((intOrPtr*)(__ecx + 4)) = __ebx;
        _t5 = __esi;
        __ebx = __ecx;
    }
    return __ebx;
}

camlList__flatten_1058(
    intOrPtr* __eax                        // r0
)
{// addr = 0x08053CD0
    intOrPtr* _t6;                         // _t6
    _unknown_ _t7;                         // _t7
    intOrPtr _t11;                         // _t11
    intOrPtr* _t12;                        // _t12
    _unknown_ _t13;                        // _t13
    intOrPtr _t16;                         // _t16

    _t6 = __eax;
    if(_t6 == 1) {
        return 1;
    } else {
         *__esp =  *__eax;
        __eax =  *__esp;
        __esp = __esp + 4;
        __esp = __esp - 4;
        if(_t6 == 1) {
            return _t13;
        } else {
             *__esp =  *_t6;
            L1();
            _t16 =  *((intOrPtr*)(_t6 + 4));
            while(1) {
                _t11 = caml_young_ptr - 12;
                caml_young_ptr = _t11;
                if(_t11 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t12 = _t11 + 4;
             *((intOrPtr*)(_t12 - 4)) = 2048;
             *_t12 =  *__esp;
             *((intOrPtr*)(_t12 + 4)) = _t16;
            return _t12;
        }
    }
}

camlList__map_1062(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx,                       // r1
    intOrPtr* __esp                        // r7
)
{// addr = 0x08053D10
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    _unknown_ _t10;                        // _t10
    intOrPtr _t13;                         // _t13
    intOrPtr _t15;                         // _t15
    intOrPtr* _t16;                        // _t16
    intOrPtr* _t17;                        // _t17
    _unknown_ _t18;                        // _t18
    intOrPtr _t22;                         // _t22

    __esp = __esp;
    _t17 = __ebx;
    __edx = __eax;
    if(_t17 == 1) {
        return;
    } else {
         *__esp = __edx;
        _v8 =  *((intOrPtr*)(_t17 + 4));
         *((intOrPtr*)( *__edx))();
        _v4 =  *_t17;
        _t13 =  *__esp;
        camlList__map_1062(_t13, _v8, __esp);
        _t22 = _t13;
        while(1) {
            _t15 = caml_young_ptr - 12;
            caml_young_ptr = _t15;
            if(_t15 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t16 = _t15 + 4;
         *((intOrPtr*)(_t16 - 4)) = 2048;
         *_t16 = _v4;
         *((intOrPtr*)(_t16 + 4)) = _t22;
        return;
    }
}

camlList__rev_map_1067(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx                        // r1
)
{// addr = 0x08053D80
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _t15;                        // _t15
    intOrPtr _t19;                         // _t19
    intOrPtr* _t20;                        // _t20
    intOrPtr _t22;                         // _t22
    intOrPtr _t24;                         // _t24

    _t20 = __ebx;
    _t15 = __eax;
    __edx = _t15;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 20;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    __ecx = __eax + 4;
     *((intOrPtr*)(__ecx - 4)) = 4343;
     *__ecx = caml_curry2;
     *((intOrPtr*)(__ecx + 4)) = 5;
     *((intOrPtr*)(__ecx + 8)) = camlList__rmap_f_1070;
     *((intOrPtr*)(__ecx + 12)) = __edx;
    __eax = 1;
    __esp = __esp - 12;
    while(_t20 != 1) {
        _v4 = _t24;
         *__esp = _t15;
        _v8 =  *((intOrPtr*)(_t20 + 4));
         *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t24 + 12))))))();
        _t22 =  *_t20;
        while(1) {
            _t19 = caml_young_ptr - 12;
            caml_young_ptr = _t19;
            if(_t19 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t15 = _t19 + 4;
         *((intOrPtr*)(_t15 - 4)) = 2048;
         *_t15 = _t22;
         *((intOrPtr*)(_t15 + 4)) =  *__esp;
        _t20 = _v8;
        _t24 = _v4;
    }
    __esp = __esp + 12;
    return;
}

camlList__iter_1074(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr* __esp                        // r7
)
{// addr = 0x08053DD0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _t4;                         // _t4
    _unknown_ _t5;                         // _t5
    _unknown_ _t7;                         // _t7
    intOrPtr _t8;                          // _t8
    _unknown_ _t9;                         // _t9

    __esp = __esp;
    _t8 = __ebx;
    _t4 = __eax;
    while(1) {
        __edx = _t4;
        if(_t8 == 1) {
            break;
        }
         *__esp = __edx;
        _v4 =  *((intOrPtr*)(_t8 + 4));
         *((intOrPtr*)( *__edx))();
        _t4 =  *__esp;
        _t8 = _v4;
    }
    return;
}

camlList__fold_left_1078(
    intOrPtr __eax,                        // r0
    _unknown_ __ebx,                       // r1
    intOrPtr __ecx,                        // r2
    intOrPtr* __esp                        // r7
)
{// addr = 0x08053E10
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _t4;                          // _t4
    _unknown_ _t5;                         // _t5
    _unknown_ _t6;                         // _t6
    _unknown_ _t7;                         // _t7
    intOrPtr _t8;                          // _t8
    _unknown_ _t10;                        // _t10

    __esp = __esp;
    _t8 = __ecx;
    _t6 = __ebx;
    _t4 = __eax;
    while(1) {
        __edx = _t4;
        _t5 = _t6;
        if(_t8 == 1) {
            break;
        }
         *__esp = __edx;
        _v4 =  *((intOrPtr*)(_t8 + 4));
        caml_apply2();
        _t6 = _t5;
        _t4 =  *__esp;
        _t8 = _v4;
    }
    return _t5;
}

camlList__fold_right_1084(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr* __esp                        // r7
)
{// addr = 0x08053E50
    intOrPtr* _v4;                         // _cfa_fffffffc
    intOrPtr* _t6;                         // _t6
    _unknown_ _t7;                         // _t7
    intOrPtr* _t8;                         // _t8
    _unknown_ _t10;                        // _t10
    intOrPtr* _t13;                        // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t18;                        // _t18

    __esp = __esp;
    _t9 = __ebx;
    _t6 = __eax;
    if(__ebx != 1) {
        _v4 = _t8;
         *__esp =  *_t11;
        camlList__fold_right_1084(_t8,  *((intOrPtr*)(_t11 + 4)), __esp);
        _t9 = _t8;
        _t6 =  *__esp;
        _t13 = _v4;
        __esp = __esp + 8;
        __esp = __esp - 4;
        if( *((intOrPtr*)(_t13 + 4)) != 5) {
             *__esp = _t9;
             *((intOrPtr*)( *_t13))();
            _t11 = _t6;
            _t8 =  *__esp;
            __esp = __esp + 4;
            goto __ecx;
        }
        __esp = __esp + 4;
        goto __edx;
    }
    return;
}

camlList__map2_1090(
    intOrPtr __eax,                        // r0
    _unknown_ __ebx,                       // r1
    intOrPtr* __ecx,                       // r2
    intOrPtr* __esp                        // r7
)
{// addr = 0x08053E90
    intOrPtr* _v4;                         // _cfa_fffffffc
    intOrPtr* _v8;                         // _cfa_fffffff8
    intOrPtr* _v12;                        // _cfa_fffffff4
    intOrPtr _t17;                         // _t17
    intOrPtr* _t18;                        // _t18
    _unknown_ _t19;                        // _t19
    _unknown_ _t20;                        // _t20
    char* _t22;                            // _t22

    __esp = __esp;
    __ecx = __ecx;
    __edx = __eax;
    if(__ebx == 1) {
        if(__ecx != 1) {
            goto L11;
        }
    } else {
        if(__ecx == 1) {
L11:
            __esp = __esp + 16;
            _t22 = "List.map2";
            while(1) {
                _t17 = caml_young_ptr - 12;
                caml_young_ptr = _t17;
                if(_t17 >= caml_young_limit) {
                    _t18 = _t17 + 4;
                     *((intOrPtr*)(_t18 - 4)) = 2048;
                     *_t18 =  &caml_exn_Invalid_argument;
                     *((intOrPtr*)(_t18 + 4)) = _t22;
                    caml_raise_exn(_t18);
                }
                caml_call_gc(__esp);
            }
        }
         *__esp = __edx;
        __eax =  *((intOrPtr*)(__ecx + 4));
        _v8 =  *((intOrPtr*)(__ecx + 4));
        __ecx =  *__ecx;
        __eax =  *((intOrPtr*)(__ebx + 4));
        _v12 =  *((intOrPtr*)(__ebx + 4));
        __eax =  *__ebx;
        __ebx = __ecx;
        __ecx = __edx;
        caml_apply2();
        _v4 = __eax;
        __eax =  *__esp;
        __ebx = _v12;
        __ecx = _v8;
        __ecx = camlList__map2_1090( *__esp, _v12, _v8, __esp);
        while(1) {
L7:
            __eax = caml_young_ptr;
            __eax = caml_young_ptr - 12;
            caml_young_ptr = __eax;
            if(__eax >= caml_young_limit) {
                break;
            }
            goto L12;
        }
        __eax = __eax + 4;
         *((intOrPtr*)(__eax - 4)) = 2048;
        __ebx = _v4;
         *__eax = _v4;
         *((intOrPtr*)(__eax + 4)) = __ecx;
        return __eax;
L13:
L12:
        caml_call_gc(__esp);
        goto L7;
    }
    return 1;
    goto L13;
}

camlList__rev_map2_1099(
    intOrPtr* __eax,                       // r0
    _unknown_ __ebx,                       // r1
    intOrPtr* __ecx                        // r2
)
{// addr = 0x08053F30
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _v8;                         // _cfa_fffffff8
    intOrPtr* _v12;                        // _cfa_fffffff4
    intOrPtr* _t21;                        // _t21
    intOrPtr _t23;                         // _t23
    intOrPtr* _t24;                        // _t24
    _unknown_ _t25;                        // _t25
    _unknown_ _t26;                        // _t26
    intOrPtr _t27;                         // _t27

    __ecx = __ecx;
    _t21 = __eax;
    __esi = _t21;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 20;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
L17:
        caml_call_gc(__esp);
    }
    __edx = __eax + 4;
     *((intOrPtr*)(__edx - 4)) = 4343;
     *__edx = caml_curry3;
     *((intOrPtr*)(__edx + 4)) = 7;
     *((intOrPtr*)(__edx + 8)) = camlList__rmap2_f_1103;
     *((intOrPtr*)(__edx + 12)) = __esi;
    __eax = 1;
    __esp = __esp - 16;
    while(__ebx != 1) {
        if(__ecx == 1) {
L13:
            __eax = "List.rev_map2";
            __esp = __esp + 16;
            _t27 = _t21;
            while(1) {
                _t23 = caml_young_ptr - 12;
                caml_young_ptr = _t23;
                if(_t23 >= caml_young_limit) {
                    _t24 = _t23 + 4;
                     *((intOrPtr*)(_t24 - 4)) = 2048;
                     *_t24 =  &caml_exn_Invalid_argument;
                     *((intOrPtr*)(_t24 + 4)) = _t27;
                    caml_raise_exn(_t24);
                }
                caml_call_gc(__esp);
            }
        }
        _v4 = __edx;
         *__esp = __eax;
        __eax =  *((intOrPtr*)(__ecx + 4));
        _v8 =  *((intOrPtr*)(__ecx + 4));
        __esi =  *__ecx;
        __eax =  *((intOrPtr*)(__ebx + 4));
        _v12 =  *((intOrPtr*)(__ebx + 4));
        __eax =  *__ebx;
        __ecx =  *((intOrPtr*)(__edx + 12));
        __ebx = __esi;
        caml_apply2();
        __ebx = __eax;
        while(1) {
            __eax = caml_young_ptr;
            __eax = caml_young_ptr - 12;
            caml_young_ptr = __eax;
            if(__eax >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        __eax = __eax + 4;
         *((intOrPtr*)(__eax - 4)) = 2048;
         *__eax = __ebx;
        __ebx =  *__esp;
         *((intOrPtr*)(__eax + 4)) =  *__esp;
        __ebx = _v12;
        __ecx = _v8;
        __edx = _v4;
    }
    if(__ecx != 1) {
        goto L13;
    }
    __esp = __esp + 16;
    return;
    goto L17;
}

camlList__iter2_1111(
    intOrPtr __eax,                        // r0
    _unknown_ __ebx,                       // r1
    intOrPtr* __ecx,                       // r2
    intOrPtr* __esp                        // r7
)
{// addr = 0x08053F80
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _t10;                         // _t10
    intOrPtr _t12;                         // _t12
    intOrPtr* _t13;                        // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    intOrPtr _t16;                         // _t16

    __esp = __esp;
    __ecx = __ecx;
    _t10 = __eax;
    while(1) {
        __edx = __eax;
        if(__ebx == 1) {
            break;
        }
        if(__ecx == 1) {
L10:
            __eax = "List.iter2";
            __esp = __esp + 12;
            _t16 = _t10;
            while(1) {
                _t12 = caml_young_ptr - 12;
                caml_young_ptr = _t12;
                if(_t12 >= caml_young_limit) {
                    _t13 = _t12 + 4;
                     *((intOrPtr*)(_t13 - 4)) = 2048;
                     *_t13 =  &caml_exn_Invalid_argument;
                     *((intOrPtr*)(_t13 + 4)) = _t16;
                    caml_raise_exn(_t13);
                }
                caml_call_gc(__esp);
            }
        }
         *__esp = __edx;
        __eax =  *((intOrPtr*)(__ecx + 4));
        _v4 =  *((intOrPtr*)(__ecx + 4));
        __ecx =  *__ecx;
        __eax =  *((intOrPtr*)(__ebx + 4));
        _v8 =  *((intOrPtr*)(__ebx + 4));
        __eax =  *__ebx;
        __ebx = __ecx;
        __ecx = __edx;
        caml_apply2();
        __eax =  *__esp;
        __ebx = _v8;
        __ecx = _v4;
L11:
    }
    if(__ecx != 1) {
        goto L10;
    }
    __eax = 1;
    return 1;
    goto L11;
}

camlList__fold_left2_1119(
    intOrPtr __eax,                        // r0
    _unknown_ __ebx,                       // r1
    intOrPtr* __ecx,                       // r2
    intOrPtr* __edx,                       // r3
    intOrPtr* __esp                        // r7
)
{// addr = 0x08053FE0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _t10;                         // _t10
    intOrPtr _t12;                         // _t12
    intOrPtr* _t13;                        // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    intOrPtr _t16;                         // _t16

    __esp = __esp;
    __edx = __edx;
    __ecx = __ecx;
    _t10 = __eax;
    while(1) {
        __esi = __eax;
        if(__ecx == 1) {
            break;
        }
        if(__edx == 1) {
L10:
            __eax = "List.fold_left2";
            __esp = __esp + 12;
            _t16 = _t10;
            while(1) {
                _t12 = caml_young_ptr - 12;
                caml_young_ptr = _t12;
                if(_t12 >= caml_young_limit) {
                    _t13 = _t12 + 4;
                     *((intOrPtr*)(_t13 - 4)) = 2048;
                     *_t13 =  &caml_exn_Invalid_argument;
                     *((intOrPtr*)(_t13 + 4)) = _t16;
                    caml_raise_exn(_t13);
                }
                caml_call_gc(__esp);
            }
        }
         *__esp = __esi;
        __eax =  *((intOrPtr*)(__edx + 4));
        _v4 =  *((intOrPtr*)(__edx + 4));
        __edx =  *__edx;
        __eax =  *((intOrPtr*)(__ecx + 4));
        _v8 =  *((intOrPtr*)(__ecx + 4));
        __ecx =  *__ecx;
        __eax = __ebx;
        __ebx = __ecx;
        __ecx = __edx;
        __edx = __esi;
        caml_apply3();
        __ebx = __eax;
        __eax =  *__esp;
        __ecx = _v8;
        __edx = _v4;
L11:
    }
    if(__edx != 1) {
        goto L10;
    }
    __eax = __ebx;
    return __ebx;
    goto L11;
}

camlList__fold_right2_1128(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __ecx,                        // r2
    intOrPtr* __esp                        // r7
)
{// addr = 0x08054040
    intOrPtr* _v4;                         // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _t14;                        // _t14
    intOrPtr _t17;                         // _t17
    intOrPtr* _t18;                        // _t18
    _unknown_ _t19;                        // _t19
    intOrPtr _t21;                         // _t21
    char* _t22;                            // _t22
    _unknown_ _t23;                        // _t23
    intOrPtr _t26;                         // _t26
    _unknown_ _t29;                        // _t29
    _unknown_ _t31;                        // _t31

    __esp = __esp;
    _t26 = __ecx;
    _t21 = __ebx;
    _t14 = __eax;
    if(_t21 != 1) {
        if(__ecx == 1) {
L12:
            __esp = __esp + 12;
L4:
            _t22 = "List.fold_right2";
            while(1) {
                _t17 = caml_young_ptr - 12;
                caml_young_ptr = _t17;
                if(_t17 >= caml_young_limit) {
                    _t18 = _t17 + 4;
                     *((intOrPtr*)(_t18 - 4)) = 2048;
                     *_t18 =  &caml_exn_Invalid_argument;
                     *((intOrPtr*)(_t18 + 4)) = _t22;
                    caml_raise_exn(_t18);
                }
                caml_call_gc(__esp);
            }
        }
        _v4 = __eax;
        __esi =  *((intOrPtr*)(__ecx + 4));
        _v8 = __ecx;
        __ecx =  *__ebx;
         *__esp =  *__ebx;
        __ebx =  *((intOrPtr*)(__ebx + 4));
        __ecx = __esi;
        camlList__fold_right2_1128(__eax, __ebx, __esi, __esp);
        __ecx = __eax;
        __eax =  *__esp;
        __ebx = _v8;
        __edx = _v4;
        __esp = __esp + 12;
        __esp = __esp - 8;
        if( *((intOrPtr*)(__edx + 4)) != 7) {
            _v4 = _t26;
             *__esp = _t21;
             *((intOrPtr*)( *__edx))();
             *((intOrPtr*)( *_t14))();
            __esp = __esp + 8;
            goto __ecx;
        }
        __esp = __esp + 8;
        goto __esi;
        goto L4;
    }
    if(_t26 != 1) {
        goto L12;
    }
    return;
}

camlList__for_all_1137(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx,                       // r1
    intOrPtr* __esp                        // r7
)
{// addr = 0x080540A0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _t4;                         // _t4
    _unknown_ _t5;                         // _t5
    _unknown_ _t8;                         // _t8
    intOrPtr* _t9;                         // _t9
    _unknown_ _t10;                        // _t10

    __esp = __esp;
    _t9 = __ebx;
    _t4 = __eax;
    while(1) {
        __edx = _t4;
        if(_t9 == 1) {
            break;
        }
         *__esp = __edx;
        _v4 =  *((intOrPtr*)(_t9 + 4));
         *((intOrPtr*)( *__edx))();
        if( *_t9 == 1) {
            return;
        } else {
            _t4 =  *__esp;
            _t9 = _v4;
            continue;
        }
L6:
    }
    return;
    goto L6;
}

camlList__exists_1141(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx,                       // r1
    intOrPtr* __esp                        // r7
)
{// addr = 0x080540F0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _t4;                         // _t4
    _unknown_ _t5;                         // _t5
    _unknown_ _t8;                         // _t8
    intOrPtr* _t9;                         // _t9
    _unknown_ _t10;                        // _t10

    __esp = __esp;
    _t9 = __ebx;
    _t4 = __eax;
    while(1) {
        __edx = _t4;
        if(_t9 == 1) {
            break;
        }
         *__esp = __edx;
        _v4 =  *((intOrPtr*)(_t9 + 4));
         *((intOrPtr*)( *__edx))();
        if( *_t9 == 1) {
            _t4 =  *__esp;
            _t9 = _v4;
            continue;
        }
        return;
L6:
    }
    return;
    goto L6;
}

camlList__for_all2_1145(
    intOrPtr __eax,                        // r0
    _unknown_ __ebx,                       // r1
    intOrPtr* __ecx,                       // r2
    intOrPtr* __esp                        // r7
)
{// addr = 0x08054140
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _t10;                         // _t10
    intOrPtr _t12;                         // _t12
    intOrPtr* _t13;                        // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    intOrPtr _t16;                         // _t16

    __esp = __esp;
    __ecx = __ecx;
    _t10 = __eax;
    while(1) {
        __edx = __eax;
        if(__ebx == 1) {
            break;
        }
        if(__ecx == 1) {
L12:
            __eax = "List.for_all2";
            __esp = __esp + 12;
            _t16 = _t10;
            while(1) {
                _t12 = caml_young_ptr - 12;
                caml_young_ptr = _t12;
                if(_t12 >= caml_young_limit) {
                    _t13 = _t12 + 4;
                     *((intOrPtr*)(_t13 - 4)) = 2048;
                     *_t13 =  &caml_exn_Invalid_argument;
                     *((intOrPtr*)(_t13 + 4)) = _t16;
                    caml_raise_exn(_t13);
                }
                caml_call_gc(__esp);
            }
        }
         *__esp = __edx;
        __eax =  *((intOrPtr*)(__ecx + 4));
        _v4 =  *((intOrPtr*)(__ecx + 4));
        __ecx =  *__ecx;
        __eax =  *((intOrPtr*)(__ebx + 4));
        _v8 =  *((intOrPtr*)(__ebx + 4));
        __eax =  *__ebx;
        __ebx = __ecx;
        __ecx = __edx;
        caml_apply2();
        if(__eax == 1) {
            __eax = 1;
            return 1;
        } else {
            __eax =  *__esp;
            __ebx = _v8;
            __ecx = _v4;
            continue;
        }
L13:
    }
    if(__ecx != 1) {
        goto L12;
    }
    __eax = 3;
    return 3;
    goto L13;
}

camlList__exists2_1153(
    intOrPtr __eax,                        // r0
    _unknown_ __ebx,                       // r1
    intOrPtr* __ecx,                       // r2
    intOrPtr* __esp                        // r7
)
{// addr = 0x080541B0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _t10;                         // _t10
    intOrPtr _t12;                         // _t12
    intOrPtr* _t13;                        // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    intOrPtr _t16;                         // _t16

    __esp = __esp;
    __ecx = __ecx;
    _t10 = __eax;
    while(1) {
        __edx = __eax;
        if(__ebx == 1) {
            break;
        }
        if(__ecx == 1) {
L12:
            __eax = "List.exists2";
            __esp = __esp + 12;
            _t16 = _t10;
            while(1) {
                _t12 = caml_young_ptr - 12;
                caml_young_ptr = _t12;
                if(_t12 >= caml_young_limit) {
                    _t13 = _t12 + 4;
                     *((intOrPtr*)(_t13 - 4)) = 2048;
                     *_t13 =  &caml_exn_Invalid_argument;
                     *((intOrPtr*)(_t13 + 4)) = _t16;
                    caml_raise_exn(_t13);
                }
                caml_call_gc(__esp);
            }
        }
         *__esp = __edx;
        __eax =  *((intOrPtr*)(__ecx + 4));
        _v4 =  *((intOrPtr*)(__ecx + 4));
        __ecx =  *__ecx;
        __eax =  *((intOrPtr*)(__ebx + 4));
        _v8 =  *((intOrPtr*)(__ebx + 4));
        __eax =  *__ebx;
        __ebx = __ecx;
        __ecx = __edx;
        caml_apply2();
        if(__eax == 1) {
            __eax =  *__esp;
            __ebx = _v8;
            __ecx = _v4;
            continue;
        }
        __eax = 3;
        return 3;
L13:
    }
    if(__ecx != 1) {
        goto L12;
    }
    __eax = 1;
    return 1;
    goto L13;
}

camlList__mem_1161(
    intOrPtr __eax,                        // r0
    intOrPtr* __ebx,                       // r1
    intOrPtr* __esp                        // r7
)
{// addr = 0x08054220
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _t4;                          // _t4
    _unknown_ _t5;                         // _t5
    _unknown_ _t7;                         // _t7
    intOrPtr* _t8;                         // _t8

    __esp = __esp;
    _t8 = __ebx;
    _t4 = __eax;
    while(_t8 != 1) {
         *__esp = _t4;
        _v4 =  *((intOrPtr*)(_t8 + 4));
        caml_c_call( *_t8, _t4);
        if(caml_compare != 1) {
            _t4 =  *__esp;
            _t8 = _v4;
            continue;
        }
        return 3;
L6:
    }
    return 1;
    goto L6;
}

camlList__memq_1165(
    _unknown_ __eax,                       // r0
    intOrPtr* __ebx                        // r1
)
{// addr = 0x08054280
    _unknown_ _t2;                         // _t2
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4
    intOrPtr* _t5;                         // _t5
    _unknown_ _t6;                         // _t6

L0:
    while(1) {
L0:
        _t5 = __ebx;
        _t2 = __eax;
        if(_t5 == 1) {
            break;
        }
L1:
        if( *_t5 != _t2) {
L3:
            continue;
        }
L2:
        return 3;
L5:
    }
    return 1;
    goto L5;
}

camlList__assoc_1169(
    intOrPtr __eax                         // r0
)
{// addr = 0x080542C0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _t9;                          // _t9
    intOrPtr _t11;                         // _t11
    intOrPtr* _t12;                        // _t12
    _unknown_ _t13;                        // _t13
    intOrPtr* _t16;                        // _t16
    intOrPtr* _t20;                        // _t20

    _t9 = __eax;
    while(_t16 != 1) {
         *__esp = _t9;
        _v8 =  *((intOrPtr*)(_t16 + 4));
        _t20 =  *_t16;
        _v4 =  *((intOrPtr*)(_t20 + 4));
        caml_c_call( *_t20, _t9);
        if(caml_compare != 1) {
            _t9 =  *__esp;
            _t16 = _v8;
            continue;
        }
        return _v4;
        while(1) {
L5:
            _t11 = caml_young_ptr - 8;
            caml_young_ptr = _t11;
            if(_t11 >= caml_young_limit) {
                _t12 = _t11 + 4;
                 *((intOrPtr*)(_t12 - 4)) = 1024;
                 *_t12 =  &caml_exn_Not_found;
                caml_raise_exn(_t12);
            }
            goto L7;
        }
    }
    goto L5;
}

camlList__assq_1174(
    _unknown_ __eax,                       // r0
    intOrPtr* __ebx                        // r1
)
{// addr = 0x08054350
    _unknown_ _t5;                         // _t5
    intOrPtr _t7;                          // _t7
    intOrPtr* _t8;                         // _t8
    _unknown_ _t9;                         // _t9
    intOrPtr* _t11;                        // _t11
    _unknown_ _t12;                        // _t12
    intOrPtr* _t13;                        // _t13

L0:
    while(1) {
L0:
        _t11 = __ebx;
        _t5 = __eax;
        if(_t11 == 1) {
            break;
        }
L1:
        _t13 =  *_t11;
        __edx =  *((intOrPtr*)(_t13 + 4));
        if( *_t13 != _t5) {
L3:
            continue;
        }
L2:
        return __edx;
        while(1) {
L4:
            _t7 = caml_young_ptr - 8;
            caml_young_ptr = _t7;
            if(_t7 >= caml_young_limit) {
                _t8 = _t7 + 4;
                 *((intOrPtr*)(_t8 - 4)) = 1024;
                 *_t8 =  &caml_exn_Not_found;
                caml_raise_exn(_t8);
            }
            goto L6;
        }
    }
    goto L4;
}

camlList__mem_assoc_1179(
    intOrPtr __eax,                        // r0
    intOrPtr* __ebx,                       // r1
    intOrPtr* __esp                        // r7
)
{// addr = 0x080543C0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _t4;                          // _t4
    _unknown_ _t5;                         // _t5
    _unknown_ _t7;                         // _t7
    intOrPtr* _t8;                         // _t8

    __esp = __esp;
    _t8 = __ebx;
    _t4 = __eax;
    while(_t8 != 1) {
         *__esp = _t4;
        _v4 =  *((intOrPtr*)(_t8 + 4));
        caml_c_call( *((intOrPtr*)( *_t8)), _t4);
        if(caml_compare != 1) {
            _t4 =  *__esp;
            _t8 = _v4;
            continue;
        }
        return 3;
L6:
    }
    return 1;
    goto L6;
}

camlList__mem_assq_1184(
    _unknown_ __eax,                       // r0
    intOrPtr* __ebx                        // r1
)
{// addr = 0x08054420
    _unknown_ _t2;                         // _t2
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4
    intOrPtr* _t5;                         // _t5
    _unknown_ _t6;                         // _t6

L0:
    while(1) {
L0:
        _t5 = __ebx;
        _t2 = __eax;
        if(_t5 == 1) {
            break;
        }
L1:
        if( *((intOrPtr*)( *_t5)) != _t2) {
L3:
            continue;
        }
L2:
        return 3;
L5:
    }
    return 1;
    goto L5;
}

camlList__remove_assoc_1189(
    intOrPtr __eax,                        // r0
    intOrPtr* __ebx,                       // r1
    intOrPtr* __esp                        // r7
)
{// addr = 0x08054460
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _v8;                         // _cfa_fffffff8
    intOrPtr _t10;                         // _t10
    _unknown_ _t11;                        // _t11
    intOrPtr _t16;                         // _t16
    intOrPtr* _t17;                        // _t17
    intOrPtr* _t19;                        // _t19
    intOrPtr* _t20;                        // _t20
    intOrPtr _t25;                         // _t25

    __esp = __esp;
    _t19 = __ebx;
    _t10 = __eax;
    if(_t19 == 1) {
        return 1;
    } else {
         *__esp = _t10;
        _v4 =  *((intOrPtr*)(_t19 + 4));
        _t20 =  *_t19;
        _v8 = _t20;
        caml_c_call( *_t20, _t10);
        if(caml_compare != 1) {
            _t25 = camlList__remove_assoc_1189( *__esp, _v4, __esp);
            while(1) {
                _t16 = caml_young_ptr - 12;
                caml_young_ptr = _t16;
                if(_t16 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t17 = _t16 + 4;
             *((intOrPtr*)(_t17 - 4)) = 2048;
             *_t17 = _v8;
             *((intOrPtr*)(_t17 + 4)) = _t25;
            return _t17;
            goto L8;
        }
        return _v4;
    }
L8:
}

camlList__remove_assq_1195(
    _unknown_ __eax,                       // r0
    intOrPtr* __ebx                        // r1
)
{// addr = 0x080544F0
    _unknown_ _t5;                         // _t5
    _unknown_ _t6;                         // _t6
    intOrPtr _t9;                          // _t9
    intOrPtr* _t10;                        // _t10
    intOrPtr* _t12;                        // _t12
    intOrPtr _t16;                         // _t16

    _t12 = __ebx;
    _t5 = __eax;
    if(_t12 == 1) {
        return 1;
    } else {
        __esi =  *((intOrPtr*)(_t12 + 4));
        __edx =  *_t12;
        if( *__edx != _t5) {
             *__esp = __edx;
            _t16 = camlList__remove_assq_1195(_t5, __esi);
            while(1) {
                _t9 = caml_young_ptr - 12;
                caml_young_ptr = _t9;
                if(_t9 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t10 = _t9 + 4;
             *((intOrPtr*)(_t10 - 4)) = 2048;
             *_t10 =  *__esp;
             *((intOrPtr*)(_t10 + 4)) = _t16;
            return _t10;
            goto L8;
        }
        return __esi;
    }
L8:
}

camlList__find_1201(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx                        // r1
)
{// addr = 0x08054560
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _t8;                         // _t8
    intOrPtr _t10;                         // _t10
    intOrPtr* _t11;                        // _t11
    intOrPtr _t13;                         // _t13
    _unknown_ _t14;                        // _t14
    intOrPtr* _t15;                        // _t15
    _unknown_ _t16;                        // _t16

    _t15 = __ebx;
    _t8 = __eax;
    while(1) {
        __edx = _t8;
        if(_t15 == 1) {
            break;
        }
         *__esp = __edx;
        _v8 =  *((intOrPtr*)(_t15 + 4));
        _t13 =  *_t15;
        _v4 = _t13;
         *((intOrPtr*)( *__edx))();
        if(_t13 == 1) {
            _t8 =  *__esp;
            _t15 = _v8;
            continue;
        }
        return;
        while(1) {
L5:
            _t10 = caml_young_ptr - 8;
            caml_young_ptr = _t10;
            if(_t10 >= caml_young_limit) {
                _t11 = _t10 + 4;
                 *((intOrPtr*)(_t11 - 4)) = 1024;
                 *_t11 =  &caml_exn_Not_found;
                caml_raise_exn(_t11);
            }
            goto L7;
        }
    }
    goto L5;
}

camlList__find_all_1205()
{// addr = 0x080545E0
    intOrPtr _t6;                          // _t6
    intOrPtr _t8;                          // _t8
    _unknown_ _t9;                         // _t9

    __ecx = _t6;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    __ebx = _t8 + 4;
     *((intOrPtr*)(__ebx - 4)) = 4343;
     *__ebx = caml_curry2;
     *((intOrPtr*)(__ebx + 4)) = 5;
     *((intOrPtr*)(__ebx + 8)) = camlList__find_1207;
     *((intOrPtr*)(__ebx + 12)) = __ecx;
    __ecx =  *__ebx;
    goto ( *__ebx);
}

camlList__partition_1212(
    intOrPtr* __eax                        // r0
)
{// addr = 0x08054630
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _v12;                        // _cfa_fffffff4
    intOrPtr* _v16;                        // _cfa_fffffff0
    intOrPtr* _t30;                        // _t30
    intOrPtr* _t31;                        // _t31
    intOrPtr* _t32;                        // _t32
    intOrPtr _t34;                         // _t34
    intOrPtr* _t35;                        // _t35
    intOrPtr _t37;                         // _t37
    intOrPtr _t39;                         // _t39
    intOrPtr _t43;                         // _t43
    intOrPtr* _t44;                        // _t44
    _unknown_ _t45;                        // _t45
    _unknown_ _t46;                        // _t46
    intOrPtr _t47;                         // _t47
    intOrPtr* _t52;                        // _t52
    _unknown_ _t53;                        // _t53

    _t30 = __eax;
    __esi = _t30;
    _t52 = _t44;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 20;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    __edx = __eax + 4;
     *((intOrPtr*)(__edx - 4)) = 4343;
     *__edx = caml_curry3;
     *((intOrPtr*)(__edx + 4)) = 7;
     *((intOrPtr*)(__edx + 8)) = camlList__part_1215;
     *((intOrPtr*)(__edx + 12)) = __esi;
    __ebx = 1;
    __eax = 1;
    __esp = __esp - 20;
    while(1) {
        _v16 = _t30;
        if(_t52 == 1) {
            break;
        }
        _v4 = __edx;
        _v12 = _t44;
        _v8 =  *((intOrPtr*)(_t52 + 4));
        _t37 =  *_t52;
         *__esp = _t37;
         *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(__edx + 12))))))();
        if(_t37 == 1) {
            while(1) {
                _t39 = caml_young_ptr - 12;
                caml_young_ptr = _t39;
                if(_t39 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
        } else {
            while(1) {
                _t43 = caml_young_ptr - 12;
                caml_young_ptr = _t43;
                if(_t43 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t30 = _t43 + 4;
             *((intOrPtr*)(_t30 - 4)) = 2048;
             *_t30 =  *__esp;
             *((intOrPtr*)(_t30 + 4)) = _v16;
            _t44 = _v12;
            _t52 = _v8;
            __edx = _v4;
            continue;
        }
        _t44 = _t39 + 4;
         *((intOrPtr*)(_t44 - 4)) = 2048;
         *_t44 =  *__esp;
         *((intOrPtr*)(_t44 + 4)) = _v12;
        _t30 = _v16;
        _t52 = _v8;
        __edx = _v4;
    }
    _t31 = _t44;
    camlList__rev_append_1051(_t31, 1);
     *__esp = _t31;
    _t32 = _v16;
    camlList__rev_append_1051(_t32, 1);
    _t47 = _t32;
    while(1) {
        _t34 = caml_young_ptr - 12;
        caml_young_ptr = _t34;
        if(_t34 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t35 = _t34 + 4;
     *((intOrPtr*)(_t35 - 4)) = 2048;
     *_t35 = _t47;
     *((intOrPtr*)(_t35 + 4)) =  *__esp;
    __esp = __esp + 20;
    return;
}

camlList__split_1220(
    intOrPtr* __eax,                       // r0
    intOrPtr* __esp                        // r7
)
{// addr = 0x08054680
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _t15;                        // _t15
    intOrPtr* _t18;                        // _t18
    intOrPtr _t20;                         // _t20
    intOrPtr* _t23;                        // _t23
    intOrPtr _t26;                         // _t26
    intOrPtr* _t27;                        // _t27
    intOrPtr* _t28;                        // _t28
    intOrPtr* _t29;                        // _t29
    intOrPtr _t31;                         // _t31

    __esp = __esp;
    _t15 = __eax;
    if(_t15 == 1) {
        return  &camlList__41;
    } else {
        _t28 =  *_t15;
         *__esp =  *((intOrPtr*)(_t28 + 4));
        _v4 =  *_t28;
        _t18 = camlList__split_1220( *((intOrPtr*)(_t15 + 4)), __esp);
        _t26 =  *((intOrPtr*)(_t18 + 4));
        _t31 =  *_t18;
        while(1) {
            _t20 = caml_young_ptr - 36;
            caml_young_ptr = _t20;
            if(_t20 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t29 = _t20 + 4;
         *((intOrPtr*)(_t29 - 4)) = 2048;
         *_t29 =  *__esp;
         *((intOrPtr*)(_t29 + 4)) = _t26;
        _t27 = _t29 + 12;
         *((intOrPtr*)(_t27 - 4)) = 2048;
         *_t27 = _v4;
         *((intOrPtr*)(_t27 + 4)) = _t31;
        _t23 = _t29 + 24;
         *((intOrPtr*)(_t23 - 4)) = 2048;
         *_t23 = _t27;
         *((intOrPtr*)(_t23 + 4)) = _t29;
        return _t23;
    }
}

camlList__combine_1226(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    intOrPtr* __esp                        // r7
)
{// addr = 0x08054710
    intOrPtr* _v4;                         // _cfa_fffffffc
    intOrPtr _t16;                         // _t16
    intOrPtr* _t17;                        // _t17
    _unknown_ _t18;                        // _t18
    _unknown_ _t19;                        // _t19
    _unknown_ _t20;                        // _t20
    char* _t21;                            // _t21

    __esp = __esp;
    _t20 = __ebx;
    if(__eax == 1) {
        if(_t20 != 1) {
            goto L11;
        }
    } else {
        if(__ebx == 1) {
L11:
            __esp = __esp + 8;
            _t21 = "List.combine";
            while(1) {
                _t16 = caml_young_ptr - 12;
                caml_young_ptr = _t16;
                if(_t16 >= caml_young_limit) {
                    _t17 = _t16 + 4;
                     *((intOrPtr*)(_t17 - 4)) = 2048;
                     *_t17 =  &caml_exn_Invalid_argument;
                     *((intOrPtr*)(_t17 + 4)) = _t21;
                    caml_raise_exn(_t17);
                }
                caml_call_gc(__esp);
            }
        }
        __ecx =  *__ebx;
        _v4 =  *__ebx;
        __ecx =  *__eax;
         *__esp =  *__eax;
        __eax =  *((intOrPtr*)(__eax + 4));
        __ecx = __eax;
        while(1) {
L7:
            __eax = caml_young_ptr;
            __eax = caml_young_ptr - 24;
            caml_young_ptr = __eax;
            if(__eax >= caml_young_limit) {
                break;
            }
            goto L12;
        }
        __ebx = __eax + 4;
         *((intOrPtr*)(__ebx - 4)) = 2048;
        __eax =  *__esp;
         *__ebx =  *__esp;
        __eax = _v4;
         *((intOrPtr*)(__ebx + 4)) = _v4;
        __eax = __ebx + 12;
         *((intOrPtr*)(__eax - 4)) = 2048;
         *__eax = __ebx;
         *((intOrPtr*)(__eax + 4)) = __ecx;
        return __eax;
L13:
L12:
        caml_call_gc(__esp);
        goto L7;
    }
    return 1;
    goto L13;
}

camlList__merge_1233(
    intOrPtr __eax,                        // r0
    intOrPtr* __ebx,                       // r1
    intOrPtr* __ecx,                       // r2
    intOrPtr* __esp                        // r7
)
{// addr = 0x080547B0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _v8;                         // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _t23;                         // _t23
    intOrPtr _t26;                         // _t26
    intOrPtr _t30;                         // _t30
    intOrPtr _t36;                         // _t36
    intOrPtr* _t39;                        // _t39
    _unknown_ _t40;                        // _t40
    intOrPtr* _t42;                        // _t42
    intOrPtr* _t44;                        // _t44
    intOrPtr* _t45;                        // _t45
    _unknown_ _t47;                        // _t47
    intOrPtr _t49;                         // _t49
    intOrPtr _t51;                         // _t51

    __esp = __esp;
    _t45 = __ecx;
    _t39 = __ebx;
    _t23 = __eax;
    if(_t39 == 1) {
        return _t45;
    } else {
        if(_t45 == 1) {
            return _t39;
        } else {
            _v8 = _t45;
             *__esp = _t39;
            _v16 = _t23;
            _v24 =  *((intOrPtr*)(_t45 + 4));
            _v20 =  *_t45;
            _v12 =  *((intOrPtr*)(_t39 + 4));
            _t26 =  *_t39;
            _v4 = _t26;
            caml_apply2();
            if(_t26 > 1) {
                _t49 = camlList__merge_1233(_v16,  *__esp, _v24, __esp);
                while(1) {
L7:
                    _t30 = caml_young_ptr - 12;
                    caml_young_ptr = _t30;
                    if(_t30 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                _t42 = _t30 + 4;
                 *((intOrPtr*)(_t42 - 4)) = 2048;
                 *_t42 = _v20;
                 *((intOrPtr*)(_t42 + 4)) = _t49;
                return _t42;
            } else {
                _t51 = camlList__merge_1233(_v16, _v12, _v8, __esp);
                while(1) {
                    _t36 = caml_young_ptr - 12;
                    caml_young_ptr = _t36;
                    if(_t36 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                _t44 = _t36 + 4;
                 *((intOrPtr*)(_t44 - 4)) = 2048;
                 *_t44 = _v4;
                 *((intOrPtr*)(_t44 + 4)) = _t51;
                return _t44;
            }
        }
    }
}

camlList__chop_1243(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx                        // r1
)
{// addr = 0x080548B0
    intOrPtr _t7;                          // _t7
    intOrPtr* _t8;                         // _t8
    _unknown_ _t9;                         // _t9
    _unknown_ _t10;                        // _t10
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13

L0:
    while(1) {
L0:
        _t12 = __ebx;
        if(__eax == 1) {
            break;
        }
L2:
        if(_t12 == 1) {
            while(1) {
L4:
                _t7 = caml_young_ptr - 12;
                caml_young_ptr = _t7;
                if(_t7 >= caml_young_limit) {
                    _t8 = _t7 + 4;
                     *((intOrPtr*)(_t8 - 4)) = 2048;
                     *_t8 =  &caml_exn_Assert_failure;
                     *((intOrPtr*)(_t8 + 4)) =  &camlList__39;
                    caml_raise_exn(_t8);
                }
                goto L6;
            }
        }
L3:
    }
    return _t12;
}

camlList__stable_sort_1248(
    signed int __eax                       // r0
)
{// addr = 0x08054910
    signed int _v4;                        // _cfa_fffffffc
    signed int _v8;                        // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    signed int _t161;                      // _t161
    signed int _t164;                      // _t164
    intOrPtr _t165;                        // _t165
    signed int _t167;                      // _t167
    signed int _t171;                      // _t171
    signed int _t174;                      // _t174
    signed int _t175;                      // _t175
    signed int _t177;                      // _t177
    signed int _t178;                      // _t178
    _unknown_ _t181;                       // _t181
    signed int _t182;                      // _t182
    _unknown_ _t183;                       // _t183
    _unknown_ _t184;                       // _t184
    signed int _t185;                      // _t185

    _t161 = __eax;
    __esp = __esp - 8;
    _v4 = _t174;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 84;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    __edx = __eax + 4;
     *((intOrPtr*)(__edx - 4)) = 4343;
     *__edx = caml_curry3;
     *(__edx + 4) = 7;
     *((intOrPtr*)(__edx + 8)) = camlList__rev_merge_1251;
     *(__edx + 12) = __esi;
    __ecx = __edx + 20;
     *((intOrPtr*)(__ecx - 4)) = 4343;
     *__ecx = caml_curry3;
     *(__ecx + 4) = 7;
     *((intOrPtr*)(__ecx + 8)) = camlList__rev_merge_rev_1261;
     *(__ecx + 12) = __esi;
    __eax = __edx + 40;
     *__esp = __eax;
     *((intOrPtr*)(__eax - 4)) = 10487;
     *__eax = caml_curry2;
     *(__eax + 4) = 5;
     *((intOrPtr*)(__eax + 8)) = camlList__sort_1271;
     *((intOrPtr*)(__eax + 12)) = 4345;
     *((intOrPtr*)(__eax + 16)) = caml_curry2;
     *((intOrPtr*)(__eax + 20)) = 5;
     *((intOrPtr*)(__eax + 24)) = camlList__rev_sort_1272;
     *(__eax + 28) = __esi;
     *(__eax + 32) = __edx;
     *(__eax + 36) = __ecx;
    __eax = 1;
    __eax = camlList__length_aux_1030(1, __ebx);
    if(__eax >= 5) {
        __ebx = _v4;
        __ecx =  *__esp;
        __esp =  &((__esp)[2]);
        __esp = __esp - 20;
        if(__eax == 5) {
            if(__ebx == 1) {
                _v4 = __ecx;
                goto L44;
            }
            __edx =  *(__ebx + 4);
            if(__edx == 1) {
                _v4 = __ecx;
                goto L44;
            }
            __edx =  *__edx;
             *__esp = __edx;
            __eax =  *__ebx;
            _v16 = __eax;
            __ecx =  *(__ecx + 28);
            __ebx = __edx;
            caml_apply2();
            if(__eax > 1) {
                while(1) {
                    __eax = caml_young_ptr;
                    __eax = caml_young_ptr - 24;
                    caml_young_ptr = __eax;
                    if(__eax >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
            } else {
                while(1) {
                    __eax = caml_young_ptr;
                    __eax = caml_young_ptr - 24;
                    caml_young_ptr = __eax;
                    if(__eax >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                __ecx = __eax + 4;
                 *((intOrPtr*)(__ecx - 4)) = 2048;
                __eax =  *__esp;
                 *__ecx =  *__esp;
                 *(__ecx + 4) = 1;
                __ebx = __ecx + 12;
                 *((intOrPtr*)(__ebx - 4)) = 2048;
                __eax = _v16;
                 *__ebx = _v16;
                 *(__ebx + 4) = __ecx;
                __eax = __ebx;
                __esp =  &((__esp)[5]);
                return __ebx;
                goto L64;
            }
            __ecx = __eax + 4;
             *((intOrPtr*)(__ecx - 4)) = 2048;
            __eax = _v16;
             *__ecx = _v16;
             *(__ecx + 4) = 1;
            __ebx = __ecx + 12;
             *((intOrPtr*)(__ebx - 4)) = 2048;
            __eax =  *__esp;
             *__ebx =  *__esp;
             *(__ebx + 4) = __ecx;
            __eax = __ebx;
            __esp =  &((__esp)[5]);
            return __ebx;
        } else {
            _v4 = __ecx;
            if(__eax != 7 || __ebx == 1) {
L44:
                _v16 = __ebx;
                __eax = __eax >> 1;
                __ecx = __eax >> 1 | 1;
                 *__esp = __ecx;
                __eax = __eax - __ecx;
                _v12 = __eax;
                __eax = __ecx;
                _v8 = camlList__chop_1243(__ecx, __ebx);
                _v4 = _v4 + 16;
                __eax =  *__esp;
                __ebx = _v16;
                 *__esp = camlList__rev_sort_1272( *__esp, __esp);
                _v4 = _v4 + 16;
                __eax = _v12;
                __ebx = _v8;
                __ebx = camlList__rev_sort_1272(_v12, __esp);
                __eax = _v4;
                __edx =  *(_v4 + 36);
                __ecx = 1;
                __eax =  *__esp;
                __esp =  &((__esp)[5]);
                __esp = __esp - 32;
                while(_t161 != 1) {
                    if(_t174 == 1) {
                        _t175 = _t177;
                        __esp =  &((__esp)[8]);
L53:
                        while(_t161 != 1) {
                            _t185 =  *(_t161 + 4);
                            _t183 =  *_t161;
                            while(1) {
                                _t164 = caml_young_ptr - 12;
                                caml_young_ptr = _t164;
                                if(_t164 >= caml_young_limit) {
                                    break;
                                }
                                caml_call_gc(__esp);
                            }
                            _t178 = _t164 + 4;
                             *((intOrPtr*)(_t178 - 4)) = 2048;
                             *_t178 = _t183;
                             *(_t178 + 4) = _t175;
                            _t161 = _t185;
                            _t175 = _t178;
                        }
                        return _t175;
                        goto L64;
                    }
                    _v4 = _t182;
                    _v16 = _t177;
                    _v8 = _t174;
                    _v28 = _t161;
                    _v24 =  *(_t174 + 4);
                     *__esp =  *_t174;
                    _v12 =  *(_t161 + 4);
                    _t165 =  *_t161;
                    _v20 = _t165;
                    caml_apply2();
                    if(_t165 <= 1) {
                        while(1) {
                            _t167 = caml_young_ptr - 12;
                            caml_young_ptr = _t167;
                            if(_t167 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                    } else {
                        while(1) {
                            _t171 = caml_young_ptr - 12;
                            caml_young_ptr = _t171;
                            if(_t171 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                        _t177 = _t171 + 4;
                         *((intOrPtr*)(_t177 - 4)) = 2048;
                         *_t177 = _v20;
                         *(_t177 + 4) = _v16;
                        _t161 = _v12;
                        _t174 = _v8;
                        _t182 = _v4;
                        continue;
                    }
                    _t177 = _t167 + 4;
                     *((intOrPtr*)(_t177 - 4)) = 2048;
                     *_t177 =  *__esp;
                     *(_t177 + 4) = _v16;
                    _t161 = _v28;
                    _t174 = _v24;
                    _t182 = _v4;
                }
                _t161 = _t174;
                _t175 = _t177;
                __esp =  &((__esp)[8]);
                goto L53;
            }
            __esi =  *(__ebx + 4);
            if(__esi == 1) {
                goto L44;
            }
            __edx =  *(__esi + 4);
            if(__edx == 1) {
                goto L44;
            }
            __eax =  *__edx;
             *__esp =  *__edx;
            __edx =  *__esi;
            _v16 = __edx;
            __eax =  *__ebx;
            _v12 = __eax;
            __ecx =  *(__ecx + 28);
            __ebx = __edx;
            caml_apply2();
            if(__eax > 1) {
                __eax = _v4;
                __ecx =  *(_v4 + 28);
                __eax = _v12;
                __ebx =  *__esp;
                caml_apply2();
                if(_v12 > 1) {
                    __eax = _v4;
                    __ecx =  *(_v4 + 28);
                    __eax = _v16;
                    __ebx =  *__esp;
                    caml_apply2();
                    if(_v16 > 1) {
                        while(1) {
                            __eax = caml_young_ptr;
                            __eax = caml_young_ptr - 36;
                            caml_young_ptr = __eax;
                            if(__eax >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                    } else {
                        while(1) {
                            __eax = caml_young_ptr;
                            __eax = caml_young_ptr - 36;
                            caml_young_ptr = __eax;
                            if(__eax >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                        __ebx = __eax + 4;
                         *((intOrPtr*)(__ebx - 4)) = 2048;
                        __eax = _v12;
                         *__ebx = _v12;
                         *(__ebx + 4) = 1;
                        __ecx = __ebx + 12;
                         *((intOrPtr*)(__ecx - 4)) = 2048;
                        __eax =  *__esp;
                         *__ecx =  *__esp;
                         *(__ecx + 4) = __ebx;
                        __ebx = __ebx + 24;
                         *((intOrPtr*)(__ebx - 4)) = 2048;
                        __eax = _v16;
                         *__ebx = _v16;
                         *(__ebx + 4) = __ecx;
                        __eax = __ebx;
                        __esp =  &((__esp)[5]);
                        return __ebx;
                        goto L64;
                    }
                    __ebx = __eax + 4;
                     *((intOrPtr*)(__ebx - 4)) = 2048;
                    __eax = _v12;
                     *__ebx = _v12;
                     *(__ebx + 4) = 1;
                    __ecx = __ebx + 12;
                     *((intOrPtr*)(__ecx - 4)) = 2048;
                    __eax = _v16;
                     *__ecx = _v16;
                     *(__ecx + 4) = __ebx;
                    __ebx = __ebx + 24;
                     *((intOrPtr*)(__ebx - 4)) = 2048;
                    __eax =  *__esp;
                     *__ebx =  *__esp;
                     *(__ebx + 4) = __ecx;
                    __eax = __ebx;
                    __esp =  &((__esp)[5]);
                    return __ebx;
                } else {
                    while(1) {
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 36;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                    __ebx = __eax + 4;
                     *((intOrPtr*)(__ebx - 4)) = 2048;
                    __eax =  *__esp;
                     *__ebx =  *__esp;
                     *(__ebx + 4) = 1;
                    __ecx = __ebx + 12;
                     *((intOrPtr*)(__ecx - 4)) = 2048;
                    __eax = _v12;
                     *__ecx = _v12;
                     *(__ecx + 4) = __ebx;
                    __ebx = __ebx + 24;
                     *((intOrPtr*)(__ebx - 4)) = 2048;
                    __eax = _v16;
                     *__ebx = _v16;
                     *(__ebx + 4) = __ecx;
                    __eax = __ebx;
                    __esp =  &((__esp)[5]);
                    return __ebx;
                }
            } else {
                __eax = _v4;
                __ecx =  *(_v4 + 28);
                __eax = _v16;
                __ebx =  *__esp;
                caml_apply2();
                if(_v16 > 1) {
                    __eax = _v4;
                    __ecx =  *(_v4 + 28);
                    __eax = _v12;
                    __ebx =  *__esp;
                    caml_apply2();
                    if(_v12 > 1) {
                        while(1) {
                            __eax = caml_young_ptr;
                            __eax = caml_young_ptr - 36;
                            caml_young_ptr = __eax;
                            if(__eax >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                    } else {
                        while(1) {
                            __eax = caml_young_ptr;
                            __eax = caml_young_ptr - 36;
                            caml_young_ptr = __eax;
                            if(__eax >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                        __ebx = __eax + 4;
                         *((intOrPtr*)(__ebx - 4)) = 2048;
                        __eax = _v16;
                         *__ebx = _v16;
                         *(__ebx + 4) = 1;
                        __ecx = __ebx + 12;
                         *((intOrPtr*)(__ecx - 4)) = 2048;
                        __eax =  *__esp;
                         *__ecx =  *__esp;
                         *(__ecx + 4) = __ebx;
                        __ebx = __ebx + 24;
                         *((intOrPtr*)(__ebx - 4)) = 2048;
                        __eax = _v12;
                         *__ebx = _v12;
                         *(__ebx + 4) = __ecx;
                        __eax = __ebx;
                        __esp =  &((__esp)[5]);
                        return __ebx;
                        goto L64;
                    }
                    __ebx = __eax + 4;
                     *((intOrPtr*)(__ebx - 4)) = 2048;
                    __eax = _v16;
                     *__ebx = _v16;
                     *(__ebx + 4) = 1;
                    __ecx = __ebx + 12;
                     *((intOrPtr*)(__ecx - 4)) = 2048;
                    __eax = _v12;
                     *__ecx = _v12;
                     *(__ecx + 4) = __ebx;
                    __ebx = __ebx + 24;
                     *((intOrPtr*)(__ebx - 4)) = 2048;
                    __eax =  *__esp;
                     *__ebx =  *__esp;
                     *(__ebx + 4) = __ecx;
                    __eax = __ebx;
                    __esp =  &((__esp)[5]);
                    return __ebx;
                } else {
                    while(1) {
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 36;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                    __ebx = __eax + 4;
                     *((intOrPtr*)(__ebx - 4)) = 2048;
                    __eax =  *__esp;
                     *__ebx =  *__esp;
                     *(__ebx + 4) = 1;
                    __ecx = __ebx + 12;
                     *((intOrPtr*)(__ecx - 4)) = 2048;
                    __eax = _v16;
                     *__ecx = _v16;
                     *(__ecx + 4) = __ebx;
                    __ebx = __ebx + 24;
                     *((intOrPtr*)(__ebx - 4)) = 2048;
                    __eax = _v12;
                     *__ebx = _v12;
                     *(__ebx + 4) = __ecx;
                    __eax = __ebx;
                    __esp =  &((__esp)[5]);
                    return __ebx;
                }
            }
        }
L64:
    }
    __eax = _v4;
    __esp =  &((__esp)[2]);
    return _v4;
    goto L64;
}

camlList__entry()
{// addr = 0x08054A00
    _unknown_ _t44;                        // _t44

     *134686140 =  &camlList__38;
    camlList =  &camlList__37;
     *134685980 =  &camlList__36;
     *134685984 =  &camlList__35;
     *134685988 =  &camlList__34;
     *134685996 =  *134678636;
     *134686000 =  &camlList__33;
     *134685992 =  &camlList__32;
     *134686008 =  &camlList__31;
     *134686004 =  *134686008;
     *134686016 =  &camlList__30;
     *134686020 =  &camlList__29;
     *134686012 =  &camlList__28;
     *134686024 =  &camlList__27;
     *134686028 =  &camlList__26;
     *134686036 =  &camlList__25;
     *134686040 =  &camlList__24;
     *134686032 =  &camlList__23;
     *134686044 =  &camlList__22;
     *134686048 =  &camlList__21;
     *134686052 =  &camlList__20;
     *134686056 =  &camlList__19;
     *134686060 =  &camlList__18;
     *134686064 =  &camlList__17;
     *134686068 =  &camlList__16;
     *134686072 =  &camlList__15;
     *134686092 =  &camlList__14;
     *134686096 =  &camlList__13;
     *134686100 =  &camlList__12;
     *134686104 =  &camlList__11;
     *134686108 =  &camlList__10;
     *134686112 =  &camlList__9;
     *134686076 =  &camlList__8;
     *134686084 =  &camlList__7;
     *134686080 =  *134686084;
     *134686088 =  &camlList__6;
     *134686116 =  &camlList__5;
     *134686120 =  &camlList__4;
     *134686136 =  &camlList__3;
     *134686144 =  &camlList__2;
     *134686128 =  &camlList__1;
     *134686124 =  *134686128;
     *134686132 =  *134686128;
    return 1;
}

camlSys__set_signal_1057(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx                        // r1
)
{// addr = 0x08054C00
    _unknown_ _t2;                         // _t2
    _unknown_ _t3;                         // _t3

    __ebx = __ebx;
    caml_c_call(__eax, __ebx);
    return 1;
}

camlSys__catch_break_1082(
    intOrPtr __eax                         // r0
)
{// addr = 0x08054C20
    intOrPtr _t3;                          // _t3
    _unknown_ _t4;                         // _t4
    _unknown_ _t5;                         // _t5

    _t3 = __eax;
    if(_t3 == 1) {
        __ebx = 1;
        _t3 = -11;
    } else {
        while(1) {
            __eax = caml_young_ptr;
            __eax = caml_young_ptr - 8;
            caml_young_ptr = __eax;
            if(__eax >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        __ebx = __eax + 4;
         *((intOrPtr*)(__ebx - 4)) = 1024;
         *__ebx =  &camlSys__5;
        __eax = -11;
    }
    caml_c_call(_t3, __ebx);
    return 1;
}

camlSys__entry()
{// addr = 0x08054C80
    _unknown_ _t13;                        // _t13
    signed int _t18;                       // _t18
    intOrPtr _t23;                         // _t23
    intOrPtr* _t25;                        // _t25
    _unknown_ _t28;                        // _t28
    signed int _t32;                       // _t32
    intOrPtr* _t33;                        // _t33

    _push(1);
    caml_c_call();
    __esp = __esp + 4;
     *134688916 =  *caml_sys_get_argv;
    camlSys =  *((intOrPtr*)(caml_sys_get_argv + 4));
    _push(1);
    caml_c_call();
    __esp = __esp + 4;
     *134688924 =  *caml_sys_get_config;
     *134688928 =  *(caml_sys_get_config + 4);
     *134688936 = (2 << ( *134688928 + -20 >> 1 & 255)) - 3 + 2;
    _t32 =  *134688936 >> 1;
    _t18 =  *134688928 >> 1;
    if(_t18 < 0) {
        _t18 = _t18 + 7;
    }
    _t23 = (_t18 >> 3 << 1) * _t32 - 3 + 2;
     *134688932 = _t23;
    caml_alloc3(__esp);
    _t33 = _t23 + 4;
     *((intOrPtr*)(_t33 - 4)) = 1024;
     *_t33 = 1;
     *134688920 = _t33;
     *134688940 =  &camlSys__4;
     *134688944 = -1;
     *134688948 = -3;
     *134688952 = -5;
     *134688956 = -7;
     *134688960 = -9;
     *134688964 = -11;
     *134688968 = -13;
     *134688972 = -15;
     *134688976 = -17;
     *134688980 = -19;
     *134688984 = -21;
     *134688988 = -23;
     *134688992 = -25;
     *134688996 = -27;
     *134689000 = -29;
     *134689004 = -31;
     *134689008 = -33;
     *134689012 = -35;
     *134689016 = -37;
     *134689020 = -39;
     *134689024 = -41;
    _t25 = _t33 + 8;
     *((intOrPtr*)(_t25 - 4)) = 1024;
     *_t25 = "Sys.Break";
     *134689028 = _t25;
     *134689032 =  &camlSys__2;
     *134689036 = "3.12.1";
    return 1;
}

camlHashtbl__code_begin(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr* __esp                        // r7
)
{// addr = 0x08054E30
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr* _t18;                        // _t18
    _unknown_ _t19;                        // _t19
    intOrPtr _t20;                         // _t20
    intOrPtr _t24;                         // _t24
    intOrPtr* _t25;                        // _t25
    intOrPtr _t29;                         // _t29
    _unknown_ _t30;                        // _t30
    _unknown_ _t37;                        // _t37
    intOrPtr _t38;                         // _t38

    __esp = __esp;
    _t29 = __ebx;
    _t18 = __eax;
    if(_t18 == 1) {
        return 1;
    } else {
        _v8 = _t29;
        _v4 =  *((intOrPtr*)(_t18 + 8));
        _v12 =  *((intOrPtr*)(_t18 + 4));
        _t20 =  *_t18;
         *__esp = _t20;
        caml_apply2();
        if(_t20 == 1) {
            _t38 = camlHashtbl__code_begin(_v4, _v8, __esp);
            while(1) {
                _t24 = caml_young_ptr - 16;
                caml_young_ptr = _t24;
                if(_t24 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t25 = _t24 + 4;
             *((intOrPtr*)(_t25 - 4)) = 3072;
             *_t25 =  *__esp;
             *((intOrPtr*)(_t25 + 4)) = _v12;
             *((intOrPtr*)(_t25 + 8)) = _t38;
            return _t25;
            goto L8;
        }
         *((intOrPtr*)( *((intOrPtr*)(_v8 + 12)))) =  *((intOrPtr*)( *((intOrPtr*)(_v8 + 12)))) + -2;
        return _v4;
    }
L8:
}

camlHashtbl__find_in_bucket_1213(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr* __esp                        // r7
)
{// addr = 0x08054EE0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _t13;                        // _t13
    _unknown_ _t14;                        // _t14
    intOrPtr _t19;                         // _t19
    intOrPtr* _t20;                        // _t20
    intOrPtr _t21;                         // _t21
    _unknown_ _t22;                        // _t22
    _unknown_ _t28;                        // _t28
    intOrPtr _t29;                         // _t29

    __esp = __esp;
    _t21 = __ebx;
    _t13 = __eax;
    while(_t13 != 1) {
        _v8 = _t21;
         *__esp =  *((intOrPtr*)(_t13 + 8));
        _v4 =  *((intOrPtr*)(_t13 + 4));
        caml_apply2();
        if( *_t13 == 1) {
            _t13 =  *__esp;
            _t21 = _v8;
            continue;
        }
        _t29 = camlHashtbl__find_in_bucket_1213( *__esp, _v8, __esp);
        while(1) {
            _t19 = caml_young_ptr - 12;
            caml_young_ptr = _t19;
            if(_t19 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t20 = _t19 + 4;
         *((intOrPtr*)(_t20 - 4)) = 2048;
         *_t20 = _v4;
         *((intOrPtr*)(_t20 + 4)) = _t29;
        return _t20;
L9:
    }
    return 1;
    goto L9;
}

camlHashtbl__replace_bucket_1221(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x08054F70
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr* _t25;                        // _t25
    intOrPtr _t27;                         // _t27
    intOrPtr* _t28;                        // _t28
    _unknown_ _t29;                        // _t29
    intOrPtr _t30;                         // _t30
    intOrPtr _t31;                         // _t31
    intOrPtr _t33;                         // _t33
    intOrPtr* _t34;                        // _t34
    intOrPtr _t36;                         // _t36
    intOrPtr* _t37;                        // _t37
    intOrPtr _t38;                         // _t38
    _unknown_ _t39;                        // _t39
    _unknown_ _t50;                        // _t50
    intOrPtr _t51;                         // _t51

    _t38 = __ebx;
    _t25 = __eax;
    if(_t25 == 1) {
        while(1) {
            _t27 = caml_young_ptr - 8;
            caml_young_ptr = _t27;
            if(_t27 >= caml_young_limit) {
                _t28 = _t27 + 4;
                 *((intOrPtr*)(_t28 - 4)) = 1024;
                 *_t28 =  &caml_exn_Not_found;
                caml_raise_exn(_t28);
            }
            caml_call_gc(__esp);
        }
    }
    _v8 = _t38;
    _v4 =  *((intOrPtr*)(_t25 + 8));
     *__esp =  *((intOrPtr*)(_t25 + 4));
    _t30 =  *_t25;
    _v12 = _t30;
    caml_apply2();
    if(_t30 == 1) {
        _t31 = _v4;
        camlHashtbl__replace_bucket_1221(_t31, _v8);
        _t51 = _t31;
        while(1) {
L5:
            _t33 = caml_young_ptr - 16;
            caml_young_ptr = _t33;
            if(_t33 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t34 = _t33 + 4;
         *((intOrPtr*)(_t34 - 4)) = 3072;
         *_t34 = _v12;
         *((intOrPtr*)(_t34 + 4)) =  *__esp;
         *((intOrPtr*)(_t34 + 8)) = _t51;
        return;
        goto L12;
    } else {
        while(1) {
            _t36 = caml_young_ptr - 16;
            caml_young_ptr = _t36;
            if(_t36 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t37 = _t36 + 4;
         *((intOrPtr*)(_t37 - 4)) = 3072;
         *_t37 = _v12;
         *((intOrPtr*)(_t37 + 4)) =  *((intOrPtr*)(_v8 + 16));
         *((intOrPtr*)(_t37 + 8)) = _v4;
        return;
L12:
    }
    goto L5;
}

camlHashtbl__mem_in_bucket_1230(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr* __esp                        // r7
)
{// addr = 0x08055090
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _t6;                         // _t6
    _unknown_ _t7;                         // _t7
    _unknown_ _t9;                         // _t9
    intOrPtr _t10;                         // _t10
    _unknown_ _t11;                        // _t11
    _unknown_ _t14;                        // _t14

    __esp = __esp;
    _t10 = __ebx;
    _t6 = __eax;
    while(_t6 != 1) {
        _v4 = _t10;
         *__esp =  *((intOrPtr*)(_t6 + 8));
        caml_apply2();
        if( *_t6 == 1) {
            _t6 =  *__esp;
            _t10 = _v4;
            continue;
        }
        return 3;
L6:
    }
    return 1;
    goto L6;
}

camlHashtbl__insert_bucket_1068(
    signed int* __eax,                     // r0
    unsigned int __ebx,                    // r1
    unsigned int* __esp                    // r7
)
{// addr = 0x080550E0
    signed int _v4;                        // _cfa_fffffffc
    signed int _v8;                        // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    unsigned int _v20;                     // _cfa_ffffffec
    unsigned int _v24;                     // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    signed int* _t48;                      // _t48
    _unknown_ _t49;                        // _t49
    _unknown_ _t51;                        // _t51
    unsigned int _t52;                     // _t52
    unsigned int _t55;                     // _t55
    _unknown_ _t56;                        // _t56
    intOrPtr _t61;                         // _t61
    unsigned int* _t62;                    // _t62
    _unknown_ _t65;                        // _t65
    intOrPtr _t67;                         // _t67
    _unknown_ _t69;                        // _t69
    _unknown_ _t72;                        // _t72
    unsigned int _t73;                     // _t73
    signed int _t75;                       // _t75
    unsigned int _t76;                     // _t76
    _unknown_ _t77;                        // _t77
    unsigned int _t88;                     // _t88
    signed int _t91;                       // _t91
    signed int _t93;                       // _t93
    intOrPtr _t94;                         // _t94
    _unknown_ _t95;                        // _t95

    __esp = __esp;
    _t73 = __ebx;
    _t48 = __eax;
    if(_t48 == 1) {
        return;
    } else {
         *__esp = _t73;
        _t91 = _t48[2];
        _v12 = _t48[1];
        _v8 =  *_t48;
        camlHashtbl__insert_bucket_1068(_t91, _t73, __esp);
        _t52 =  *__esp;
        _t75 =  *(_t52 + 12) >> 1;
        if(_t75 == 0) {
            caml_raise_exn( &caml_bucket_Division_by_zero);
            _t94 = _t94;
        } else {
            _v4 = _t75;
             *__esp = _t52;
             *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t52 + 8))))))();
            asm("cdq ");
            _t91 = (_v8 >> 1) % _v4;
        }
        _t93 = (_t91 << 1) + 1;
        _t76 =  *__esp;
        _t85 =  *((intOrPtr*)(_t76 + 16));
        _t55 =  *( *((intOrPtr*)(_t76 + 16)) - 4) >> 9;
        if(_t55 <= _t93) {
L11:
            caml_ml_array_bound_error();
        } else {
            while(1) {
                _t67 = caml_young_ptr - 16;
                caml_young_ptr = _t67;
                if(_t67 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t55 = _t67 + 4;
             *((intOrPtr*)(_t55 - 4)) = 3072;
             *_t55 = _v8;
             *(_t55 + 4) = _v12;
            _t94 =  *((intOrPtr*)(_t76 + 16));
            _t76 =  *(_t94 - 4) >> 9;
            if(_t76 <= _t93) {
                caml_ml_array_bound_error();
                goto L11;
            }
             *(_t55 + 8) =  *(_t94 + _t93 * 2 - 2);
            caml_modify( *(_t94 + _t93 * 2 - 2), _t85 + _t93 * 2 - 2, _t55);
            return;
            goto L20;
        }
        __esp = __esp - 16;
        if(_t55 == 1) {
            return;
        } else {
            _v24 = _t76;
            _v20 =  *(_t55 + 8);
            _v28 =  *(_t55 + 4);
             *__esp =  *_t55;
            caml_c_call( *_t55,  *((intOrPtr*)(_t76 + 12)));
            if(caml_compare != 1) {
                L12();
                _t88 = _v20;
                while(1) {
                    _t61 = caml_young_ptr - 16;
                    caml_young_ptr = _t61;
                    if(_t61 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                _t62 = _t61 + 4;
                 *((intOrPtr*)(_t62 - 4)) = 3072;
                 *_t62 =  *__esp;
                _t62[1] = _v28;
                _t62[2] = _t88;
                return;
                goto L20;
            }
             *((intOrPtr*)( *((intOrPtr*)(_v24 + 8)))) =  *((intOrPtr*)( *((intOrPtr*)(_v24 + 8)))) + -2;
            return;
        }
    }
L20:
}

camlHashtbl__remove_bucket_1083(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr* __esp                        // r7
)
{// addr = 0x080551D0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr* _t17;                        // _t17
    _unknown_ _t18;                        // _t18
    intOrPtr _t24;                         // _t24
    intOrPtr* _t25;                        // _t25
    intOrPtr _t29;                         // _t29
    intOrPtr _t35;                         // _t35

    __esp = __esp;
    _t29 = __ebx;
    _t17 = __eax;
    if(_t17 == 1) {
        return 1;
    } else {
        _v8 = _t29;
        _v4 =  *((intOrPtr*)(_t17 + 8));
        _v12 =  *((intOrPtr*)(_t17 + 4));
         *__esp =  *_t17;
        caml_c_call( *_t17,  *((intOrPtr*)(_t29 + 12)));
        if(caml_compare != 1) {
            _t35 = camlHashtbl__remove_bucket_1083(_v4, _v8, __esp);
            while(1) {
                _t24 = caml_young_ptr - 16;
                caml_young_ptr = _t24;
                if(_t24 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t25 = _t24 + 4;
             *((intOrPtr*)(_t25 - 4)) = 3072;
             *_t25 =  *__esp;
             *((intOrPtr*)(_t25 + 4)) = _v12;
             *((intOrPtr*)(_t25 + 8)) = _t35;
            return _t25;
            goto L8;
        }
         *((intOrPtr*)( *((intOrPtr*)(_v8 + 8)))) =  *((intOrPtr*)( *((intOrPtr*)(_v8 + 8)))) + -2;
        return _v4;
    }
L8:
}

camlHashtbl__find_in_bucket_1108(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr* __esp                        // r7
)
{// addr = 0x08055280
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _t12;                        // _t12
    _unknown_ _t13;                        // _t13
    intOrPtr _t19;                         // _t19
    intOrPtr* _t20;                        // _t20
    intOrPtr _t21;                         // _t21
    intOrPtr _t26;                         // _t26

    __esp = __esp;
    _t21 = __ebx;
    _t12 = __eax;
    while(_t12 != 1) {
        _v8 = _t21;
         *__esp =  *((intOrPtr*)(_t12 + 8));
        _v4 =  *((intOrPtr*)(_t12 + 4));
        caml_c_call( *_t12,  *((intOrPtr*)(_t21 + 8)));
        if(caml_compare != 1) {
            _t12 =  *__esp;
            _t21 = _v8;
            continue;
        }
        _t26 = camlHashtbl__find_in_bucket_1108( *__esp, _v8, __esp);
        while(1) {
            _t19 = caml_young_ptr - 12;
            caml_young_ptr = _t19;
            if(_t19 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t20 = _t19 + 4;
         *((intOrPtr*)(_t20 - 4)) = 2048;
         *_t20 = _v4;
         *((intOrPtr*)(_t20 + 4)) = _t26;
        return _t20;
L9:
    }
    return 1;
    goto L9;
}

camlHashtbl__replace_bucket_1116(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x08055310
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr* _t24;                        // _t24
    intOrPtr _t26;                         // _t26
    intOrPtr* _t27;                        // _t27
    _unknown_ _t28;                        // _t28
    intOrPtr _t31;                         // _t31
    intOrPtr _t33;                         // _t33
    intOrPtr* _t34;                        // _t34
    intOrPtr _t36;                         // _t36
    intOrPtr* _t37;                        // _t37
    intOrPtr _t38;                         // _t38
    intOrPtr _t48;                         // _t48

    _t38 = __ebx;
    _t24 = __eax;
    if(_t24 == 1) {
        while(1) {
            _t26 = caml_young_ptr - 8;
            caml_young_ptr = _t26;
            if(_t26 >= caml_young_limit) {
                _t27 = _t26 + 4;
                 *((intOrPtr*)(_t27 - 4)) = 1024;
                 *_t27 =  &caml_exn_Not_found;
                caml_raise_exn(_t27);
            }
            caml_call_gc(__esp);
        }
    }
    _v8 = _t38;
    _v4 =  *((intOrPtr*)(_t24 + 8));
     *__esp =  *((intOrPtr*)(_t24 + 4));
    _t29 =  *_t24;
    _v12 =  *_t24;
    caml_c_call(_t29,  *((intOrPtr*)(_t38 + 8)));
    if(caml_compare != 1) {
        _t31 = _v4;
        camlHashtbl__replace_bucket_1116(_t31, _v8);
        _t48 = _t31;
        while(1) {
L5:
            _t33 = caml_young_ptr - 16;
            caml_young_ptr = _t33;
            if(_t33 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t34 = _t33 + 4;
         *((intOrPtr*)(_t34 - 4)) = 3072;
         *_t34 = _v12;
         *((intOrPtr*)(_t34 + 4)) =  *__esp;
         *((intOrPtr*)(_t34 + 8)) = _t48;
        return;
        goto L12;
    } else {
        while(1) {
            _t36 = caml_young_ptr - 16;
            caml_young_ptr = _t36;
            if(_t36 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t37 = _t36 + 4;
         *((intOrPtr*)(_t37 - 4)) = 3072;
         *_t37 = _v12;
         *((intOrPtr*)(_t37 + 4)) =  *((intOrPtr*)(_v8 + 12));
         *((intOrPtr*)(_t37 + 8)) = _v4;
        return;
L12:
    }
    goto L5;
}

camlHashtbl__mem_in_bucket_1125(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr* __esp                        // r7
)
{// addr = 0x08055430
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _t5;                         // _t5
    _unknown_ _t6;                         // _t6
    _unknown_ _t9;                         // _t9

    __esp = __esp;
    __ebx = __ebx;
    _t5 = __eax;
    while(_t5 != 1) {
        _v4 = __ebx;
         *__esp =  *((intOrPtr*)(_t5 + 8));
        caml_c_call( *_t5,  *((intOrPtr*)(__ebx + 8)));
        if(caml_compare != 1) {
            _t5 =  *__esp;
            __ebx = _v4;
            continue;
        }
        return 3;
L6:
    }
    return 1;
    goto L6;
}

camlHashtbl__do_bucket_1132(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx,                        // r1
    intOrPtr* __esp                        // r7
)
{// addr = 0x08055490
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _t6;                          // _t6
    _unknown_ _t7;                         // _t7
    _unknown_ _t8;                         // _t8
    intOrPtr _t9;                          // _t9
    _unknown_ _t10;                        // _t10
    _unknown_ _t12;                        // _t12

    __esp = __esp;
    _t9 = __ebx;
    _t6 = __eax;
    while(_t6 != 1) {
        _v4 = _t9;
         *__esp =  *((intOrPtr*)(_t6 + 8));
        caml_apply2();
        _t6 =  *__esp;
        _t9 = _v4;
    }
    return 1;
}

camlHashtbl__do_bucket_1142(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __ecx,                        // r2
    intOrPtr* __esp                        // r7
)
{// addr = 0x080554D0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _t6;                         // _t6
    intOrPtr _t9;                          // _t9
    _unknown_ _t11;                        // _t11
    intOrPtr _t12;                         // _t12
    _unknown_ _t13;                        // _t13

    __esp = __esp;
    _t12 = __ecx;
    _t9 = __ebx;
    _t6 = __eax;
    while(1) {
        __esi = _t9;
        if(_t6 == 1) {
            break;
        }
        _v4 = _t12;
         *__esp =  *((intOrPtr*)(_t6 + 8));
        caml_apply3();
        _t9 =  *_t6;
        _t6 =  *__esp;
        _t12 = _v4;
    }
    return __esi;
}

camlHashtbl__safehash_1177(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx                        // r1
)
{// addr = 0x08055510
    _unknown_ _t4;                         // _t4
    _unknown_ _t8;                         // _t8

     *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(__ebx + 8)) + 4))))))();
    return;
}

camlHashtbl__add_1179(
    signed int __eax                       // r0
)
{// addr = 0x08055530
    signed int _v4;                        // _cfa_fffffffc
    signed int _v8;                        // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    intOrPtr _v28;                         // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    unsigned int _v44;                     // _cfa_ffffffd4
    signed int _t176;                      // _t176
    intOrPtr _t179;                        // _t179
    signed int _t180;                      // _t180
    intOrPtr _t182;                        // _t182
    intOrPtr* _t183;                       // _t183
    unsigned int _t185;                    // _t185
    intOrPtr _t187;                        // _t187
    intOrPtr* _t188;                       // _t188
    _unknown_ _t189;                       // _t189
    intOrPtr* _t191;                       // _t191
    _unknown_ _t194;                       // _t194
    _unknown_ _t200;                       // _t200
    _unknown_ _t207;                       // _t207
    unsigned int _t209;                    // _t209
    signed int _t210;                      // _t210
    signed int _t213;                      // _t213
    signed int _t215;                      // _t215
    _unknown_ _t216;                       // _t216
    intOrPtr _t219;                        // _t219
    signed int _t222;                      // _t222
    _unknown_ _t226;                       // _t226
    signed int _t227;                      // _t227
    intOrPtr _t230;                        // _t230
    unsigned int _t231;                    // _t231
    intOrPtr _t233;                        // _t233
    signed int _t234;                      // _t234
    unsigned int _t236;                    // _t236
    unsigned int _t238;                    // _t238
    intOrPtr _t240;                        // _t240
    intOrPtr* _t241;                       // _t241
    _unknown_ _t243;                       // _t243
    intOrPtr* _t245;                       // _t245
    _unknown_ _t248;                       // _t248
    _unknown_ _t250;                       // _t250
    _unknown_ _t257;                       // _t257
    _unknown_ _t259;                       // _t259
    signed int _t261;                      // _t261
    _unknown_ _t267;                       // _t267
    signed int _t268;                      // _t268
    signed int _t271;                      // _t271
    unsigned int _t272;                    // _t272
    unsigned int _t274;                    // _t274
    _unknown_ _t275;                       // _t275
    _unknown_ _t278;                       // _t278
    _unknown_ _t279;                       // _t279
    _unknown_ _t280;                       // _t280
    signed int _t281;                      // _t281
    signed int _t282;                      // _t282
    signed int _t285;                      // _t285
    unsigned int _t288;                    // _t288
    unsigned int _t289;                    // _t289
    _unknown_ _t296;                       // _t296
    _unknown_ _t297;                       // _t297
    signed int _t298;                      // _t298
    unsigned int _t300;                    // _t300
    _unknown_ _t302;                       // _t302
    unsigned int _t307;                    // _t307
    unsigned int _t309;                    // _t309
    signed int _t310;                      // _t310
    unsigned int _t311;                    // _t311
    signed int _t314;                      // _t314
    signed int _t321;                      // _t321
    signed int _t323;                      // _t323
    signed int _t324;                      // _t324
    signed int _t326;                      // _t326
    signed int _t332;                      // _t332
    _unknown_ _t334;                       // _t334
    _unknown_ _t335;                       // _t335
    signed int _t336;                      // _t336
    unsigned int _t337;                    // _t337
    unsigned int _t340;                    // _t340
    _unknown_ _t341;                       // _t341
    _unknown_ _t343;                       // _t343
    unsigned int _t347;                    // _t347
    _unknown_ _t348;                       // _t348
    _unknown_ _t349;                       // _t349
    _unknown_ _t351;                       // _t351
    signed int _t353;                      // _t353
    _unknown_ _t354;                       // _t354

    _t176 = __eax;
    __esp = __esp - 20;
    _t340 =  *( *((intOrPtr*)(_t176 + 4)) - 4) >> 10;
    if(_t340 == 0) {
        caml_raise_exn( &caml_bucket_Division_by_zero);
    } else {
        _v4 = _t340;
        _v8 = _t321;
        _v16 = _t298;
         *__esp = _t268;
        _v12 = _t176;
         *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t321 + 12)) + 8)) + 4))))))();
        asm("cdq ");
        _t321 = ((_t268 & 2147483647) >> 1) % _v4;
    }
    _t323 = (_t321 << 1) + 1;
    while(1) {
        _t179 = caml_young_ptr - 16;
        caml_young_ptr = _t179;
        if(_t179 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t180 = _t179 + 4;
     *((intOrPtr*)(_t180 - 4)) = 3072;
     *_t180 =  *__esp;
     *(_t180 + 4) = _v16;
    _t271 = _v12;
    _t342 =  *(_t271 + 4);
    _t300 =  *(_t342 - 4) >> 9;
    if(_t300 <= _t323) {
L12:
        caml_ml_array_bound_error();
        __esp = __esp - 12;
        _t324 = _t180;
        while(1) {
            _t182 = caml_young_ptr - 24;
            caml_young_ptr = _t182;
            if(_t182 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t183 = _t182 + 4;
         *((intOrPtr*)(_t183 - 4)) = 5367;
         *_t183 = camlHashtbl__code_begin;
         *(_t183 + 4) = 3;
         *((intOrPtr*)(_t183 + 8)) =  *((intOrPtr*)(_t300 + 12));
         *(_t183 + 12) = _t324;
         *(_t183 + 16) = _t271;
        _t347 =  *( *((intOrPtr*)(_t324 + 4)) - 4) >> 10;
        if(_t347 == 0) {
            caml_raise_exn( &caml_bucket_Division_by_zero);
        } else {
            _v24 = _t347;
            _v28 = _t183;
             *__esp = _t324;
             *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t300 + 16)) + 8)) + 4))))))();
            _t300 = _v24;
            asm("cdq ");
            _t324 = ((_t271 & 2147483647) >> 1) % _t300;
        }
        _t326 = (_t324 << 1) + 1;
        _v24 = _t326;
        _t185 =  *__esp;
        _t272 =  *(_t185 + 4);
         *__esp = _t272;
        _t274 =  *(_t272 - 4) >> 9;
        if(_t274 <= _t326) {
L23:
            caml_ml_array_bound_error();
            __esp = __esp - 16;
            while(_t274 != 1) {
                _v40 = _t300;
                 *__esp = _t185;
                _v44 =  *(_t274 + 8);
                _v36 =  *((intOrPtr*)(_t274 + 4));
                caml_apply2();
                if(_t185 == 1) {
                    _t185 =  *__esp;
                    _t274 = _v44;
                    _t300 = _v40;
                    continue;
                }
                __esp =  &((__esp)[4]);
                return;
L75:
            }
            while(1) {
                _t187 = caml_young_ptr - 8;
                caml_young_ptr = _t187;
                if(_t187 >= caml_young_limit) {
                    _t188 = _t187 + 4;
                     *((intOrPtr*)(_t188 - 4)) = 1024;
                     *_t188 =  &caml_exn_Not_found;
                    caml_raise_exn(_t188);
                }
                caml_call_gc(__esp);
            }
        }
        _t274 =  *(_t185 + 4);
        _t185 =  *(_t274 - 4) >> 9;
        if(_t185 <= _t326) {
            caml_ml_array_bound_error();
            goto L23;
        }
        _t191 =  *((intOrPtr*)(_t274 + _t326 * 2 - 2));
        camlHashtbl__code_begin(_t191, _v28, __esp);
        caml_modify(_v32, _v32 + _v24 * 2 - 2, _t191);
        __esp =  &((__esp)[3]);
        return;
        goto L75;
    }
     *((intOrPtr*)(_t180 + 8)) =  *((intOrPtr*)(_t342 + _t323 * 2 - 2));
    _t342 =  *(_t271 + 4);
    _t300 =  *( *(_t271 + 4) - 4) >> 9;
    if(_t300 <= _t323) {
        caml_ml_array_bound_error();
        goto L12;
    }
    caml_modify(_t271, _t342 + _t323 * 2 - 2, _t180);
     *_t271 =  *_t271 + 2;
    if( *_t271 <= ( *( *(_t271 + 4) - 4) >> 9 | 1) + ( *( *(_t271 + 4) - 4) >> 9 | 1) - 1) {
        __esp =  &((__esp)[5]);
        return;
    } else {
        _t209 =  *(_v8 + 12);
        __esp =  &((__esp)[5]);
        while(1) {
            __esp = __esp - 24;
             *__esp = _t209;
            _v8 = _t271;
            _t210 =  *(_t271 + 4);
            _v4 = _t210;
            _t213 =  *(_t210 - 4) >> 9 | 1;
            _v16 = _t213;
            _t215 = 3 + (_t213 >> 1) * 4;
            camlPervasives__min_1022(_t215, __esp);
            _t281 = _v16;
            if(_t215 == _t281) {
                break;
            }
            _v20 = _t215;
            _v16 = _t281;
            caml_c_call(_t215, 1);
            _t282 = caml_make_vect;
            _v12 = caml_make_vect;
            while(1) {
                _t219 = caml_young_ptr - 24;
                caml_young_ptr = _t219;
                if(_t219 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t307 = _t219 + 4;
             *((intOrPtr*)(_t307 - 4)) = 5367;
             *_t307 = camlHashtbl__insert_bucket_1068;
             *(_t307 + 4) = 3;
             *(_t307 + 8) =  *__esp;
             *(_t307 + 12) = _v20;
             *((intOrPtr*)(_t307 + 16)) = _t282;
            _t222 = 1;
            _t284 = _v16 + -2;
            if(_t222 > _t284) {
L39:
                caml_modify(_t284, _v8 + 4, _v12);
                __esp =  &((__esp)[6]);
                return;
            } else {
                _v16 = _t284;
                _v20 = _t222;
                 *__esp = _t307;
                while(1) {
                    _t285 = _v4;
                    _t309 =  *(_t285 - 4) >> 9;
                    if(_t309 <= _t222) {
                        break;
                    }
                    camlHashtbl__insert_bucket_1068( *((intOrPtr*)(_t285 + _t222 * 2 - 2)),  *__esp, __esp);
                    _t261 = _v20;
                    _t222 = _t261 + 2;
                    _v20 = _t222;
                    _t284 = _v16;
                    if(_t261 != _v16) {
                        continue;
                    } else {
                        goto L39;
                    }
                    goto L75;
                }
                caml_ml_array_bound_error();
                __esp = __esp - 4;
                _t336 = _t222;
                _t227 =  *(_t336 + 4);
                _t342 =  *(_t227 - 4) >> 10;
                if(_t342 == 0) {
                    caml_raise_exn( &caml_bucket_Division_by_zero);
                    _t342 = _t342;
                } else {
                     *__esp = _t309;
                    caml_hash_univ_param(21, 201, _t285);
                    asm("cdq ");
                    _t323 = (_t227 >> 1) % _t342;
                }
                _t323 = (_t323 << 1) + 1;
                while(1) {
                    _t230 = caml_young_ptr - 16;
                    caml_young_ptr = _t230;
                    if(_t230 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                _t231 = _t230 + 4;
                 *((intOrPtr*)(_t231 - 4)) = 3072;
                 *_t231 = _t285;
                 *(_t231 + 4) =  *__esp;
                _t310 =  *(_t336 + 4);
                _t288 =  *(_t310 - 4) >> 9;
                if(_t288 <= _t323) {
L55:
                    caml_ml_array_bound_error();
                    __esp = __esp - 8;
                    _t337 = _t231;
                    _t311 = _t288;
                    while(1) {
                        _t233 = caml_young_ptr - 20;
                        caml_young_ptr = _t233;
                        if(_t233 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                    _t289 = _t233 + 4;
                     *((intOrPtr*)(_t289 - 4)) = 4343;
                     *_t289 = camlHashtbl__remove_bucket_1083;
                     *(_t289 + 4) = 3;
                     *(_t289 + 8) = _t337;
                     *(_t289 + 12) = _t311;
                    _t234 =  *(_t337 + 4);
                    _t353 =  *(_t234 - 4) >> 10;
                    if(_t353 == 0) {
                        caml_raise_exn( &caml_bucket_Division_by_zero);
                    } else {
                        caml_hash_univ_param(21, 201, _t311);
                        asm("cdq ");
                        _t323 = (_t234 >> 1) % _t353;
                    }
                    _t332 = (_t323 << 1) + 1;
                    _v32 = _t332;
                    _t236 =  *(_t337 + 4);
                     *__esp = _t236;
                    _t238 =  *(_t236 - 4) >> 9;
                    if(_t238 <= _t332) {
L66:
                        caml_ml_array_bound_error();
                        __esp = __esp - 12;
                        while(_t289 != 1) {
                             *__esp = _t238;
                            _v44 =  *(_t289 + 8);
                            _v40 =  *(_t289 + 4);
                            caml_c_call(_t238,  *_t289);
                            if(caml_compare != 1) {
                                _t238 =  *__esp;
                                _t289 = _v44;
                                continue;
                            }
                            __esp =  &((__esp)[3]);
                            return;
                            goto L75;
                        }
                        while(1) {
                            _t240 = caml_young_ptr - 8;
                            caml_young_ptr = _t240;
                            if(_t240 >= caml_young_limit) {
                                _t241 = _t240 + 4;
                                 *((intOrPtr*)(_t241 - 4)) = 1024;
                                 *_t241 =  &caml_exn_Not_found;
                                caml_raise_exn(_t241);
                            }
                            goto L74;
                        }
                    }
                    _t314 =  *(_t337 + 4);
                    _t238 =  *(_t314 - 4) >> 9;
                    if(_t238 <= _t332) {
                        caml_ml_array_bound_error();
                        goto L66;
                    }
                    _t245 =  *((intOrPtr*)(_t314 + _t332 * 2 - 2));
                    camlHashtbl__remove_bucket_1083(_t245, _t289, __esp);
                    caml_modify(_v36, _v36 + _v32 * 2 - 2, _t245);
                    __esp =  &((__esp)[2]);
                    return;
                    goto L75;
                }
                 *((intOrPtr*)(_t231 + 8)) =  *((intOrPtr*)(_t310 + _t323 * 2 - 2));
                _t316 =  *(_t336 + 4);
                _t288 =  *( *(_t336 + 4) - 4) >> 9;
                if(_t288 <= _t323) {
                    caml_ml_array_bound_error();
                    goto L55;
                }
                caml_modify(_t288, _t316 + _t323 * 2 - 2, _t231);
                 *_t336 =  *_t336 + 2;
                if( *_t336 <= ( *( *(_t336 + 4) - 4) >> 9 | 1) + ( *( *(_t336 + 4) - 4) >> 9 | 1) - 1) {
                    __esp =  &((__esp)[1]);
                    return;
                } else {
                    _t209 =  *134689320;
                    _t271 = _t336;
                    __esp =  &((__esp)[1]);
                    continue;
                }
            }
            goto L75;
        }
        __esp =  &((__esp)[6]);
        return;
    }
    goto L75;
}

camlHashtbl__remove_1185(
    signed int __eax,                      // r0
    signed int __ecx,                      // r2
    _unknown_ __edi                        // r4
)
{// addr = 0x08055640
    signed int _v4;                        // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    unsigned int _v24;                     // _cfa_ffffffe8
    intOrPtr _t49;                         // _t49
    intOrPtr* _t50;                        // _t50
    unsigned int _t52;                     // _t52
    intOrPtr _t54;                         // _t54
    intOrPtr* _t55;                        // _t55
    _unknown_ _t56;                        // _t56
    intOrPtr* _t58;                        // _t58
    _unknown_ _t61;                        // _t61
    _unknown_ _t67;                        // _t67
    signed int _t68;                       // _t68
    unsigned int _t69;                     // _t69
    unsigned int _t71;                     // _t71
    _unknown_ _t72;                        // _t72
    _unknown_ _t75;                        // _t75
    _unknown_ _t76;                        // _t76
    signed int _t77;                       // _t77
    _unknown_ _t79;                        // _t79
    signed int _t81;                       // _t81
    signed int _t83;                       // _t83
    _unknown_ _t87;                        // _t87
    _unknown_ _t88;                        // _t88
    unsigned int _t92;                     // _t92
    _unknown_ _t93;                        // _t93

    _t77 = __ecx;
    __esp = __esp - 12;
    _t81 = __eax;
    while(1) {
        _t49 = caml_young_ptr - 24;
        caml_young_ptr = _t49;
        if(_t49 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t50 = _t49 + 4;
     *((intOrPtr*)(_t50 - 4)) = 5367;
     *_t50 = camlHashtbl__code_begin;
     *((intOrPtr*)(_t50 + 4)) = 3;
     *((intOrPtr*)(_t50 + 8)) =  *((intOrPtr*)(_t77 + 12));
     *(_t50 + 12) = _t81;
     *(_t50 + 16) = _t68;
    _t92 =  *( *((intOrPtr*)(_t81 + 4)) - 4) >> 10;
    if(_t92 == 0) {
        caml_raise_exn( &caml_bucket_Division_by_zero);
    } else {
        _v4 = _t92;
        _v8 = _t50;
         *__esp = _t81;
         *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t77 + 16)) + 8)) + 4))))))();
        _t77 = _v4;
        asm("cdq ");
        _t81 = ((_t68 & 2147483647) >> 1) % _t77;
    }
    _t83 = (_t81 << 1) + 1;
    _v4 = _t83;
    _t52 =  *__esp;
    _t69 =  *(_t52 + 4);
     *__esp = _t69;
    _t71 =  *(_t69 - 4) >> 9;
    if(_t71 <= _t83) {
L10:
        caml_ml_array_bound_error();
        __esp = __esp - 16;
        while(_t71 != 1) {
            _v20 = _t77;
             *__esp = _t52;
            _v24 =  *(_t71 + 8);
            _v16 =  *((intOrPtr*)(_t71 + 4));
            caml_apply2();
            if(_t52 == 1) {
                _t52 =  *__esp;
                _t71 = _v24;
                _t77 = _v20;
                continue;
            }
            __esp =  &((__esp)[4]);
            return;
L19:
        }
        while(1) {
            _t54 = caml_young_ptr - 8;
            caml_young_ptr = _t54;
            if(_t54 >= caml_young_limit) {
                _t55 = _t54 + 4;
                 *((intOrPtr*)(_t55 - 4)) = 1024;
                 *_t55 =  &caml_exn_Not_found;
                caml_raise_exn(_t55);
            }
            goto L18;
        }
    }
    _t71 =  *(_t52 + 4);
    _t52 =  *(_t71 - 4) >> 9;
    if(_t52 <= _t83) {
        caml_ml_array_bound_error();
        goto L10;
    }
    _t58 =  *((intOrPtr*)(_t71 + _t83 * 2 - 2));
    camlHashtbl__code_begin(_t58, _v8, __esp);
    caml_modify(_v12, _v12 + _v4 * 2 - 2, _t58);
    __esp =  &((__esp)[3]);
    return;
    goto L19;
}

camlHashtbl__find_rec_1193(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __ecx,                        // r2
    intOrPtr* __esp                        // r7
)
{// addr = 0x08055740
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _t12;                         // _t12
    intOrPtr _t14;                         // _t14
    intOrPtr* _t15;                        // _t15
    _unknown_ _t16;                        // _t16
    intOrPtr _t18;                         // _t18
    _unknown_ _t19;                        // _t19
    intOrPtr _t20;                         // _t20
    _unknown_ _t22;                        // _t22

    __esp = __esp;
    _t20 = __ecx;
    _t18 = __ebx;
    _t12 = __eax;
    while(_t18 != 1) {
        _v8 = _t20;
         *__esp = _t12;
        _v12 =  *((intOrPtr*)(_t18 + 8));
        _v4 =  *((intOrPtr*)(_t18 + 4));
        caml_apply2();
        if(_t12 == 1) {
            _t12 =  *__esp;
            _t18 = _v12;
            _t20 = _v8;
            continue;
        }
        return _v4;
        while(1) {
L5:
            _t14 = caml_young_ptr - 8;
            caml_young_ptr = _t14;
            if(_t14 >= caml_young_limit) {
                _t15 = _t14 + 4;
                 *((intOrPtr*)(_t15 - 4)) = 1024;
                 *_t15 =  &caml_exn_Not_found;
                caml_raise_exn(_t15);
            }
            goto L7;
        }
    }
    goto L5;
}

camlHashtbl__find_1198(
    unsigned int __eax                     // r0
)
{// addr = 0x080557D0
    signed int _v4;                        // _cfa_fffffffc
    signed int _v8;                        // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    signed int _v20;                       // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    signed int _v32;                       // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    signed int* _v72;                      // _cfa_ffffffb8
    signed int _t290;                      // _t290
    intOrPtr _t292;                        // _t292
    intOrPtr* _t293;                       // _t293
    unsigned int _t297;                    // _t297
    intOrPtr _t299;                        // _t299
    signed int _t300;                      // _t300
    unsigned int _t303;                    // _t303
    intOrPtr _t305;                        // _t305
    signed int _t306;                      // _t306
    unsigned int _t311;                    // _t311
    _unknown_ _t312;                       // _t312
    _unknown_ _t314;                       // _t314
    _unknown_ _t320;                       // _t320
    _unknown_ _t323;                       // _t323
    intOrPtr _t326;                        // _t326
    _unknown_ _t336;                       // _t336
    unsigned int _t338;                    // _t338
    signed int _t339;                      // _t339
    signed int _t342;                      // _t342
    signed int _t344;                      // _t344
    _unknown_ _t345;                       // _t345
    intOrPtr _t348;                        // _t348
    signed int _t351;                      // _t351
    _unknown_ _t355;                       // _t355
    signed int _t356;                      // _t356
    intOrPtr _t359;                        // _t359
    signed int* _t360;                     // _t360
    intOrPtr _t362;                        // _t362
    signed int _t363;                      // _t363
    unsigned int _t365;                    // _t365
    unsigned int _t367;                    // _t367
    intOrPtr _t369;                        // _t369
    intOrPtr* _t370;                       // _t370
    _unknown_ _t372;                       // _t372
    intOrPtr* _t374;                       // _t374
    _unknown_ _t377;                       // _t377
    _unknown_ _t379;                       // _t379
    _unknown_ _t386;                       // _t386
    _unknown_ _t388;                       // _t388
    signed int _t390;                      // _t390
    _unknown_ _t396;                       // _t396
    _unknown_ _t397;                       // _t397
    intOrPtr _t401;                        // _t401
    signed int* _t402;                     // _t402
    _unknown_ _t408;                       // _t408
    intOrPtr _t410;                        // _t410
    intOrPtr* _t411;                       // _t411
    _unknown_ _t414;                       // _t414
    unsigned int _t417;                    // _t417
    intOrPtr _t419;                        // _t419
    intOrPtr* _t420;                       // _t420
    _unknown_ _t421;                       // _t421
    unsigned int _t424;                    // _t424
    intOrPtr _t426;                        // _t426
    intOrPtr* _t427;                       // _t427
    _unknown_ _t428;                       // _t428
    unsigned int _t432;                    // _t432
    intOrPtr _t434;                        // _t434
    intOrPtr* _t435;                       // _t435
    _unknown_ _t436;                       // _t436
    _unknown_ _t438;                       // _t438
    _unknown_ _t439;                       // _t439
    _unknown_ _t440;                       // _t440
    intOrPtr _t441;                        // _t441
    signed int _t442;                      // _t442
    signed int _t443;                      // _t443
    unsigned int _t444;                    // _t444
    signed int _t445;                      // _t445
    signed int _t446;                      // _t446
    _unknown_ _t447;                       // _t447
    _unknown_ _t448;                       // _t448
    _unknown_ _t449;                       // _t449
    _unknown_ _t450;                       // _t450
    signed int _t451;                      // _t451
    _unknown_ _t455;                       // _t455
    signed int _t456;                      // _t456
    intOrPtr _t457;                        // _t457
    signed int _t460;                      // _t460
    unsigned int _t463;                    // _t463
    signed int* _t464;                     // _t464
    _unknown_ _t472;                       // _t472
    _unknown_ _t473;                       // _t473
    _unknown_ _t474;                       // _t474
    _unknown_ _t476;                       // _t476
    _unknown_ _t477;                       // _t477
    intOrPtr _t478;                        // _t478
    _unknown_ _t479;                       // _t479
    _unknown_ _t482;                       // _t482
    _unknown_ _t485;                       // _t485
    signed int _t486;                      // _t486
    _unknown_ _t487;                       // _t487
    signed int _t488;                      // _t488
    signed int _t489;                      // _t489
    _unknown_ _t492;                       // _t492
    unsigned int _t496;                    // _t496
    unsigned int _t498;                    // _t498
    signed int _t499;                      // _t499
    unsigned int _t500;                    // _t500
    signed int _t503;                      // _t503
    _unknown_ _t513;                       // _t513
    unsigned int _t514;                    // _t514
    _unknown_ _t516;                       // _t516
    _unknown_ _t517;                       // _t517
    _unknown_ _t518;                       // _t518
    signed int _t519;                      // _t519
    _unknown_ _t521;                       // _t521
    signed int _t524;                      // _t524
    signed int _t526;                      // _t526
    signed int _t527;                      // _t527
    signed int _t529;                      // _t529
    signed int _t531;                      // _t531
    signed int _t532;                      // _t532
    signed int _t534;                      // _t534
    signed int _t536;                      // _t536
    signed int _t539;                      // _t539
    _unknown_ _t543;                       // _t543
    _unknown_ _t544;                       // _t544
    _unknown_ _t545;                       // _t545
    unsigned int _t549;                    // _t549
    _unknown_ _t550;                       // _t550
    unsigned int _t551;                    // _t551
    signed int* _t552;                     // _t552
    _unknown_ _t553;                       // _t553
    _unknown_ _t554;                       // _t554
    unsigned int _t558;                    // _t558
    _unknown_ _t559;                       // _t559
    unsigned int _t560;                    // _t560
    unsigned int _t564;                    // _t564
    _unknown_ _t565;                       // _t565
    _unknown_ _t566;                       // _t566
    signed int _t567;                      // _t567
    _unknown_ _t568;                       // _t568
    _unknown_ _t570;                       // _t570
    signed int _t572;                      // _t572
    _unknown_ _t573;                       // _t573
    _unknown_ _t574;                       // _t574

    _t286 = __eax;
    __esp = __esp - 16;
    _t524 =  *( *((intOrPtr*)(__eax + 4)) - 4) >> 10;
    if(_t524 == 0) {
        caml_raise_exn( &caml_bucket_Division_by_zero);
    } else {
        _v4 = __edx;
        _v12 = __ecx;
        _v8 = __ebx;
         *__esp = __eax;
         *((intOrPtr*)(__ecx + 16)) =  *((intOrPtr*)( *((intOrPtr*)(__ecx + 16)) + 8));
        __edx =  *( *((intOrPtr*)( *((intOrPtr*)(__ecx + 16)) + 8)) + 4);
        __ecx =  *__edx;
        __eax = __ebx;
        __ebx = __edx;
         *( *__edx)();
        __ebx = 2147483647;
        __eax = __eax & __ebx;
        __eax = __eax >> 1;
        __ecx = _v4;
        asm("cdq ");
        _t39 = __eax % __ecx;
        __eax = __eax / __ecx;
        __edx = _t39;
    }
    _t526 = (_t524 << 1) + 1;
    _t442 =  *( *__esp + 4);
    _t290 =  *(_t442 - 4) >> 9;
    if(_t290 <= _t526) {
        caml_ml_array_bound_error();
        __esp = __esp - 12;
        _t527 = _t290;
        while(1) {
L48:
            _t292 = caml_young_ptr - 20;
            caml_young_ptr = _t292;
            if(_t292 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t293 = _t292 + 4;
         *((intOrPtr*)(_t293 - 4)) = 4343;
         *_t293 = camlHashtbl__find_in_bucket_1213;
         *(_t293 + 4) = 3;
         *((intOrPtr*)(_t293 + 8)) =  *((intOrPtr*)(_t488 + 12));
         *(_t293 + 12) = _t442;
        _t558 =  *( *((intOrPtr*)(_t527 + 4)) - 4) >> 10;
        if(_t558 == 0) {
            caml_raise_exn( &caml_bucket_Division_by_zero);
            _t558 = _t558;
        } else {
            _v20 = _t558;
            _v24 = _t293;
             *__esp = _t527;
             *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t488 + 16)) + 8)) + 4))))))();
            _t488 = _v20;
            asm("cdq ");
            _t527 = ((_t442 & 2147483647) >> 1) % _t488;
        }
        _t529 = (_t527 << 1) + 1;
        _t443 =  *( *__esp + 4);
        _t297 =  *(_t443 - 4) >> 9;
        if(_t297 <= _t529) {
            caml_ml_array_bound_error();
            __esp = __esp - 32;
            _t560 = _t297;
            while(1) {
L57:
                _t299 = caml_young_ptr - 24;
                caml_young_ptr = _t299;
                if(_t299 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t300 = _t299 + 4;
             *((intOrPtr*)(_t300 - 4)) = 5367;
             *_t300 = camlHashtbl__replace_bucket_1221;
             *(_t300 + 4) = 3;
             *((intOrPtr*)(_t300 + 8)) =  *((intOrPtr*)(_t529 + 12));
             *(_t300 + 12) = _t443;
             *(_t300 + 16) = _t488;
            _t549 =  *( *((intOrPtr*)(_t560 + 4)) - 4) >> 10;
            if(_t549 == 0) {
                caml_raise_exn( &caml_bucket_Division_by_zero);
                _t560 = _t560;
            } else {
                _v52 = _t549;
                _v44 = _t300;
                _v48 = _t529;
                _v56 = _t488;
                _v32 = _t443;
                 *__esp = _t560;
                 *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t529 + 16)) + 8)) + 4))))))();
                asm("cdq ");
                _t529 = ((_v32 & 2147483647) >> 1) % _v52;
            }
            _t531 = (_t529 << 1) + 1;
            _v36 = _t531;
            _t444 =  *__esp;
            _t489 =  *(_t444 + 4);
            _t303 =  *(_t489 - 4) >> 9;
            if(_t303 <= _t531) {
L75:
                caml_ml_array_bound_error();
                __esp = __esp - 12;
                _t532 = _t303;
                while(1) {
                    _t305 = caml_young_ptr - 20;
                    caml_young_ptr = _t305;
                    if(_t305 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                _t306 = _t305 + 4;
                 *((intOrPtr*)(_t306 - 4)) = 4343;
                 *_t306 = camlHashtbl__mem_in_bucket_1230;
                 *(_t306 + 4) = 3;
                 *((intOrPtr*)(_t306 + 8)) =  *((intOrPtr*)(_t489 + 12));
                 *(_t306 + 12) = _t444;
                _t564 =  *( *((intOrPtr*)(_t532 + 4)) - 4) >> 10;
                if(_t564 == 0) {
                    caml_raise_exn( &caml_bucket_Division_by_zero);
                    _t564 = _t564;
                } else {
                    _v64 = _t564;
                    _v68 = _t306;
                     *__esp = _t532;
                     *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t489 + 16)) + 8)) + 4))))))();
                    asm("cdq ");
                    _t532 = ((_t444 & 2147483647) >> 1) % _v64;
                }
                _t534 = (_t532 << 1) + 1;
                _t445 =  *( *__esp + 4);
                _t310 =  *(_t445 - 4) >> 9;
                if( *(_t445 - 4) >> 9 <= _t534) {
                    caml_ml_array_bound_error();
                    caml_hash_univ_param(21, 201, _t310);
                    return;
                    goto L129;
                }
                _t311 =  *(_t445 + _t534 * 2 - 2);
                _t446 = _v68;
                __esp =  &((__esp)[3]);
                __esp = __esp - 8;
                while(_t311 != 1) {
                    _v64 = _t446;
                     *__esp =  *(_t311 + 8);
                    caml_apply2();
                    if( *_t311 == 1) {
                        _t311 =  *__esp;
                        _t446 = _v64;
                        continue;
                    }
                    __esp =  &((__esp)[2]);
                    return 3;
                    goto L129;
                }
                __esp =  &((__esp)[2]);
                return 1;
                goto L129;
            }
            _t303 =  *(_t489 + _t531 * 2 - 2);
            _v52 = _t303;
            L69();
            _t489 =  &caml_exn_Not_found;
            _t450 =  *_t303;
            if(_t450 != _t489) {
                caml_raise_exn(_t303);
                _t549 = _t549;
                _push(caml_exception_pointer);
                caml_exception_pointer = __esp;
                _t451 =  *(_t450 + 4);
                _v36 = _t451;
                _t444 =  *(_t451 - 4) >> 9;
                if(_t444 <= _t531) {
                    caml_ml_array_bound_error();
L74:
                    caml_ml_array_bound_error();
                    goto L75;
                }
                camlHashtbl__replace_bucket_1221(_t303, _v40);
                caml_modify(_v36, _v36 + _v32 * 2 - 2, _t303);
                _pop(caml_exception_pointer);
                __esp =  &((__esp)[8]);
                return;
                goto L129;
            }
            _t444 =  *__esp;
            _t536 =  *(_t444 + 4);
            _t303 =  *(_t536 - 4) >> 9;
            _t489 = _v36;
            if(_t303 <= _t489) {
                goto L74;
            } else {
                while(1) {
                    _t326 = caml_young_ptr - 16;
                    caml_young_ptr = _t326;
                    if(_t326 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                _t567 = _t326 + 4;
                 *((intOrPtr*)(_t567 - 4)) = 3072;
                 *_t567 = _v32;
                 *(_t567 + 4) = _v56;
                 *(_t567 + 8) = _v52;
                caml_modify(_t444, _t536 + _t489 * 2 - 2, _t567);
                 *_t444 =  *_t444 + 2;
                if( *_t444 <= ( *( *(_t444 + 4) - 4) >> 9 | 1) + ( *( *(_t444 + 4) - 4) >> 9 | 1) - 1) {
                    __esp =  &((__esp)[8]);
                    return;
                } else {
                    _t338 =  *(_v48 + 16);
                    __esp =  &((__esp)[8]);
                    while(1) {
                        __esp = __esp - 24;
                         *__esp = _t338;
                        _v36 = _t444;
                        _t339 =  *(_t444 + 4);
                        _v32 = _t339;
                        _t342 =  *(_t339 - 4) >> 9 | 1;
                        _v44 = _t342;
                        _t344 = 3 + (_t342 >> 1) * 4;
                        camlPervasives__min_1022(_t344, __esp);
                        _t456 = _v44;
                        if(_t344 == _t456) {
                            break;
                        }
                        _v48 = _t344;
                        _v44 = _t456;
                        caml_c_call(_t344, 1);
                        _t457 = caml_make_vect;
                        _v40 = caml_make_vect;
                        while(1) {
                            _t348 = caml_young_ptr - 24;
                            caml_young_ptr = _t348;
                            if(_t348 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                        _t496 = _t348 + 4;
                         *((intOrPtr*)(_t496 - 4)) = 5367;
                         *_t496 = camlHashtbl__insert_bucket_1068;
                         *(_t496 + 4) = 3;
                         *(_t496 + 8) =  *__esp;
                         *(_t496 + 12) = _v48;
                         *((intOrPtr*)(_t496 + 16)) = _t457;
                        _t351 = 1;
                        _t459 = _v44 + -2;
                        if(_t351 > _t459) {
L93:
                            caml_modify(_t459, _v36 + 4, _v40);
                            __esp =  &((__esp)[6]);
                            return;
                        } else {
                            _v44 = _t459;
                            _v48 = _t351;
                             *__esp = _t496;
                            while(1) {
                                _t460 = _v32;
                                _t498 =  *(_t460 - 4) >> 9;
                                if(_t498 <= _t351) {
                                    break;
                                }
                                camlHashtbl__insert_bucket_1068( *((intOrPtr*)(_t460 + _t351 * 2 - 2)),  *__esp, __esp);
                                _t390 = _v48;
                                _t351 = _t390 + 2;
                                _v48 = _t351;
                                _t459 = _v44;
                                if(_t390 != _v44) {
                                    continue;
                                } else {
                                    goto L93;
                                }
                                goto L129;
                            }
                            caml_ml_array_bound_error();
                            __esp = __esp - 4;
                            _t551 = _t351;
                            _t356 =  *(_t551 + 4);
                            _t567 =  *(_t356 - 4) >> 10;
                            if(_t567 == 0) {
                                caml_raise_exn( &caml_bucket_Division_by_zero);
                                _t567 = _t567;
                            } else {
                                 *__esp = _t498;
                                caml_hash_univ_param(21, 201, _t460);
                                asm("cdq ");
                                _t536 = (_t356 >> 1) % _t567;
                            }
                            _t536 = (_t536 << 1) + 1;
                            while(1) {
                                _t359 = caml_young_ptr - 16;
                                caml_young_ptr = _t359;
                                if(_t359 >= caml_young_limit) {
                                    break;
                                }
                                caml_call_gc(__esp);
                            }
                            _t360 = _t359 + 4;
                             *((intOrPtr*)(_t360 - 4)) = 3072;
                             *_t360 = _t460;
                            _t360[1] =  *__esp;
                            _t499 =  *(_t551 + 4);
                            _t463 =  *(_t499 - 4) >> 9;
                            if(_t463 <= _t536) {
L109:
                                caml_ml_array_bound_error();
                                __esp = __esp - 8;
                                _t552 = _t360;
                                _t500 = _t463;
                                while(1) {
                                    _t362 = caml_young_ptr - 20;
                                    caml_young_ptr = _t362;
                                    if(_t362 >= caml_young_limit) {
                                        break;
                                    }
                                    caml_call_gc(__esp);
                                }
                                _t464 = _t362 + 4;
                                 *((intOrPtr*)(_t464 - 4)) = 4343;
                                 *_t464 = camlHashtbl__remove_bucket_1083;
                                _t464[1] = 3;
                                _t464[2] = _t552;
                                _t464[3] = _t500;
                                _t363 = _t552[1];
                                _t572 =  *(_t363 - 4) >> 10;
                                if(_t572 == 0) {
                                    caml_raise_exn( &caml_bucket_Division_by_zero);
                                } else {
                                    caml_hash_univ_param(21, 201, _t500);
                                    asm("cdq ");
                                    _t536 = (_t363 >> 1) % _t572;
                                }
                                _t539 = (_t536 << 1) + 1;
                                _v60 = _t539;
                                _t365 = _t552[1];
                                 *__esp = _t365;
                                _t367 =  *(_t365 - 4) >> 9;
                                if(_t367 <= _t539) {
L120:
                                    caml_ml_array_bound_error();
                                    __esp = __esp - 12;
                                    while(_t464 != 1) {
                                         *__esp = _t367;
                                        _v72 = _t464[2];
                                        _v68 = _t464[1];
                                        caml_c_call(_t367,  *_t464);
                                        if(caml_compare != 1) {
                                            _t367 =  *__esp;
                                            _t464 = _v72;
                                            continue;
                                        }
                                        __esp =  &((__esp)[3]);
                                        return;
                                        goto L129;
                                    }
                                    while(1) {
                                        _t369 = caml_young_ptr - 8;
                                        caml_young_ptr = _t369;
                                        if(_t369 >= caml_young_limit) {
                                            _t370 = _t369 + 4;
                                             *((intOrPtr*)(_t370 - 4)) = 1024;
                                             *_t370 =  &caml_exn_Not_found;
                                            caml_raise_exn(_t370);
                                        }
                                        goto L128;
                                    }
                                }
                                _t503 = _t552[1];
                                _t367 =  *(_t503 - 4) >> 9;
                                if(_t367 <= _t539) {
                                    caml_ml_array_bound_error();
                                    goto L120;
                                }
                                _t374 =  *((intOrPtr*)(_t503 + _t539 * 2 - 2));
                                camlHashtbl__remove_bucket_1083(_t374, _t464, __esp);
                                caml_modify(_v64, _v64 + _v60 * 2 - 2, _t374);
                                __esp =  &((__esp)[2]);
                                return;
                                goto L129;
                            }
                            _t360[2] =  *(_t499 + _t536 * 2 - 2);
                            _t505 =  *(_t551 + 4);
                            _t463 =  *( *(_t551 + 4) - 4) >> 9;
                            if(_t463 <= _t536) {
                                caml_ml_array_bound_error();
                                goto L109;
                            }
                            caml_modify(_t463, _t505 + _t536 * 2 - 2, _t360);
                             *_t551 =  *_t551 + 2;
                            if( *_t551 <= ( *( *(_t551 + 4) - 4) >> 9 | 1) + ( *( *(_t551 + 4) - 4) >> 9 | 1) - 1) {
                                __esp =  &((__esp)[1]);
                                return;
                            } else {
                                _t338 =  *134689320;
                                _t444 = _t551;
                                __esp =  &((__esp)[1]);
                                continue;
                            }
                        }
                        goto L129;
                    }
                    __esp =  &((__esp)[6]);
                    return;
                }
                goto L129;
            }
            goto L75;
        } else {
            _t286 =  *(_t443 + _t529 * 2 - 2);
            _t441 = _v24;
            __esp =  &((__esp)[3]);
            __esp = __esp - 12;
            while(_t286 != 1) {
                _v24 = _t441;
                 *__esp =  *(_t286 + 8);
                _v20 =  *(_t286 + 4);
                caml_apply2();
                if( *_t286 == 1) {
                    _t286 =  *__esp;
                    _t441 = _v24;
                    continue;
                }
                L1();
                _t514 =  *__esp;
                while(1) {
                    _t401 = caml_young_ptr - 12;
                    caml_young_ptr = _t401;
                    if(_t401 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                _t402 = _t401 + 4;
                 *((intOrPtr*)(_t402 - 4)) = 2048;
                 *_t402 = _v20;
                _t402[1] = _t514;
                __esp =  &((__esp)[3]);
                return _t402;
                goto L129;
            }
            __esp =  &((__esp)[3]);
            return 1;
            goto L129;
        }
        goto L57;
    } else {
        _t478 =  *((intOrPtr*)(_t442 + _t526 * 2 - 2));
        if(_t478 == 1) {
            while(1) {
L41:
                _t410 = caml_young_ptr - 8;
                caml_young_ptr = _t410;
                if(_t410 >= caml_young_limit) {
                    _t411 = _t410 + 4;
                     *((intOrPtr*)(_t411 - 4)) = 1024;
                     *_t411 =  &caml_exn_Not_found;
                    caml_raise_exn(_t411);
                }
                caml_call_gc(__esp);
            }
        }
         *__esp =  *(_t478 + 8);
        _v4 =  *(_t478 + 4);
        caml_apply2();
        if(_v8 == 1) {
            _t417 =  *__esp;
            if(_t417 == 1) {
                while(1) {
L39:
                    _t419 = caml_young_ptr - 8;
                    caml_young_ptr = _t419;
                    if(_t419 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                _t420 = _t419 + 4;
                 *((intOrPtr*)(_t420 - 4)) = 1024;
                 *_t420 =  &caml_exn_Not_found;
                caml_raise_exn(_t420);
                goto L41;
            }
             *__esp =  *(_t417 + 8);
            _v4 =  *(_t417 + 4);
            caml_apply2();
            if(_v8 == 1) {
                _t424 =  *__esp;
                if(_t424 == 1) {
                    while(1) {
                        _t426 = caml_young_ptr - 8;
                        caml_young_ptr = _t426;
                        if(_t426 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                    _t427 = _t426 + 4;
                     *((intOrPtr*)(_t427 - 4)) = 1024;
                     *_t427 =  &caml_exn_Not_found;
                    caml_raise_exn(_t427);
                    asm("o16 nop ");
                    goto L39;
                }
                 *__esp =  *(_t424 + 8);
                _v4 =  *(_t424 + 4);
                caml_apply2();
                if(_v8 == 1) {
                    _t519 =  *(_v12 + 20);
                    _t432 = _v8;
                    _t486 =  *__esp;
                    __esp =  &((__esp)[4]);
                    __esp = __esp - 16;
                    while(_t486 != 1) {
                        _v8 = _t519;
                         *__esp = _t432;
                        _v12 =  *(_t486 + 8);
                        _v4 =  *(_t486 + 4);
                        caml_apply2();
                        if(_t432 == 1) {
                            _t432 =  *__esp;
                            _t486 = _v12;
                            _t519 = _v8;
                            continue;
                        }
                        __esp =  &((__esp)[4]);
                        return _v4;
L129:
                    }
                    while(1) {
                        _t434 = caml_young_ptr - 8;
                        caml_young_ptr = _t434;
                        if(_t434 >= caml_young_limit) {
                            _t435 = _t434 + 4;
                             *((intOrPtr*)(_t435 - 4)) = 1024;
                             *_t435 =  &caml_exn_Not_found;
                            caml_raise_exn(_t435);
                        }
                        caml_call_gc(__esp);
                    }
                }
                __esp =  &((__esp)[4]);
                return;
                goto L129;
            }
            __esp =  &((__esp)[4]);
            return;
            goto L129;
        }
        __esp =  &((__esp)[4]);
        return;
        goto L129;
    }
    goto L48;
}

camlHashtbl__find_all_1210(
    signed int __eax                       // r0
)
{// addr = 0x080559E0
    signed int _v4;                        // _cfa_fffffffc
    unsigned int _v8;                      // _cfa_fffffff8
    unsigned int _v16;                     // _cfa_fffffff0
    unsigned int _v20;                     // _cfa_ffffffec
    unsigned int _v24;                     // _cfa_ffffffe8
    unsigned int _v28;                     // _cfa_ffffffe4
    unsigned int _v32;                     // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    unsigned int _v48;                     // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    unsigned int _v56;                     // _cfa_ffffffc8
    signed int _t224;                      // _t224
    _unknown_ _t225;                       // _t225
    unsigned int _t229;                    // _t229
    signed int* _t230;                     // _t230
    unsigned int _t231;                    // _t231
    _unknown_ _t232;                       // _t232
    _unknown_ _t233;                       // _t233
    _unknown_ _t238;                       // _t238
    unsigned int _t239;                    // _t239

    _t224 = __eax;
    __esp = __esp - 12;
    __edx = _t224;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 20;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    __eax = __eax + 4;
     *(__eax - 4) = 4343;
     *__eax = camlHashtbl__find_in_bucket_1213;
     *(__eax + 4) = 3;
    __esi =  *(__ecx + 12);
     *(__eax + 8) =  *(__ecx + 12);
     *(__eax + 12) = __ebx;
    __esi =  *(__edx + 4);
    __esi =  *( *(__edx + 4) - 4);
    __esi =  *( *(__edx + 4) - 4) >> 10;
    if(__esi == 0) {
        __eax =  ?_? ( &caml_bucket_Division_by_zero);
        caml_raise_exn( &caml_bucket_Division_by_zero);
        __esi = __esi;
    } else {
        _v4 = __esi;
        _v8 = __eax;
         *__esp = __edx;
        __eax =  *(__ecx + 16);
        __eax =  *( *(__ecx + 16) + 8);
        __edx =  *( *( *(__ecx + 16) + 8) + 4);
        __ecx =  *__edx;
        __eax = __ebx;
        __ebx = __edx;
         *( *__edx)();
        __ebx = 2147483647;
        __eax = __eax & 2147483647;
        __eax = __eax >> 1;
        __ecx = _v4;
        asm("cdq ");
        _t33 = __eax % __ecx;
        __eax = __eax / __ecx;
        __edx = _t33;
    }
    __edx = __edx << 1;
    __edx = __edx + 1;
    __eax =  *__esp;
    __ebx =  *( *__esp + 4);
     *(__ebx - 4) =  *(__ebx - 4) >> 9;
    if( *(__ebx - 4) >> 9 <= __edx) {
        caml_ml_array_bound_error();
        __esi = __esi;
        __edi = __edi;
        __esp = __esp - 32;
        __esi = __eax;
        while(1) {
L25:
            __eax = caml_young_ptr;
            __eax = caml_young_ptr - 24;
            caml_young_ptr = __eax;
            if(__eax >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        __eax = __eax + 4;
         *(__eax - 4) = 5367;
         *__eax = camlHashtbl__replace_bucket_1221;
         *(__eax + 4) = 3;
        __edi =  *(__edx + 12);
         *(__eax + 8) =  *(__edx + 12);
         *(__eax + 12) = __ebx;
         *(__eax + 16) = __ecx;
        __edi =  *(__esi + 4);
        __edi =  *( *(__esi + 4) - 4);
        __edi =  *( *(__esi + 4) - 4) >> 10;
        if(__edi == 0) {
            __eax =  ?_? ( &caml_bucket_Division_by_zero);
            caml_raise_exn( &caml_bucket_Division_by_zero);
            __esi = __esi;
        } else {
            _v36 = __edi;
            _v28 = __eax;
            _v32 = __edx;
            _v40 = __ecx;
            _v16 = __ebx;
             *__esp = __esi;
            __eax =  *(__edx + 16);
            __eax =  *( *(__edx + 16) + 8);
            __ebx =  *(__eax + 4);
            __ecx =  *( *(__eax + 4));
            __eax = _v16;
             *__ecx();
            __ebx = 2147483647;
            __eax = _v16 & 2147483647;
            __eax = (_v16 & 2147483647) >> 1;
            __ecx = _v36;
            asm("cdq ");
            _t65 = __eax % __ecx;
            __eax = __eax / __ecx;
            __edx = _t65;
        }
        __edx = __edx << 1;
        __edx = __edx + 1;
        _v20 = __edx;
        __ebx =  *__esp;
        __ecx =  *(__ebx + 4);
         *(__ecx - 4) =  *(__ecx - 4) >> 9;
        if( *(__ecx - 4) >> 9 <= __edx) {
L43:
            caml_ml_array_bound_error();
            __esp = __esp - 12;
            __edx = __eax;
            while(1) {
                __eax = caml_young_ptr;
                __eax = caml_young_ptr - 20;
                caml_young_ptr = __eax;
                if(__eax >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            __eax = __eax + 4;
             *(__eax - 4) = 4343;
             *__eax = camlHashtbl__mem_in_bucket_1230;
             *(__eax + 4) = 3;
            __esi =  *(__ecx + 12);
             *(__eax + 8) =  *(__ecx + 12);
             *(__eax + 12) = __ebx;
            __esi =  *(__edx + 4);
            __esi =  *( *(__edx + 4) - 4);
            __esi =  *( *(__edx + 4) - 4) >> 10;
            if(__esi == 0) {
                __eax =  ?_? ( &caml_bucket_Division_by_zero);
                caml_raise_exn( &caml_bucket_Division_by_zero);
                __esi = __esi;
            } else {
                _v48 = __esi;
                _v52 = __eax;
                 *__esp = __edx;
                __eax =  *(__ecx + 16);
                __eax =  *( *(__ecx + 16) + 8);
                __edx =  *( *( *(__ecx + 16) + 8) + 4);
                __ecx =  *__edx;
                __eax = __ebx;
                __ebx = __edx;
                 *( *__edx)();
                __ebx = 2147483647;
                __eax = __eax & 2147483647;
                __eax = __eax >> 1;
                __ecx = _v48;
                asm("cdq ");
                _t121 = __eax % __ecx;
                __eax = __eax / __ecx;
                __edx = _t121;
            }
            __edx = __edx << 1;
            __edx = __edx + 1;
            __eax =  *__esp;
            __ebx =  *( *__esp + 4);
             *(__ebx - 4) =  *(__ebx - 4) >> 9;
            if( *(__ebx - 4) >> 9 <= __edx) {
                caml_ml_array_bound_error();
                __esi = __esi;
                __edi = __edi;
                caml_hash_univ_param(21, 201, __eax);
                return;
                goto L97;
            }
            __eax =  *(__ebx + __edx * 2 - 2);
            __ebx = _v52;
            __esp =  &((__esp)[3]);
            __esp = __esp - 8;
            while(__eax != 1) {
                _v48 = __ebx;
                __ecx =  *(__eax + 8);
                 *__esp =  *(__eax + 8);
                __eax =  *__eax;
                 *(__ebx + 8) =  *( *(__ebx + 8));
                __ebx =  *(__ebx + 12);
                caml_apply2();
                if(__eax == 1) {
                    __eax =  *__esp;
                    __ebx = _v48;
                    continue;
                }
                __eax = 3;
                __esp =  &((__esp)[2]);
                return 3;
                goto L97;
            }
            __eax = 1;
            __esp =  &((__esp)[2]);
            return 1;
            goto L97;
        }
        __eax =  *(__ecx + __edx * 2 - 2);
        _v36 = __eax;
        L37();
        __ecx =  ?_? ( &caml_exn_Not_found);
        __ebx =  *__eax;
        if(__ebx !=  &caml_exn_Not_found) {
            caml_raise_exn(__eax);
            __esi = __esi;
            __edi = __edi;
            _push(caml_exception_pointer);
            caml_exception_pointer = __esp;
            __ebx =  *(__ebx + 4);
            _v20 = __ebx;
            __ebx =  *(__ebx - 4);
            __ebx = __ebx >> 9;
            if(__ebx <= __edx) {
                caml_ml_array_bound_error();
                goto L42;
            }
            __ebx = _v24;
            camlHashtbl__replace_bucket_1221(__eax, _v24);
            _push(__eax);
            __ebx = _v20;
            __eax = _v16;
            __eax = __ebx + _v16 * 2 - 2;
            _push(__ebx + _v16 * 2 - 2);
            caml_modify(__ebx);
            __esp =  &((__esp)[2]);
            __eax = 1;
            _pop(caml_exception_pointer);
            __esp =  &((__esp)[8]);
            return;
        } else {
            __ebx =  *__esp;
            __edx =  *(__ebx + 4);
             *(__edx - 4) =  *(__edx - 4) >> 9;
            __ecx = _v20;
            if( *(__edx - 4) >> 9 <= __ecx) {
L42:
                caml_ml_array_bound_error();
            } else {
                while(1) {
                    __eax = caml_young_ptr;
                    __eax = caml_young_ptr - 16;
                    caml_young_ptr = __eax;
                    if(__eax >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                __esi = __eax + 4;
                 *(__esi - 4) = 3072;
                __eax = _v16;
                 *__esi = _v16;
                __eax = _v40;
                 *(__esi + 4) = _v40;
                __eax = _v36;
                 *(__esi + 8) = _v36;
                _push(__esi);
                __eax = __edx + __ecx * 2 - 2;
                _push(__edx + __ecx * 2 - 2);
                caml_modify(__ebx);
                __esp =  &((__esp)[2]);
                 *__ebx =  *__ebx + 2;
                __eax =  *(__ebx + 4);
                __eax =  *( *(__ebx + 4) - 4);
                __eax =  *( *(__ebx + 4) - 4) >> 9;
                __ecx = ( *( *(__ebx + 4) - 4) >> 9 | 1) + ( *( *(__ebx + 4) - 4) >> 9 | 1) - 1;
                __eax =  *__ebx;
                if( *__ebx <= __ecx) {
                    __eax = 1;
                    __esp =  &((__esp)[8]);
                    return;
                } else {
                    __eax = _v32;
                    __eax =  *(_v32 + 16);
                    __esp =  &((__esp)[8]);
                    while(1) {
                        __esp = __esp - 24;
                         *__esp = __eax;
                        _v20 = __ebx;
                        __eax =  *(__ebx + 4);
                        _v16 = __eax;
                        __eax =  *(__eax - 4);
                        __eax = __eax >> 9;
                        __eax = __eax | 1;
                        _v28 = __eax;
                        __ebx =  *134688936;
                        __eax = __eax >> 1;
                        __eax = 3 + __eax * 4;
                        camlPervasives__min_1022(__eax, __esp);
                        __ebx = _v28;
                        if(__eax == __ebx) {
                            break;
                        }
                        _v32 = __eax;
                        _v28 = __ebx;
                        _push(1);
                        _push(__eax);
                        __eax = caml_make_vect;
                        caml_c_call();
                        __esp =  &((__esp)[2]);
                        __ebx = caml_make_vect;
                        _v24 = caml_make_vect;
                        while(1) {
                            __eax = caml_young_ptr;
                            __eax = caml_young_ptr - 24;
                            caml_young_ptr = __eax;
                            if(__eax >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                        __ecx = __eax + 4;
                         *(__ecx - 4) = 5367;
                         *__ecx = camlHashtbl__insert_bucket_1068;
                         *(__ecx + 4) = 3;
                        __eax =  *__esp;
                         *(__ecx + 8) =  *__esp;
                        __eax = _v32;
                         *(__ecx + 12) = _v32;
                         *(__ecx + 16) = __ebx;
                        __eax = 1;
                        __ebx = _v28;
                        __ebx = _v28 + -2;
                        if(__eax > __ebx) {
L61:
                            __eax = _v24;
                            _push(_v24);
                            _v20 = _v20 + 4;
                            _push(_v20 + 4);
                            caml_modify(__ebx);
                            __esp =  &((__esp)[2]);
                            __eax = 1;
                            __esp =  &((__esp)[6]);
                            return;
                        } else {
                            _v28 = __ebx;
                            _v32 = __eax;
                             *__esp = __ecx;
                            while(1) {
                                __ebx = _v16;
                                 *(__ebx - 4) =  *(__ebx - 4) >> 9;
                                if( *(__ebx - 4) >> 9 <= __eax) {
                                    break;
                                }
                                __eax =  *(__ebx + __eax * 2 - 2);
                                __ebx =  *__esp;
                                camlHashtbl__insert_bucket_1068(__eax,  *__esp, __esp);
                                __eax = _v32;
                                __ecx = __eax;
                                __eax = __eax + 2;
                                _v32 = __eax;
                                __ebx = _v28;
                                if(__ecx != __ebx) {
                                    continue;
                                } else {
                                    goto L61;
                                }
                                goto L97;
                            }
                            caml_ml_array_bound_error();
                            __esi = __esi;
                            __esp = __esp - 4;
                            __edi = __eax;
                            __eax =  *(__edi + 4);
                            __esi =  *(__eax - 4);
                            __esi =  *(__eax - 4) >> 10;
                            if(__esi == 0) {
                                __eax =  ?_? ( &caml_bucket_Division_by_zero);
                                caml_raise_exn( &caml_bucket_Division_by_zero);
                                __esi = __esi;
                            } else {
                                 *__esp = __ecx;
                                caml_hash_univ_param(21, 201, __ebx);
                                __eax = __eax >> 1;
                                __ecx = __esi;
                                asm("cdq ");
                                _t168 = __eax % __ecx;
                                __eax = __eax / __ecx;
                                __edx = _t168;
                            }
                            __edx = __edx << 1;
                            __edx = __edx + 1;
                            while(1) {
                                __eax = caml_young_ptr;
                                __eax = caml_young_ptr - 16;
                                caml_young_ptr = __eax;
                                if(__eax >= caml_young_limit) {
                                    break;
                                }
                                caml_call_gc(__esp);
                            }
                            __eax = __eax + 4;
                             *(__eax - 4) = 3072;
                             *__eax = __ebx;
                            __ebx =  *__esp;
                             *(__eax + 4) =  *__esp;
                            __ecx =  *(__edi + 4);
                            __ebx =  *(__ecx - 4);
                            __ebx =  *(__ecx - 4) >> 9;
                            if(__ebx <= __edx) {
L77:
                                caml_ml_array_bound_error();
                                __esi = __esi;
                                __esp = __esp - 8;
                                __edi = __eax;
                                __ecx = __ebx;
                                while(1) {
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 20;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        break;
                                    }
                                    caml_call_gc(__esp);
                                }
                                __ebx = __eax + 4;
                                 *(__ebx - 4) = 4343;
                                 *__ebx = camlHashtbl__remove_bucket_1083;
                                 *(__ebx + 4) = 3;
                                 *(__ebx + 8) = __edi;
                                 *(__ebx + 12) = __ecx;
                                __eax =  *(__edi + 4);
                                __esi =  *(__eax - 4);
                                __esi =  *(__eax - 4) >> 10;
                                if(__esi == 0) {
                                    __eax =  ?_? ( &caml_bucket_Division_by_zero);
                                    caml_raise_exn( &caml_bucket_Division_by_zero);
                                    __esi = __esi;
                                } else {
                                    caml_hash_univ_param(21, 201, __ecx);
                                    __eax = __eax >> 1;
                                    __ecx = __esi;
                                    asm("cdq ");
                                    _t199 = __eax % __ecx;
                                    __eax = __eax / __ecx;
                                    __edx = _t199;
                                }
                                __edx = __edx << 1;
                                __edx = __edx + 1;
                                _v44 = __edx;
                                __eax =  *(__edi + 4);
                                 *__esp = __eax;
                                __eax =  *(__eax - 4);
                                if(__eax <= __edx) {
L88:
                                    caml_ml_array_bound_error();
                                    __esp = __esp - 12;
                                    while(__ebx != 1) {
                                         *__esp = __eax;
                                        __ecx =  *(__ebx + 8);
                                        _v56 =  *(__ebx + 8);
                                        __ecx =  *(__ebx + 4);
                                        _v52 =  *(__ebx + 4);
                                        _push(__ebx);
                                        _push(__eax);
                                        __eax = caml_compare;
                                        caml_c_call();
                                        __esp =  &((__esp)[2]);
                                        if(caml_compare != 1) {
                                            __eax =  *__esp;
                                            __ebx = _v56;
                                            continue;
                                        }
                                        __eax = _v52;
                                        __esp =  &((__esp)[3]);
                                        return;
                                        goto L97;
                                    }
                                    while(1) {
                                        __eax = caml_young_ptr;
                                        __eax = caml_young_ptr - 8;
                                        caml_young_ptr = __eax;
                                        if(__eax >= caml_young_limit) {
                                            __eax = __eax + 4;
                                             *(__eax - 4) = 1024;
                                             *__eax =  &caml_exn_Not_found;
                                            caml_raise_exn(__eax);
                                        }
                                        goto L96;
                                    }
                                }
                                __ecx =  *(__edi + 4);
                                 *(__ecx - 4) =  *(__ecx - 4) >> 9;
                                if( *(__ecx - 4) >> 9 <= __edx) {
                                    caml_ml_array_bound_error();
                                    goto L88;
                                }
                                __eax =  *(__ecx + __edx * 2 - 2);
                                camlHashtbl__remove_bucket_1083(__eax, __ebx, __esp);
                                _push(__eax);
                                __ebx = _v48;
                                __eax = _v44;
                                __eax = __ebx + _v44 * 2 - 2;
                                _push(__ebx + _v44 * 2 - 2);
                                caml_modify(__ebx);
                                __esp =  &((__esp)[2]);
                                __eax = 1;
                                __esp =  &((__esp)[2]);
                                return;
                                goto L97;
                            }
                            __ebx =  *(__ecx + __edx * 2 - 2);
                             *(__eax + 8) =  *(__ecx + __edx * 2 - 2);
                            __ecx =  *(__edi + 4);
                            __ebx =  *(__ecx - 4);
                            __ebx =  *(__ecx - 4) >> 9;
                            if(__ebx <= __edx) {
                                caml_ml_array_bound_error();
                                goto L77;
                            }
                            _push(__eax);
                            __eax = __ecx + __edx * 2 - 2;
                            _push(__ecx + __edx * 2 - 2);
                            caml_modify(__ebx);
                            __esp =  &((__esp)[2]);
                             *__edi =  *__edi + 2;
                            __eax =  *(__edi + 4);
                            __eax =  *( *(__edi + 4) - 4);
                            __eax =  *( *(__edi + 4) - 4) >> 9;
                            __ebx = ( *( *(__edi + 4) - 4) >> 9 | 1) + ( *( *(__edi + 4) - 4) >> 9 | 1) - 1;
                            __eax =  *__edi;
                            if( *__edi <= __ebx) {
                                __eax = 1;
                                __esp =  &((__esp)[1]);
                                return;
                            } else {
                                __eax =  *134689320;
                                __ebx = __edi;
                                __esp =  &((__esp)[1]);
                                continue;
                            }
                        }
                        goto L97;
                    }
                    __eax = 1;
                    __esp =  &((__esp)[6]);
                    return;
                }
                goto L97;
            }
            goto L43;
        }
    } else {
        __eax =  *(__ebx + __edx * 2 - 2);
        __ebx = _v8;
        __esp =  &((__esp)[3]);
        __esp = __esp - 12;
        while(_t224 != 1) {
            _v8 = _t231;
             *__esp =  *(_t224 + 8);
            _v4 =  *(_t224 + 4);
            caml_apply2();
            if( *_t224 == 1) {
                _t224 =  *__esp;
                _t231 = _v8;
                continue;
            }
            L1();
            _t239 =  *__esp;
            while(1) {
                _t229 = caml_young_ptr - 12;
                caml_young_ptr = _t229;
                if(_t229 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t230 = _t229 + 4;
             *((intOrPtr*)(_t230 - 4)) = 2048;
             *_t230 = _v4;
            _t230[1] = _t239;
            __esp =  &((__esp)[3]);
            return _t230;
L97:
        }
        __esp =  &((__esp)[3]);
        return 1;
    }
}

camlHashtbl__replace_1217(
    signed int __eax                       // r0
)
{// addr = 0x08055AB0
    unsigned int _v4;                      // _cfa_fffffffc
    unsigned int _v8;                      // _cfa_fffffff8
    unsigned int _v12;                     // _cfa_fffffff4
    unsigned int _v16;                     // _cfa_fffffff0
    unsigned int _v20;                     // _cfa_ffffffec
    unsigned int _v24;                     // _cfa_ffffffe8
    unsigned int _v28;                     // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    unsigned int _v44;                     // _cfa_ffffffd4
    signed int _t185;                      // _t185
    _unknown_ _t186;                       // _t186
    _unknown_ _t188;                       // _t188
    unsigned int _t189;                    // _t189
    _unknown_ _t190;                       // _t190
    _unknown_ _t193;                       // _t193

    _t185 = __eax;
    __esp = __esp - 32;
    __esi = _t185;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 24;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    __eax = __eax + 4;
     *(__eax - 4) = 5367;
     *__eax = camlHashtbl__replace_bucket_1221;
     *(__eax + 4) = 3;
    __edi =  *(__edx + 12);
     *(__eax + 8) =  *(__edx + 12);
     *(__eax + 12) = __ebx;
     *(__eax + 16) = __ecx;
    __edi =  *(__esi + 4);
    __edi =  *( *(__esi + 4) - 4);
    __edi =  *( *(__esi + 4) - 4) >> 10;
    if(__edi == 0) {
        __eax =  ?_? ( &caml_bucket_Division_by_zero);
        caml_raise_exn( &caml_bucket_Division_by_zero);
        __esi = __esi;
    } else {
        _v24 = __edi;
        _v16 = __eax;
        _v20 = __edx;
        _v28 = __ecx;
        _v4 = __ebx;
         *__esp = __esi;
        __eax =  *(__edx + 16);
        __eax =  *( *(__edx + 16) + 8);
        __ebx =  *(__eax + 4);
        __ecx =  *( *(__eax + 4));
        __eax = _v4;
         *__ecx();
        __ebx = 2147483647;
        __eax = _v4 & 2147483647;
        __eax = (_v4 & 2147483647) >> 1;
        __ecx = _v24;
        asm("cdq ");
        _t26 = __eax % __ecx;
        __eax = __eax / __ecx;
        __edx = _t26;
    }
    __edx = __edx << 1;
    __edx = __edx + 1;
    _v8 = __edx;
    __ebx =  *__esp;
    __ecx =  *(__ebx + 4);
     *(__ecx - 4) =  *(__ecx - 4) >> 9;
    if( *(__ecx - 4) >> 9 <= __edx) {
L25:
        caml_ml_array_bound_error();
        __esp = __esp - 12;
        __edx = __eax;
        while(1) {
            __eax = caml_young_ptr;
            __eax = caml_young_ptr - 20;
            caml_young_ptr = __eax;
            if(__eax >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        __eax = __eax + 4;
         *(__eax - 4) = 4343;
         *__eax = camlHashtbl__mem_in_bucket_1230;
         *(__eax + 4) = 3;
        __esi =  *(__ecx + 12);
         *(__eax + 8) =  *(__ecx + 12);
         *(__eax + 12) = __ebx;
        __esi =  *(__edx + 4);
        __esi =  *( *(__edx + 4) - 4);
        __esi =  *( *(__edx + 4) - 4) >> 10;
        if(__esi == 0) {
            __eax =  ?_? ( &caml_bucket_Division_by_zero);
            caml_raise_exn( &caml_bucket_Division_by_zero);
            __esi = __esi;
        } else {
            _v36 = __esi;
            _v40 = __eax;
             *__esp = __edx;
            __eax =  *(__ecx + 16);
            __eax =  *( *(__ecx + 16) + 8);
            __edx =  *( *( *(__ecx + 16) + 8) + 4);
            __ecx =  *__edx;
            __eax = __ebx;
            __ebx = __edx;
             *( *__edx)();
            __ebx = 2147483647;
            __eax = __eax & 2147483647;
            __eax = __eax >> 1;
            __ecx = _v36;
            asm("cdq ");
            _t82 = __eax % __ecx;
            __eax = __eax / __ecx;
            __edx = _t82;
        }
        __edx = __edx << 1;
        __edx = __edx + 1;
        __eax =  *__esp;
        __ebx =  *( *__esp + 4);
         *(__ebx - 4) =  *(__ebx - 4) >> 9;
        if( *(__ebx - 4) >> 9 <= __edx) {
            caml_ml_array_bound_error();
            __esi = __esi;
            __edi = __edi;
        } else {
            __eax =  *(__ebx + __edx * 2 - 2);
            __ebx = _v40;
            __esp =  &((__esp)[3]);
            __esp = __esp - 8;
            while(_t185 != 1) {
                _v36 = _t189;
                 *__esp =  *(_t185 + 8);
                caml_apply2();
                if( *_t185 == 1) {
                    _t185 =  *__esp;
                    _t189 = _v36;
                    continue;
                }
                __esp =  &((__esp)[2]);
                return 3;
L79:
            }
            __esp =  &((__esp)[2]);
            return 1;
            goto L79;
        }
        caml_hash_univ_param(21, 201, __eax);
        return;
        goto L79;
    }
    __eax =  *(__ecx + __edx * 2 - 2);
    _v24 = __eax;
    L19();
    __ecx =  ?_? ( &caml_exn_Not_found);
    __ebx =  *__eax;
    if(__ebx !=  &caml_exn_Not_found) {
        caml_raise_exn(__eax);
        __esi = __esi;
        __edi = __edi;
        _push(caml_exception_pointer);
        caml_exception_pointer = __esp;
        __ebx =  *(__ebx + 4);
        _v8 = __ebx;
        __ebx =  *(__ebx - 4);
        __ebx = __ebx >> 9;
        if(__ebx <= __edx) {
            caml_ml_array_bound_error();
            goto L24;
        }
        __ebx = _v12;
        camlHashtbl__replace_bucket_1221(__eax, _v12);
        _push(__eax);
        __ebx = _v8;
        __eax = _v4;
        __eax = __ebx + _v4 * 2 - 2;
        _push(__ebx + _v4 * 2 - 2);
        caml_modify(__ebx);
        __esp =  &((__esp)[2]);
        __eax = 1;
        _pop(caml_exception_pointer);
        __esp =  &((__esp)[8]);
        return;
    } else {
        __ebx =  *__esp;
        __edx =  *(__ebx + 4);
         *(__edx - 4) =  *(__edx - 4) >> 9;
        __ecx = _v8;
        if( *(__edx - 4) >> 9 <= __ecx) {
L24:
            caml_ml_array_bound_error();
        } else {
            while(1) {
                __eax = caml_young_ptr;
                __eax = caml_young_ptr - 16;
                caml_young_ptr = __eax;
                if(__eax >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            __esi = __eax + 4;
             *(__esi - 4) = 3072;
            __eax = _v4;
             *__esi = _v4;
            __eax = _v28;
             *(__esi + 4) = _v28;
            __eax = _v24;
             *(__esi + 8) = _v24;
            _push(__esi);
            __eax = __edx + __ecx * 2 - 2;
            _push(__edx + __ecx * 2 - 2);
            caml_modify(__ebx);
            __esp =  &((__esp)[2]);
             *__ebx =  *__ebx + 2;
            __eax =  *(__ebx + 4);
            __eax =  *( *(__ebx + 4) - 4);
            __eax =  *( *(__ebx + 4) - 4) >> 9;
            __ecx = ( *( *(__ebx + 4) - 4) >> 9 | 1) + ( *( *(__ebx + 4) - 4) >> 9 | 1) - 1;
            __eax =  *__ebx;
            if( *__ebx <= __ecx) {
                __eax = 1;
                __esp =  &((__esp)[8]);
                return;
            } else {
                __eax = _v20;
                __eax =  *(_v20 + 16);
                __esp =  &((__esp)[8]);
                while(1) {
                    __esp = __esp - 24;
                     *__esp = __eax;
                    _v8 = __ebx;
                    __eax =  *(__ebx + 4);
                    _v4 = __eax;
                    __eax =  *(__eax - 4);
                    __eax = __eax >> 9;
                    __eax = __eax | 1;
                    _v16 = __eax;
                    __ebx =  *134688936;
                    __eax = __eax >> 1;
                    __eax = 3 + __eax * 4;
                    camlPervasives__min_1022(__eax, __esp);
                    __ebx = _v16;
                    if(__eax == __ebx) {
                        break;
                    }
                    _v20 = __eax;
                    _v16 = __ebx;
                    _push(1);
                    _push(__eax);
                    __eax = caml_make_vect;
                    caml_c_call();
                    __esp =  &((__esp)[2]);
                    __ebx = caml_make_vect;
                    _v12 = caml_make_vect;
                    while(1) {
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 24;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                    __ecx = __eax + 4;
                     *(__ecx - 4) = 5367;
                     *__ecx = camlHashtbl__insert_bucket_1068;
                     *(__ecx + 4) = 3;
                    __eax =  *__esp;
                     *(__ecx + 8) =  *__esp;
                    __eax = _v20;
                     *(__ecx + 12) = _v20;
                     *(__ecx + 16) = __ebx;
                    __eax = 1;
                    __ebx = _v16;
                    __ebx = _v16 + -2;
                    if(__eax > __ebx) {
L43:
                        __eax = _v12;
                        _push(_v12);
                        _v8 = _v8 + 4;
                        _push(_v8 + 4);
                        caml_modify(__ebx);
                        __esp =  &((__esp)[2]);
                        __eax = 1;
                        __esp =  &((__esp)[6]);
                        return;
                    } else {
                        _v16 = __ebx;
                        _v20 = __eax;
                         *__esp = __ecx;
                        while(1) {
                            __ebx = _v4;
                             *(__ebx - 4) =  *(__ebx - 4) >> 9;
                            if( *(__ebx - 4) >> 9 <= __eax) {
                                break;
                            }
                            __eax =  *(__ebx + __eax * 2 - 2);
                            __ebx =  *__esp;
                            camlHashtbl__insert_bucket_1068(__eax,  *__esp, __esp);
                            __eax = _v20;
                            __ecx = __eax;
                            __eax = __eax + 2;
                            _v20 = __eax;
                            __ebx = _v16;
                            if(__ecx != __ebx) {
                                continue;
                            } else {
                                goto L43;
                            }
                            goto L79;
                        }
                        caml_ml_array_bound_error();
                        __esi = __esi;
                        __esp = __esp - 4;
                        __edi = __eax;
                        __eax =  *(__edi + 4);
                        __esi =  *(__eax - 4);
                        __esi =  *(__eax - 4) >> 10;
                        if(__esi == 0) {
                            __eax =  ?_? ( &caml_bucket_Division_by_zero);
                            caml_raise_exn( &caml_bucket_Division_by_zero);
                            __esi = __esi;
                        } else {
                             *__esp = __ecx;
                            caml_hash_univ_param(21, 201, __ebx);
                            __eax = __eax >> 1;
                            __ecx = __esi;
                            asm("cdq ");
                            _t129 = __eax % __ecx;
                            __eax = __eax / __ecx;
                            __edx = _t129;
                        }
                        __edx = __edx << 1;
                        __edx = __edx + 1;
                        while(1) {
                            __eax = caml_young_ptr;
                            __eax = caml_young_ptr - 16;
                            caml_young_ptr = __eax;
                            if(__eax >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                        __eax = __eax + 4;
                         *(__eax - 4) = 3072;
                         *__eax = __ebx;
                        __ebx =  *__esp;
                         *(__eax + 4) =  *__esp;
                        __ecx =  *(__edi + 4);
                        __ebx =  *(__ecx - 4);
                        __ebx =  *(__ecx - 4) >> 9;
                        if(__ebx <= __edx) {
L59:
                            caml_ml_array_bound_error();
                            __esi = __esi;
                            __esp = __esp - 8;
                            __edi = __eax;
                            __ecx = __ebx;
                            while(1) {
                                __eax = caml_young_ptr;
                                __eax = caml_young_ptr - 20;
                                caml_young_ptr = __eax;
                                if(__eax >= caml_young_limit) {
                                    break;
                                }
                                caml_call_gc(__esp);
                            }
                            __ebx = __eax + 4;
                             *(__ebx - 4) = 4343;
                             *__ebx = camlHashtbl__remove_bucket_1083;
                             *(__ebx + 4) = 3;
                             *(__ebx + 8) = __edi;
                             *(__ebx + 12) = __ecx;
                            __eax =  *(__edi + 4);
                            __esi =  *(__eax - 4);
                            __esi =  *(__eax - 4) >> 10;
                            if(__esi == 0) {
                                __eax =  ?_? ( &caml_bucket_Division_by_zero);
                                caml_raise_exn( &caml_bucket_Division_by_zero);
                                __esi = __esi;
                            } else {
                                caml_hash_univ_param(21, 201, __ecx);
                                __eax = __eax >> 1;
                                __ecx = __esi;
                                asm("cdq ");
                                _t160 = __eax % __ecx;
                                __eax = __eax / __ecx;
                                __edx = _t160;
                            }
                            __edx = __edx << 1;
                            __edx = __edx + 1;
                            _v32 = __edx;
                            __eax =  *(__edi + 4);
                             *__esp = __eax;
                            __eax =  *(__eax - 4);
                            if(__eax <= __edx) {
L70:
                                caml_ml_array_bound_error();
                                __esp = __esp - 12;
                                while(__ebx != 1) {
                                     *__esp = __eax;
                                    __ecx =  *(__ebx + 8);
                                    _v44 =  *(__ebx + 8);
                                    __ecx =  *(__ebx + 4);
                                    _v40 =  *(__ebx + 4);
                                    _push(__ebx);
                                    _push(__eax);
                                    __eax = caml_compare;
                                    caml_c_call();
                                    __esp =  &((__esp)[2]);
                                    if(caml_compare != 1) {
                                        __eax =  *__esp;
                                        __ebx = _v44;
                                        continue;
                                    }
                                    __eax = _v40;
                                    __esp =  &((__esp)[3]);
                                    return;
                                    goto L79;
                                }
                                while(1) {
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 8;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        __eax = __eax + 4;
                                         *(__eax - 4) = 1024;
                                         *__eax =  &caml_exn_Not_found;
                                        caml_raise_exn(__eax);
                                    }
                                    goto L78;
                                }
                            }
                            __ecx =  *(__edi + 4);
                             *(__ecx - 4) =  *(__ecx - 4) >> 9;
                            if( *(__ecx - 4) >> 9 <= __edx) {
                                caml_ml_array_bound_error();
                                goto L70;
                            }
                            __eax =  *(__ecx + __edx * 2 - 2);
                            camlHashtbl__remove_bucket_1083(__eax, __ebx, __esp);
                            _push(__eax);
                            __ebx = _v36;
                            __eax = _v32;
                            __eax = __ebx + _v32 * 2 - 2;
                            _push(__ebx + _v32 * 2 - 2);
                            caml_modify(__ebx);
                            __esp =  &((__esp)[2]);
                            __eax = 1;
                            __esp =  &((__esp)[2]);
                            return;
                            goto L79;
                        }
                        __ebx =  *(__ecx + __edx * 2 - 2);
                         *(__eax + 8) =  *(__ecx + __edx * 2 - 2);
                        __ecx =  *(__edi + 4);
                        __ebx =  *(__ecx - 4);
                        __ebx =  *(__ecx - 4) >> 9;
                        if(__ebx <= __edx) {
                            caml_ml_array_bound_error();
                            goto L59;
                        }
                        _push(__eax);
                        __eax = __ecx + __edx * 2 - 2;
                        _push(__ecx + __edx * 2 - 2);
                        caml_modify(__ebx);
                        __esp =  &((__esp)[2]);
                         *__edi =  *__edi + 2;
                        __eax =  *(__edi + 4);
                        __eax =  *( *(__edi + 4) - 4);
                        __eax =  *( *(__edi + 4) - 4) >> 9;
                        __ebx = ( *( *(__edi + 4) - 4) >> 9 | 1) + ( *( *(__edi + 4) - 4) >> 9 | 1) - 1;
                        __eax =  *__edi;
                        if( *__edi <= __ebx) {
                            __eax = 1;
                            __esp =  &((__esp)[1]);
                            return;
                        } else {
                            __eax =  *134689320;
                            __ebx = __edi;
                            __esp =  &((__esp)[1]);
                            continue;
                        }
                    }
                    goto L79;
                }
                __eax = 1;
                __esp =  &((__esp)[6]);
                return;
            }
            goto L79;
        }
        goto L25;
    }
    goto L79;
}

L08055C30(
    signed int __eax,                      // r0
    _unknown_ __ecx,                       // r2
    _unknown_ __edx,                       // r3
    _unknown_ __edi,                       // r4
    intOrPtr _a20,                         // _cfa_14
    intOrPtr _a24,                         // _cfa_18
    signed int _a28                        // _cfa_1c
)
{
    signed int _v8;                        // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    signed int _t42;                       // _t42
    _unknown_ _t43;                        // _t43
    _unknown_ _t44;                        // _t44
    signed int _t45;                       // _t45
    intOrPtr _t47;                         // _t47
    signed int _t48;                       // _t48
    _unknown_ _t53;                        // _t53
    _unknown_ _t55;                        // _t55
    _unknown_ _t61;                        // _t61
    _unknown_ _t62;                        // _t62
    intOrPtr _t63;                         // _t63
    signed int _t65;                       // _t65
    intOrPtr _t66;                         // _t66
    _unknown_ _t67;                        // _t67
    _unknown_ _t68;                        // _t68
    _unknown_ _t69;                        // _t69
    _unknown_ _t70;                        // _t70
    _unknown_ _t73;                        // _t73
    signed int _t77;                       // _t77
    signed int _t79;                       // _t79
    _unknown_ _t81;                        // _t81
    _unknown_ _t82;                        // _t82
    unsigned int _t86;                     // _t86
    _unknown_ _t87;                        // _t87

    _t70 = __ecx;
    _t42 = __eax;
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    _t63 =  *((intOrPtr*)(_t62 + 4));
    _a24 = _t63;
    _t65 =  *(_t63 - 4) >> 9;
    if(_t65 <= __edx) {
        caml_ml_array_bound_error();
        caml_ml_array_bound_error();
        _t45 = caml_ml_array_bound_error();
        __esp = __esp - 12;
        _t77 = _t45;
        while(1) {
            _t47 = caml_young_ptr - 20;
            caml_young_ptr = _t47;
            if(_t47 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t48 = _t47 + 4;
         *((intOrPtr*)(_t48 - 4)) = 4343;
         *_t48 = camlHashtbl__mem_in_bucket_1230;
         *((intOrPtr*)(_t48 + 4)) = 3;
         *((intOrPtr*)(_t48 + 8)) =  *((intOrPtr*)(_t70 + 12));
         *(_t48 + 12) = _t65;
        _t86 =  *( *((intOrPtr*)(_t77 + 4)) - 4) >> 10;
        if(_t86 == 0) {
            caml_raise_exn( &caml_bucket_Division_by_zero);
            _t86 = _t86;
        } else {
            _v8 = _t86;
            _v12 = _t48;
             *__esp = _t77;
             *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t70 + 16)) + 8)) + 4))))))();
            asm("cdq ");
            _t77 = ((_t65 & 2147483647) >> 1) % _v8;
        }
        _t79 = (_t77 << 1) + 1;
        _t66 =  *((intOrPtr*)( *__esp + 4));
        _t52 =  *(_t66 - 4) >> 9;
        if( *(_t66 - 4) >> 9 <= _t79) {
            caml_ml_array_bound_error();
            caml_hash_univ_param(21, 201, _t52);
            return;
L21:
        }
        _t42 =  *(_t66 + _t79 * 2 - 2);
        _t65 = _v12;
        __esp =  &((__esp)[3]);
        __esp = __esp - 8;
        while(_t42 != 1) {
            _v8 = _t65;
             *__esp =  *(_t42 + 8);
            caml_apply2();
            if( *_t42 == 1) {
                _t42 =  *__esp;
                _t65 = _v8;
                continue;
            }
            __esp =  &((__esp)[2]);
            return;
            goto L21;
        }
        __esp =  &((__esp)[2]);
        return;
        goto L21;
    }
    __ebx = _a20;
    camlHashtbl__replace_bucket_1221(__eax, _a20);
    _push(__eax);
    __ebx = _a24;
    _a28 = __ebx + _a28 * 2 - 2;
    _push(__ebx + _a28 * 2 - 2);
    caml_modify(__ebx);
    __esp =  &((__esp)[2]);
    __eax = 1;
    _pop(caml_exception_pointer);
    __esp =  &((__esp)[8]);
    return;
    goto L21;
}

camlHashtbl__mem_1227(
    signed int __eax,                      // r0
    signed int __ebx,                      // r1
    _unknown_ __ecx,                       // r2
    _unknown_ __edi                        // r4
)
{// addr = 0x08055CB0
    signed int _v4;                        // _cfa_fffffffc
    signed int _v8;                        // _cfa_fffffff8
    signed int _t33;                       // _t33
    _unknown_ _t34;                        // _t34
    _unknown_ _t36;                        // _t36
    signed int _t37;                       // _t37
    _unknown_ _t38;                        // _t38
    _unknown_ _t39;                        // _t39
    _unknown_ _t42;                        // _t42

    __edi = __edi;
    _t37 = __ebx;
    _t33 = __eax;
    __esp = __esp - 12;
    __edx = _t33;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 20;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    __eax = __eax + 4;
     *((intOrPtr*)(__eax - 4)) = 4343;
     *__eax = camlHashtbl__mem_in_bucket_1230;
     *(__eax + 4) = 3;
    __esi =  *(__ecx + 12);
     *(__eax + 8) =  *(__ecx + 12);
     *(__eax + 12) = __ebx;
    __esi =  *(__edx + 4);
    __esi =  *( *(__edx + 4) - 4);
    __esi =  *( *(__edx + 4) - 4) >> 10;
    if(__esi == 0) {
        __eax =  ?_? ( &caml_bucket_Division_by_zero);
        caml_raise_exn( &caml_bucket_Division_by_zero);
        __esi = __esi;
    } else {
        _v4 = __esi;
        _v8 = __eax;
         *__esp = __edx;
        __eax =  *(__ecx + 16);
        __eax =  *( *(__ecx + 16) + 8);
        __edx =  *( *( *(__ecx + 16) + 8) + 4);
        __ecx =  *__edx;
        __eax = __ebx;
        __ebx = __edx;
         *( *__edx)();
        __ebx = 2147483647;
        __eax = __eax & 2147483647;
        __eax = __eax >> 1;
        __ecx = _v4;
        asm("cdq ");
        _t21 = __eax % __ecx;
        __eax = __eax / __ecx;
        __edx = _t21;
    }
    __edx = __edx << 1;
    __edx = __edx + 1;
    __eax =  *__esp;
    __ebx =  *( *__esp + 4);
     *(__ebx - 4) =  *(__ebx - 4) >> 9;
    if( *(__ebx - 4) >> 9 <= __edx) {
        caml_ml_array_bound_error();
        __esi = __esi;
        __edi = __edi;
        caml_hash_univ_param(21, 201, __eax);
        return;
L16:
    }
    __eax =  *(__ebx + __edx * 2 - 2);
    __ebx = _v8;
    __esp =  &((__esp)[3]);
    __esp = __esp - 8;
    while(_t33 != 1) {
        _v4 = _t37;
         *__esp =  *(_t33 + 8);
        caml_apply2();
        if( *_t33 == 1) {
            _t33 =  *__esp;
            _t37 = _v4;
            continue;
        }
        __esp =  &((__esp)[2]);
        return;
        goto L16;
    }
    __esp =  &((__esp)[2]);
    return;
    goto L16;
}

camlHashtbl__hash_1031(
    _unknown_ __eax                        // r0
)
{// addr = 0x08055D80
    _unknown_ _t2;                         // _t2

    caml_hash_univ_param(21, 201, __eax);
    return;
}

camlHashtbl__create_1051(
    _unknown_ __eax                        // r0
)
{// addr = 0x08055DA0
    _unknown_ _t5;                         // _t5
    intOrPtr _t10;                         // _t10
    intOrPtr* _t11;                        // _t11
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13
    intOrPtr _t14;                         // _t14

    caml_c_call(camlPervasives__min_1022(camlPervasives__max_1025(3, __esp), __esp), 1);
    _t14 = caml_make_vect;
    while(1) {
        _t10 = caml_young_ptr - 12;
        caml_young_ptr = _t10;
        if(_t10 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t11 = _t10 + 4;
     *((intOrPtr*)(_t11 - 4)) = 2048;
     *_t11 = 1;
     *((intOrPtr*)(_t11 + 4)) = _t14;
    return;
}

camlHashtbl__clear_1054(
    signed int* __eax                      // r0
)
{// addr = 0x08055E00
    _unknown_ _t14;                        // _t14
    intOrPtr _t17;                         // _t17
    intOrPtr _t21;                         // _t21
    intOrPtr* _t22;                        // _t22
    signed int _t25;                       // _t25
    intOrPtr _t29;                         // _t29
    _unknown_ _t33;                        // _t33

    __edi = __eax;
    _t25 = 1;
    _t33 = ( *((__edi)[1] - 4) >> 9 | 1) + -2;
    if(_t25 > _t33) {
L3:
         *__edi = 1;
        return;
    } else {
        while(1) {
            _t28 = (__edi)[1];
            if( *((__edi)[1] - 4) >> 9 <= _t25) {
                break;
            }
            caml_modify(_t25, _t28 + _t25 * 2 - 2, 1);
            _t25 = _t25 + 2;
            if(_t25 != _t33) {
                continue;
            } else {
                goto L3;
            }
            goto L9;
        }
        _t17 = caml_ml_array_bound_error();
        __esp = __esp - 4;
         *__esp = _t17;
        _t29 = camlArray__copy_1049( *((intOrPtr*)(_t17 + 4)));
        while(1) {
            _t21 = caml_young_ptr - 12;
            caml_young_ptr = _t21;
            if(_t21 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t22 = _t21 + 4;
         *((intOrPtr*)(_t22 - 4)) = 2048;
         *_t22 =  *((intOrPtr*)( *__esp));
         *((intOrPtr*)(_t22 + 4)) = _t29;
        __esp = __esp + 4;
        return;
    }
L9:
}

camlHashtbl__copy_1057(
    intOrPtr __eax                         // r0
)
{// addr = 0x08055E50
    intOrPtr _t9;                          // _t9
    intOrPtr* _t10;                        // _t10

    _t5 = __eax;
     *__esp = __eax;
    __ecx = camlArray__copy_1049( *((intOrPtr*)(_t5 + 4)));
    while(1) {
        _t9 = caml_young_ptr - 12;
        caml_young_ptr = _t9;
        if(_t9 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t10 = _t9 + 4;
     *((intOrPtr*)(_t10 - 4)) = 2048;
     *_t10 =  *((intOrPtr*)( *__esp));
     *((intOrPtr*)(_t10 + 4)) = __ecx;
    return;
}

camlHashtbl__length_1059(
    _unknown_ __eax                        // r0
)
{// addr = 0x08055EA0
    return  *((intOrPtr*)(__eax));
}

camlHashtbl__resize_1061(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    _unknown_ __esi,                       // r5
    _unknown_ __esp                        // r7
)
{// addr = 0x08055EB0
    _unknown_ _v4;                         // _cfa_fffffffc
    _unknown_ _v8;                         // _cfa_fffffff8
    _unknown_ _v12;                        // _cfa_fffffff4
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _t93;                        // _t93
    _unknown_ _t99;                        // _t99
    _unknown_ _t100;                       // _t100
    _unknown_ _t103;                       // _t103
    _unknown_ _t106;                       // _t106
    _unknown_ _t110;                       // _t110
    _unknown_ _t111;                       // _t111
    _unknown_ _t114;                       // _t114
    _unknown_ _t116;                       // _t116
    _unknown_ _t117;                       // _t117
    _unknown_ _t118;                       // _t118
    _unknown_ _t120;                       // _t120
    _unknown_ _t123;                       // _t123
    _unknown_ _t124;                       // _t124
    _unknown_ _t127;                       // _t127
    _unknown_ _t129;                       // _t129
    _unknown_ _t130;                       // _t130
    _unknown_ _t131;                       // _t131
    _unknown_ _t136;                       // _t136
    _unknown_ _t141;                       // _t141
    _unknown_ _t142;                       // _t142
    _unknown_ _t144;                       // _t144
    _unknown_ _t145;                       // _t145
    _unknown_ _t152;                       // _t152
    _unknown_ _t153;                       // _t153
    _unknown_ _t154;                       // _t154
    _unknown_ _t156;                       // _t156
    _unknown_ _t158;                       // _t158
    _unknown_ _t159;                       // _t159
    _unknown_ _t160;                       // _t160
    _unknown_ _t161;                       // _t161
    _unknown_ _t162;                       // _t162
    _unknown_ _t163;                       // _t163
    _unknown_ _t166;                       // _t166
    _unknown_ _t169;                       // _t169
    _unknown_ _t170;                       // _t170
    _unknown_ _t176;                       // _t176
    _unknown_ _t178;                       // _t178
    _unknown_ _t180;                       // _t180
    _unknown_ _t181;                       // _t181
    _unknown_ _t182;                       // _t182
    _unknown_ _t190;                       // _t190
    _unknown_ _t192;                       // _t192
    _unknown_ _t194;                       // _t194
    _unknown_ _t195;                       // _t195
    _unknown_ _t196;                       // _t196
    _unknown_ _t197;                       // _t197
    _unknown_ _t198;                       // _t198
    _unknown_ _t200;                       // _t200
    _unknown_ _t201;                       // _t201
    _unknown_ _t203;                       // _t203
    _unknown_ _t204;                       // _t204


}

camlHashtbl__add_1074(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    _unknown_ __ecx,                       // r2
    _unknown_ __esp                        // r7
)
{// addr = 0x08055FE0
    _unknown_ _v4;                         // _cfa_fffffffc
    _unknown_ _v8;                         // _cfa_fffffff8
    _unknown_ _v12;                        // _cfa_fffffff4
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _t95;                        // _t95
    _unknown_ _t97;                        // _t97
    _unknown_ _t98;                        // _t98
    _unknown_ _t99;                        // _t99
    _unknown_ _t101;                       // _t101
    _unknown_ _t104;                       // _t104
    _unknown_ _t105;                       // _t105
    _unknown_ _t108;                       // _t108
    _unknown_ _t110;                       // _t110
    _unknown_ _t111;                       // _t111
    _unknown_ _t112;                       // _t112
    _unknown_ _t117;                       // _t117
    _unknown_ _t122;                       // _t122
    _unknown_ _t123;                       // _t123
    _unknown_ _t125;                       // _t125
    _unknown_ _t126;                       // _t126
    _unknown_ _t133;                       // _t133
    _unknown_ _t134;                       // _t134
    _unknown_ _t140;                       // _t140
    _unknown_ _t141;                       // _t141
    _unknown_ _t144;                       // _t144
    _unknown_ _t147;                       // _t147
    _unknown_ _t151;                       // _t151
    _unknown_ _t152;                       // _t152
    _unknown_ _t153;                       // _t153
    _unknown_ _t155;                       // _t155
    _unknown_ _t157;                       // _t157
    _unknown_ _t158;                       // _t158
    _unknown_ _t162;                       // _t162
    _unknown_ _t163;                       // _t163
    _unknown_ _t169;                       // _t169
    _unknown_ _t170;                       // _t170
    _unknown_ _t171;                       // _t171
    _unknown_ _t175;                       // _t175
    _unknown_ _t176;                       // _t176
    _unknown_ _t177;                       // _t177
    _unknown_ _t183;                       // _t183
    _unknown_ _t185;                       // _t185
    _unknown_ _t188;                       // _t188
    _unknown_ _t190;                       // _t190
    _unknown_ _t192;                       // _t192
    _unknown_ _t193;                       // _t193
    _unknown_ _t194;                       // _t194
    _unknown_ _t196;                       // _t196
    _unknown_ _t197;                       // _t197
    _unknown_ _t199;                       // _t199
    _unknown_ _t200;                       // _t200


}

camlHashtbl__remove_1080(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx,                        // r1
    intOrPtr* __esp                        // r7
)
{// addr = 0x080560D0
    signed int _v4;                        // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _t36;                         // _t36
    _unknown_ _t39;                        // _t39
    intOrPtr _t40;                         // _t40
    intOrPtr _t43;                         // _t43
    intOrPtr _t45;                         // _t45
    intOrPtr* _t46;                        // _t46
    _unknown_ _t47;                        // _t47
    _unknown_ _t52;                        // _t52
    _unknown_ _t57;                        // _t57
    signed int _t58;                       // _t58
    _unknown_ _t60;                        // _t60
    intOrPtr* _t62;                        // _t62
    intOrPtr _t65;                         // _t65
    signed int _t70;                       // _t70
    signed int _t72;                       // _t72
    signed int _t74;                       // _t74
    _unknown_ _t75;                        // _t75

    __esp = __esp;
    __esp = __esp - 8;
    __edi = __eax;
    _t65 = __ebx;
    while(1) {
        _t36 = caml_young_ptr - 20;
        caml_young_ptr = _t36;
        if(_t36 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t62 = _t36 + 4;
     *((intOrPtr*)(_t62 - 4)) = 4343;
     *_t62 = camlHashtbl__remove_bucket_1083;
     *((intOrPtr*)(_t62 + 4)) = 3;
     *((intOrPtr*)(_t62 + 8)) = __edi;
     *((intOrPtr*)(_t62 + 12)) = _t65;
    _t74 =  *( *((intOrPtr*)(__edi + 4)) - 4) >> 10;
    if(_t74 == 0) {
        caml_raise_exn( &caml_bucket_Division_by_zero);
    } else {
        _t58 = caml_hash_univ_param(21, 201, _t65);
        asm("cdq ");
        _t70 = (_t58 >> 1) % _t74;
    }
    _t72 = (_t70 << 1) + 1;
    _v4 = _t72;
    _t40 =  *((intOrPtr*)(__edi + 4));
     *__esp = _t40;
    if( *(_t40 - 4) >> 9 <= _t72) {
L10:
        _t43 = caml_ml_array_bound_error();
        __esp = __esp - 12;
        while(_t62 != 1) {
             *__esp = _t43;
            _v16 =  *((intOrPtr*)(_t62 + 8));
            _v12 =  *((intOrPtr*)(_t62 + 4));
            caml_c_call(_t43,  *_t62);
            if(caml_compare != 1) {
                _t43 =  *__esp;
                _t62 = _v16;
                continue;
            }
            __esp = __esp + 12;
            return _v12;
L19:
        }
        while(1) {
            _t45 = caml_young_ptr - 8;
            caml_young_ptr = _t45;
            if(_t45 >= caml_young_limit) {
                _t46 = _t45 + 4;
                 *((intOrPtr*)(_t46 - 4)) = 1024;
                 *_t46 =  &caml_exn_Not_found;
                caml_raise_exn(_t46);
            }
            goto L18;
        }
    }
    _t68 =  *((intOrPtr*)(__edi + 4));
    if( *( *((intOrPtr*)(__edi + 4)) - 4) >> 9 <= _t72) {
        caml_ml_array_bound_error();
        goto L10;
    }
    caml_modify(_v8, _v8 + _v4 * 2 - 2, camlHashtbl__remove_bucket_1083( *((intOrPtr*)(_t68 + _t72 * 2 - 2)), _t62, __esp));
    __esp = __esp + 8;
    return 1;
    goto L19;
}

camlHashtbl__find_rec_1088(
    intOrPtr __eax,                        // r0
    intOrPtr* __ebx,                       // r1
    intOrPtr* __esp                        // r7
)
{// addr = 0x080561B0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _t9;                          // _t9
    intOrPtr _t11;                         // _t11
    intOrPtr* _t12;                        // _t12
    _unknown_ _t13;                        // _t13
    intOrPtr* _t16;                        // _t16

    __esp = __esp;
    _t16 = __ebx;
    _t9 = __eax;
    while(_t16 != 1) {
         *__esp = _t9;
        _v8 =  *((intOrPtr*)(_t16 + 8));
        _v4 =  *((intOrPtr*)(_t16 + 4));
        caml_c_call(_t9,  *_t16);
        if(caml_compare != 1) {
            _t9 =  *__esp;
            _t16 = _v8;
            continue;
        }
        return _v4;
        while(1) {
L5:
            _t11 = caml_young_ptr - 8;
            caml_young_ptr = _t11;
            if(_t11 >= caml_young_limit) {
                _t12 = _t11 + 4;
                 *((intOrPtr*)(_t12 - 4)) = 1024;
                 *_t12 =  &caml_exn_Not_found;
                caml_raise_exn(_t12);
            }
            goto L7;
        }
    }
    goto L5;
}

camlHashtbl__find_1093(
    _unknown_ __eax,                       // r0
    _unknown_ __esi                        // r5
)
{// addr = 0x08056240
    intOrPtr _v4;                          // _cfa_fffffffc
    unsigned int _v8;                      // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    unsigned int _v20;                     // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    unsigned int _v56;                     // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    signed int _v64;                       // _cfa_ffffffc0
    unsigned int* _v68;                    // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    unsigned int _v80;                     // _cfa_ffffffb0
    unsigned int _v84;                     // _cfa_ffffffac
    unsigned int _v88;                     // _cfa_ffffffa8
    unsigned int _v92;                     // _cfa_ffffffa4
    unsigned int _v96;                     // _cfa_ffffffa0
    unsigned int _v100;                    // _cfa_ffffff9c
    _unknown_ _t341;                       // _t341
    _unknown_ _t344;                       // _t344
    intOrPtr _t346;                        // _t346
    _unknown_ _t349;                       // _t349
    unsigned int _t352;                    // _t352
    intOrPtr _t354;                        // _t354
    _unknown_ _t357;                       // _t357
    _unknown_ _t360;                       // _t360
    intOrPtr _t362;                        // _t362
    _unknown_ _t365;                       // _t365
    intOrPtr _t368;                        // _t368
    intOrPtr _t370;                        // _t370
    signed int _t371;                      // _t371
    _unknown_ _t372;                       // _t372
    intOrPtr _t373;                        // _t373
    intOrPtr _t375;                        // _t375
    signed int _t376;                      // _t376
    _unknown_ _t377;                       // _t377
    intOrPtr _t378;                        // _t378
    intOrPtr _t383;                        // _t383
    intOrPtr* _t384;                       // _t384
    unsigned int* _t385;                   // _t385
    signed int _t388;                      // _t388
    _unknown_ _t390;                       // _t390
    signed int _t391;                      // _t391
    unsigned int _t392;                    // _t392
    _unknown_ _t393;                       // _t393
    _unknown_ _t396;                       // _t396
    signed int _t397;                      // _t397
    _unknown_ _t399;                       // _t399
    signed int _t400;                      // _t400
    intOrPtr* _t401;                       // _t401
    _unknown_ _t402;                       // _t402
    _unknown_ _t403;                       // _t403
    _unknown_ _t406;                       // _t406
    intOrPtr _t410;                        // _t410
    _unknown_ _t420;                       // _t420
    unsigned int _t421;                    // _t421
    signed int _t422;                      // _t422
    signed int _t428;                      // _t428
    _unknown_ _t429;                       // _t429
    intOrPtr _t432;                        // _t432
    signed int _t435;                      // _t435
    _unknown_ _t439;                       // _t439
    unsigned int _t440;                    // _t440
    _unknown_ _t443;                       // _t443
    intOrPtr _t445;                        // _t445
    signed int* _t446;                     // _t446
    unsigned int _t447;                    // _t447
    intOrPtr _t449;                        // _t449
    _unknown_ _t452;                       // _t452
    unsigned int _t453;                    // _t453
    unsigned int _t456;                    // _t456
    intOrPtr _t458;                        // _t458
    intOrPtr* _t459;                       // _t459
    _unknown_ _t460;                       // _t460
    _unknown_ _t462;                       // _t462
    _unknown_ _t465;                       // _t465
    _unknown_ _t470;                       // _t470
    signed int _t471;                      // _t471
    _unknown_ _t473;                       // _t473
    _unknown_ _t474;                       // _t474
    _unknown_ _t481;                       // _t481
    signed int _t482;                      // _t482
    _unknown_ _t484;                       // _t484
    _unknown_ _t486;                       // _t486
    signed int _t487;                      // _t487
    signed int _t488;                      // _t488
    _unknown_ _t490;                       // _t490
    _unknown_ _t491;                       // _t491
    intOrPtr _t496;                        // _t496
    signed int* _t497;                     // _t497
    signed int _t498;                      // _t498
    _unknown_ _t500;                       // _t500
    intOrPtr _t502;                        // _t502
    intOrPtr* _t503;                       // _t503
    _unknown_ _t504;                       // _t504
    unsigned int _t509;                    // _t509
    intOrPtr _t511;                        // _t511
    intOrPtr* _t512;                       // _t512
    _unknown_ _t513;                       // _t513
    unsigned int _t517;                    // _t517
    intOrPtr _t519;                        // _t519
    intOrPtr* _t520;                       // _t520
    _unknown_ _t521;                       // _t521
    _unknown_ _t525;                       // _t525
    _unknown_ _t526;                       // _t526
    _unknown_ _t527;                       // _t527
    unsigned int _t528;                    // _t528
    unsigned int _t529;                    // _t529
    signed int _t530;                      // _t530
    signed int _t534;                      // _t534
    unsigned int _t535;                    // _t535
    unsigned int* _t536;                   // _t536
    unsigned int _t537;                    // _t537
    intOrPtr _t538;                        // _t538
    signed int _t550;                      // _t550
    _unknown_ _t554;                       // _t554
    signed int _t555;                      // _t555
    signed int _t556;                      // _t556
    signed int _t559;                      // _t559
    unsigned int _t562;                    // _t562
    unsigned int _t563;                    // _t563
    _unknown_ _t570;                       // _t570
    unsigned int _t576;                    // _t576
    unsigned int _t577;                    // _t577
    signed int _t578;                      // _t578
    unsigned int _t579;                    // _t579
    intOrPtr _t580;                        // _t580
    unsigned int _t581;                    // _t581
    unsigned int _t583;                    // _t583
    intOrPtr _t587;                        // _t587
    unsigned int _t589;                    // _t589
    unsigned int _t590;                    // _t590
    unsigned int _t591;                    // _t591
    unsigned int _t592;                    // _t592
    unsigned int _t601;                    // _t601
    unsigned int _t603;                    // _t603
    intOrPtr _t604;                        // _t604
    unsigned int _t605;                    // _t605
    unsigned int _t616;                    // _t616
    intOrPtr* _t618;                       // _t618
    signed int _t619;                      // _t619
    signed int _t621;                      // _t621
    signed int _t623;                      // _t623
    signed int _t624;                      // _t624
    signed int _t626;                      // _t626
    signed int _t628;                      // _t628
    intOrPtr _t629;                        // _t629
    unsigned int _t630;                    // _t630
    intOrPtr* _t631;                       // _t631
    intOrPtr* _t634;                       // _t634
    unsigned int _t635;                    // _t635
    signed int _t639;                      // _t639
    _unknown_ _t640;                       // _t640
    _unknown_ _t641;                       // _t641
    _unknown_ _t642;                       // _t642
    unsigned int _t643;                    // _t643
    _unknown_ _t644;                       // _t644
    _unknown_ _t645;                       // _t645
    unsigned int _t647;                    // _t647
    unsigned int _t648;                    // _t648
    unsigned int _t649;                    // _t649
    _unknown_ _t650;                       // _t650
    _unknown_ _t653;                       // _t653
    signed int _t655;                      // _t655
    _unknown_ _t656;                       // _t656
    signed int _t658;                      // _t658
    signed int _t660;                      // _t660
    _unknown_ _t661;                       // _t661
    _unknown_ _t662;                       // _t662
    intOrPtr _t663;                        // _t663
    unsigned int _t664;                    // _t664
    _unknown_ _t665;                       // _t665
    unsigned int _t666;                    // _t666
    _unknown_ _t667;                       // _t667
    signed int _t668;                      // _t668
    _unknown_ _t669;                       // _t669
    _unknown_ _t671;                       // _t671
    signed int _t673;                      // _t673
    _unknown_ _t674;                       // _t674
    _unknown_ _t675;                       // _t675

    __esp = __esp - 12;
    _t640 = __eax;
    _t339 =  *(_t640 + 4);
    if( *( *(_t640 + 4) - 4) >> 10 == 0) {
        caml_raise_exn( &caml_bucket_Division_by_zero);
    } else {
        __eax = caml_hash_univ_param(21, 201, __ebx);
        __eax = __eax >> 1;
        __ecx = __esi;
        asm("cdq ");
        __eax = __eax / __esi;
    }
    _t621 = (_t619 << 1) + 1;
    _t576 =  *(_t640 + 4);
    if( *(_t576 - 4) >> 9 <= _t621) {
        _t344 = caml_ml_array_bound_error();
        _t642 = _t344;
        _t577 = _t528;
        while(1) {
L83:
            _t346 = caml_young_ptr - 16;
            caml_young_ptr = _t346;
            if(_t346 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t528 = _t346 + 4;
         *((intOrPtr*)(_t528 - 4)) = 3319;
         *_t528 = camlHashtbl__find_in_bucket_1108;
         *(_t528 + 4) = 3;
         *(_t528 + 8) = _t577;
        _t655 =  *( *(_t642 + 4) - 4) >> 10;
        if(_t655 == 0) {
            caml_raise_exn( &caml_bucket_Division_by_zero);
            _t655 = _t655;
        } else {
            _t498 = caml_hash_univ_param(21, 201, _t577);
            asm("cdq ");
            _t621 = (_t498 >> 1) % _t655;
        }
        _t623 = (_t621 << 1) + 1;
        _t578 =  *(_t642 + 4);
        if( *(_t578 - 4) >> 9 <= _t623) {
            _t352 = caml_ml_array_bound_error();
            __esp = __esp - 28;
            _t643 = _t352;
            while(1) {
                _t354 = caml_young_ptr - 20;
                caml_young_ptr = _t354;
                if(_t354 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t624 = _t354 + 4;
             *((intOrPtr*)(_t624 - 4)) = 4343;
             *_t624 = camlHashtbl__replace_bucket_1116;
             *(_t624 + 4) = 3;
             *(_t624 + 8) = _t528;
             *(_t624 + 12) = _t578;
            _t658 =  *( *(_t643 + 4) - 4) >> 10;
            if(_t658 == 0) {
                caml_raise_exn( &caml_bucket_Division_by_zero);
                _t658 = _t658;
            } else {
                _v24 = _t624;
                _v32 = _t578;
                _v36 = _t528;
                 *__esp = _t643;
                _t488 = caml_hash_univ_param(21, 201, _t528);
                asm("cdq ");
                _t624 = (_t488 >> 1) % _t658;
            }
            _t626 = (_t624 << 1) + 1;
            _v16 = _t626;
            _t529 =  *(_t643 + 4);
            if( *(_t529 - 4) >> 9 <= _t626) {
L110:
                _t360 = caml_ml_array_bound_error();
                _t644 = _t360;
                _t579 = _t529;
                while(1) {
                    _t362 = caml_young_ptr - 16;
                    caml_young_ptr = _t362;
                    if(_t362 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                _t530 = _t362 + 4;
                 *((intOrPtr*)(_t530 - 4)) = 3319;
                 *_t530 = camlHashtbl__mem_in_bucket_1125;
                 *(_t530 + 4) = 3;
                 *(_t530 + 8) = _t579;
                _t660 =  *( *((intOrPtr*)(_t644 + 4)) - 4) >> 10;
                if(_t660 == 0) {
                    caml_raise_exn( &caml_bucket_Division_by_zero);
                    _t660 = _t660;
                } else {
                    _t397 = caml_hash_univ_param(21, 201, _t579);
                    asm("cdq ");
                    _t626 = (_t397 >> 1) % _t660;
                }
                _t628 = (_t626 << 1) + 1;
                _t580 =  *((intOrPtr*)(_t644 + 4));
                if( *(_t580 - 4) >> 9 <= _t628) {
                    _t368 = caml_ml_array_bound_error();
                    __esp = __esp - 16;
                    _t629 = _t368;
                    while(1) {
                        _t370 = caml_young_ptr - 16;
                        caml_young_ptr = _t370;
                        if(_t370 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                    _t581 = _t370 + 4;
                     *((intOrPtr*)(_t581 - 4)) = 3319;
                     *_t581 = camlHashtbl__do_bucket_1132;
                     *(_t581 + 4) = 3;
                     *((intOrPtr*)(_t581 + 8)) = _t629;
                    _t630 =  *(_t530 + 4);
                    _t371 = 1;
                    _t534 = ( *(_t630 - 4) >> 9 | 1) + -2;
                    if(_t371 > _t534) {
L126:
                        __esp =  &((__esp)[4]);
                        return;
                    } else {
                        _v44 = _t534;
                        _v48 = _t371;
                         *__esp = _t630;
                        _v52 = _t581;
                        while(1) {
                            _t535 =  *__esp;
                            _t583 =  *(_t535 - 4) >> 9;
                            if(_t583 <= _t371) {
                                break;
                            }
                            camlHashtbl__do_bucket_1132( *((intOrPtr*)(_t535 + _t371 * 2 - 2)), _v52, __esp);
                            _t391 = _v48;
                            _t371 = _t391 + 2;
                            _v48 = _t371;
                            if(_t391 != _v44) {
                                continue;
                            } else {
                                goto L126;
                            }
                            goto L142;
                        }
                        _t373 = caml_ml_array_bound_error();
                        __esp = __esp - 20;
                        _t663 = _t373;
                        while(1) {
                            _t375 = caml_young_ptr - 28;
                            caml_young_ptr = _t375;
                            if(_t375 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                        _t631 = _t375 + 4;
                         *((intOrPtr*)(_t631 - 4)) = 4343;
                         *_t631 = caml_curry2;
                         *((intOrPtr*)(_t631 + 4)) = 5;
                         *((intOrPtr*)(_t631 + 8)) = camlHashtbl__do_bucket_1142;
                         *((intOrPtr*)(_t631 + 12)) = _t663;
                        _t664 =  *(_t535 + 4);
                        _t536 = _t631 + 20;
                         *((intOrPtr*)(_t536 - 4)) = 1024;
                         *_t536 = _t583;
                        _t376 = 1;
                        _t587 = ( *(_t664 - 4) >> 9 | 1) + -2;
                        if(_t376 > _t587) {
L135:
                            __esp =  &((__esp)[5]);
                            return;
                        } else {
                            _v60 = _t587;
                            _v64 = _t376;
                            _v68 = _t536;
                             *__esp = _t664;
                            _v72 = _t631;
                            while(1) {
                                _t537 =  *_t536;
                                _t588 =  *__esp;
                                if( *( *__esp - 4) >> 9 <= _t376) {
                                    break;
                                }
                                _push(camlHashtbl__do_bucket_1142( *((intOrPtr*)(_t588 + _t376 * 2 - 2)), _t537, _v72, __esp));
                                _t536 = _v68;
                                _push(_t536);
                                caml_modify(_t536);
                                __esp =  &((__esp)[2]);
                                _t388 = _v64;
                                _t376 = _t388 + 2;
                                _v64 = _t376;
                                if(_t388 != _v60) {
                                    continue;
                                } else {
                                    goto L135;
                                }
                                goto L142;
                            }
                            _t378 = caml_ml_array_bound_error();
                            __esp = __esp - 28;
                            _t538 = _t378;
                             *__esp = camlHashtbl;
                            _v100 =  *134689272;
                            _v96 =  *134689280;
                            while(1) {
                                _t383 = caml_young_ptr - 232;
                                caml_young_ptr = _t383;
                                if(_t383 >= caml_young_limit) {
                                    break;
                                }
                                caml_call_gc(__esp);
                            }
                            _t384 = _t383 + 4;
                             *((intOrPtr*)(_t384 - 4)) = 3319;
                             *_t384 = camlHashtbl__safehash_1177;
                             *(_t384 + 4) = 3;
                             *((intOrPtr*)(_t384 + 8)) = _t538;
                            _t589 = _t384 + 16;
                            _v92 = _t589;
                             *((intOrPtr*)(_t589 - 4)) = 4343;
                             *_t589 = caml_curry3;
                             *((intOrPtr*)(_t589 + 4)) = 7;
                             *((intOrPtr*)(_t589 + 8)) = camlHashtbl__add_1179;
                             *((intOrPtr*)(_t589 + 12)) = _t384;
                            _t590 = _t384 + 36;
                            _v88 = _t590;
                             *((intOrPtr*)(_t590 - 4)) = 5367;
                             *_t590 = caml_curry2;
                             *((intOrPtr*)(_t590 + 4)) = 5;
                             *((intOrPtr*)(_t590 + 8)) = camlHashtbl__remove_1185;
                             *((intOrPtr*)(_t590 + 12)) = _t538;
                             *((intOrPtr*)(_t590 + 16)) = _t384;
                            _t634 = _t384 + 60;
                             *((intOrPtr*)(_t634 - 4)) = 4343;
                             *_t634 = caml_curry2;
                             *((intOrPtr*)(_t634 + 4)) = 5;
                             *((intOrPtr*)(_t634 + 8)) = camlHashtbl__find_rec_1193;
                             *((intOrPtr*)(_t634 + 12)) = _t538;
                            _t591 = _t384 + 80;
                            _v84 = _t591;
                             *((intOrPtr*)(_t591 - 4)) = 6391;
                             *_t591 = caml_curry2;
                             *((intOrPtr*)(_t591 + 4)) = 5;
                             *((intOrPtr*)(_t591 + 8)) = camlHashtbl__find_1198;
                             *((intOrPtr*)(_t591 + 12)) = _t538;
                             *((intOrPtr*)(_t591 + 16)) = _t384;
                             *((intOrPtr*)(_t591 + 20)) = _t634;
                            _t666 = _t384 + 108;
                             *((intOrPtr*)(_t666 - 4)) = 5367;
                             *_t666 = caml_curry2;
                             *((intOrPtr*)(_t666 + 4)) = 5;
                             *((intOrPtr*)(_t666 + 8)) = camlHashtbl__find_all_1210;
                             *((intOrPtr*)(_t666 + 12)) = _t538;
                             *((intOrPtr*)(_t666 + 16)) = _t384;
                            _t635 = _t384 + 132;
                             *((intOrPtr*)(_t635 - 4)) = 5367;
                             *_t635 = caml_curry3;
                             *((intOrPtr*)(_t635 + 4)) = 7;
                             *((intOrPtr*)(_t635 + 8)) = camlHashtbl__replace_1217;
                             *((intOrPtr*)(_t635 + 12)) = _t538;
                             *((intOrPtr*)(_t635 + 16)) = _t384;
                            _t592 = _t384 + 156;
                             *((intOrPtr*)(_t592 - 4)) = 5367;
                             *_t592 = caml_curry2;
                             *((intOrPtr*)(_t592 + 4)) = 5;
                             *((intOrPtr*)(_t592 + 8)) = camlHashtbl__mem_1227;
                             *((intOrPtr*)(_t592 + 12)) = _t538;
                             *((intOrPtr*)(_t592 + 16)) = _t384;
                            _v80 =  *134689304;
                            _t385 = _t384 + 180;
                             *((intOrPtr*)(_t385 - 4)) = 12288;
                             *_t385 =  *__esp;
                            _t385[1] = _v100;
                            _t385[2] = _v96;
                            _t385[3] = _v92;
                            _t385[4] = _v88;
                            _t385[5] = _v84;
                            _t385[6] = _t666;
                            _t385[7] = _t635;
                            _t385[8] = _t592;
                            _t385[9] = _v80;
                            _t385[0xa] =  *134689308;
                            _t385[0xb] =  *134689312;
                            __esp =  &((__esp)[7]);
                            return;
                        }
                    }
                    goto L142;
                }
                _t392 =  *(_t580 + _t628 * 2 - 2);
                __esp = __esp - 8;
                while(_t392 != 1) {
                    _v44 = _t530;
                     *__esp =  *(_t392 + 8);
                    caml_c_call( *_t392,  *(_t530 + 8));
                    if(caml_compare != 1) {
                        _t392 =  *__esp;
                        _t530 = _v44;
                        continue;
                    }
                    __esp =  &((__esp)[2]);
                    return;
                    goto L142;
                }
                __esp =  &((__esp)[2]);
                return;
                goto L142;
            }
            _t400 =  *(_t529 + _t626 * 2 - 2);
            _v28 = _t400;
            L104();
            if( *_t400 !=  &caml_exn_Not_found) {
                _t401 = caml_raise_exn(_t400);
                _t647 = _t643;
                _push(caml_exception_pointer);
                caml_exception_pointer = __esp;
                _t550 =  *(_t647 + 4);
                _v16 = _t550;
                _t529 =  *(_t550 - 4) >> 9;
                if(_t529 <= _t626) {
                    caml_ml_array_bound_error();
L109:
                    caml_ml_array_bound_error();
                    goto L110;
                }
                camlHashtbl__replace_bucket_1116(_t401, _v20);
                caml_modify(_v16, _v16 + _v12 * 2 - 2, _t401);
                _pop(caml_exception_pointer);
                __esp =  &((__esp)[7]);
                return;
                goto L142;
            }
            _t529 =  *__esp;
            _t626 =  *(_t529 + 4);
            _t599 = _v16;
            if( *(_t626 - 4) >> 9 <= _v16) {
                goto L109;
            } else {
                while(1) {
                    _t410 = caml_young_ptr - 16;
                    caml_young_ptr = _t410;
                    if(_t410 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                _t668 = _t410 + 4;
                 *((intOrPtr*)(_t668 - 4)) = 3072;
                 *_t668 = _v36;
                 *(_t668 + 4) = _v32;
                 *(_t668 + 8) = _v28;
                caml_modify(_t529, _t626 + _t599 * 2 - 2, _t668);
                 *_t529 =  *_t529 + 2;
                if( *_t529 <= ( *( *(_t529 + 4) - 4) >> 9 | 1) + ( *( *(_t529 + 4) - 4) >> 9 | 1) - 1) {
                    __esp =  &((__esp)[7]);
                    return;
                } else {
                    _t421 =  *134689320;
                    __esp =  &((__esp)[7]);
                    while(1) {
                        __esp = __esp - 24;
                         *__esp = _t421;
                        _v20 = _t529;
                        _t422 =  *(_t529 + 4);
                        _v16 = _t422;
                        _v28 =  *(_t422 - 4) >> 9 | 1;
                        _t428 = camlPervasives__min_1022(3 + (( *(_t422 - 4) >> 9 | 1) >> 1) * 4, __esp);
                        _t555 = _v28;
                        if(_t428 == _t555) {
                            break;
                        }
                        _v32 = _t428;
                        _v28 = _t555;
                        caml_c_call(_t428, 1);
                        _t556 = caml_make_vect;
                        _v24 = caml_make_vect;
                        while(1) {
                            _t432 = caml_young_ptr - 24;
                            caml_young_ptr = _t432;
                            if(_t432 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                        _t601 = _t432 + 4;
                         *((intOrPtr*)(_t601 - 4)) = 5367;
                         *_t601 = camlHashtbl__insert_bucket_1068;
                         *(_t601 + 4) = 3;
                         *(_t601 + 8) =  *__esp;
                         *(_t601 + 12) = _v32;
                         *((intOrPtr*)(_t601 + 16)) = _t556;
                        _t435 = 1;
                        _t558 = _v28 + -2;
                        if(_t435 > _t558) {
L23:
                            caml_modify(_t558, _v20 + 4, _v24);
                            __esp =  &((__esp)[6]);
                            return;
                        } else {
                            _v28 = _t558;
                            _v32 = _t435;
                             *__esp = _t601;
                            while(1) {
                                _t559 = _v16;
                                _t603 =  *(_t559 - 4) >> 9;
                                if(_t603 <= _t435) {
                                    break;
                                }
                                camlHashtbl__insert_bucket_1068( *((intOrPtr*)(_t559 + _t435 * 2 - 2)),  *__esp, __esp);
                                _t487 = _v32;
                                _t435 = _t487 + 2;
                                _v32 = _t435;
                                _t558 = _v28;
                                if(_t487 != _v28) {
                                    continue;
                                } else {
                                    goto L23;
                                }
                                goto L142;
                            }
                            _t440 = caml_ml_array_bound_error();
                            __esp = __esp - 4;
                            _t648 = _t440;
                            _t668 =  *( *((intOrPtr*)(_t648 + 4)) - 4) >> 10;
                            if(_t668 == 0) {
                                caml_raise_exn( &caml_bucket_Division_by_zero);
                                _t668 = _t668;
                            } else {
                                 *__esp = _t603;
                                _t482 = caml_hash_univ_param(21, 201, _t559);
                                asm("cdq ");
                                _t626 = (_t482 >> 1) % _t668;
                            }
                            _t626 = (_t626 << 1) + 1;
                            while(1) {
                                _t445 = caml_young_ptr - 16;
                                caml_young_ptr = _t445;
                                if(_t445 >= caml_young_limit) {
                                    break;
                                }
                                caml_call_gc(__esp);
                            }
                            _t446 = _t445 + 4;
                             *((intOrPtr*)(_t446 - 4)) = 3072;
                             *_t446 = _t559;
                            _t446[1] =  *__esp;
                            _t604 =  *((intOrPtr*)(_t648 + 4));
                            _t562 =  *(_t604 - 4) >> 9;
                            if(_t562 <= _t626) {
L39:
                                _t447 = caml_ml_array_bound_error();
                                __esp = __esp - 8;
                                _t649 = _t447;
                                _t605 = _t562;
                                while(1) {
                                    _t449 = caml_young_ptr - 20;
                                    caml_young_ptr = _t449;
                                    if(_t449 >= caml_young_limit) {
                                        break;
                                    }
                                    caml_call_gc(__esp);
                                }
                                _t563 = _t449 + 4;
                                 *((intOrPtr*)(_t563 - 4)) = 4343;
                                 *_t563 = camlHashtbl__remove_bucket_1083;
                                 *(_t563 + 4) = 3;
                                 *(_t563 + 8) = _t649;
                                 *(_t563 + 12) = _t605;
                                _t673 =  *( *(_t649 + 4) - 4) >> 10;
                                if(_t673 == 0) {
                                    caml_raise_exn( &caml_bucket_Division_by_zero);
                                } else {
                                    _t471 = caml_hash_univ_param(21, 201, _t605);
                                    asm("cdq ");
                                    _t626 = (_t471 >> 1) % _t673;
                                }
                                _t639 = (_t626 << 1) + 1;
                                _v44 = _t639;
                                _t453 =  *(_t649 + 4);
                                 *__esp = _t453;
                                if( *(_t453 - 4) >> 9 <= _t639) {
L50:
                                    _t456 = caml_ml_array_bound_error();
                                    goto L51;
                                }
                                _t608 =  *(_t649 + 4);
                                if( *( *(_t649 + 4) - 4) >> 9 <= _t639) {
                                    caml_ml_array_bound_error();
                                    goto L50;
                                }
                                caml_modify(_v48, _v48 + _v44 * 2 - 2, camlHashtbl__remove_bucket_1083( *((intOrPtr*)(_t608 + _t639 * 2 - 2)), _t563, __esp));
                                __esp =  &((__esp)[2]);
                                return;
                                goto L142;
                            }
                            _t446[2] =  *(_t604 + _t626 * 2 - 2);
                            _t610 =  *((intOrPtr*)(_t648 + 4));
                            _t562 =  *( *((intOrPtr*)(_t648 + 4)) - 4) >> 9;
                            if(_t562 <= _t626) {
                                caml_ml_array_bound_error();
                                goto L39;
                            }
                            caml_modify(_t562, _t610 + _t626 * 2 - 2, _t446);
                             *_t648 =  *_t648 + 2;
                            if( *_t648 <= ( *( *((intOrPtr*)(_t648 + 4)) - 4) >> 9 | 1) + ( *( *((intOrPtr*)(_t648 + 4)) - 4) >> 9 | 1) - 1) {
                                __esp =  &((__esp)[1]);
                                return;
                            } else {
                                _t421 =  *134689320;
                                _t529 = _t648;
                                __esp =  &((__esp)[1]);
                                continue;
                            }
                        }
                        goto L142;
                    }
                    __esp =  &((__esp)[6]);
                    return;
                }
                goto L142;
            }
            goto L110;
        }
        _t339 =  *(_t578 + _t623 * 2 - 2);
        __esp = __esp - 12;
        while(_t339 != 1) {
            _v20 = _t528;
             *__esp =  *(_t339 + 8);
            _v16 =  *(_t339 + 4);
            caml_c_call( *_t339,  *(_t528 + 8));
            if(caml_compare != 1) {
                _t339 =  *__esp;
                _t528 = _v20;
                continue;
            }
            L1();
            _t616 =  *__esp;
            while(1) {
                _t496 = caml_young_ptr - 12;
                caml_young_ptr = _t496;
                if(_t496 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t497 = _t496 + 4;
             *((intOrPtr*)(_t497 - 4)) = 2048;
             *_t497 = _v16;
            _t497[1] = _t616;
            __esp =  &((__esp)[3]);
            return;
            goto L142;
        }
        __esp =  &((__esp)[3]);
        return;
    } else {
        _t618 =  *((intOrPtr*)(_t576 + _t621 * 2 - 2));
        if(_t618 == 1) {
            while(1) {
L76:
                _t502 = caml_young_ptr - 8;
                caml_young_ptr = _t502;
                if(_t502 >= caml_young_limit) {
                    _t503 = _t502 + 4;
                     *((intOrPtr*)(_t503 - 4)) = 1024;
                     *_t503 =  &caml_exn_Not_found;
                    caml_raise_exn(_t503);
                }
                caml_call_gc(__esp);
            }
        }
        _v8 = _t528;
         *__esp =  *(_t618 + 8);
        _v4 =  *((intOrPtr*)(_t618 + 4));
        caml_c_call(_t528,  *_t618);
        if(caml_compare != 1) {
            _t509 =  *__esp;
            if(_t509 == 1) {
                while(1) {
L74:
                    _t511 = caml_young_ptr - 8;
                    caml_young_ptr = _t511;
                    if(_t511 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                _t512 = _t511 + 4;
                 *((intOrPtr*)(_t512 - 4)) = 1024;
                 *_t512 =  &caml_exn_Not_found;
                caml_raise_exn(_t512);
                goto L76;
            }
             *__esp =  *(_t509 + 8);
            _v4 =  *((intOrPtr*)(_t509 + 4));
            caml_c_call(_v8,  *_t509);
            if(caml_compare != 1) {
                _t517 =  *__esp;
                if(_t517 == 1) {
                    while(1) {
                        _t519 = caml_young_ptr - 8;
                        caml_young_ptr = _t519;
                        if(_t519 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                    _t520 = _t519 + 4;
                     *((intOrPtr*)(_t520 - 4)) = 1024;
                     *_t520 =  &caml_exn_Not_found;
                    caml_raise_exn(_t520);
                    asm("o16 nop ");
                    goto L74;
                }
                 *__esp =  *(_t517 + 8);
                _v4 =  *((intOrPtr*)(_t517 + 4));
                caml_c_call(_v8,  *_t517);
                if(caml_compare != 1) {
                    _t456 = _v8;
                    _t563 =  *__esp;
                    __esp =  &((__esp)[3]);
L51:
                    __esp = __esp - 12;
                    while(_t563 != 1) {
                         *__esp = _t456;
                        _v56 =  *(_t563 + 8);
                        _v52 =  *(_t563 + 4);
                        caml_c_call(_t456,  *_t563);
                        if(caml_compare != 1) {
                            _t456 =  *__esp;
                            _t563 = _v56;
                            continue;
                        }
                        __esp =  &((__esp)[3]);
                        return;
                        goto L142;
                    }
                    while(1) {
                        _t458 = caml_young_ptr - 8;
                        caml_young_ptr = _t458;
                        if(_t458 >= caml_young_limit) {
                            _t459 = _t458 + 4;
                             *((intOrPtr*)(_t459 - 4)) = 1024;
                             *_t459 =  &caml_exn_Not_found;
                            caml_raise_exn(_t459);
                        }
                        caml_call_gc(__esp);
                    }
                } else {
                    __esp =  &((__esp)[3]);
                    return;
                }
L142:
            }
            __esp =  &((__esp)[3]);
            return;
            goto L142;
        }
        __esp =  &((__esp)[3]);
        return;
    }
}

camlHashtbl__find_all_1105(
    unsigned int __eax,                    // r0
    signed int __esi                       // r5
)
{// addr = 0x08056410
    signed int _v0;                        // _cfa_0
    unsigned int _v4;                      // _cfa_fffffffc
    unsigned int _v8;                      // _cfa_fffffff8
    unsigned int _v12;                     // _cfa_fffffff4
    unsigned int _v16;                     // _cfa_fffffff0
    unsigned int _v20;                     // _cfa_ffffffec
    unsigned int _v24;                     // _cfa_ffffffe8
    signed int _v32;                       // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    unsigned int _v56;                     // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    unsigned int _v68;                     // _cfa_ffffffbc
    unsigned int _v72;                     // _cfa_ffffffb8
    unsigned int _v76;                     // _cfa_ffffffb4
    unsigned int _v80;                     // _cfa_ffffffb0
    unsigned int _v84;                     // _cfa_ffffffac
    unsigned int _v88;                     // _cfa_ffffffa8
    unsigned int _t302;                    // _t302
    _unknown_ _t303;                       // _t303
    unsigned int _t308;                    // _t308
    unsigned int* _t309;                   // _t309
    unsigned int _t310;                    // _t310
    _unknown_ _t311;                       // _t311
    _unknown_ _t313;                       // _t313
    unsigned int _t316;                    // _t316

    __esi = __esi;
    _t302 = __eax;
    __edi = _t302;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 16;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    __ebx = __eax + 4;
     *(__ebx - 4) = 3319;
     *__ebx = camlHashtbl__find_in_bucket_1108;
     *(__ebx + 4) = 3;
     *(__ebx + 8) = __ecx;
    __eax =  *(__edi + 4);
    __esi =  *(__eax - 4);
    __esi =  *(__eax - 4) >> 10;
    if(__esi == 0) {
         ?_? ( &caml_bucket_Division_by_zero) = caml_raise_exn( &caml_bucket_Division_by_zero);
        __esi = __esi;
    } else {
        __eax = caml_hash_univ_param(21, 201, __ecx);
        __eax = __eax >> 1;
        __ecx = __esi;
        asm("cdq ");
        _t114 = __eax % __ecx;
        __eax = __eax / __ecx;
        __edx = _t114;
    }
    __edx = __edx << 1;
    __edx = __edx + 1;
    __ecx =  *(__edi + 4);
     *(__ecx - 4) =  *(__ecx - 4) >> 9;
    if( *(__ecx - 4) >> 9 <= __edx) {
        __eax = caml_ml_array_bound_error();
        __esi = __esi;
        __esp = __esp - 28;
        __edi = __eax;
        while(1) {
            __eax = caml_young_ptr;
            __eax = caml_young_ptr - 20;
            caml_young_ptr = __eax;
            if(__eax >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        __edx = __eax + 4;
         *(__edx - 4) = 4343;
         *__edx = camlHashtbl__replace_bucket_1116;
         *(__edx + 4) = 3;
         *(__edx + 8) = __ebx;
         *(__edx + 12) = __ecx;
        __eax =  *(__edi + 4);
        __esi =  *(__eax - 4);
        __esi =  *(__eax - 4) >> 10;
        if(__esi == 0) {
             ?_? ( &caml_bucket_Division_by_zero) = caml_raise_exn( &caml_bucket_Division_by_zero);
            __esi = __esi;
        } else {
            _v12 = __edx;
            _v20 = __ecx;
            _v24 = __ebx;
             *__esp = __edi;
            __eax = caml_hash_univ_param(21, 201, __ebx);
            __eax = __eax >> 1;
            __ecx = __esi;
            asm("cdq ");
            _t135 = __eax % __ecx;
            __eax = __eax / __ecx;
            __edx = _t135;
        }
        __edx = __edx << 1;
        __edx = __edx + 1;
        _v4 = __edx;
        __ebx =  *(__edi + 4);
         *(__ebx - 4) =  *(__ebx - 4) >> 9;
        if( *(__ebx - 4) >> 9 <= __edx) {
L86:
            __eax = caml_ml_array_bound_error();
            __edi = __eax;
            __ecx = __ebx;
            while(1) {
                __eax = caml_young_ptr;
                __eax = caml_young_ptr - 16;
                caml_young_ptr = __eax;
                if(__eax >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            __ebx = __eax + 4;
             *(__ebx - 4) = 3319;
             *__ebx = camlHashtbl__mem_in_bucket_1125;
             *(__ebx + 4) = 3;
             *(__ebx + 8) = __ecx;
            __eax =  *(__edi + 4);
            __esi =  *(__eax - 4);
            __esi =  *(__eax - 4) >> 10;
            if(__esi == 0) {
                 ?_? ( &caml_bucket_Division_by_zero) = caml_raise_exn( &caml_bucket_Division_by_zero);
                __esi = __esi;
            } else {
                __eax = caml_hash_univ_param(21, 201, __ecx);
                __eax = __eax >> 1;
                __ecx = __esi;
                asm("cdq ");
                _t181 = __eax % __ecx;
                __eax = __eax / __ecx;
                __edx = _t181;
            }
            __edx = __edx << 1;
            __edx = __edx + 1;
            __ecx =  *(__edi + 4);
             *(__ecx - 4) =  *(__ecx - 4) >> 9;
            if( *(__ecx - 4) >> 9 <= __edx) {
                __eax = caml_ml_array_bound_error();
                __esi = __esi;
                __esp = __esp - 16;
                __edx = __eax;
                while(1) {
                    __eax = caml_young_ptr;
                    __eax = caml_young_ptr - 16;
                    caml_young_ptr = __eax;
                    if(__eax >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                __ecx = __eax + 4;
                 *(__ecx - 4) = 3319;
                 *__ecx = camlHashtbl__do_bucket_1132;
                 *(__ecx + 4) = 3;
                 *(__ecx + 8) = __edx;
                __edx =  *(__ebx + 4);
                __eax = 1;
                 *(__edx - 4) =  *(__edx - 4) >> 9;
                __ebx =  *(__edx - 4) >> 9 | 1;
                __ebx = ( *(__edx - 4) >> 9 | 1) + -2;
                if(__eax > __ebx) {
L102:
                    __eax = 1;
                    __esp =  &((__esp)[4]);
                    return;
                } else {
                    _v32 = __ebx;
                    _v36 = __eax;
                     *__esp = __edx;
                    _v40 = __ecx;
                    while(1) {
                        __ebx =  *__esp;
                         *(__ebx - 4) =  *(__ebx - 4) >> 9;
                        if( *(__ebx - 4) >> 9 <= __eax) {
                            break;
                        }
                        __eax =  *(__ebx + __eax * 2 - 2);
                        __ebx = _v40;
                        __eax = camlHashtbl__do_bucket_1132(__eax, _v40, __esp);
                        __eax = _v36;
                        __ecx = __eax;
                        __eax = __eax + 2;
                        _v36 = __eax;
                        __ebx = _v32;
                        if(__ecx != _v32) {
                            continue;
                        } else {
                            goto L102;
                        }
                        goto L118;
                    }
                    __eax = caml_ml_array_bound_error();
                    __esi = __esi;
                    __edi = __edi;
                    __esp = __esp - 20;
                    __esi = __eax;
                    while(1) {
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 28;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                    __edx = __eax + 4;
                     *(__edx - 4) = 4343;
                     *__edx = caml_curry2;
                     *(__edx + 4) = 5;
                     *(__edx + 8) = camlHashtbl__do_bucket_1142;
                     *(__edx + 12) = __esi;
                    __esi =  *(__ebx + 4);
                    __ebx = __edx + 20;
                     *(__ebx - 4) = 1024;
                     *__ebx = __ecx;
                    __eax = 1;
                     *(__esi - 4) =  *(__esi - 4) >> 9;
                    __ecx =  *(__esi - 4) >> 9 | 1;
                    __ecx = ( *(__esi - 4) >> 9 | 1) + -2;
                    if(__eax > __ecx) {
L111:
                        __eax =  *__ebx;
                        __esp =  &((__esp)[5]);
                        return;
                    } else {
                        _v48 = __ecx;
                        _v52 = __eax;
                        _v56 = __ebx;
                         *__esp = __esi;
                        _v60 = __edx;
                        while(1) {
                            __ebx =  *__ebx;
                            __ecx =  *__esp;
                             *(__ecx - 4) =  *(__ecx - 4) >> 9;
                            if( *(__ecx - 4) >> 9 <= __eax) {
                                break;
                            }
                            __eax =  *(__ecx + __eax * 2 - 2);
                            __ecx = _v60;
                            _push(__eax);
                            __ebx = _v56;
                            _push(__ebx);
                            caml_modify(__ebx);
                            __esp =  &((__esp)[2]);
                            __eax = _v52;
                            __edx = __eax;
                            __eax = __eax + 2;
                            _v52 = __eax;
                            __ecx = _v48;
                            if(__edx != _v48) {
                                continue;
                            } else {
                                goto L111;
                            }
                            goto L118;
                        }
                        __eax = caml_ml_array_bound_error();
                        __esi = __esi;
                        __esp = __esp - 28;
                        __ebx = __eax;
                        __eax = camlHashtbl;
                         *__esp = camlHashtbl;
                        __eax =  *134689272;
                        _v88 =  *134689272;
                        __eax =  *134689280;
                        _v84 =  *134689280;
                        while(1) {
                            __eax = caml_young_ptr;
                            __eax = caml_young_ptr - 232;
                            caml_young_ptr = __eax;
                            if(__eax >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                        __eax = __eax + 4;
                         *(__eax - 4) = 3319;
                         *__eax = camlHashtbl__safehash_1177;
                         *(__eax + 4) = 3;
                         *(__eax + 8) = __ebx;
                        __ecx = __eax + 16;
                        _v80 = __ecx;
                         *(__ecx - 4) = 4343;
                         *__ecx = caml_curry3;
                         *(__ecx + 4) = 7;
                         *(__ecx + 8) = camlHashtbl__add_1179;
                         *(__ecx + 12) = __eax;
                        __ecx = __eax + 36;
                        _v76 = __ecx;
                         *(__ecx - 4) = 5367;
                         *__ecx = caml_curry2;
                         *(__ecx + 4) = 5;
                         *(__ecx + 8) = camlHashtbl__remove_1185;
                         *(__ecx + 12) = __ebx;
                         *(__ecx + 16) = __eax;
                        __edx = __eax + 60;
                         *(__edx - 4) = 4343;
                         *__edx = caml_curry2;
                         *(__edx + 4) = 5;
                         *(__edx + 8) = camlHashtbl__find_rec_1193;
                         *(__edx + 12) = __ebx;
                        __ecx = __eax + 80;
                        _v72 = __ecx;
                         *(__ecx - 4) = 6391;
                         *__ecx = caml_curry2;
                         *(__ecx + 4) = 5;
                         *(__ecx + 8) = camlHashtbl__find_1198;
                         *(__ecx + 12) = __ebx;
                         *(__ecx + 16) = __eax;
                         *(__ecx + 20) = __edx;
                        __esi = __eax + 108;
                         *(__esi - 4) = 5367;
                         *__esi = caml_curry2;
                         *(__esi + 4) = 5;
                         *(__esi + 8) = camlHashtbl__find_all_1210;
                         *(__esi + 12) = __ebx;
                         *(__esi + 16) = __eax;
                        __edx = __eax + 132;
                         *(__edx - 4) = 5367;
                         *__edx = caml_curry3;
                         *(__edx + 4) = 7;
                         *(__edx + 8) = camlHashtbl__replace_1217;
                         *(__edx + 12) = __ebx;
                         *(__edx + 16) = __eax;
                        __ecx = __eax + 156;
                         *(__ecx - 4) = 5367;
                         *__ecx = caml_curry2;
                         *(__ecx + 4) = 5;
                         *(__ecx + 8) = camlHashtbl__mem_1227;
                         *(__ecx + 12) = __ebx;
                         *(__ecx + 16) = __eax;
                        __ebx =  *134689304;
                        _v68 =  *134689304;
                        __edi =  *134689312;
                        __eax = __eax + 180;
                         *(__eax - 4) = 12288;
                        __ebx =  *__esp;
                         *__eax =  *__esp;
                        __ebx = _v88;
                         *(__eax + 4) = _v88;
                        __ebx = _v84;
                         *(__eax + 8) = _v84;
                        __ebx = _v80;
                         *(__eax + 12) = _v80;
                        __ebx = _v76;
                         *(__eax + 16) = _v76;
                        __ebx = _v72;
                         *(__eax + 20) = _v72;
                         *(__eax + 24) = __esi;
                         *(__eax + 28) = __edx;
                         *(__eax + 32) = __ecx;
                        __ebx = _v68;
                         *(__eax + 36) = _v68;
                         *((intOrPtr*)(__eax + 40)) =  *134689308;
                         *(__eax + 44) =  *134689312;
                        __esp =  &((__esp)[7]);
                        return;
                    }
                }
L118:
            }
            __eax =  *(__ecx + __edx * 2 - 2);
            __esp = __esp - 8;
            while(__eax != 1) {
                _v32 = __ebx;
                __ecx =  *(__eax + 8);
                 *__esp =  *(__eax + 8);
                __eax =  *__eax;
                _push( *(__ebx + 8));
                _push(__eax);
                __eax = caml_compare;
                caml_c_call();
                __esp =  &((__esp)[2]);
                if(caml_compare != 1) {
                    __eax =  *__esp;
                    __ebx = _v32;
                    continue;
                }
                __eax = 3;
                __esp =  &((__esp)[2]);
                return;
                goto L118;
            }
            __eax = 1;
            __esp =  &((__esp)[2]);
            return;
            goto L118;
        }
        __eax =  *(__ebx + __edx * 2 - 2);
        _v16 = __eax;
        L80();
        __ecx =  ?_? ( &caml_exn_Not_found);
        __ebx =  *__eax;
        if( *__eax !=  &caml_exn_Not_found) {
            __eax = caml_raise_exn(__eax);
            __esi = __esi;
            __edi = __edi;
            _push(caml_exception_pointer);
            caml_exception_pointer = __esp;
            __ebx =  *(__edi + 4);
            _v4 = __ebx;
            __ebx =  *(__ebx - 4);
            __ebx = __ebx >> 9;
            if(__ebx <= __edx) {
                __eax = caml_ml_array_bound_error();
L85:
                __eax = caml_ml_array_bound_error();
                goto L86;
            }
            __ebx = _v8;
            camlHashtbl__replace_bucket_1116(__eax, _v8);
            _push(__eax);
            __ebx = _v4;
            __eax = _v0;
            __eax = __ebx + _v0 * 2 - 2;
            _push(__ebx + _v0 * 2 - 2);
            caml_modify(__ebx);
            __esp =  &((__esp)[2]);
            __eax = 1;
            _pop(caml_exception_pointer);
            __esp =  &((__esp)[7]);
            return;
            goto L118;
        }
        __ebx =  *__esp;
        __edx =  *(__ebx + 4);
         *(__edx - 4) =  *(__edx - 4) >> 9;
        __ecx = _v4;
        if( *(__edx - 4) >> 9 <= __ecx) {
            goto L85;
        } else {
            while(1) {
                __eax = caml_young_ptr;
                __eax = caml_young_ptr - 16;
                caml_young_ptr = __eax;
                if(__eax >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            __esi = __eax + 4;
             *(__esi - 4) = 3072;
            __eax = _v24;
             *__esi = _v24;
            __eax = _v20;
             *(__esi + 4) = _v20;
            __eax = _v16;
             *(__esi + 8) = _v16;
            _push(__esi);
            __eax = __edx + __ecx * 2 - 2;
            _push(__edx + __ecx * 2 - 2);
            caml_modify(__ebx);
            __esp =  &((__esp)[2]);
             *__ebx =  *__ebx + 2;
            __eax =  *(__ebx + 4);
            __eax =  *( *(__ebx + 4) - 4);
            __eax =  *( *(__ebx + 4) - 4) >> 9;
            __ecx = ( *( *(__ebx + 4) - 4) >> 9 | 1) + ( *( *(__ebx + 4) - 4) >> 9 | 1) - 1;
            __eax =  *__ebx;
            if( *__ebx <= __ecx) {
                __eax = 1;
                __esp =  &((__esp)[7]);
                return;
            } else {
                __eax =  *134689320;
                __esp =  &((__esp)[7]);
                while(1) {
                    __esp = __esp - 24;
                     *__esp = __eax;
                    _v8 = __ebx;
                    __eax =  *(__ebx + 4);
                    _v4 = __eax;
                    __eax =  *(__eax - 4);
                    __eax = __eax >> 9;
                    __eax = __eax | 1;
                    _v16 = __eax;
                    __ebx =  *134688936;
                    __eax = __eax >> 1;
                    __eax = 3 + __eax * 4;
                    __eax = camlPervasives__min_1022(__eax, __esp);
                    __ebx = _v16;
                    if(__eax == __ebx) {
                        break;
                    }
                    _v20 = __eax;
                    _v16 = __ebx;
                    _push(1);
                    _push(__eax);
                    __eax = caml_make_vect;
                    caml_c_call();
                    __esp =  &((__esp)[2]);
                    __ebx = caml_make_vect;
                    _v12 = caml_make_vect;
                    while(1) {
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 24;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                    __ecx = __eax + 4;
                     *(__ecx - 4) = 5367;
                     *__ecx = camlHashtbl__insert_bucket_1068;
                     *(__ecx + 4) = 3;
                    __eax =  *__esp;
                     *(__ecx + 8) =  *__esp;
                    __eax = _v20;
                     *(__ecx + 12) = _v20;
                     *(__ecx + 16) = __ebx;
                    __eax = 1;
                    __ebx = _v16;
                    __ebx = _v16 + -2;
                    if(__eax > __ebx) {
L23:
                        __eax = _v12;
                        _push(_v12);
                        _v8 = _v8 + 4;
                        _push(_v8 + 4);
                        caml_modify(__ebx);
                        __esp =  &((__esp)[2]);
                        __eax = 1;
                        __esp =  &((__esp)[6]);
                        return;
                    } else {
                        _v16 = __ebx;
                        _v20 = __eax;
                         *__esp = __ecx;
                        while(1) {
                            __ebx = _v4;
                             *(__ebx - 4) =  *(__ebx - 4) >> 9;
                            if( *(__ebx - 4) >> 9 <= __eax) {
                                break;
                            }
                            __eax =  *(__ebx + __eax * 2 - 2);
                            __ebx =  *__esp;
                            __eax = camlHashtbl__insert_bucket_1068(__eax,  *__esp, __esp);
                            __eax = _v20;
                            __ecx = __eax;
                            __eax = __eax + 2;
                            _v20 = __eax;
                            __ebx = _v16;
                            if(__ecx != __ebx) {
                                continue;
                            } else {
                                goto L23;
                            }
                            goto L118;
                        }
                        __eax = caml_ml_array_bound_error();
                        __esi = __esi;
                        __esp = __esp - 4;
                        __edi = __eax;
                        __eax =  *(__edi + 4);
                        __esi =  *(__eax - 4);
                        __esi =  *(__eax - 4) >> 10;
                        if(__esi == 0) {
                             ?_? ( &caml_bucket_Division_by_zero) = caml_raise_exn( &caml_bucket_Division_by_zero);
                            __esi = __esi;
                        } else {
                             *__esp = __ecx;
                            __eax = caml_hash_univ_param(21, 201, __ebx);
                            __eax = __eax >> 1;
                            __ecx = __esi;
                            asm("cdq ");
                            _t51 = __eax % __ecx;
                            __eax = __eax / __ecx;
                            __edx = _t51;
                        }
                        __edx = __edx << 1;
                        __edx = __edx + 1;
                        while(1) {
                            __eax = caml_young_ptr;
                            __eax = caml_young_ptr - 16;
                            caml_young_ptr = __eax;
                            if(__eax >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                        __eax = __eax + 4;
                         *(__eax - 4) = 3072;
                         *__eax = __ebx;
                        __ebx =  *__esp;
                         *(__eax + 4) =  *__esp;
                        __ecx =  *(__edi + 4);
                        __ebx =  *(__ecx - 4);
                        __ebx =  *(__ecx - 4) >> 9;
                        if(__ebx <= __edx) {
L39:
                            __eax = caml_ml_array_bound_error();
                            __esi = __esi;
                            __esp = __esp - 8;
                            __edi = __eax;
                            __ecx = __ebx;
                            while(1) {
                                __eax = caml_young_ptr;
                                __eax = caml_young_ptr - 20;
                                caml_young_ptr = __eax;
                                if(__eax >= caml_young_limit) {
                                    break;
                                }
                                caml_call_gc(__esp);
                            }
                            __ebx = __eax + 4;
                             *(__ebx - 4) = 4343;
                             *__ebx = camlHashtbl__remove_bucket_1083;
                             *(__ebx + 4) = 3;
                             *(__ebx + 8) = __edi;
                             *(__ebx + 12) = __ecx;
                            __eax =  *(__edi + 4);
                            __esi =  *(__eax - 4);
                            __esi =  *(__eax - 4) >> 10;
                            if(__esi == 0) {
                                 ?_? ( &caml_bucket_Division_by_zero) = caml_raise_exn( &caml_bucket_Division_by_zero);
                                __esi = __esi;
                            } else {
                                __eax = caml_hash_univ_param(21, 201, __ecx);
                                __eax = __eax >> 1;
                                __ecx = __esi;
                                asm("cdq ");
                                _t82 = __eax % __ecx;
                                __eax = __eax / __ecx;
                                __edx = _t82;
                            }
                            __edx = __edx << 1;
                            __edx = __edx + 1;
                            _v32 = __edx;
                            __eax =  *(__edi + 4);
                             *__esp = __eax;
                            __eax =  *(__eax - 4);
                            if(__eax <= __edx) {
L50:
                                __eax = caml_ml_array_bound_error();
                                __esp = __esp - 12;
                                while(__ebx != 1) {
                                     *__esp = __eax;
                                    __ecx =  *(__ebx + 8);
                                    _v44 =  *(__ebx + 8);
                                    __ecx =  *(__ebx + 4);
                                    _v40 =  *(__ebx + 4);
                                    _push(__ebx);
                                    _push(__eax);
                                    __eax = caml_compare;
                                    caml_c_call();
                                    __esp =  &((__esp)[2]);
                                    if(caml_compare != 1) {
                                        __eax =  *__esp;
                                        __ebx = _v44;
                                        continue;
                                    }
                                    __eax = _v40;
                                    __esp =  &((__esp)[3]);
                                    return;
                                    goto L118;
                                }
                                while(1) {
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 8;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        __eax = __eax + 4;
                                         *(__eax - 4) = 1024;
                                         *__eax =  &caml_exn_Not_found;
                                        __eax = caml_raise_exn(__eax);
                                    }
                                    caml_call_gc(__esp);
                                }
                            }
                            __ecx =  *(__edi + 4);
                             *(__ecx - 4) =  *(__ecx - 4) >> 9;
                            if( *(__ecx - 4) >> 9 <= __edx) {
                                __eax = caml_ml_array_bound_error();
                                goto L50;
                            }
                            __eax =  *(__ecx + __edx * 2 - 2);
                            _push(camlHashtbl__remove_bucket_1083( *(__ecx + __edx * 2 - 2), __ebx, __esp));
                            __ebx = _v36;
                            __eax = _v32;
                            __eax = __ebx + _v32 * 2 - 2;
                            _push(__ebx + _v32 * 2 - 2);
                            caml_modify(__ebx);
                            __esp =  &((__esp)[2]);
                            __eax = 1;
                            __esp =  &((__esp)[2]);
                            return;
                            goto L118;
                        }
                        __ebx =  *(__ecx + __edx * 2 - 2);
                         *(__eax + 8) =  *(__ecx + __edx * 2 - 2);
                        __ecx =  *(__edi + 4);
                        __ebx =  *(__ecx - 4);
                        __ebx =  *(__ecx - 4) >> 9;
                        if(__ebx <= __edx) {
                            __eax = caml_ml_array_bound_error();
                            goto L39;
                        }
                        _push(__eax);
                        __eax = __ecx + __edx * 2 - 2;
                        _push(__ecx + __edx * 2 - 2);
                        caml_modify(__ebx);
                        __esp =  &((__esp)[2]);
                         *__edi =  *__edi + 2;
                        __eax =  *(__edi + 4);
                        __eax =  *( *(__edi + 4) - 4);
                        __eax =  *( *(__edi + 4) - 4) >> 9;
                        __ebx = ( *( *(__edi + 4) - 4) >> 9 | 1) + ( *( *(__edi + 4) - 4) >> 9 | 1) - 1;
                        __eax =  *__edi;
                        if( *__edi <= __ebx) {
                            __eax = 1;
                            __esp =  &((__esp)[1]);
                            return;
                        } else {
                            __eax =  *134689320;
                            __ebx = __edi;
                            __esp =  &((__esp)[1]);
                            continue;
                        }
                    }
                    goto L118;
                }
                __eax = 1;
                __esp =  &((__esp)[6]);
                return;
            }
            goto L118;
        }
        goto L86;
    }
    __eax =  *(__ecx + __edx * 2 - 2);
    __esp = __esp - 12;
    while(_t302 != 1) {
        _v8 = _t310;
         *__esp =  *(_t302 + 8);
        _v4 =  *(_t302 + 4);
        caml_c_call( *_t302,  *((intOrPtr*)(_t310 + 8)));
        if(caml_compare != 1) {
            _t302 =  *__esp;
            _t310 = _v8;
            continue;
        }
        L1();
        _t316 =  *__esp;
        while(1) {
            _t308 = caml_young_ptr - 12;
            caml_young_ptr = _t308;
            if(_t308 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t309 = _t308 + 4;
         *((intOrPtr*)(_t309 - 4)) = 2048;
         *_t309 = _v4;
        _t309[1] = _t316;
        __esp =  &((__esp)[3]);
        return;
        goto L118;
    }
    __esp =  &((__esp)[3]);
    return;
    goto L118;
}

camlHashtbl__replace_1112(
    unsigned int __eax,                    // r0
    signed int __esi                       // r5
)
{// addr = 0x080564B0
    signed int _v0;                        // _cfa_0
    unsigned int _v4;                      // _cfa_fffffffc
    unsigned int _v8;                      // _cfa_fffffff8
    unsigned int _v12;                     // _cfa_fffffff4
    unsigned int _v16;                     // _cfa_fffffff0
    unsigned int _v20;                     // _cfa_ffffffec
    unsigned int _v24;                     // _cfa_ffffffe8
    signed int _v32;                       // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    unsigned int _v56;                     // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    unsigned int _v68;                     // _cfa_ffffffbc
    unsigned int _v72;                     // _cfa_ffffffb8
    unsigned int _v76;                     // _cfa_ffffffb4
    unsigned int _v80;                     // _cfa_ffffffb0
    unsigned int _v84;                     // _cfa_ffffffac
    unsigned int _v88;                     // _cfa_ffffffa8
    unsigned int _t274;                    // _t274
    _unknown_ _t275;                       // _t275
    _unknown_ _t278;                       // _t278

    __esi = __esi;
    _t274 = __eax;
    __esp = __esp - 28;
    __edi = _t274;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 20;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    __edx = __eax + 4;
     *(__edx - 4) = 4343;
     *__edx = camlHashtbl__replace_bucket_1116;
     *(__edx + 4) = 3;
     *(__edx + 8) = __ebx;
     *(__edx + 12) = __ecx;
    __eax =  *(__edi + 4);
    __esi =  *(__eax - 4);
    __esi =  *(__eax - 4) >> 10;
    if(__esi == 0) {
         ?_? ( &caml_bucket_Division_by_zero) = caml_raise_exn( &caml_bucket_Division_by_zero);
        __esi = __esi;
    } else {
        _v12 = __edx;
        _v20 = __ecx;
        _v24 = __ebx;
         *__esp = __edi;
        __eax = caml_hash_univ_param(21, 201, __ebx);
        __eax = __eax >> 1;
        __ecx = __esi;
        asm("cdq ");
        _t107 = __eax % __ecx;
        __eax = __eax / __ecx;
        __edx = _t107;
    }
    __edx = __edx << 1;
    __edx = __edx + 1;
    _v4 = __edx;
    __ebx =  *(__edi + 4);
     *(__ebx - 4) =  *(__ebx - 4) >> 9;
    if( *(__ebx - 4) >> 9 <= __edx) {
L68:
        __eax = caml_ml_array_bound_error();
        __edi = __eax;
        __ecx = __ebx;
        while(1) {
            __eax = caml_young_ptr;
            __eax = caml_young_ptr - 16;
            caml_young_ptr = __eax;
            if(__eax >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        __ebx = __eax + 4;
         *(__ebx - 4) = 3319;
         *__ebx = camlHashtbl__mem_in_bucket_1125;
         *(__ebx + 4) = 3;
         *(__ebx + 8) = __ecx;
        __eax =  *(__edi + 4);
        __esi =  *(__eax - 4);
        __esi =  *(__eax - 4) >> 10;
        if(__esi == 0) {
             ?_? ( &caml_bucket_Division_by_zero) = caml_raise_exn( &caml_bucket_Division_by_zero);
            __esi = __esi;
        } else {
            __eax = caml_hash_univ_param(21, 201, __ecx);
            __eax = __eax >> 1;
            __ecx = __esi;
            asm("cdq ");
            _t153 = __eax % __ecx;
            __eax = __eax / __ecx;
            __edx = _t153;
        }
        __edx = __edx << 1;
        __edx = __edx + 1;
        __ecx =  *(__edi + 4);
         *(__ecx - 4) =  *(__ecx - 4) >> 9;
        if( *(__ecx - 4) >> 9 <= __edx) {
            __eax = caml_ml_array_bound_error();
            __esi = __esi;
            __esp = __esp - 16;
            __edx = __eax;
            while(1) {
                __eax = caml_young_ptr;
                __eax = caml_young_ptr - 16;
                caml_young_ptr = __eax;
                if(__eax >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            __ecx = __eax + 4;
             *(__ecx - 4) = 3319;
             *__ecx = camlHashtbl__do_bucket_1132;
             *(__ecx + 4) = 3;
             *(__ecx + 8) = __edx;
            __edx =  *(__ebx + 4);
            __eax = 1;
             *(__edx - 4) =  *(__edx - 4) >> 9;
            __ebx =  *(__edx - 4) >> 9 | 1;
            __ebx = ( *(__edx - 4) >> 9 | 1) + -2;
            if(__eax > __ebx) {
L84:
                __eax = 1;
                __esp =  &((__esp)[4]);
                return;
            } else {
                _v32 = __ebx;
                _v36 = __eax;
                 *__esp = __edx;
                _v40 = __ecx;
                while(1) {
                    __ebx =  *__esp;
                     *(__ebx - 4) =  *(__ebx - 4) >> 9;
                    if( *(__ebx - 4) >> 9 <= __eax) {
                        break;
                    }
                    __eax =  *(__ebx + __eax * 2 - 2);
                    __ebx = _v40;
                    __eax = camlHashtbl__do_bucket_1132(__eax, _v40, __esp);
                    __eax = _v36;
                    __ecx = __eax;
                    __eax = __eax + 2;
                    _v36 = __eax;
                    __ebx = _v32;
                    if(__ecx != _v32) {
                        continue;
                    } else {
                        goto L84;
                    }
                    goto L100;
                }
                __eax = caml_ml_array_bound_error();
                __esi = __esi;
                __edi = __edi;
                __esp = __esp - 20;
                __esi = __eax;
                while(1) {
                    __eax = caml_young_ptr;
                    __eax = caml_young_ptr - 28;
                    caml_young_ptr = __eax;
                    if(__eax >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                __edx = __eax + 4;
                 *(__edx - 4) = 4343;
                 *__edx = caml_curry2;
                 *(__edx + 4) = 5;
                 *(__edx + 8) = camlHashtbl__do_bucket_1142;
                 *(__edx + 12) = __esi;
                __esi =  *(__ebx + 4);
                __ebx = __edx + 20;
                 *(__ebx - 4) = 1024;
                 *__ebx = __ecx;
                __eax = 1;
                 *(__esi - 4) =  *(__esi - 4) >> 9;
                __ecx =  *(__esi - 4) >> 9 | 1;
                __ecx = ( *(__esi - 4) >> 9 | 1) + -2;
                if(__eax > __ecx) {
L93:
                    __eax =  *__ebx;
                    __esp =  &((__esp)[5]);
                    return;
                } else {
                    _v48 = __ecx;
                    _v52 = __eax;
                    _v56 = __ebx;
                     *__esp = __esi;
                    _v60 = __edx;
                    while(1) {
                        __ebx =  *__ebx;
                        __ecx =  *__esp;
                         *(__ecx - 4) =  *(__ecx - 4) >> 9;
                        if( *(__ecx - 4) >> 9 <= __eax) {
                            break;
                        }
                        __eax =  *(__ecx + __eax * 2 - 2);
                        __ecx = _v60;
                        _push(__eax);
                        __ebx = _v56;
                        _push(__ebx);
                        caml_modify(__ebx);
                        __esp =  &((__esp)[2]);
                        __eax = _v52;
                        __edx = __eax;
                        __eax = __eax + 2;
                        _v52 = __eax;
                        __ecx = _v48;
                        if(__edx != _v48) {
                            continue;
                        } else {
                            goto L93;
                        }
                        goto L100;
                    }
                    __eax = caml_ml_array_bound_error();
                    __esi = __esi;
                    __esp = __esp - 28;
                    __ebx = __eax;
                    __eax = camlHashtbl;
                     *__esp = camlHashtbl;
                    __eax =  *134689272;
                    _v88 =  *134689272;
                    __eax =  *134689280;
                    _v84 =  *134689280;
                    while(1) {
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 232;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                    __eax = __eax + 4;
                     *(__eax - 4) = 3319;
                     *__eax = camlHashtbl__safehash_1177;
                     *(__eax + 4) = 3;
                     *(__eax + 8) = __ebx;
                    __ecx = __eax + 16;
                    _v80 = __ecx;
                     *(__ecx - 4) = 4343;
                     *__ecx = caml_curry3;
                     *(__ecx + 4) = 7;
                     *(__ecx + 8) = camlHashtbl__add_1179;
                     *(__ecx + 12) = __eax;
                    __ecx = __eax + 36;
                    _v76 = __ecx;
                     *(__ecx - 4) = 5367;
                     *__ecx = caml_curry2;
                     *(__ecx + 4) = 5;
                     *(__ecx + 8) = camlHashtbl__remove_1185;
                     *(__ecx + 12) = __ebx;
                     *(__ecx + 16) = __eax;
                    __edx = __eax + 60;
                     *(__edx - 4) = 4343;
                     *__edx = caml_curry2;
                     *(__edx + 4) = 5;
                     *(__edx + 8) = camlHashtbl__find_rec_1193;
                     *(__edx + 12) = __ebx;
                    __ecx = __eax + 80;
                    _v72 = __ecx;
                     *(__ecx - 4) = 6391;
                     *__ecx = caml_curry2;
                     *(__ecx + 4) = 5;
                     *(__ecx + 8) = camlHashtbl__find_1198;
                     *(__ecx + 12) = __ebx;
                     *(__ecx + 16) = __eax;
                     *(__ecx + 20) = __edx;
                    __esi = __eax + 108;
                     *(__esi - 4) = 5367;
                     *__esi = caml_curry2;
                     *(__esi + 4) = 5;
                     *(__esi + 8) = camlHashtbl__find_all_1210;
                     *(__esi + 12) = __ebx;
                     *(__esi + 16) = __eax;
                    __edx = __eax + 132;
                     *(__edx - 4) = 5367;
                     *__edx = caml_curry3;
                     *(__edx + 4) = 7;
                     *(__edx + 8) = camlHashtbl__replace_1217;
                     *(__edx + 12) = __ebx;
                     *(__edx + 16) = __eax;
                    __ecx = __eax + 156;
                     *(__ecx - 4) = 5367;
                     *__ecx = caml_curry2;
                     *(__ecx + 4) = 5;
                     *(__ecx + 8) = camlHashtbl__mem_1227;
                     *(__ecx + 12) = __ebx;
                     *(__ecx + 16) = __eax;
                    __ebx =  *134689304;
                    _v68 =  *134689304;
                    __edi =  *134689312;
                    __eax = __eax + 180;
                     *(__eax - 4) = 12288;
                    __ebx =  *__esp;
                     *__eax =  *__esp;
                    __ebx = _v88;
                     *(__eax + 4) = _v88;
                    __ebx = _v84;
                     *(__eax + 8) = _v84;
                    __ebx = _v80;
                     *(__eax + 12) = _v80;
                    __ebx = _v76;
                     *(__eax + 16) = _v76;
                    __ebx = _v72;
                     *(__eax + 20) = _v72;
                     *(__eax + 24) = __esi;
                     *(__eax + 28) = __edx;
                     *(__eax + 32) = __ecx;
                    __ebx = _v68;
                     *(__eax + 36) = _v68;
                     *((intOrPtr*)(__eax + 40)) =  *134689308;
                     *(__eax + 44) =  *134689312;
                    __esp =  &((__esp)[7]);
                    return;
                }
            }
L100:
        }
        __eax =  *(__ecx + __edx * 2 - 2);
        __esp = __esp - 8;
        while(_t274 != 1) {
            _v32 = __ebx;
            __ecx =  *(_t274 + 8);
             *__esp =  *(_t274 + 8);
            caml_c_call( *_t274,  *(__ebx + 8));
            if(caml_compare != 1) {
                _t274 =  *__esp;
                __ebx = _v32;
                continue;
            }
            __esp =  &((__esp)[2]);
            return;
            goto L100;
        }
        __esp =  &((__esp)[2]);
        return;
        goto L100;
    }
    __eax =  *(__ebx + __edx * 2 - 2);
    _v16 = __eax;
    L62();
    __ecx =  ?_? ( &caml_exn_Not_found);
    __ebx =  *__eax;
    if( *__eax !=  &caml_exn_Not_found) {
        __eax = caml_raise_exn(__eax);
        __esi = __esi;
        __edi = __edi;
        _push(caml_exception_pointer);
        caml_exception_pointer = __esp;
        __ebx =  *(__edi + 4);
        _v4 = __ebx;
        __ebx =  *(__ebx - 4);
        __ebx = __ebx >> 9;
        if(__ebx <= __edx) {
            __eax = caml_ml_array_bound_error();
L67:
            __eax = caml_ml_array_bound_error();
            goto L68;
        }
        __ebx = _v8;
        camlHashtbl__replace_bucket_1116(__eax, _v8);
        _push(__eax);
        __ebx = _v4;
        __eax = _v0;
        __eax = __ebx + _v0 * 2 - 2;
        _push(__ebx + _v0 * 2 - 2);
        caml_modify(__ebx);
        __esp =  &((__esp)[2]);
        __eax = 1;
        _pop(caml_exception_pointer);
        __esp =  &((__esp)[7]);
        return;
        goto L100;
    }
    __ebx =  *__esp;
    __edx =  *(__ebx + 4);
     *(__edx - 4) =  *(__edx - 4) >> 9;
    __ecx = _v4;
    if( *(__edx - 4) >> 9 <= __ecx) {
        goto L67;
    } else {
        while(1) {
            __eax = caml_young_ptr;
            __eax = caml_young_ptr - 16;
            caml_young_ptr = __eax;
            if(__eax >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        __esi = __eax + 4;
         *(__esi - 4) = 3072;
        __eax = _v24;
         *__esi = _v24;
        __eax = _v20;
         *(__esi + 4) = _v20;
        __eax = _v16;
         *(__esi + 8) = _v16;
        _push(__esi);
        __eax = __edx + __ecx * 2 - 2;
        _push(__edx + __ecx * 2 - 2);
        caml_modify(__ebx);
        __esp =  &((__esp)[2]);
         *__ebx =  *__ebx + 2;
        __eax =  *(__ebx + 4);
        __eax =  *( *(__ebx + 4) - 4);
        __eax =  *( *(__ebx + 4) - 4) >> 9;
        __ecx = ( *( *(__ebx + 4) - 4) >> 9 | 1) + ( *( *(__ebx + 4) - 4) >> 9 | 1) - 1;
        __eax =  *__ebx;
        if( *__ebx <= __ecx) {
            __eax = 1;
            __esp =  &((__esp)[7]);
            return;
        } else {
            __eax =  *134689320;
            __esp =  &((__esp)[7]);
            while(1) {
                __esp = __esp - 24;
                 *__esp = __eax;
                _v8 = __ebx;
                __eax =  *(__ebx + 4);
                _v4 = __eax;
                __eax =  *(__eax - 4);
                __eax = __eax >> 9;
                __eax = __eax | 1;
                _v16 = __eax;
                __ebx =  *134688936;
                __eax = __eax >> 1;
                __eax = 3 + __eax * 4;
                __eax = camlPervasives__min_1022(__eax, __esp);
                __ebx = _v16;
                if(__eax == __ebx) {
                    break;
                }
                _v20 = __eax;
                _v16 = __ebx;
                _push(1);
                _push(__eax);
                __eax = caml_make_vect;
                caml_c_call();
                __esp =  &((__esp)[2]);
                __ebx = caml_make_vect;
                _v12 = caml_make_vect;
                while(1) {
                    __eax = caml_young_ptr;
                    __eax = caml_young_ptr - 24;
                    caml_young_ptr = __eax;
                    if(__eax >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                __ecx = __eax + 4;
                 *(__ecx - 4) = 5367;
                 *__ecx = camlHashtbl__insert_bucket_1068;
                 *(__ecx + 4) = 3;
                __eax =  *__esp;
                 *(__ecx + 8) =  *__esp;
                __eax = _v20;
                 *(__ecx + 12) = _v20;
                 *(__ecx + 16) = __ebx;
                __eax = 1;
                __ebx = _v16;
                __ebx = _v16 + -2;
                if(__eax > __ebx) {
L14:
                    __eax = _v12;
                    _push(_v12);
                    _v8 = _v8 + 4;
                    _push(_v8 + 4);
                    caml_modify(__ebx);
                    __esp =  &((__esp)[2]);
                    __eax = 1;
                    __esp =  &((__esp)[6]);
                    return;
                } else {
                    _v16 = __ebx;
                    _v20 = __eax;
                     *__esp = __ecx;
                    while(1) {
                        __ebx = _v4;
                         *(__ebx - 4) =  *(__ebx - 4) >> 9;
                        if( *(__ebx - 4) >> 9 <= __eax) {
                            break;
                        }
                        __eax =  *(__ebx + __eax * 2 - 2);
                        __ebx =  *__esp;
                        __eax = camlHashtbl__insert_bucket_1068(__eax,  *__esp, __esp);
                        __eax = _v20;
                        __ecx = __eax;
                        __eax = __eax + 2;
                        _v20 = __eax;
                        __ebx = _v16;
                        if(__ecx != __ebx) {
                            continue;
                        } else {
                            goto L14;
                        }
                        goto L100;
                    }
                    __eax = caml_ml_array_bound_error();
                    __esi = __esi;
                    __esp = __esp - 4;
                    __edi = __eax;
                    __eax =  *(__edi + 4);
                    __esi =  *(__eax - 4);
                    __esi =  *(__eax - 4) >> 10;
                    if(__esi == 0) {
                         ?_? ( &caml_bucket_Division_by_zero) = caml_raise_exn( &caml_bucket_Division_by_zero);
                        __esi = __esi;
                    } else {
                         *__esp = __ecx;
                        __eax = caml_hash_univ_param(21, 201, __ebx);
                        __eax = __eax >> 1;
                        __ecx = __esi;
                        asm("cdq ");
                        _t40 = __eax % __ecx;
                        __eax = __eax / __ecx;
                        __edx = _t40;
                    }
                    __edx = __edx << 1;
                    __edx = __edx + 1;
                    while(1) {
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 16;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                    __eax = __eax + 4;
                     *(__eax - 4) = 3072;
                     *__eax = __ebx;
                    __ebx =  *__esp;
                     *(__eax + 4) =  *__esp;
                    __ecx =  *(__edi + 4);
                    __ebx =  *(__ecx - 4);
                    __ebx =  *(__ecx - 4) >> 9;
                    if(__ebx <= __edx) {
L30:
                        __eax = caml_ml_array_bound_error();
                        __esi = __esi;
                        __esp = __esp - 8;
                        __edi = __eax;
                        __ecx = __ebx;
                        while(1) {
                            __eax = caml_young_ptr;
                            __eax = caml_young_ptr - 20;
                            caml_young_ptr = __eax;
                            if(__eax >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc(__esp);
                        }
                        __ebx = __eax + 4;
                         *(__ebx - 4) = 4343;
                         *__ebx = camlHashtbl__remove_bucket_1083;
                         *(__ebx + 4) = 3;
                         *(__ebx + 8) = __edi;
                         *(__ebx + 12) = __ecx;
                        __eax =  *(__edi + 4);
                        __esi =  *(__eax - 4);
                        __esi =  *(__eax - 4) >> 10;
                        if(__esi == 0) {
                             ?_? ( &caml_bucket_Division_by_zero) = caml_raise_exn( &caml_bucket_Division_by_zero);
                            __esi = __esi;
                        } else {
                            __eax = caml_hash_univ_param(21, 201, __ecx);
                            __eax = __eax >> 1;
                            __ecx = __esi;
                            asm("cdq ");
                            _t71 = __eax % __ecx;
                            __eax = __eax / __ecx;
                            __edx = _t71;
                        }
                        __edx = __edx << 1;
                        __edx = __edx + 1;
                        _v32 = __edx;
                        __eax =  *(__edi + 4);
                         *__esp = __eax;
                        __eax =  *(__eax - 4);
                        if(__eax <= __edx) {
L41:
                            __eax = caml_ml_array_bound_error();
                            __esp = __esp - 12;
                            while(__ebx != 1) {
                                 *__esp = __eax;
                                __ecx =  *(__ebx + 8);
                                _v44 =  *(__ebx + 8);
                                __ecx =  *(__ebx + 4);
                                _v40 =  *(__ebx + 4);
                                _push(__ebx);
                                _push(__eax);
                                __eax = caml_compare;
                                caml_c_call();
                                __esp =  &((__esp)[2]);
                                if(caml_compare != 1) {
                                    __eax =  *__esp;
                                    __ebx = _v44;
                                    continue;
                                }
                                __eax = _v40;
                                __esp =  &((__esp)[3]);
                                return;
                                goto L100;
                            }
                            while(1) {
                                __eax = caml_young_ptr;
                                __eax = caml_young_ptr - 8;
                                caml_young_ptr = __eax;
                                if(__eax >= caml_young_limit) {
                                    __eax = __eax + 4;
                                     *(__eax - 4) = 1024;
                                     *__eax =  &caml_exn_Not_found;
                                    __eax = caml_raise_exn(__eax);
                                }
                                goto L49;
                            }
                        }
                        __ecx =  *(__edi + 4);
                         *(__ecx - 4) =  *(__ecx - 4) >> 9;
                        if( *(__ecx - 4) >> 9 <= __edx) {
                            __eax = caml_ml_array_bound_error();
                            goto L41;
                        }
                        __eax =  *(__ecx + __edx * 2 - 2);
                        _push(camlHashtbl__remove_bucket_1083( *(__ecx + __edx * 2 - 2), __ebx, __esp));
                        __ebx = _v36;
                        __eax = _v32;
                        __eax = __ebx + _v32 * 2 - 2;
                        _push(__ebx + _v32 * 2 - 2);
                        caml_modify(__ebx);
                        __esp =  &((__esp)[2]);
                        __eax = 1;
                        __esp =  &((__esp)[2]);
                        return;
                        goto L100;
                    }
                    __ebx =  *(__ecx + __edx * 2 - 2);
                     *(__eax + 8) =  *(__ecx + __edx * 2 - 2);
                    __ecx =  *(__edi + 4);
                    __ebx =  *(__ecx - 4);
                    __ebx =  *(__ecx - 4) >> 9;
                    if(__ebx <= __edx) {
                        __eax = caml_ml_array_bound_error();
                        goto L30;
                    }
                    _push(__eax);
                    __eax = __ecx + __edx * 2 - 2;
                    _push(__ecx + __edx * 2 - 2);
                    caml_modify(__ebx);
                    __esp =  &((__esp)[2]);
                     *__edi =  *__edi + 2;
                    __eax =  *(__edi + 4);
                    __eax =  *( *(__edi + 4) - 4);
                    __eax =  *( *(__edi + 4) - 4) >> 9;
                    __ebx = ( *( *(__edi + 4) - 4) >> 9 | 1) + ( *( *(__edi + 4) - 4) >> 9 | 1) - 1;
                    __eax =  *__edi;
                    if( *__edi <= __ebx) {
                        __eax = 1;
                        __esp =  &((__esp)[1]);
                        return;
                    } else {
                        __eax =  *134689320;
                        __ebx = __edi;
                        __esp =  &((__esp)[1]);
                        continue;
                    }
                }
                goto L100;
            }
            __eax = 1;
            __esp =  &((__esp)[6]);
            return;
        }
        goto L100;
    }
    goto L68;
}

L08056610(
    intOrPtr* __eax,                       // r0
    signed int __edx,                      // r3
    _unknown_ __edi,                       // r4
    intOrPtr _a20,                         // _cfa_14
    intOrPtr _a24,                         // _cfa_18
    signed int _a28                        // _cfa_1c
)
{
    unsigned int _v8;                      // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v24;                         // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    unsigned int* _v32;                    // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v44;                         // _cfa_ffffffd4
    intOrPtr* _v48;                        // _cfa_ffffffd0
    intOrPtr* _v52;                        // _cfa_ffffffcc
    intOrPtr* _v56;                        // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    intOrPtr* _t142;                       // _t142
    _unknown_ _t143;                       // _t143
    _unknown_ _t144;                       // _t144
    _unknown_ _t145;                       // _t145
    intOrPtr _t147;                        // _t147
    _unknown_ _t150;                       // _t150
    intOrPtr _t153;                        // _t153
    intOrPtr _t155;                        // _t155
    signed int _t156;                      // _t156
    _unknown_ _t157;                       // _t157
    intOrPtr _t158;                        // _t158
    intOrPtr _t160;                        // _t160
    signed int _t161;                      // _t161
    _unknown_ _t162;                       // _t162
    intOrPtr _t163;                        // _t163
    intOrPtr _t168;                        // _t168
    intOrPtr* _t169;                       // _t169
    intOrPtr* _t170;                       // _t170
    signed int _t173;                      // _t173
    _unknown_ _t175;                       // _t175
    signed int _t176;                      // _t176
    _unknown_ _t177;                       // _t177
    _unknown_ _t180;                       // _t180
    signed int _t181;                      // _t181
    _unknown_ _t183;                       // _t183
    intOrPtr _t184;                        // _t184
    unsigned int _t186;                    // _t186
    unsigned int _t190;                    // _t190
    intOrPtr _t191;                        // _t191
    unsigned int* _t192;                   // _t192
    unsigned int _t193;                    // _t193
    intOrPtr _t194;                        // _t194
    unsigned int _t205;                    // _t205
    intOrPtr _t206;                        // _t206
    intOrPtr* _t207;                       // _t207
    unsigned int _t209;                    // _t209
    intOrPtr _t213;                        // _t213
    intOrPtr* _t215;                       // _t215
    intOrPtr* _t216;                       // _t216
    intOrPtr* _t217;                       // _t217
    intOrPtr* _t218;                       // _t218
    signed int _t224;                      // _t224
    signed int _t226;                      // _t226
    intOrPtr _t227;                        // _t227
    intOrPtr _t228;                        // _t228
    intOrPtr* _t229;                       // _t229
    intOrPtr* _t232;                       // _t232
    intOrPtr* _t233;                       // _t233
    _unknown_ _t236;                       // _t236
    _unknown_ _t237;                       // _t237
    signed int _t240;                      // _t240
    _unknown_ _t241;                       // _t241
    _unknown_ _t242;                       // _t242
    intOrPtr _t243;                        // _t243
    intOrPtr _t244;                        // _t244
    _unknown_ _t245;                       // _t245
    intOrPtr* _t246;                       // _t246

    _t224 = __edx;
    _t142 = __eax;
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    _t184 =  *((intOrPtr*)(__edi + 4));
    _a24 = _t184;
    _t186 =  *(_t184 - 4) >> 9;
    if(_t186 <= _t224) {
        caml_ml_array_bound_error();
        caml_ml_array_bound_error();
        _t145 = caml_ml_array_bound_error();
        _t236 = _t145;
        _t205 = _t186;
        while(1) {
            _t147 = caml_young_ptr - 16;
            caml_young_ptr = _t147;
            if(_t147 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t186 = _t147 + 4;
         *((intOrPtr*)(_t186 - 4)) = 3319;
         *_t186 = camlHashtbl__mem_in_bucket_1125;
         *((intOrPtr*)(_t186 + 4)) = 3;
         *(_t186 + 8) = _t205;
        _t240 =  *( *((intOrPtr*)(_t236 + 4)) - 4) >> 10;
        if(_t240 == 0) {
            caml_raise_exn( &caml_bucket_Division_by_zero);
            _t240 = _t240;
        } else {
            _t181 = caml_hash_univ_param(21, 201, _t205);
            asm("cdq ");
            _t224 = (_t181 >> 1) % _t240;
        }
        _t226 = (_t224 << 1) + 1;
        _t206 =  *((intOrPtr*)(_t236 + 4));
        if( *(_t206 - 4) >> 9 <= _t226) {
            _t153 = caml_ml_array_bound_error();
            __esp = __esp - 16;
            _t227 = _t153;
            while(1) {
                _t155 = caml_young_ptr - 16;
                caml_young_ptr = _t155;
                if(_t155 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t207 = _t155 + 4;
             *((intOrPtr*)(_t207 - 4)) = 3319;
             *_t207 = camlHashtbl__do_bucket_1132;
             *((intOrPtr*)(_t207 + 4)) = 3;
             *((intOrPtr*)(_t207 + 8)) = _t227;
            _t228 =  *((intOrPtr*)(_t186 + 4));
            _t156 = 1;
            _t190 = ( *(_t228 - 4) >> 9 | 1) + -2;
            if(_t156 > _t190) {
L26:
                __esp = __esp + 16;
                return;
            } else {
                _v8 = _t190;
                _v12 = _t156;
                 *__esp = _t228;
                _v16 = _t207;
                while(1) {
                    _t191 =  *__esp;
                    _t209 =  *(_t191 - 4) >> 9;
                    if(_t209 <= _t156) {
                        break;
                    }
                    camlHashtbl__do_bucket_1132( *((intOrPtr*)(_t191 + _t156 * 2 - 2)), _v16, __esp);
                    _t176 = _v12;
                    _t156 = _t176 + 2;
                    _v12 = _t156;
                    if(_t176 != _v8) {
                        continue;
                    } else {
                        goto L26;
                    }
                    goto L42;
                }
                _t158 = caml_ml_array_bound_error();
                __esp = __esp - 20;
                _t243 = _t158;
                while(1) {
                    _t160 = caml_young_ptr - 28;
                    caml_young_ptr = _t160;
                    if(_t160 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                _t229 = _t160 + 4;
                 *((intOrPtr*)(_t229 - 4)) = 4343;
                 *_t229 = caml_curry2;
                 *((intOrPtr*)(_t229 + 4)) = 5;
                 *((intOrPtr*)(_t229 + 8)) = camlHashtbl__do_bucket_1142;
                 *((intOrPtr*)(_t229 + 12)) = _t243;
                _t244 =  *((intOrPtr*)(_t191 + 4));
                _t192 = _t229 + 20;
                 *((intOrPtr*)(_t192 - 4)) = 1024;
                 *_t192 = _t209;
                _t161 = 1;
                _t213 = ( *(_t244 - 4) >> 9 | 1) + -2;
                if(_t161 > _t213) {
L35:
                    __esp = __esp + 20;
                    return;
                } else {
                    _v24 = _t213;
                    _v28 = _t161;
                    _v32 = _t192;
                     *__esp = _t244;
                    _v36 = _t229;
                    while(1) {
                        _t193 =  *_t192;
                        _t214 =  *__esp;
                        if( *( *__esp - 4) >> 9 <= _t161) {
                            break;
                        }
                        _push(camlHashtbl__do_bucket_1142( *((intOrPtr*)(_t214 + _t161 * 2 - 2)), _t193, _v36, __esp));
                        _t192 = _v32;
                        _push(_t192);
                        caml_modify(_t192);
                        __esp = __esp + 8;
                        _t173 = _v28;
                        _t161 = _t173 + 2;
                        _v28 = _t161;
                        if(_t173 != _v24) {
                            continue;
                        } else {
                            goto L35;
                        }
                        goto L42;
                    }
                    _t163 = caml_ml_array_bound_error();
                    __esp = __esp - 28;
                    _t194 = _t163;
                     *__esp = camlHashtbl;
                    _v64 =  *134689272;
                    _v60 =  *134689280;
                    while(1) {
                        _t168 = caml_young_ptr - 232;
                        caml_young_ptr = _t168;
                        if(_t168 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc(__esp);
                    }
                    _t169 = _t168 + 4;
                     *((intOrPtr*)(_t169 - 4)) = 3319;
                     *_t169 = camlHashtbl__safehash_1177;
                     *((intOrPtr*)(_t169 + 4)) = 3;
                     *((intOrPtr*)(_t169 + 8)) = _t194;
                    _t215 = _t169 + 16;
                    _v56 = _t215;
                     *((intOrPtr*)(_t215 - 4)) = 4343;
                     *_t215 = caml_curry3;
                     *((intOrPtr*)(_t215 + 4)) = 7;
                     *((intOrPtr*)(_t215 + 8)) = camlHashtbl__add_1179;
                     *((intOrPtr*)(_t215 + 12)) = _t169;
                    _t216 = _t169 + 36;
                    _v52 = _t216;
                     *((intOrPtr*)(_t216 - 4)) = 5367;
                     *_t216 = caml_curry2;
                     *((intOrPtr*)(_t216 + 4)) = 5;
                     *((intOrPtr*)(_t216 + 8)) = camlHashtbl__remove_1185;
                     *((intOrPtr*)(_t216 + 12)) = _t194;
                     *((intOrPtr*)(_t216 + 16)) = _t169;
                    _t232 = _t169 + 60;
                     *((intOrPtr*)(_t232 - 4)) = 4343;
                     *_t232 = caml_curry2;
                     *((intOrPtr*)(_t232 + 4)) = 5;
                     *((intOrPtr*)(_t232 + 8)) = camlHashtbl__find_rec_1193;
                     *((intOrPtr*)(_t232 + 12)) = _t194;
                    _t217 = _t169 + 80;
                    _v48 = _t217;
                     *((intOrPtr*)(_t217 - 4)) = 6391;
                     *_t217 = caml_curry2;
                     *((intOrPtr*)(_t217 + 4)) = 5;
                     *((intOrPtr*)(_t217 + 8)) = camlHashtbl__find_1198;
                     *((intOrPtr*)(_t217 + 12)) = _t194;
                     *((intOrPtr*)(_t217 + 16)) = _t169;
                     *((intOrPtr*)(_t217 + 20)) = _t232;
                    _t246 = _t169 + 108;
                     *((intOrPtr*)(_t246 - 4)) = 5367;
                     *_t246 = caml_curry2;
                     *((intOrPtr*)(_t246 + 4)) = 5;
                     *((intOrPtr*)(_t246 + 8)) = camlHashtbl__find_all_1210;
                     *((intOrPtr*)(_t246 + 12)) = _t194;
                     *((intOrPtr*)(_t246 + 16)) = _t169;
                    _t233 = _t169 + 132;
                     *((intOrPtr*)(_t233 - 4)) = 5367;
                     *_t233 = caml_curry3;
                     *((intOrPtr*)(_t233 + 4)) = 7;
                     *((intOrPtr*)(_t233 + 8)) = camlHashtbl__replace_1217;
                     *((intOrPtr*)(_t233 + 12)) = _t194;
                     *((intOrPtr*)(_t233 + 16)) = _t169;
                    _t218 = _t169 + 156;
                     *((intOrPtr*)(_t218 - 4)) = 5367;
                     *_t218 = caml_curry2;
                     *((intOrPtr*)(_t218 + 4)) = 5;
                     *((intOrPtr*)(_t218 + 8)) = camlHashtbl__mem_1227;
                     *((intOrPtr*)(_t218 + 12)) = _t194;
                     *((intOrPtr*)(_t218 + 16)) = _t169;
                    _v44 =  *134689304;
                    _t170 = _t169 + 180;
                     *((intOrPtr*)(_t170 - 4)) = 12288;
                     *_t170 =  *__esp;
                     *((intOrPtr*)(_t170 + 4)) = _v64;
                     *((intOrPtr*)(_t170 + 8)) = _v60;
                     *((intOrPtr*)(_t170 + 12)) = _v56;
                     *((intOrPtr*)(_t170 + 16)) = _v52;
                     *((intOrPtr*)(_t170 + 20)) = _v48;
                     *((intOrPtr*)(_t170 + 24)) = _t246;
                     *((intOrPtr*)(_t170 + 28)) = _t233;
                     *((intOrPtr*)(_t170 + 32)) = _t218;
                     *((intOrPtr*)(_t170 + 36)) = _v44;
                     *((intOrPtr*)(_t170 + 40)) =  *134689308;
                     *((intOrPtr*)(_t170 + 44)) =  *134689312;
                    __esp = __esp + 28;
                    return;
                }
            }
L42:
        }
        _t142 =  *((intOrPtr*)(_t206 + _t226 * 2 - 2));
        __esp = __esp - 8;
        while(_t142 != 1) {
            _v8 = _t186;
             *__esp =  *((intOrPtr*)(_t142 + 8));
            caml_c_call( *_t142,  *(_t186 + 8));
            if(caml_compare != 1) {
                _t142 =  *__esp;
                _t186 = _v8;
                continue;
            }
            __esp = __esp + 8;
            return;
            goto L42;
        }
        __esp = __esp + 8;
        return;
        goto L42;
    }
    __ebx = _a20;
    camlHashtbl__replace_bucket_1116(__eax, _a20);
    _push(__eax);
    __ebx = _a24;
    _a28 = __ebx + _a28 * 2 - 2;
    _push(__ebx + _a28 * 2 - 2);
    caml_modify(__ebx);
    __esp = __esp + 8;
    __eax = 1;
    _pop(caml_exception_pointer);
    __esp = __esp + 28;
    return;
    goto L42;
}

camlHashtbl__mem_1122(
    signed int __eax                       // r0
)
{// addr = 0x08056690
    signed int _v4;                        // _cfa_fffffffc
    signed int _v8;                        // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    signed int _t133;                      // _t133
    _unknown_ _t134;                       // _t134
    _unknown_ _t137;                       // _t137
    _unknown_ _t138;                       // _t138

    _t133 = __eax;
    __edi = _t133;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 16;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    __ebx = __eax + 4;
     *(__ebx - 4) = 3319;
     *__ebx = camlHashtbl__mem_in_bucket_1125;
     *(__ebx + 4) = 3;
     *(__ebx + 8) = __ecx;
    __eax =  *(__edi + 4);
    __esi =  *(__eax - 4);
    __esi =  *(__eax - 4) >> 10;
    if(__esi == 0) {
         ?_? ( &caml_bucket_Division_by_zero) = caml_raise_exn( &caml_bucket_Division_by_zero);
        __esi = __esi;
    } else {
        __eax = caml_hash_univ_param(21, 201, __ecx);
        __eax = __eax >> 1;
        __ecx = __esi;
        asm("cdq ");
        _t12 = __eax % __ecx;
        __eax = __eax / __ecx;
        __edx = _t12;
    }
    __edx = __edx << 1;
    __edx = __edx + 1;
    __ecx =  *(__edi + 4);
     *(__ecx - 4) =  *(__ecx - 4) >> 9;
    if( *(__ecx - 4) >> 9 <= __edx) {
        __eax = caml_ml_array_bound_error();
        __esi = __esi;
        __esp = __esp - 16;
        __edx = __eax;
        while(1) {
            __eax = caml_young_ptr;
            __eax = caml_young_ptr - 16;
            caml_young_ptr = __eax;
            if(__eax >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        __ecx = __eax + 4;
         *(__ecx - 4) = 3319;
         *__ecx = camlHashtbl__do_bucket_1132;
         *(__ecx + 4) = 3;
         *(__ecx + 8) = __edx;
        __edx =  *(__ebx + 4);
        __eax = 1;
         *(__edx - 4) =  *(__edx - 4) >> 9;
        __ebx =  *(__edx - 4) >> 9 | 1;
        __ebx = ( *(__edx - 4) >> 9 | 1) + -2;
        if(__eax > __ebx) {
L21:
            __eax = 1;
            __esp =  &((__esp)[4]);
            return;
        } else {
            _v4 = __ebx;
            _v8 = __eax;
             *__esp = __edx;
            _v12 = __ecx;
            while(1) {
                __ebx =  *__esp;
                 *(__ebx - 4) =  *(__ebx - 4) >> 9;
                if( *(__ebx - 4) >> 9 <= __eax) {
                    break;
                }
                __eax =  *(__ebx + __eax * 2 - 2);
                __ebx = _v12;
                __eax = camlHashtbl__do_bucket_1132(__eax, _v12, __esp);
                __eax = _v8;
                __ecx = __eax;
                __eax = __eax + 2;
                _v8 = __eax;
                __ebx = _v4;
                if(__ecx != _v4) {
                    continue;
                } else {
                    goto L21;
                }
                goto L37;
            }
            __eax = caml_ml_array_bound_error();
            __esi = __esi;
            __edi = __edi;
            __esp = __esp - 20;
            __esi = __eax;
            while(1) {
                __eax = caml_young_ptr;
                __eax = caml_young_ptr - 28;
                caml_young_ptr = __eax;
                if(__eax >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            __edx = __eax + 4;
             *(__edx - 4) = 4343;
             *__edx = caml_curry2;
             *(__edx + 4) = 5;
             *((intOrPtr*)(__edx + 8)) = camlHashtbl__do_bucket_1142;
             *(__edx + 12) = __esi;
            __esi =  *(__ebx + 4);
            __ebx = __edx + 20;
             *(__ebx - 4) = 1024;
             *__ebx = __ecx;
            __eax = 1;
             *(__esi - 4) =  *(__esi - 4) >> 9;
            __ecx =  *(__esi - 4) >> 9 | 1;
            __ecx = ( *(__esi - 4) >> 9 | 1) + -2;
            if(__eax > __ecx) {
L30:
                __eax =  *__ebx;
                __esp =  &((__esp)[5]);
                return;
            } else {
                _v20 = __ecx;
                _v24 = __eax;
                _v28 = __ebx;
                 *__esp = __esi;
                _v32 = __edx;
                while(1) {
                    __ebx =  *__ebx;
                    __ecx =  *__esp;
                     *(__ecx - 4) =  *(__ecx - 4) >> 9;
                    if( *(__ecx - 4) >> 9 <= __eax) {
                        break;
                    }
                    __eax =  *(__ecx + __eax * 2 - 2);
                    __ecx = _v32;
                    _push(__eax);
                    __ebx = _v28;
                    _push(__ebx);
                    caml_modify(__ebx);
                    __esp =  &((__esp)[2]);
                    __eax = _v24;
                    __edx = __eax;
                    __eax = __eax + 2;
                    _v24 = __eax;
                    __ecx = _v20;
                    if(__edx != _v20) {
                        continue;
                    } else {
                        goto L30;
                    }
                    goto L37;
                }
                __eax = caml_ml_array_bound_error();
                __esi = __esi;
                __esp = __esp - 28;
                __ebx = __eax;
                __eax = camlHashtbl;
                 *__esp = camlHashtbl;
                __eax =  *134689272;
                _v60 =  *134689272;
                __eax =  *134689280;
                _v56 =  *134689280;
                while(1) {
                    __eax = caml_young_ptr;
                    __eax = caml_young_ptr - 232;
                    caml_young_ptr = __eax;
                    if(__eax >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc(__esp);
                }
                __eax = __eax + 4;
                 *(__eax - 4) = 3319;
                 *__eax = camlHashtbl__safehash_1177;
                 *(__eax + 4) = 3;
                 *(__eax + 8) = __ebx;
                __ecx = __eax + 16;
                _v52 = __ecx;
                 *(__ecx - 4) = 4343;
                 *__ecx = caml_curry3;
                 *(__ecx + 4) = 7;
                 *(__ecx + 8) = camlHashtbl__add_1179;
                 *(__ecx + 12) = __eax;
                __ecx = __eax + 36;
                _v48 = __ecx;
                 *(__ecx - 4) = 5367;
                 *__ecx = caml_curry2;
                 *(__ecx + 4) = 5;
                 *(__ecx + 8) = camlHashtbl__remove_1185;
                 *(__ecx + 12) = __ebx;
                 *(__ecx + 16) = __eax;
                __edx = __eax + 60;
                 *(__edx - 4) = 4343;
                 *__edx = caml_curry2;
                 *(__edx + 4) = 5;
                 *((intOrPtr*)(__edx + 8)) = camlHashtbl__find_rec_1193;
                 *(__edx + 12) = __ebx;
                __ecx = __eax + 80;
                _v44 = __ecx;
                 *(__ecx - 4) = 6391;
                 *__ecx = caml_curry2;
                 *(__ecx + 4) = 5;
                 *(__ecx + 8) = camlHashtbl__find_1198;
                 *(__ecx + 12) = __ebx;
                 *(__ecx + 16) = __eax;
                 *(__ecx + 20) = __edx;
                __esi = __eax + 108;
                 *(__esi - 4) = 5367;
                 *__esi = caml_curry2;
                 *(__esi + 4) = 5;
                 *((intOrPtr*)(__esi + 8)) = camlHashtbl__find_all_1210;
                 *(__esi + 12) = __ebx;
                 *(__esi + 16) = __eax;
                __edx = __eax + 132;
                 *(__edx - 4) = 5367;
                 *__edx = caml_curry3;
                 *(__edx + 4) = 7;
                 *((intOrPtr*)(__edx + 8)) = camlHashtbl__replace_1217;
                 *(__edx + 12) = __ebx;
                 *(__edx + 16) = __eax;
                __ecx = __eax + 156;
                 *(__ecx - 4) = 5367;
                 *__ecx = caml_curry2;
                 *(__ecx + 4) = 5;
                 *(__ecx + 8) = camlHashtbl__mem_1227;
                 *(__ecx + 12) = __ebx;
                 *(__ecx + 16) = __eax;
                __ebx =  *134689304;
                _v40 =  *134689304;
                __edi =  *134689312;
                __eax = __eax + 180;
                 *(__eax - 4) = 12288;
                __ebx =  *__esp;
                 *__eax =  *__esp;
                __ebx = _v60;
                 *(__eax + 4) = _v60;
                __ebx = _v56;
                 *(__eax + 8) = _v56;
                __ebx = _v52;
                 *(__eax + 12) = _v52;
                __ebx = _v48;
                 *(__eax + 16) = _v48;
                __ebx = _v44;
                 *(__eax + 20) = _v44;
                 *(__eax + 24) = __esi;
                 *(__eax + 28) = __edx;
                 *(__eax + 32) = __ecx;
                __ebx = _v40;
                 *(__eax + 36) = _v40;
                 *((intOrPtr*)(__eax + 40)) =  *134689308;
                 *(__eax + 44) =  *134689312;
                __esp =  &((__esp)[7]);
                return;
            }
        }
L37:
    }
    __eax =  *(__ecx + __edx * 2 - 2);
    __esp = __esp - 8;
    while(_t133 != 1) {
        _v4 = __ebx;
         *__esp =  *(_t133 + 8);
        caml_c_call( *_t133,  *(__ebx + 8));
        if(caml_compare != 1) {
            _t133 =  *__esp;
            __ebx = _v4;
            continue;
        }
        __esp =  &((__esp)[2]);
        return;
        goto L37;
    }
    __esp =  &((__esp)[2]);
    return;
    goto L37;
}

camlHashtbl__iter_1129(
    intOrPtr __eax,                        // r0
    _unknown_ __edi,                       // r4
    _unknown_ __esi                        // r5
)
{// addr = 0x08056730
    intOrPtr _v4;                          // _cfa_fffffffc
    signed int _v8;                        // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v20;                         // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    unsigned int* _v28;                    // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr* _v44;                        // _cfa_ffffffd4
    intOrPtr* _v48;                        // _cfa_ffffffd0
    intOrPtr* _v52;                        // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    intOrPtr _t114;                        // _t114
    signed int _t115;                      // _t115
    _unknown_ _t116;                       // _t116
    intOrPtr _t117;                        // _t117
    intOrPtr _t119;                        // _t119
    signed int _t120;                      // _t120
    _unknown_ _t121;                       // _t121
    intOrPtr _t122;                        // _t122
    intOrPtr _t127;                        // _t127
    intOrPtr* _t128;                       // _t128
    intOrPtr* _t129;                       // _t129
    signed int _t132;                      // _t132
    _unknown_ _t134;                       // _t134
    signed int _t135;                      // _t135
    _unknown_ _t136;                       // _t136
    intOrPtr _t140;                        // _t140
    intOrPtr _t141;                        // _t141
    unsigned int* _t142;                   // _t142
    unsigned int _t143;                    // _t143
    intOrPtr _t144;                        // _t144
    intOrPtr* _t155;                       // _t155
    unsigned int _t157;                    // _t157
    intOrPtr _t161;                        // _t161
    intOrPtr* _t163;                       // _t163
    intOrPtr* _t164;                       // _t164
    intOrPtr* _t165;                       // _t165
    intOrPtr* _t166;                       // _t166
    intOrPtr _t170;                        // _t170
    intOrPtr _t171;                        // _t171
    intOrPtr* _t172;                       // _t172
    intOrPtr* _t175;                       // _t175
    intOrPtr* _t176;                       // _t176
    _unknown_ _t178;                       // _t178
    _unknown_ _t179;                       // _t179
    _unknown_ _t181;                       // _t181
    _unknown_ _t182;                       // _t182
    intOrPtr _t183;                        // _t183
    intOrPtr _t184;                        // _t184
    _unknown_ _t185;                       // _t185
    intOrPtr* _t186;                       // _t186

    __esp = __esp - 16;
    _t170 = __eax;
    while(1) {
        _t114 = caml_young_ptr - 16;
        caml_young_ptr = _t114;
        if(_t114 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t155 = _t114 + 4;
     *((intOrPtr*)(_t155 - 4)) = 3319;
     *_t155 = camlHashtbl__do_bucket_1132;
     *((intOrPtr*)(_t155 + 4)) = 3;
     *((intOrPtr*)(_t155 + 8)) = _t170;
    _t171 =  *((intOrPtr*)(_t136 + 4));
    _t115 = 1;
    _t140 = ( *(_t171 - 4) >> 9 | 1) + -2;
    if(_t115 > _t140) {
L6:
        __esp = __esp + 16;
        return;
    } else {
        _v4 = _t140;
        _v8 = _t115;
         *__esp = _t171;
        _v12 = _t155;
        while(1) {
            _t141 =  *__esp;
            _t157 =  *(_t141 - 4) >> 9;
            if(_t157 <= _t115) {
                break;
            }
            camlHashtbl__do_bucket_1132( *((intOrPtr*)(_t141 + _t115 * 2 - 2)), _v12, __esp);
            _t135 = _v8;
            _t115 = _t135 + 2;
            _v8 = _t115;
            if(_t135 != _v4) {
                continue;
            } else {
                goto L6;
            }
            goto L22;
        }
        _t117 = caml_ml_array_bound_error();
        __esp = __esp - 20;
        _t183 = _t117;
        while(1) {
            _t119 = caml_young_ptr - 28;
            caml_young_ptr = _t119;
            if(_t119 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t172 = _t119 + 4;
         *((intOrPtr*)(_t172 - 4)) = 4343;
         *_t172 = caml_curry2;
         *((intOrPtr*)(_t172 + 4)) = 5;
         *((intOrPtr*)(_t172 + 8)) = camlHashtbl__do_bucket_1142;
         *((intOrPtr*)(_t172 + 12)) = _t183;
        _t184 =  *((intOrPtr*)(_t141 + 4));
        _t142 = _t172 + 20;
         *((intOrPtr*)(_t142 - 4)) = 1024;
         *_t142 = _t157;
        _t120 = 1;
        _t161 = ( *(_t184 - 4) >> 9 | 1) + -2;
        if(_t120 > _t161) {
L15:
            __esp = __esp + 20;
            return;
        } else {
            _v20 = _t161;
            _v24 = _t120;
            _v28 = _t142;
             *__esp = _t184;
            _v32 = _t172;
            while(1) {
                _t143 =  *_t142;
                _t162 =  *__esp;
                if( *( *__esp - 4) >> 9 <= _t120) {
                    break;
                }
                _push(camlHashtbl__do_bucket_1142( *((intOrPtr*)(_t162 + _t120 * 2 - 2)), _t143, _v32, __esp));
                _t142 = _v28;
                _push(_t142);
                caml_modify(_t142);
                __esp = __esp + 8;
                _t132 = _v24;
                _t120 = _t132 + 2;
                _v24 = _t120;
                if(_t132 != _v20) {
                    continue;
                } else {
                    goto L15;
                }
                goto L22;
            }
            _t122 = caml_ml_array_bound_error();
            __esp = __esp - 28;
            _t144 = _t122;
             *__esp = camlHashtbl;
            _v60 =  *134689272;
            _v56 =  *134689280;
            while(1) {
                _t127 = caml_young_ptr - 232;
                caml_young_ptr = _t127;
                if(_t127 >= caml_young_limit) {
                    break;
                }
                caml_call_gc(__esp);
            }
            _t128 = _t127 + 4;
             *((intOrPtr*)(_t128 - 4)) = 3319;
             *_t128 = camlHashtbl__safehash_1177;
             *((intOrPtr*)(_t128 + 4)) = 3;
             *((intOrPtr*)(_t128 + 8)) = _t144;
            _t163 = _t128 + 16;
            _v52 = _t163;
             *((intOrPtr*)(_t163 - 4)) = 4343;
             *_t163 = caml_curry3;
             *((intOrPtr*)(_t163 + 4)) = 7;
             *((intOrPtr*)(_t163 + 8)) = camlHashtbl__add_1179;
             *((intOrPtr*)(_t163 + 12)) = _t128;
            _t164 = _t128 + 36;
            _v48 = _t164;
             *((intOrPtr*)(_t164 - 4)) = 5367;
             *_t164 = caml_curry2;
             *((intOrPtr*)(_t164 + 4)) = 5;
             *((intOrPtr*)(_t164 + 8)) = camlHashtbl__remove_1185;
             *((intOrPtr*)(_t164 + 12)) = _t144;
             *((intOrPtr*)(_t164 + 16)) = _t128;
            _t175 = _t128 + 60;
             *((intOrPtr*)(_t175 - 4)) = 4343;
             *_t175 = caml_curry2;
             *((intOrPtr*)(_t175 + 4)) = 5;
             *((intOrPtr*)(_t175 + 8)) = camlHashtbl__find_rec_1193;
             *((intOrPtr*)(_t175 + 12)) = _t144;
            _t165 = _t128 + 80;
            _v44 = _t165;
             *((intOrPtr*)(_t165 - 4)) = 6391;
             *_t165 = caml_curry2;
             *((intOrPtr*)(_t165 + 4)) = 5;
             *((intOrPtr*)(_t165 + 8)) = camlHashtbl__find_1198;
             *((intOrPtr*)(_t165 + 12)) = _t144;
             *((intOrPtr*)(_t165 + 16)) = _t128;
             *((intOrPtr*)(_t165 + 20)) = _t175;
            _t186 = _t128 + 108;
             *((intOrPtr*)(_t186 - 4)) = 5367;
             *_t186 = caml_curry2;
             *((intOrPtr*)(_t186 + 4)) = 5;
             *((intOrPtr*)(_t186 + 8)) = camlHashtbl__find_all_1210;
             *((intOrPtr*)(_t186 + 12)) = _t144;
             *((intOrPtr*)(_t186 + 16)) = _t128;
            _t176 = _t128 + 132;
             *((intOrPtr*)(_t176 - 4)) = 5367;
             *_t176 = caml_curry3;
             *((intOrPtr*)(_t176 + 4)) = 7;
             *((intOrPtr*)(_t176 + 8)) = camlHashtbl__replace_1217;
             *((intOrPtr*)(_t176 + 12)) = _t144;
             *((intOrPtr*)(_t176 + 16)) = _t128;
            _t166 = _t128 + 156;
             *((intOrPtr*)(_t166 - 4)) = 5367;
             *_t166 = caml_curry2;
             *((intOrPtr*)(_t166 + 4)) = 5;
             *((intOrPtr*)(_t166 + 8)) = camlHashtbl__mem_1227;
             *((intOrPtr*)(_t166 + 12)) = _t144;
             *((intOrPtr*)(_t166 + 16)) = _t128;
            _v40 =  *134689304;
            _t129 = _t128 + 180;
             *((intOrPtr*)(_t129 - 4)) = 12288;
             *_t129 =  *__esp;
             *((intOrPtr*)(_t129 + 4)) = _v60;
             *((intOrPtr*)(_t129 + 8)) = _v56;
             *((intOrPtr*)(_t129 + 12)) = _v52;
             *((intOrPtr*)(_t129 + 16)) = _v48;
             *((intOrPtr*)(_t129 + 20)) = _v44;
             *((intOrPtr*)(_t129 + 24)) = _t186;
             *((intOrPtr*)(_t129 + 28)) = _t176;
             *((intOrPtr*)(_t129 + 32)) = _t166;
             *((intOrPtr*)(_t129 + 36)) = _v40;
             *((intOrPtr*)(_t129 + 40)) =  *134689308;
             *((intOrPtr*)(_t129 + 44)) =  *134689312;
            __esp = __esp + 28;
            return;
        }
    }
L22:
}

camlHashtbl__fold_1138(
    intOrPtr __eax                         // r0
)
{// addr = 0x080567E0
    intOrPtr _v4;                          // _cfa_fffffffc
    signed int _v8;                        // _cfa_fffffff8
    intOrPtr* _v12;                        // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr* _v28;                        // _cfa_ffffffe4
    intOrPtr* _v32;                        // _cfa_ffffffe0
    intOrPtr* _v36;                        // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    intOrPtr _t95;                         // _t95
    signed int _t96;                       // _t96
    _unknown_ _t97;                        // _t97
    intOrPtr _t98;                         // _t98
    intOrPtr _t103;                        // _t103
    intOrPtr* _t104;                       // _t104
    intOrPtr* _t105;                       // _t105
    signed int _t108;                      // _t108
    _unknown_ _t109;                       // _t109
    intOrPtr* _t110;                       // _t110
    intOrPtr _t111;                        // _t111
    intOrPtr _t112;                        // _t112
    intOrPtr _t121;                        // _t121
    intOrPtr _t125;                        // _t125
    intOrPtr* _t127;                       // _t127
    intOrPtr* _t128;                       // _t128
    intOrPtr* _t129;                       // _t129
    intOrPtr* _t130;                       // _t130
    intOrPtr* _t133;                       // _t133
    intOrPtr* _t136;                       // _t136
    intOrPtr* _t137;                       // _t137
    intOrPtr _t139;                        // _t139
    intOrPtr _t140;                        // _t140
    _unknown_ _t141;                       // _t141
    intOrPtr* _t142;                       // _t142

    __esp = __esp - 20;
    _t139 = __eax;
    while(1) {
        _t95 = caml_young_ptr - 28;
        caml_young_ptr = _t95;
        if(_t95 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t133 = _t95 + 4;
     *((intOrPtr*)(_t133 - 4)) = 4343;
     *_t133 = caml_curry2;
     *((intOrPtr*)(_t133 + 4)) = 5;
     *((intOrPtr*)(_t133 + 8)) = camlHashtbl__do_bucket_1142;
     *((intOrPtr*)(_t133 + 12)) = _t139;
    _t140 =  *((intOrPtr*)(_t109 + 4));
    _t110 = _t133 + 20;
     *((intOrPtr*)(_t110 - 4)) = 1024;
     *_t110 = _t121;
    _t96 = 1;
    _t125 = ( *(_t140 - 4) >> 9 | 1) + -2;
    if(_t96 > _t125) {
L6:
        __esp = __esp + 20;
        return;
    } else {
        _v4 = _t125;
        _v8 = _t96;
        _v12 = _t110;
         *__esp = _t140;
        _v16 = _t133;
        while(1) {
            _t111 =  *_t110;
            _t126 =  *__esp;
            if( *( *__esp - 4) >> 9 <= _t96) {
                break;
            }
            _push(camlHashtbl__do_bucket_1142( *((intOrPtr*)(_t126 + _t96 * 2 - 2)), _t111, _v16, __esp));
            _t110 = _v12;
            _push(_t110);
            caml_modify(_t110);
            __esp = __esp + 8;
            _t108 = _v8;
            _t96 = _t108 + 2;
            _v8 = _t96;
            if(_t108 != _v4) {
                continue;
            } else {
                goto L6;
            }
            goto L13;
        }
        _t98 = caml_ml_array_bound_error();
        __esp = __esp - 28;
        _t112 = _t98;
         *__esp = camlHashtbl;
        _v44 =  *134689272;
        _v40 =  *134689280;
        while(1) {
            _t103 = caml_young_ptr - 232;
            caml_young_ptr = _t103;
            if(_t103 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t104 = _t103 + 4;
         *((intOrPtr*)(_t104 - 4)) = 3319;
         *_t104 = camlHashtbl__safehash_1177;
         *((intOrPtr*)(_t104 + 4)) = 3;
         *((intOrPtr*)(_t104 + 8)) = _t112;
        _t127 = _t104 + 16;
        _v36 = _t127;
         *((intOrPtr*)(_t127 - 4)) = 4343;
         *_t127 = caml_curry3;
         *((intOrPtr*)(_t127 + 4)) = 7;
         *((intOrPtr*)(_t127 + 8)) = camlHashtbl__add_1179;
         *((intOrPtr*)(_t127 + 12)) = _t104;
        _t128 = _t104 + 36;
        _v32 = _t128;
         *((intOrPtr*)(_t128 - 4)) = 5367;
         *_t128 = caml_curry2;
         *((intOrPtr*)(_t128 + 4)) = 5;
         *((intOrPtr*)(_t128 + 8)) = camlHashtbl__remove_1185;
         *((intOrPtr*)(_t128 + 12)) = _t112;
         *((intOrPtr*)(_t128 + 16)) = _t104;
        _t136 = _t104 + 60;
         *((intOrPtr*)(_t136 - 4)) = 4343;
         *_t136 = caml_curry2;
         *((intOrPtr*)(_t136 + 4)) = 5;
         *((intOrPtr*)(_t136 + 8)) = camlHashtbl__find_rec_1193;
         *((intOrPtr*)(_t136 + 12)) = _t112;
        _t129 = _t104 + 80;
        _v28 = _t129;
         *((intOrPtr*)(_t129 - 4)) = 6391;
         *_t129 = caml_curry2;
         *((intOrPtr*)(_t129 + 4)) = 5;
         *((intOrPtr*)(_t129 + 8)) = camlHashtbl__find_1198;
         *((intOrPtr*)(_t129 + 12)) = _t112;
         *((intOrPtr*)(_t129 + 16)) = _t104;
         *((intOrPtr*)(_t129 + 20)) = _t136;
        _t142 = _t104 + 108;
         *((intOrPtr*)(_t142 - 4)) = 5367;
         *_t142 = caml_curry2;
         *((intOrPtr*)(_t142 + 4)) = 5;
         *((intOrPtr*)(_t142 + 8)) = camlHashtbl__find_all_1210;
         *((intOrPtr*)(_t142 + 12)) = _t112;
         *((intOrPtr*)(_t142 + 16)) = _t104;
        _t137 = _t104 + 132;
         *((intOrPtr*)(_t137 - 4)) = 5367;
         *_t137 = caml_curry3;
         *((intOrPtr*)(_t137 + 4)) = 7;
         *((intOrPtr*)(_t137 + 8)) = camlHashtbl__replace_1217;
         *((intOrPtr*)(_t137 + 12)) = _t112;
         *((intOrPtr*)(_t137 + 16)) = _t104;
        _t130 = _t104 + 156;
         *((intOrPtr*)(_t130 - 4)) = 5367;
         *_t130 = caml_curry2;
         *((intOrPtr*)(_t130 + 4)) = 5;
         *((intOrPtr*)(_t130 + 8)) = camlHashtbl__mem_1227;
         *((intOrPtr*)(_t130 + 12)) = _t112;
         *((intOrPtr*)(_t130 + 16)) = _t104;
        _v24 =  *134689304;
        _t105 = _t104 + 180;
         *((intOrPtr*)(_t105 - 4)) = 12288;
         *_t105 =  *__esp;
         *((intOrPtr*)(_t105 + 4)) = _v44;
         *((intOrPtr*)(_t105 + 8)) = _v40;
         *((intOrPtr*)(_t105 + 12)) = _v36;
         *((intOrPtr*)(_t105 + 16)) = _v32;
         *((intOrPtr*)(_t105 + 20)) = _v28;
         *((intOrPtr*)(_t105 + 24)) = _t142;
         *((intOrPtr*)(_t105 + 28)) = _t137;
         *((intOrPtr*)(_t105 + 32)) = _t130;
         *((intOrPtr*)(_t105 + 36)) = _v24;
         *((intOrPtr*)(_t105 + 40)) =  *134689308;
         *((intOrPtr*)(_t105 + 44)) =  *134689312;
        __esp = __esp + 28;
        return;
    }
L13:
}

camlHashtbl__Make_1251(
    intOrPtr __eax                         // r0
)
{// addr = 0x080568B0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _v8;                         // _cfa_fffffff8
    intOrPtr* _v12;                        // _cfa_fffffff4
    intOrPtr* _v16;                        // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _t75;                         // _t75
    intOrPtr* _t76;                        // _t76
    intOrPtr* _t77;                        // _t77
    intOrPtr _t78;                         // _t78
    intOrPtr* _t87;                        // _t87
    intOrPtr* _t88;                        // _t88
    intOrPtr* _t89;                        // _t89
    intOrPtr* _t90;                        // _t90
    intOrPtr* _t91;                        // _t91
    intOrPtr* _t92;                        // _t92

    _t78 = __eax;
     *__esp = camlHashtbl;
    _v24 =  *134689272;
    _v20 =  *134689280;
    while(1) {
        _t75 = caml_young_ptr - 232;
        caml_young_ptr = _t75;
        if(_t75 >= caml_young_limit) {
            break;
        }
        caml_call_gc(__esp);
    }
    _t76 = _t75 + 4;
     *((intOrPtr*)(_t76 - 4)) = 3319;
     *_t76 = camlHashtbl__safehash_1177;
     *((intOrPtr*)(_t76 + 4)) = 3;
     *((intOrPtr*)(_t76 + 8)) = _t78;
    _t87 = _t76 + 16;
    _v16 = _t87;
     *((intOrPtr*)(_t87 - 4)) = 4343;
     *_t87 = caml_curry3;
     *((intOrPtr*)(_t87 + 4)) = 7;
     *((intOrPtr*)(_t87 + 8)) = camlHashtbl__add_1179;
     *((intOrPtr*)(_t87 + 12)) = _t76;
    _t88 = _t76 + 36;
    _v12 = _t88;
     *((intOrPtr*)(_t88 - 4)) = 5367;
     *_t88 = caml_curry2;
     *((intOrPtr*)(_t88 + 4)) = 5;
     *((intOrPtr*)(_t88 + 8)) = camlHashtbl__remove_1185;
     *((intOrPtr*)(_t88 + 12)) = _t78;
     *((intOrPtr*)(_t88 + 16)) = _t76;
    _t91 = _t76 + 60;
     *((intOrPtr*)(_t91 - 4)) = 4343;
     *_t91 = caml_curry2;
     *((intOrPtr*)(_t91 + 4)) = 5;
     *((intOrPtr*)(_t91 + 8)) = camlHashtbl__find_rec_1193;
     *((intOrPtr*)(_t91 + 12)) = _t78;
    _t89 = _t76 + 80;
    _v8 = _t89;
     *((intOrPtr*)(_t89 - 4)) = 6391;
     *_t89 = caml_curry2;
     *((intOrPtr*)(_t89 + 4)) = 5;
     *((intOrPtr*)(_t89 + 8)) = camlHashtbl__find_1198;
     *((intOrPtr*)(_t89 + 12)) = _t78;
     *((intOrPtr*)(_t89 + 16)) = _t76;
     *((intOrPtr*)(_t89 + 20)) = _t91;
    __esi = _t76 + 108;
     *((intOrPtr*)(__esi - 4)) = 5367;
     *__esi = caml_curry2;
     *((intOrPtr*)(__esi + 4)) = 5;
     *((intOrPtr*)(__esi + 8)) = camlHashtbl__find_all_1210;
     *((intOrPtr*)(__esi + 12)) = _t78;
     *((intOrPtr*)(__esi + 16)) = _t76;
    _t92 = _t76 + 132;
     *((intOrPtr*)(_t92 - 4)) = 5367;
     *_t92 = caml_curry3;
     *((intOrPtr*)(_t92 + 4)) = 7;
     *((intOrPtr*)(_t92 + 8)) = camlHashtbl__replace_1217;
     *((intOrPtr*)(_t92 + 12)) = _t78;
     *((intOrPtr*)(_t92 + 16)) = _t76;
    _t90 = _t76 + 156;
     *((intOrPtr*)(_t90 - 4)) = 5367;
     *_t90 = caml_curry2;
     *((intOrPtr*)(_t90 + 4)) = 5;
     *((intOrPtr*)(_t90 + 8)) = camlHashtbl__mem_1227;
     *((intOrPtr*)(_t90 + 12)) = _t78;
     *((intOrPtr*)(_t90 + 16)) = _t76;
    _v4 =  *134689304;
    _t77 = _t76 + 180;
     *((intOrPtr*)(_t77 - 4)) = 12288;
     *_t77 =  *__esp;
     *((intOrPtr*)(_t77 + 4)) = _v24;
     *((intOrPtr*)(_t77 + 8)) = _v20;
     *((intOrPtr*)(_t77 + 12)) = _v16;
     *((intOrPtr*)(_t77 + 16)) = _v12;
     *((intOrPtr*)(_t77 + 20)) = _v8;
     *((intOrPtr*)(_t77 + 24)) = __esi;
     *((intOrPtr*)(_t77 + 28)) = _t92;
     *((intOrPtr*)(_t77 + 32)) = _t90;
     *((intOrPtr*)(_t77 + 36)) = _v4;
     *((intOrPtr*)(_t77 + 40)) =  *134689308;
     *((intOrPtr*)(_t77 + 44)) =  *134689312;
    return;
}

camlHashtbl__entry()
{// addr = 0x08056A80
    _unknown_ _t17;                        // _t17

     *134689320 =  &camlHashtbl__16;
    camlHashtbl =  &camlHashtbl__15;
     *134689272 =  &camlHashtbl__14;
     *134689280 =  &camlHashtbl__13;
     *134689312 =  &camlHashtbl__12;
     *134689324 =  &camlHashtbl__11;
     *134689276 =  &camlHashtbl__10;
     *134689296 =  &camlHashtbl__9;
     *134689328 =  &camlHashtbl__8;
     *134689284 =  &camlHashtbl__7;
     *134689288 =  &camlHashtbl__6;
     *134689300 =  &camlHashtbl__5;
     *134689292 =  &camlHashtbl__4;
     *134689304 =  &camlHashtbl__3;
     *134689308 =  &camlHashtbl__2;
     *134689316 =  &camlHashtbl__1;
    return 1;
}

camlCallback__register_exception_1034()
{// addr = 0x08056B40
    _unknown_ _t4;                         // _t4
    intOrPtr _t7;                          // _t7
    intOrPtr _t8;                          // _t8
    _unknown_ _t9;                         // _t9

    __ecx = _t4;
    if(( *(__ebx - 4) & 255) == 254) {
        while(1) {
            _t7 = caml_young_ptr - 12;
            caml_young_ptr = _t7;
            if(_t7 >= caml_young_limit) {
                break;
            }
            caml_call_gc(__esp);
        }
        _t8 = _t7 + 4;
         *((intOrPtr*)(_t8 - 4)) = 2301;
        asm("fld qword [ebx]");
        asm("fstp qword [eax]");
L4:
        caml_c_call(__ecx, _t8);
        return;
    }
    _t8 =  *__ebx;
    goto L4;
}

camlCallback__entry()
{// addr = 0x08056BA0
    _unknown_ _t3;                         // _t3

    camlCallback =  &camlCallback__2;
     *134691800 =  &camlCallback__1;
    return 1;
}

unix_accept(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08056BBC
    signed int _v32;                       // _cfa_ffffffe0
    char _v144;                            // _cfa_ffffff70
    char _v148;                            // _cfa_ffffff6c
    char* _v168;                           // _cfa_ffffff58
    intOrPtr _v172;                        // _cfa_ffffff54
    intOrPtr _v176;                        // _cfa_ffffff50
    char _v180;                            // _cfa_ffffff4c
    signed int _v196;                      // _cfa_ffffff3c
    char* _v200;                           // _cfa_ffffff38
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t30;                       // _t30
    signed int _t32;                       // _t32
    intOrPtr* _t36;                        // _t36
    _unknown_ _t38;                        // _t38
    _unknown_ _t39;                        // _t39
    _unknown_ _t40;                        // _t40
    _unknown_ _t44;                        // _t44
    intOrPtr* _t45;                        // _t45

    __i686.get_pc_thunk.bx();
    _t40 = _t39 + 92919;
    _v148 = 112;
    caml_enter_blocking_section();
    _v196 =  &_v148;
    _v200 =  &_v144;
    _t30 = _a4 >> 1;
     *__esp = _t30;
    accept();
    __edi = _t30;
    caml_leave_blocking_section();
    if(__edi == 255) {
        _v200 = 0;
        uerror(_t40 + -9752, _t40, _t44, _t40 + -9752);
    }
    _v196 = __edi;
    _v200 = _v148;
    _t32 =  &_v144;
     *__esp = _t32;
    alloc_sockaddr(_t32, _t40, __edi, _t44);
    _v32 = _t32;
    _t45 =  *((intOrPtr*)(_t40 + -24));
    _v180 =  *_t45;
     *_t45 =  &_v180;
    _v172 = 1;
    _v176 = 1;
    _v168 =  &_v32;
    _t36 = caml_alloc_small(_t40, _t45, 2, 0);
     *_t36 = __edi + __edi + 1;
     *(_t36 + 4) = _v32;
     *_t45 = _v180;
    return;
}

__i686.get_pc_thunk.bx()
{// addr = 0x08056CAA
    return;
}

unix_access(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    char* _a4,                             // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08056CB0
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char* _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t12;                        // _t12
    _unknown_ _t17;                        // _t17
    _unknown_ _t19;                        // _t19
    intOrPtr _t20;                         // _t20
    _unknown_ _t22;                        // _t22
    char* _t24;                            // _t24
    _unknown_ _t25;                        // _t25

    _t20 = __ebx;
    _v12 = _t20;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t21 = _t20 + 92675;
    _t24 = _a4;
    if(access(_t24, caml_convert_flag_list(_a8, _t20 + 0x1cf7f)) == 255) {
        _v24 = _t24;
        uerror(_t21 + -9745, _t21, _t24, _t21 + -9745);
    }
    return 1;
}

unix_inet_addr_of_string(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08056D14
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char _v16;                             // _cfa_fffffff0
    char _v32;                             // _cfa_ffffffe0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    char* _t15;                            // _t15
    char* _t16;                            // _t16
    intOrPtr _t18;                         // _t18
    _unknown_ _t19;                        // _t19
    _unknown_ _t20;                        // _t20
    intOrPtr _t22;                         // _t22
    _unknown_ _t23;                        // _t23

    _t18 = __ebx;
    _v12 = _t18;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t19 = _t18 + 92575;
    _t22 = _a4;
    _t15 =  &_v16;
    _v52 = _t15;
    _v56 = _t22;
     *__esp = 2;
    inet_pton();
    if(_t15 <= 0) {
        _t16 =  &_v32;
        _v52 = _t16;
        _v56 = _t22;
         *__esp = 10;
        inet_pton();
        if(_t16 <= 0) {
             *__esp = _t19 + -9738;
            caml_failwith();
        } else {
            alloc_inet6_addr( ?_? ( &_v32), _t19, _t22,  &_v32);
        }
    } else {
        alloc_inet_addr( ?_? ( &_v16),  &_v16);
    }
    return;
}

unix_alarm(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08056D98
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t8;                         // _t8
    _unknown_ _t9;                         // _t9

    __i686.get_pc_thunk.bx();
    return alarm(_a4 >> 1) + _t6 + 1;
}

unix_bind(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08056DC4
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char _v124;                            // _cfa_ffffff84
    char _v128;                            // _cfa_ffffff80
    char* _v148;                           // _cfa_ffffff6c
    intOrPtr _v152;                        // _cfa_ffffff68
    _unknown_ __ebp;                       // r6
    signed int _t20;                       // _t20
    _unknown_ _t21;                        // _t21
    _unknown_ _t23;                        // _t23
    intOrPtr _t24;                         // _t24
    _unknown_ _t26;                        // _t26
    char* _t28;                            // _t28
    _unknown_ _t29;                        // _t29

    _t24 = __ebx;
    _v12 = _t24;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t25 = _t24 + 92396;
    _v148 =  &_v128;
    _t28 =  &_v124;
    _v152 = _t28;
     *__esp = _a8;
    get_sockaddr(_a8, _t24 + 92396, __edi, _t28);
    _v148 = _v128;
    _v152 = _t28;
    _t20 = _a4 >> 1;
     *__esp = _t20;
    bind();
    if(_t20 == 255) {
        _v152 = 0;
        uerror(_t25 + -9718, _t25, _t28, _t25 + -9718);
    }
    return 1;
}

unix_chdir(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    char* _a4                              // _cfa_4
)
{// addr = 0x08056E3C
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char* _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t8;                         // _t8
    _unknown_ _t10;                        // _t10
    _unknown_ _t12;                        // _t12
    intOrPtr _t13;                         // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    char* _t17;                            // _t17
    _unknown_ _t18;                        // _t18

    _t13 = __ebx;
    _v12 = _t13;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t14 = _t13 + 92279;
    _t17 = _a4;
    if(chdir(_t17) == 255) {
        _v24 = _t17;
        uerror(_t14 + -9713, _t14, _t17, _t14 + -9713);
    }
    return 1;
}

unix_chmod(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08056E84
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    signed int _t11;                       // _t11
    _unknown_ _t12;                        // _t12
    _unknown_ _t14;                        // _t14
    intOrPtr _t15;                         // _t15
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17
    signed int _t19;                       // _t19
    _unknown_ _t20;                        // _t20

    _t15 = __ebx;
    _v12 = _t15;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t16 = _t15 + 92207;
    _t19 = _a4;
    _t11 = _a8 >> 1;
    _v24 = _t11;
     *__esp = _t19;
    chmod();
    if(_t11 == 255) {
        _v24 = _t19;
        uerror(_t16 + -9647, _t16, _t19, _t16 + -9647);
    }
    return 1;
}

unix_chown(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    char* _a4,                             // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x08056ED8
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    _unknown_ _v20;                        // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t17;                        // _t17
    _unknown_ _t19;                        // _t19
    intOrPtr _t20;                         // _t20
    _unknown_ _t21;                        // _t21
    _unknown_ _t22;                        // _t22
    char* _t24;                            // _t24
    _unknown_ _t25;                        // _t25

    _t20 = __ebx;
    _v12 = _t20;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t21 = _t20 + 92123;
    _t24 = _a4;
    if(chown(_t24, _a8 >> 1, _a12 >> 1) == 255) {
        _v24 = _t24;
        uerror(_t21 + -9640, _t21, _t24, _t21 + -9640);
    }
    return 1;
}

unix_chroot(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    char* _a4                              // _cfa_4
)
{// addr = 0x08056F34
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char* _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t8;                         // _t8
    _unknown_ _t10;                        // _t10
    _unknown_ _t12;                        // _t12
    intOrPtr _t13;                         // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    char* _t17;                            // _t17
    _unknown_ _t18;                        // _t18

    _t13 = __ebx;
    _v12 = _t13;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t14 = _t13 + 92031;
    _t17 = _a4;
    if(chroot(_t17) == 255) {
        _v24 = _t17;
        uerror(_t14 + -9707, _t14, _t17, _t14 + -9707);
    }
    return 1;
}

unix_close(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08056F7C
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    _unknown_ _t9;                         // _t9
    _unknown_ _t10;                        // _t10
    _unknown_ _t11;                        // _t11

    __i686.get_pc_thunk.bx();
    _t11 = _t10 + 91964;
    if(close(_a4 >> 1) == 255) {
        _v24 = 0;
        uerror(_t11 + -9700, _t11, __esi, _t11 + -9700);
    }
    return 1;
}

unix_closedir(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x08056FC4
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    intOrPtr _t9;                          // _t9
    _unknown_ _t10;                        // _t10
    intOrPtr _t12;                         // _t12
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14
    intOrPtr* _t16;                        // _t16
    _unknown_ _t17;                        // _t17

    _t12 = __ebx;
    _v12 = _t12;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t13 = _t12 + 91887;
    _t16 = _a4;
    _t9 =  *_t16;
    if(_t9 == 0) {
        _v20 = 0;
        _v24 = _t13 + -9694;
        _t9 = unix_error(_t13 + -9694, _t13, _t16, 9);
    }
     *__esp = _t9;
    closedir();
     *_t16 = 0;
    return 1;
}

unix_connect(
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08057020
    char _v124;                            // _cfa_ffffff84
    char _v128;                            // _cfa_ffffff80
    char* _v148;                           // _cfa_ffffff6c
    intOrPtr _v152;                        // _cfa_ffffff68
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t16;                       // _t16
    _unknown_ _t17;                        // _t17
    _unknown_ _t19;                        // _t19
    _unknown_ _t20;                        // _t20
    char* _t22;                            // _t22

    __i686.get_pc_thunk.bx();
    _t21 = _t20 + 91796;
    _v148 =  &_v128;
    _t22 =  &_v124;
    _v152 = _t22;
     *__esp = _a8;
    get_sockaddr(_a8, _t20 + 91796, __edi, _t22);
    caml_enter_blocking_section();
    _v148 = _v128;
    _v152 = _t22;
    _t16 = _a4 >> 1;
     *__esp = _t16;
    connect();
    _t23 = _t16;
    caml_leave_blocking_section();
    if(_t16 == 255) {
        _v152 = 0;
        uerror(_t21 + -9685, _t21, _t23, _t21 + -9685);
    }
    return 1;
}

unix_dup(
    signed int _a4                         // _cfa_4
)
{// addr = 0x080570A0
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    int _t8;                               // _t8
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12

    __i686.get_pc_thunk.bx();
    _t12 = _t11 + 91672;
    _t8 = dup(_a4 >> 1);
    if(_t8 == 255) {
        _v24 = 0;
        _t8 = uerror(_t12 + -9677, _t12, __esi, _t12 + -9677);
    }
    return _t8 + _t8 + 1;
}

unix_dup2(
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x080570E4
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t11;                        // _t11
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15

    __i686.get_pc_thunk.bx();
    _t15 = _t14 + 91604;
    if(dup2(_a4 >> 1, _a8 >> 1) == 255) {
        _v24 = 0;
        uerror(_t15 + -9673, _t15, __esi, _t15 + -9673);
    }
    return 1;
}

unix_environment()
{// addr = 0x08057134
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4

    __i686.get_pc_thunk.bx();
    caml_copy_string_array( *((intOrPtr*)( *((intOrPtr*)(_t4 + 0x16570)))));
    return;
}

unix_error_message(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805715C
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t9;                        // _t9
    int _t11;                              // _t11
    _unknown_ _t13;                        // _t13
    _unknown_ _t15;                        // _t15
    _unknown_ _t16;                        // _t16

    __i686.get_pc_thunk.bx();
    _t16 = _t15 + 91484;
    _t9 = _a4;
    if((_t9 & 1) != 0) {
        _t11 =  *( *((intOrPtr*)(_t16 + -8)) + (_t9 >> 1) * 4);
    } else {
        _t11 =  *_t9 >> 1;
    }
    caml_copy_string(_t16, __edi, __esi, strerror(_t11));
    return;
}

unix_execv(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    char* _a4,                             // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805719C
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    char* _v52;                            // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    intOrPtr _v76;                         // _cfa_ffffffb4
    intOrPtr _v80;                         // _cfa_ffffffb0
    char* _v84;                            // _cfa_ffffffac
    intOrPtr _v96;                         // _cfa_ffffffa0
    __caddr_t* _v100;   // _cfa_ffffff9c
    intOrPtr _v104;                        // _cfa_ffffff98
    intOrPtr _v120;                        // _cfa_ffffff88
    intOrPtr _v140;                        // _cfa_ffffff74
    char* _v144;                           // _cfa_ffffff70
    __caddr_t* _v156;   // _cfa_ffffff64
    intOrPtr _v160;                        // _cfa_ffffff60
    intOrPtr _v164;                        // _cfa_ffffff5c
    signed int _v184;                      // _cfa_ffffff48
    char* _v188;                           // _cfa_ffffff44
    signed int _v216;                      // _cfa_ffffff28
    _unknown_ __ebp;                       // r6
    _unknown_ _t48;                        // _t48
    _unknown_ _t50;                        // _t50
    _unknown_ _t56;                        // _t56
    _unknown_ _t59;                        // _t59
    _unknown_ _t66;                        // _t66
    _unknown_ _t71;                        // _t71
    _unknown_ _t74;                        // _t74
    _unknown_ _t76;                        // _t76
    signed int _t80;                       // _t80
    _unknown_ _t81;                        // _t81
    _unknown_ _t83;                        // _t83
    intOrPtr _t84;                         // _t84
    intOrPtr _t85;                         // _t85
    intOrPtr _t86;                         // _t86
    intOrPtr _t87;                         // _t87
    _unknown_ _t88;                        // _t88
    _unknown_ _t89;                        // _t89
    char* _t91;                            // _t91
    intOrPtr _t92;                         // _t92
    __caddr_t* _t93;   // _t93
    char* _t94;                            // _t94
    intOrPtr _t95;                         // _t95
    intOrPtr _t96;                         // _t96
    __caddr_t* _t97;   // _t97
    intOrPtr* _t98;                        // _t98
    _unknown_ _t100;                       // _t100
    signed int* _t101;                     // _t101
    signed int* _t102;                     // _t102
    signed int* _t103;                     // _t103
    _unknown_ _t104;                       // _t104

    _t84 = __ebx;
    _v16 = _t84;
    _v12 = _t95;
    _v8 = __edi;
    __i686.get_pc_thunk.bx();
    _t85 = _t84 + 91412;
    _t91 = _a4;
    _t96 = cstringvect(_a8);
    execv(_t91, _t47);
    caml_stat_free(_t96);
    _v40 = _t91;
    uerror(_t85 + -9668, _t85, _t96, _t85 + -9668);
    _push(_t100);
    _t101 = __esp;
    __esp = __esp - 40;
    _v60 = _t85;
    _v56 = _t96;
    _v52 = _t91;
    __i686.get_pc_thunk.bx();
    _t86 = _t85 + 91332;
    _t97 = cstringvect(_v36);
    _t92 = cstringvect(_v32);
    execve(_v40, _t97, _t54);
    caml_stat_free(_t97);
    caml_stat_free(_t92);
    _v84 = _v40;
    uerror(_t86 + -9662, _t86, _t97, _t86 + -9662);
    _push(_t101);
    _t102 = __esp;
    __esp = __esp - 56;
    _v104 = _t86;
    _v100 = _t97;
    _v96 = _t92;
    __i686.get_pc_thunk.bx();
    _t87 = _t86 + 91224;
    _t93 = cstringvect(_v80);
    _t98 =  *((intOrPtr*)(_t87 + -20));
    _v120 =  *_t98;
     *_t98 = cstringvect(_v76);
    execvp(_v84, _t93);
    caml_stat_free(_t93);
    caml_stat_free( *_t98);
     *_t98 = _v120;
    _v144 = _v84;
    uerror(_t87 + -9655, _t87, _t98, _t87 + -9655);
    _push(_t102);
    _t103 = __esp;
    __esp = __esp - 40;
    _v164 = _t87;
    _v160 = _t98;
    _v156 = _t93;
    __i686.get_pc_thunk.bx();
    _t88 = _t87 + 91102;
    _t94 = _v144;
    _t99 = cstringvect(_v140);
    execvp(_t94, _t73);
    caml_stat_free(_t73);
    _v188 = _t94;
    uerror(_t88 + -9655, _t88, _t73, _t88 + -9655);
    _push(_t103);
    _push(_t88);
    __esp = __esp - 20;
    __i686.get_pc_thunk.bx();
    _t89 = _t88 + 91028;
    _v216 = _v184 >> 1;
    _t80 = _v188 >> 1;
     *__esp = _t80;
    fchmod();
    if(_t80 == 255) {
        _v216 = 0;
        uerror(_t89 + -9648, _t89, _t99, _t89 + -9648);
    }
    __esp =  &((__esp)[5]);
    _pop(__ebx);
    return 1;
}

unix_execve(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    char* _a4,                             // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x080571EC
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    intOrPtr _v52;                         // _cfa_ffffffcc
    __caddr_t* _v56;   // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    intOrPtr _v76;                         // _cfa_ffffffb4
    intOrPtr _v96;                         // _cfa_ffffffa0
    char* _v100;                           // _cfa_ffffff9c
    __caddr_t* _v112;   // _cfa_ffffff90
    intOrPtr _v116;                        // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    signed int _v140;                      // _cfa_ffffff74
    char* _v144;                           // _cfa_ffffff70
    signed int _v172;                      // _cfa_ffffff54
    _unknown_ __ebp;                       // r6
    _unknown_ _t43;                        // _t43
    _unknown_ _t46;                        // _t46
    _unknown_ _t53;                        // _t53
    _unknown_ _t58;                        // _t58
    _unknown_ _t61;                        // _t61
    _unknown_ _t63;                        // _t63
    signed int _t67;                       // _t67
    _unknown_ _t68;                        // _t68
    _unknown_ _t70;                        // _t70
    intOrPtr _t71;                         // _t71
    intOrPtr _t72;                         // _t72
    intOrPtr _t73;                         // _t73
    _unknown_ _t74;                        // _t74
    _unknown_ _t75;                        // _t75
    intOrPtr _t77;                         // _t77
    __caddr_t* _t78;   // _t78
    char* _t79;                            // _t79
    intOrPtr _t80;                         // _t80
    __caddr_t* _t81;   // _t81
    intOrPtr* _t82;                        // _t82
    _unknown_ _t84;                        // _t84
    signed int* _t85;                      // _t85
    signed int* _t86;                      // _t86
    _unknown_ _t87;                        // _t87

    _t71 = __ebx;
    _v16 = _t71;
    _v12 = _t80;
    _v8 = __edi;
    __i686.get_pc_thunk.bx();
    _t72 = _t71 + 91332;
    _t81 = cstringvect(_a8);
    _t77 = cstringvect(_a12);
    execve(_a4, _t81, _t41);
    caml_stat_free(_t81);
    caml_stat_free(_t77);
    _v40 = _a4;
    uerror(_t72 + -9662, _t72, _t81, _t72 + -9662);
    _push(_t84);
    _t85 = __esp;
    __esp = __esp - 56;
    _v60 = _t72;
    _v56 = _t81;
    _v52 = _t77;
    __i686.get_pc_thunk.bx();
    _t73 = _t72 + 91224;
    _t78 = cstringvect(_v36);
    _t82 =  *((intOrPtr*)(_t73 + -20));
    _v76 =  *_t82;
     *_t82 = cstringvect(_v32);
    execvp(_v40, _t78);
    caml_stat_free(_t78);
    caml_stat_free( *_t82);
     *_t82 = _v76;
    _v100 = _v40;
    uerror(_t73 + -9655, _t73, _t82, _t73 + -9655);
    _push(_t85);
    _t86 = __esp;
    __esp = __esp - 40;
    _v120 = _t73;
    _v116 = _t82;
    _v112 = _t78;
    __i686.get_pc_thunk.bx();
    _t74 = _t73 + 91102;
    _t79 = _v100;
    _t83 = cstringvect(_v96);
    execvp(_t79, _t60);
    caml_stat_free(_t60);
    _v144 = _t79;
    uerror(_t74 + -9655, _t74, _t60, _t74 + -9655);
    _push(_t86);
    _push(_t74);
    __esp = __esp - 20;
    __i686.get_pc_thunk.bx();
    _t75 = _t74 + 91028;
    _v172 = _v140 >> 1;
    _t67 = _v144 >> 1;
     *__esp = _t67;
    fchmod();
    if(_t67 == 255) {
        _v172 = 0;
        uerror(_t75 + -9648, _t75, _t83, _t75 + -9648);
    }
    __esp =  &((__esp)[5]);
    _pop(__ebx);
    return 1;
}

unix_execvpe(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    char* _a4,                             // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x08057258
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v52;                         // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    __caddr_t* _v68;   // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    intOrPtr _v76;                         // _cfa_ffffffb4
    signed int _v96;                       // _cfa_ffffffa0
    char* _v100;                           // _cfa_ffffff9c
    signed int _v128;                      // _cfa_ffffff80
    _unknown_ __ebp;                       // r6
    _unknown_ _t33;                        // _t33
    _unknown_ _t38;                        // _t38
    _unknown_ _t41;                        // _t41
    _unknown_ _t43;                        // _t43
    signed int _t47;                       // _t47
    _unknown_ _t48;                        // _t48
    _unknown_ _t50;                        // _t50
    intOrPtr _t51;                         // _t51
    intOrPtr _t52;                         // _t52
    _unknown_ _t53;                        // _t53
    _unknown_ _t54;                        // _t54
    __caddr_t* _t56;   // _t56
    char* _t57;                            // _t57
    intOrPtr _t58;                         // _t58
    intOrPtr* _t59;                        // _t59
    _unknown_ _t61;                        // _t61
    signed int* _t62;                      // _t62
    _unknown_ _t63;                        // _t63

    _t51 = __ebx;
    _v16 = _t51;
    _v12 = _t58;
    _v8 = __edi;
    __i686.get_pc_thunk.bx();
    _t52 = _t51 + 91224;
    _t56 = cstringvect(_a8);
    _t59 =  *((intOrPtr*)(_t52 + -20));
    _v32 =  *_t59;
     *_t59 = cstringvect(_a12);
    execvp(_a4, _t56);
    caml_stat_free(_t56);
    caml_stat_free( *_t59);
     *_t59 = _v32;
    _v56 = _a4;
    uerror(_t52 + -9655, _t52, _t59, _t52 + -9655);
    _push(_t61);
    _t62 = __esp;
    __esp = __esp - 40;
    _v76 = _t52;
    _v72 = _t59;
    _v68 = _t56;
    __i686.get_pc_thunk.bx();
    _t53 = _t52 + 91102;
    _t57 = _v56;
    _t60 = cstringvect(_v52);
    execvp(_t57, _t40);
    caml_stat_free(_t40);
    _v100 = _t57;
    uerror(_t53 + -9655, _t53, _t40, _t53 + -9655);
    _push(_t62);
    _push(_t53);
    __esp = __esp - 20;
    __i686.get_pc_thunk.bx();
    _t54 = _t53 + 91028;
    _v128 = _v96 >> 1;
    _t47 = _v100 >> 1;
     *__esp = _t47;
    fchmod();
    if(_t47 == 255) {
        _v128 = 0;
        uerror(_t54 + -9648, _t54, _t60, _t54 + -9648);
    }
    __esp =  &((__esp)[5]);
    _pop(__ebx);
    return 1;
}

unix_execvp(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    char* _a4,                             // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080572D2
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    signed int _v36;                       // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    signed int _v68;                       // _cfa_ffffffbc
    _unknown_ __ebp;                       // r6
    _unknown_ _t16;                        // _t16
    _unknown_ _t18;                        // _t18
    signed int _t22;                       // _t22
    _unknown_ _t23;                        // _t23
    _unknown_ _t25;                        // _t25
    intOrPtr _t26;                         // _t26
    _unknown_ _t27;                        // _t27
    _unknown_ _t28;                        // _t28
    char* _t30;                            // _t30
    intOrPtr _t31;                         // _t31
    _unknown_ _t33;                        // _t33
    _unknown_ _t34;                        // _t34

    _t26 = __ebx;
    _v16 = _t26;
    _v12 = _t31;
    _v8 = __edi;
    __i686.get_pc_thunk.bx();
    _t27 = _t26 + 91102;
    _t30 = _a4;
    _t32 = cstringvect(_a8);
    execvp(_t30, _t15);
    caml_stat_free(_t15);
    _v40 = _t30;
    uerror(_t27 + -9655, _t27, _t15, _t27 + -9655);
    _push(_t33);
    _push(_t27);
    __esp = __esp - 20;
    __i686.get_pc_thunk.bx();
    _t28 = _t27 + 91028;
    _v68 = _v36 >> 1;
    _t22 = _v40 >> 1;
     *__esp = _t22;
    fchmod();
    if(_t22 == 255) {
        _v68 = 0;
        uerror(_t28 + -9648, _t28, _t32, _t28 + -9648);
    }
    __esp =  &((__esp)[5]);
    _pop(__ebx);
    return 1;
}

unix_fchmod(
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08057324
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t9;                        // _t9
    _unknown_ _t10;                        // _t10
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14

    __i686.get_pc_thunk.bx();
    _t14 = _t13 + 91028;
    _v24 = _a8 >> 1;
    _t9 = _a4 >> 1;
     *__esp = _t9;
    fchmod();
    if(_t9 == 255) {
        _v24 = 0;
        uerror(_t14 + -9648, _t14, __esi, _t14 + -9648);
    }
    return 1;
}

unix_fchown(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x08057374
    _unknown_ _v20;                        // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t15;                        // _t15
    _unknown_ _t17;                        // _t17
    _unknown_ _t18;                        // _t18
    _unknown_ _t19;                        // _t19

    __i686.get_pc_thunk.bx();
    _t19 = _t18 + 90948;
    if(fchown(_a4 >> 1, _a8 >> 1, _a12 >> 1) == 255) {
        _v24 = 0;
        uerror(_t19 + -9641, _t19, __esi, _t19 + -9641);
    }
    return 1;
}

unix_clear_close_on_exec(
    signed int __eax,                      // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    signed int _a4                         // _cfa_4
)
{// addr = 0x080573CC
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    signed int _t12;                       // _t12
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    signed int _t16;                       // _t16
    intOrPtr _t17;                         // _t17
    _unknown_ _t18;                        // _t18
    _unknown_ _t19;                        // _t19
    signed int _t22;                       // _t22
    _unknown_ _t23;                        // _t23

    _t17 = __ebx;
    _t12 = __eax;
    _v12 = _t17;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t18 = _t17 + 90855;
    _t22 = _a4 >> 1;
    _v20 = 0;
    _v24 = 1;
     *__esp = _t22;
    fcntl();
    if(_t12 == 255) {
L2:
        _v24 = 0;
        uerror(_t18 + -9634, _t18, _t22, _t18 + -9634);
    } else {
        _t16 = _t12 & 254;
        _v20 = _t16;
        _v24 = 2;
         *__esp = _t22;
        fcntl();
        if(_t16 != 255) {
        } else {
            goto L2;
        }
L4:
    }
    return 1;
    goto L4;
}

unix_set_close_on_exec(
    signed int __eax,                      // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    signed int _a4                         // _cfa_4
)
{// addr = 0x08057446
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    signed int _t12;                       // _t12
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    signed int _t16;                       // _t16
    intOrPtr _t17;                         // _t17
    _unknown_ _t18;                        // _t18
    _unknown_ _t19;                        // _t19
    signed int _t22;                       // _t22
    _unknown_ _t23;                        // _t23

    _t17 = __ebx;
    _t12 = __eax;
    _v12 = _t17;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t18 = _t17 + 90733;
    _t22 = _a4 >> 1;
    _v20 = 0;
    _v24 = 1;
     *__esp = _t22;
    fcntl();
    if(_t12 == 255) {
L2:
        _v24 = 0;
        uerror(_t18 + -9614, _t18, _t22, _t18 + -9614);
    } else {
        _t16 = _t12 | 1;
        _v20 = _t16;
        _v24 = 2;
         *__esp = _t22;
        fcntl();
        if(_t16 != 255) {
        } else {
            goto L2;
        }
L4:
    }
    return 1;
    goto L4;
}

unix_clear_nonblock(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    signed int _a4                         // _cfa_4
)
{// addr = 0x080574C0
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    intOrPtr _t16;                         // _t16
    _unknown_ _t18;                        // _t18
    _unknown_ _t19;                        // _t19
    intOrPtr _t20;                         // _t20
    _unknown_ _t21;                        // _t21
    _unknown_ _t22;                        // _t22
    signed int _t25;                       // _t25
    _unknown_ _t26;                        // _t26

    _t20 = __ebx;
    _t16 = __eax;
    _v12 = _t20;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t21 = _t20 + 90611;
    _t25 = _a4 >> 1;
    _v20 = 0;
    _v24 = 3;
     *__esp = _t25;
    fcntl();
    if(_t16 == 255) {
L2:
        _v24 = 0;
        uerror(_t21 + -9596, _t21, _t25, _t21 + -9596);
    } else {
        _v20 = _t16;
        _v24 = 4;
         *__esp = _t25;
        fcntl();
        if(_t16 != 255) {
        } else {
            goto L2;
        }
L4:
    }
    return 1;
    goto L4;
}

unix_set_nonblock(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805753A
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    intOrPtr _t16;                         // _t16
    _unknown_ _t18;                        // _t18
    _unknown_ _t19;                        // _t19
    intOrPtr _t20;                         // _t20
    _unknown_ _t21;                        // _t21
    _unknown_ _t22;                        // _t22
    signed int _t25;                       // _t25
    _unknown_ _t26;                        // _t26

    _t20 = __ebx;
    _t16 = __eax;
    _v12 = _t20;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t21 = _t20 + 90489;
    _t25 = _a4 >> 1;
    _v20 = 0;
    _v24 = 3;
     *__esp = _t25;
    fcntl();
    if(_t16 == 255) {
L2:
        _v24 = 0;
        uerror(_t21 + -9581, _t21, _t25, _t21 + -9581);
    } else {
        _v20 = _t16;
        _v24 = 4;
         *__esp = _t25;
        fcntl();
        if(_t16 != 255) {
        } else {
            goto L2;
        }
L4:
    }
    return 1;
    goto L4;
}

unix_fork(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __esi                         // r5
)
{// addr = 0x080575C0
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t12;                        // _t12
    int _t13;                              // _t13
    intOrPtr _t17;                         // _t17
    _unknown_ _t19;                        // _t19
    intOrPtr _t20;                         // _t20
    _unknown_ _t21;                        // _t21
    _unknown_ _t22;                        // _t22
    int _t24;                              // _t24
    _unknown_ _t25;                        // _t25

    _t20 = __ebx;
    _v12 = _t20;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t21 = _t20 + 90355;
    _t13 = fork();
    _t24 = _t13;
    if(_t13 == 255) {
        _v24 = 0;
        uerror(_t21 + -9568, _t21, _t24, _t21 + -9568);
    }
    if( *((intOrPtr*)( *((intOrPtr*)(_t21 + -16)))) == 0) {
L8:
        return _t24 + _t24 + 1;
L9:
    }
    _t17 =  *((intOrPtr*)( *((intOrPtr*)(_t21 + -12))));
    if(_t17 == 0 || _t24 != 0) {
        if(_t17 != 0 || _t24 == 0) {
            goto L8;
        } else {
            goto L7;
        }
        goto L9;
    }
L7:
    _t24 = _t24;
    caml_debugger_cleanup_fork();
    goto L8;
}

unix_ftruncate_64(
    signed int _a4,                        // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08057634
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    intOrPtr _t9;                          // _t9
    signed int _t12;                       // _t12
    _unknown_ _t13;                        // _t13
    _unknown_ _t15;                        // _t15
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17

    __i686.get_pc_thunk.bx();
    _t17 = _t16 + 90244;
    _t9 = _a8;
    _v24 =  *((intOrPtr*)(_t9 + 4));
    _v20 =  *((intOrPtr*)(_t9 + 8));
    _t12 = _a4 >> 1;
     *__esp = _t12;
    ftruncate64();
    if(_t12 == 255) {
        _v24 = 0;
        uerror(_t17 + -9563, _t17, __esi, _t17 + -9563);
    }
    return 1;
}

unix_ftruncate(
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0805768A
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t8;                        // _t8
    signed int _t10;                       // _t10
    _unknown_ _t11;                        // _t11
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15

    __i686.get_pc_thunk.bx();
    _t15 = _t14 + 90158;
    _t8 = _a8 >> 1;
    _v24 = _t8;
    _v20 = _t8 >> 31;
    _t10 = _a4 >> 1;
     *__esp = _t10;
    ftruncate64();
    if(_t10 == 255) {
        _v24 = 0;
        uerror(_t15 + -9563, _t15, __esi, _t15 + -9563);
    }
    return 1;
}

unix_getaddrinfo(
    _unknown_ __eax,                       // r0
    char* _a4,                             // _cfa_4
    char* _a8,                             // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x080576F0
    char* _v40;                            // _cfa_ffffffd8
    char* _v44;                            // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    char* _v52;                            // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    char* _v64;                            // _cfa_ffffffc0
    char* _v68;                            // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8
    char* _v84;                            // _cfa_ffffffac
    char* _v88;                            // _cfa_ffffffa8
    char* _v92;                            // _cfa_ffffffa4
    char* _v96;                            // _cfa_ffffffa0
    intOrPtr _v100;                        // _cfa_ffffff9c
    char _v104;                            // _cfa_ffffff98
    signed int _v124;                      // _cfa_ffffff84
    intOrPtr _v128;                        // _cfa_ffffff80
    char* _v132;                           // _cfa_ffffff7c
    signed int _v136;                      // _cfa_ffffff78
    char* _v140;                           // _cfa_ffffff74
    char* _v144;                           // _cfa_ffffff70
    char _v148;                            // _cfa_ffffff6c
    char _v152;                            // _cfa_ffffff68
    char* _v164;                           // _cfa_ffffff5c
    char* _v168;                           // _cfa_ffffff58
    char* _v172;                           // _cfa_ffffff54
    char* _v176;                           // _cfa_ffffff50
    intOrPtr _v180;                        // _cfa_ffffff4c
    char* _v184;                           // _cfa_ffffff48
    char _v296;                            // _cfa_fffffed8
    char* _v304;                           // _cfa_fffffed0
    void* _v308;          // _cfa_fffffecc
    char** _v312;                          // _cfa_fffffec8
    char* _v316;                           // _cfa_fffffec4
    char* _v320;                           // _cfa_fffffec0
    char* _v324;                           // _cfa_fffffebc
    char* _v328;                           // _cfa_fffffeb8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t158;                       // _t158
    char** _t159;                          // _t159
    _unknown_ _t164;                       // _t164
    _unknown_ _t166;                       // _t166
    char* _t167;                           // _t167
    signed int _t168;                      // _t168
    char* _t170;                           // _t170
    char* _t175;                           // _t175
    void* _t182;          // _t182
    char* _t186;                           // _t186
    signed int _t198;                      // _t198
    signed int _t201;                      // _t201
    signed int _t202;                      // _t202
    char* _t212;                           // _t212
    _unknown_ _t214;                       // _t214
    char* _t215;                           // _t215
    _unknown_ _t217;                       // _t217
    _unknown_ _t218;                       // _t218
    _unknown_ _t219;                       // _t219
    char* _t223;                           // _t223
    intOrPtr _t228;                        // _t228
    char* _t229;                           // _t229
    _unknown_ _t232;                       // _t232
    signed int _t243;                      // _t243
    char* _t245;                           // _t245
    _unknown_ _t246;                       // _t246
    char* _t251;                           // _t251
    char* _t252;                           // _t252

    __i686.get_pc_thunk.bx();
    _t219 = _t218 + 90051;
    _t159 =  *(_t219 + -24);
    _t229 =  *_t159;
    _v316 = _t229;
    _v60 = _t229;
    _v52 = 1;
    _v56 = 3;
    _v48 =  &_a4;
    _v44 =  &_a8;
    _v40 =  &_a12;
    _v64 = 0;
    _v68 = 0;
    _v72 = 0;
    _v104 =  &_v60;
     *_t159 =  &_v104;
    _v96 = 1;
    _v100 = 3;
    _v92 =  &_v64;
    _v88 =  &_v68;
    _v84 =  &_v72;
    _t164 = caml_string_length(_a4);
    _t251 = 0;
    if(_t164 != 0) {
        _t215 = _t164 + 1;
        caml_stat_alloc(_t215);
        _t251 = _t215;
        strcpy(_t251, _a4);
    }
    _t166 = caml_string_length(_a8);
    _t245 = 0;
    if(_t166 != 0) {
        _t212 = _t166 + 1;
        caml_stat_alloc(_t212);
        _t245 = _t212;
        strcpy(_t245, _a8);
    }
    _t223 =  &_v136;
    _t167 = 0;
    while(1) {
        _t223[_t167] = 0;
        _t167 =  &(_t167[4]);
        if(_t167 >= 32) {
            break;
        }
    }
    _v132 = 0;
    _t168 = _a12;
    if((_t168 & 1) != 0) {
L23:
        caml_enter_blocking_section();
        _v320 =  &_v140;
        _t170 =  &_v136;
        _v324 = _t170;
        _v328 = _t245;
         *__esp = _t251;
        getaddrinfo();
        _v304 = _t170;
        caml_leave_blocking_section();
        if(_t251 != 0) {
            caml_stat_free(_t251);
        }
        if(_t245 != 0) {
            caml_stat_free(_t245);
        }
        _v64 = 1;
        if(_v304 != 0) {
L32:
             *( *(_t219 + -24)) = _v316;
            return _v64;
        } else {
            _t252 = _v140;
            if(_t252 == 0) {
L31:
                 *__esp = _v140;
                freeaddrinfo();
                goto L32;
            }
            _v312 =  &_v184;
            while(1) {
                _t175 =  *( *(_t219 + -24));
                _v304 = _t175;
                _v144 = 0;
                _v148 = 0;
                _v152 = 0;
                _v184 = _t175;
                 *( *(_t219 + -24)) = _v312;
                _v176 = 1;
                _v180 = 3;
                _v172 =  &_v144;
                _v168 =  &_v148;
                _v164 =  &_v152;
                _t247 = _t252[0x10] - 112 <= 0 ? _t252[0x10] : 112;
                _v308 =  &_v296;
                _t182 = memcpy(_v308, _t252[0x14], _t252[0x10] - 112 <= 0 ? _t252[0x10] : 112);
                alloc_sockaddr(_t182, _t219, _t252[0x10] - 112 <= 0 ? _t252[0x10] : 112, _t252, _v308, _t247, -1);
                _v148 = _t182;
                _t184 = _t252[0x18] == 0 ? _t219 + -5244 : _t252[0x18];
                _v152 = caml_copy_string(_t219, _t247, _t252, _t252[0x18] == 0 ? _t219 + -5244 : _t252[0x18]);
                _t186 = caml_alloc_small(_t219, _t252, 5, 0);
                _v144 = _t186;
                 *_t186 = cst_to_constr(_t252[4],  *((intOrPtr*)(_t219 + -32)), 3, 0);
                _v144[4] = cst_to_constr(_t252[8],  *((intOrPtr*)(_t219 + -28)), 4, 0);
                _v144[8] =  &(( &((1)[_t252[0xc]]))[_t252[0xc]]);
                _v144[0xc] = _v148;
                _v144[0x10] = _v152;
                 *( *(_t219 + -24)) = _v304;
                _v72 = _v144;
                _t198 = caml_alloc_small(_t219, _t252, 2, 0);
                _v68 = _t198;
                 *_t198 = _v72;
                _v68[4] = _v64;
                _v64 = _v68;
                _t252 = _t252[0x1c];
                if(_t252 == 0) {
                    break;
                }
            }
            goto L31;
        }
    } else {
        _t228 =  *((intOrPtr*)(_t219 + -28));
        while(1) {
            _t201 =  *_t168;
            _v68 = _t201;
            if((_t201 & 1) != 0) {
                _t202 = _t201 >> 1;
                if(_t202 == 1) {
                    _v136 = _v136 | 2;
                } else {
                    if(_t202 == 2) {
                        _v136 = _v136 | 1;
                    } else {
                        if(_t202 == 0) {
                            _v136 = _v136 | 4;
                        }
                    }
                }
            } else {
                _t243 =  *(_t201 - 4) & 255;
                if((_t243 & 255) == 1) {
                    _v128 =  *((intOrPtr*)(_t228 + ( *_t201 >> 1) * 4));
                } else {
                    if((_t243 & 255) < 1) {
                        _v132 =  *( *((intOrPtr*)(_t219 + -32)) + ( *_t201 >> 1) * 4);
                    } else {
                        if((_t243 & 255) == 2) {
                            _v124 =  *_t201 >> 1;
                        }
                    }
                }
            }
            _t168 =  *(_a12 + 4);
            _a12 = _t168;
            if((_t168 & 1) != 0) {
                break;
            }
        }
        goto L23;
    }
}

unix_getcwd()
{// addr = 0x08057AFC
    char _v4108;                           // _cfa_ffffeff4
    intOrPtr _v4120;                       // _cfa_ffffefe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t9;                         // _t9
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13

    __i686.get_pc_thunk.bx();
    _t13 = _t12 + 89017;
    if(getcwd( &_v4108, 4096) == 0) {
        _v4120 = 0;
        uerror(_t13 + -9553, _t13, __esi, _t13 + -9553);
    }
    caml_copy_string(_t13, __edi, __esi,  &_v4108);
    return;
}

unix_getegid(
    _unknown_ __eax                        // r0
)
{// addr = 0x08057B58
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3
    _unknown_ _t6;                         // _t6
    _unknown_ _t7;                         // _t7

    __i686.get_pc_thunk.bx();
    return getegid() + _t4 + 1;
}

unix_geteuid(
    _unknown_ __eax                        // r0
)
{// addr = 0x08057B7C
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3
    _unknown_ _t6;                         // _t6
    _unknown_ _t7;                         // _t7

    __i686.get_pc_thunk.bx();
    return geteuid() + _t4 + 1;
}

unix_getgid(
    _unknown_ __eax                        // r0
)
{// addr = 0x08057BA0
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3
    _unknown_ _t6;                         // _t6
    _unknown_ _t7;                         // _t7

    __i686.get_pc_thunk.bx();
    return getgid() + _t4 + 1;
}

alloc_group_entry(
    intOrPtr* __eax                        // r0
)
{// addr = 0x08057BD0
    char _v32;                             // _cfa_ffffffe0
    char _v36;                             // _cfa_ffffffdc
    char _v40;                             // _cfa_ffffffd8
    char* _v52;                            // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    char* _v60;                            // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    intOrPtr _v68;                         // _cfa_ffffffbc
    char _v72;                             // _cfa_ffffffb8
    _unknown_ _v88;                        // _cfa_ffffffa8
    _unknown_ __ebx;                       // r1
    intOrPtr* __edi;                       // r4
    intOrPtr* __esi;                       // r5
    _unknown_ __ebp;                       // r6
    intOrPtr _t41;                         // _t41
    intOrPtr* _t42;                        // _t42
    _unknown_ _t43;                        // _t43

    __i686.get_pc_thunk.bx();
    _t44 = _t43 + 88806;
    __esi = __eax;
    _v32 = 1;
    _v36 = 1;
    _v40 = 1;
    __edi =  *((intOrPtr*)(_t43 + 0x15ace));
    _v72 =  *__edi;
     *__edi =  &_v72;
    _v64 = 1;
    _v68 = 3;
    _v60 =  &_v32;
    _v56 =  &_v36;
    _v52 =  &_v40;
    _v32 = caml_copy_string(_t44, __edi, __esi,  *__esi);
    _v36 = caml_copy_string(_t44, __edi, __esi,  *((intOrPtr*)(__esi + 4)));
    _t41 =  *((intOrPtr*)(__esi + 12));
    caml_copy_string_array(_t41);
    _v40 = _t41;
    _t42 = caml_alloc_small(_t44, __esi, 4, 0);
     *_t42 = _v32;
     *((intOrPtr*)(_t42 + 4)) = _v36;
     *((intOrPtr*)(_t42 + 8)) =  *((intOrPtr*)(__esi + 8)) +  *((intOrPtr*)(__esi + 8)) + 1;
     *((intOrPtr*)(_t42 + 12)) = _v40;
     *__edi = _v72;
    return;
}

unix_getgrgid(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08057C90
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t3;                        // _t3
    _unknown_ _t4;                         // _t4
    _unknown_ _t5;                         // _t5

    __i686.get_pc_thunk.bx();
    _t3 = _a4 >> 1;
     *__esp = _t3;
    getgrgid();
    if(_t3 == 0) {
        caml_raise_not_found();
    }
    alloc_group_entry(_t3);
    return;
}

unix_getgrnam(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x08057CC3
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2
    _unknown_ _t3;                         // _t3

    __i686.get_pc_thunk.bx();
    __eax = _a4;
     *__esp = __eax;
    getgrnam();
    if(__eax == 0) {
        caml_raise_not_found();
    }
    alloc_group_entry(__eax);
    return;
}

unix_getgroups()
{// addr = 0x08057CF4
    char _v262172;                         // _cfa_fffbffe4
    signed int _v262184;                   // _cfa_fffbffd8
    _unknown_ __ebx;                       // r1
    char* __edi;                           // r4
    int __esi;                             // r5
    _unknown_ __ebp;                       // r6
    int _t13;                              // _t13
    _unknown_ _t15;                        // _t15
    _unknown_ _t16;                        // _t16

    __i686.get_pc_thunk.bx();
    _t16 = _t15 + 88511;
    _t13 = getgroups(65536,  &_v262172);
    __esi = _t13;
    if(_t13 == 255) {
        _v262184 = 0;
        _t13 = uerror(_t16 + -9546, _t16, __esi, _t16 + -9546);
    }
    caml_alloc_tuple(_t13);
    if(__esi > 0) {
        __edx = 0;
        __edi =  &_v262172;
        while(1) {
             *((intOrPtr*)(_t13 + __edx * 4)) =  *((intOrPtr*)(__edi + __edx * 4)) +  *((intOrPtr*)(__edi + __edx * 4)) + 1;
            __edx = __edx + 1;
            if(__edx == __esi) {
                break;
            }
        }
    }
    return;
}

alloc_host_entry(
    intOrPtr* __eax                        // r0
)
{// addr = 0x08057D74
    char _v16;                             // _cfa_fffffff0
    char _v20;                             // _cfa_ffffffec
    char _v24;                             // _cfa_ffffffe8
    char _v28;                             // _cfa_ffffffe4
    char* _v36;                            // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    char* _v44;                            // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    intOrPtr* __esi;                       // r5
    _unknown_ __ebp;                       // r6
    intOrPtr* _t48;                        // _t48
    intOrPtr _t55;                         // _t55
    intOrPtr* _t62;                        // _t62
    _unknown_ _t63;                        // _t63
    _unknown_ _t64;                        // _t64
    signed int _t66;                       // _t66
    intOrPtr* _t74;                        // _t74

    __i686.get_pc_thunk.bx();
    _t64 = _t63 + 88387;
    __esi = __eax;
    _v16 = 1;
    _v20 = 1;
    _v24 = 1;
    _v28 = 1;
    _t48 =  *((intOrPtr*)(_t64 + -24));
    _v60 =  *_t48;
     *_t48 =  &_v60;
    _v52 = 1;
    _v56 = 4;
    _v48 =  &_v16;
    _v44 =  &_v20;
    _v40 =  &_v24;
    _v36 =  &_v28;
    _v16 = caml_copy_string(_t64, __edi, __esi,  *__esi);
    _t55 =  *((intOrPtr*)(__esi + 4));
    if(_t55 == 0) {
        _v20 =  *((intOrPtr*)(_t64 + -4)) + 4;
    } else {
        caml_copy_string_array(_t55);
        _v20 = _t55;
    }
     *((intOrPtr*)(_t64 + 27496)) =  *((intOrPtr*)(__esi + 12));
    _v24 = caml_alloc_array(_t64, __edi, __esi, _t64 + -87954,  *((intOrPtr*)(__esi + 16)));
    _t62 = caml_alloc_small(_t64, __esi, 4, 0);
     *_t62 = _v16;
    _t74 = _t62;
     *((intOrPtr*)(_t62 + 4)) = _v20;
    _t66 =  *(__esi + 8);
    if(_t66 == 1) {
         *((intOrPtr*)(_t62 + 8)) = 1;
    } else {
         *((intOrPtr*)(_t62 + 8)) = (_t66 & 0xff) + (_t66 & 0xff) + 3;
    }
     *((intOrPtr*)(_t74 + 12)) = _v24;
     *((intOrPtr*)( *((intOrPtr*)(_t64 + -24)))) = _v60;
    return;
}

unix_gethostbyname(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    char* _a4                              // _cfa_4
)
{// addr = 0x08057E83
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0
    char _v52;                             // _cfa_ffffffcc
    char _v10052;                          // _cfa_ffffd8bc
    char* _v10072;                         // _cfa_ffffd8a8
    char* _v10076;                         // _cfa_ffffd8a4
    intOrPtr _v10080;                      // _cfa_ffffd8a0
    char* _v10084;                         // _cfa_ffffd89c
    intOrPtr _v10088;                      // _cfa_ffffd898
    _unknown_ __ebp;                       // r6
    char* _t20;                            // _t20
    char* _t21;                            // _t21
    char* _t24;                            // _t24
    _unknown_ _t27;                        // _t27
    _unknown_ _t28;                        // _t28
    _unknown_ _t32;                        // _t32
    _unknown_ _t35;                        // _t35

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx();
    _t20 = caml_string_length(_a4) + 1;
    caml_stat_alloc(_t20);
    _t34 = _t20;
    _t21 = strcpy(_t20, _a4);
    caml_enter_blocking_section();
    __h_errno_location();
    _v10072 = _t21;
    _v10076 =  &_v32;
    _v10080 = 10000;
    _v10084 =  &_v10052;
    _t24 =  &_v52;
    _v10088 = _t24;
     *__esp = _t20;
    gethostbyname_r();
    caml_leave_blocking_section();
    if(_t24 != 0) {
        _v32 = 0;
    }
    caml_stat_free(_t34);
    _t25 = _v32;
    if(_v32 == 0) {
        caml_raise_not_found();
    }
    alloc_host_entry(_t25);
    return;
}

alloc_one_addr(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08057F32
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char _v16;                             // _cfa_fffffff0
    char _v32;                             // _cfa_ffffffe0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    intOrPtr _t13;                         // _t13
    intOrPtr _t15;                         // _t15
    _unknown_ _t17;                        // _t17
    _unknown_ _t20;                        // _t20

    _t15 = __ebx;
    _v12 = _t15;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t16 = _t15 + 87937;
    _t13 = _a4;
    if( *((intOrPtr*)(_t15 + 0x1c2e9)) != 16) {
        _v52 = 4;
        _v56 = _t13;
        _t19 =  ?_? ( &_v16);
         *__esp =  &_v16;
        alloc_inet_addr(memmove(), _t19);
    } else {
        _v52 = 16;
        _v56 = _t13;
        _t21 =  ?_? ( &_v32);
         *__esp =  &_v32;
        alloc_inet6_addr(memmove(), _t16, _t21, _t21);
    }
    return;
}

unix_gethostbyaddr(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x08057F9F
    char _v16;                             // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    char _v40;                             // _cfa_ffffffd8
    char _v10040;                          // _cfa_ffffd8c8
    char _v10044;                          // _cfa_ffffd8c4
    char* _v10048;                         // _cfa_ffffd8c0
    char* _v10052;                         // _cfa_ffffd8bc
    intOrPtr _v10056;                      // _cfa_ffffd8b8
    char* _v10060;                         // _cfa_ffffd8b4
    char* _v10064;                         // _cfa_ffffd8b0
    intOrPtr _v10068;                      // _cfa_ffffd8ac
    intOrPtr _v10072;                      // _cfa_ffffd8a8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t24;                        // _t24
    _unknown_ _t25;                        // _t25

    __i686.get_pc_thunk.bx();
    _v16 =  *_a4;
    caml_enter_blocking_section();
    _v10048 =  &_v10044;
    _v10052 =  &_v20;
    _v10056 = 10000;
    _v10060 =  &_v10040;
    _v10064 =  &_v40;
    _v10068 = 2;
    _v10072 = 4;
    _t23 =  &_v16;
     *__esp = _t23;
    gethostbyaddr_r();
    caml_leave_blocking_section();
    if(_t23 == 0) {
        _t23 = _v20;
        if(_v20 != 0) {
        } else {
            goto L3;
        }
L5:
    } else {
        _v20 = 0;
L3:
        caml_raise_not_found();
    }
    alloc_host_entry(_t23);
    return;
    goto L5;
}

unix_gethostname(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi                         // r5
)
{// addr = 0x08058038
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char _v13;                             // _cfa_fffffff3
    char _v76;                             // _cfa_ffffffb4
    intOrPtr _v88;                         // _cfa_ffffffa8
    _unknown_ __ebp;                       // r6
    _unknown_ _t8;                         // _t8
    _unknown_ _t9;                         // _t9
    _unknown_ _t12;                        // _t12
    _unknown_ _t15;                        // _t15

    _t10 = __ebx;
    _v12 = __ebx;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _v88 = 64;
    _t14 =  ?_? ( &_v76);
     *__esp =  &_v76;
    gethostname();
    _v13 = 0;
    caml_copy_string(_t10 + 87675, __edi, _t14, _t14);
    return;
}

unix_getlogin(
    _unknown_ __eax                        // r0
)
{// addr = 0x08058078
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4
    _unknown_ _t6;                         // _t6
    _unknown_ _t8;                         // _t8
    _unknown_ _t9;                         // _t9

    __i686.get_pc_thunk.bx();
    _t9 = _t8 + 87616;
    if(getlogin() == 0) {
        _v20 = 0;
        _v24 = _t9 + -9536;
        _t5 = unix_error(_t9 + -9536, _t9, __esi, 2);
    }
    caml_copy_string(_t9, __edi, __esi, _t5);
    return;
}

unix_getnameinfo(
    _unknown_ __eax,                       // r0
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080580C0
    char _v32;                             // _cfa_ffffffe0
    char _v36;                             // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    char* _v52;                            // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    char* _v60;                            // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    intOrPtr _v68;                         // _cfa_ffffffbc
    char _v72;                             // _cfa_ffffffb8
    char _v184;                            // _cfa_ffffff48
    char _v188;                            // _cfa_ffffff44
    char _v4284;                           // _cfa_ffffef44
    char _v5308;                           // _cfa_ffffeb44
    intOrPtr _v5312;                       // _cfa_ffffeb40
    intOrPtr _v5332;                       // _cfa_ffffeb2c
    intOrPtr _v5336;                       // _cfa_ffffeb28
    char* _v5340;                          // _cfa_ffffeb24
    intOrPtr _v5344;                       // _cfa_ffffeb20
    char* _v5348;                          // _cfa_ffffeb1c
    intOrPtr _v5352;                       // _cfa_ffffeb18
    _unknown_ __ebx;                       // r1
    char __edi;                            // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t46;                        // _t46
    intOrPtr* _t47;                        // _t47
    intOrPtr _t59;                         // _t59
    intOrPtr* _t64;                        // _t64
    _unknown_ _t68;                        // _t68
    _unknown_ _t69;                        // _t69
    char* _t73;                            // _t73

    __i686.get_pc_thunk.bx();
    _t69 = _t68 + 87539;
    _t47 =  *((intOrPtr*)(_t69 + -24));
    __edi =  *_t47;
    _v32 = 0;
    _v36 = 0;
    _v40 = 0;
    _v72 = __edi;
     *_t47 =  &_v72;
    _v64 = 1;
    _v68 = 3;
    _v60 =  &_v32;
    _v56 =  &_v36;
    _v52 =  &_v40;
    _v5348 =  &_v188;
    _t73 =  &_v184;
    _v5352 = _t73;
     *__esp = _a4;
    get_sockaddr(_a4, _t69, __edi, _t73);
    _v5312 = caml_convert_flag_list(_a8, _t69 + 25996);
    caml_enter_blocking_section();
    _v5332 = _v5312;
    _v5336 = 1024;
    _v5340 =  &_v5308;
    _v5344 = 4096;
    _v5348 =  &_v4284;
    _t59 = _v188;
    _v5352 = _t59;
     *__esp = _t73;
    getnameinfo();
    _t74 = _t59;
    caml_leave_blocking_section();
    if(_t59 != 0) {
        caml_raise_not_found();
    }
    _v32 = caml_copy_string(_t69, __edi, _t74,  &_v4284);
    _v36 = caml_copy_string(_t69, __edi, _t74,  &_v5308);
    _t64 = caml_alloc_small(_t69, _t74, 2, 0);
    _v40 = _t64;
     *_t64 = _v32;
     *((intOrPtr*)(_v40 + 4)) = _v36;
     *((intOrPtr*)( *((intOrPtr*)(_t69 + -24)))) = __edi;
    return _v40;
}

unix_getpeername(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08058208
    char _v124;                            // _cfa_ffffff84
    char _v128;                            // _cfa_ffffff80
    char* _v148;                           // _cfa_ffffff6c
    char* _v152;                           // _cfa_ffffff68
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t16;                       // _t16
    _unknown_ _t20;                        // _t20
    _unknown_ _t21;                        // _t21
    _unknown_ _t22;                        // _t22

    __i686.get_pc_thunk.bx();
    _t22 = _t21 + 87213;
    _v128 = 112;
    _v148 =  &_v128;
    _v152 =  &_v124;
    _t16 = _a4 >> 1;
     *__esp = _t16;
    getpeername();
    if(_t16 == 255) {
        _v152 = 0;
        uerror(_t22 + -9527, _t22, __esi, _t22 + -9527);
    }
    alloc_sockaddr( ?_? ( &_v124), _t22, __edi, __esi,  &_v124, _v128, -1);
    return;
}

unix_getpid(
    _unknown_ __eax                        // r0
)
{// addr = 0x08058280
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3
    _unknown_ _t6;                         // _t6
    _unknown_ _t7;                         // _t7

    __i686.get_pc_thunk.bx();
    return getpid() + _t4 + 1;
}

unix_getppid(
    _unknown_ __eax                        // r0
)
{// addr = 0x080582A4
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3
    _unknown_ _t6;                         // _t6
    _unknown_ _t7;                         // _t7

    __i686.get_pc_thunk.bx();
    return getppid() + _t4 + 1;
}

alloc_proto_entry(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi                         // r5
)
{// addr = 0x080582D0
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v32;                             // _cfa_ffffffe0
    char _v36;                             // _cfa_ffffffdc
    char* _v52;                            // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    char _v68;                             // _cfa_ffffffbc
    _unknown_ _v88;                        // _cfa_ffffffa8
    _unknown_ __ebp;                       // r6
    intOrPtr _t37;                         // _t37
    intOrPtr* _t38;                        // _t38
    intOrPtr _t39;                         // _t39
    _unknown_ _t41;                        // _t41
    intOrPtr* _t48;                        // _t48
    _unknown_ _t49;                        // _t49
    intOrPtr* _t51;                        // _t51
    _unknown_ _t52;                        // _t52

    _t39 = __ebx;
    _v16 = _t39;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx();
    _t40 = _t39 + 87008;
    _t51 = __eax;
    _v32 = 1;
    _v36 = 1;
    _t48 =  *((intOrPtr*)(_t39 + 0x153c8));
    _v68 =  *_t48;
     *_t48 =  &_v68;
    _v60 = 1;
    _v64 = 2;
    _v56 =  &_v32;
    _v52 =  &_v36;
    _v32 = caml_copy_string(_t40, _t48, _t51,  *_t51);
    _t37 =  *((intOrPtr*)(_t51 + 4));
    caml_copy_string_array(_t37);
    _v36 = _t37;
    _t38 = caml_alloc_small(_t40, _t51, 3, 0);
     *_t38 = _v32;
     *((intOrPtr*)(_t38 + 4)) = _v36;
     *((intOrPtr*)(_t38 + 8)) =  *((intOrPtr*)(_t51 + 8)) +  *((intOrPtr*)(_t51 + 8)) + 1;
     *_t48 = _v68;
    return;
}

unix_getprotobynumber(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805837A
    _unknown_ __ebp;                       // r6
    signed int _t3;                        // _t3
    _unknown_ _t4;                         // _t4
    intOrPtr _t5;                          // _t5

    __i686.get_pc_thunk.bx();
    _t5 = _t4 + 86846;
    _t3 = _a4 >> 1;
     *__esp = _t3;
    getprotobynumber();
    if(_t3 == 0) {
        caml_raise_not_found();
    }
    alloc_proto_entry(_t3, _t5, __edi, __esi);
    return;
}

unix_getprotobyname(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x080583AD
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2
    intOrPtr _t3;                          // _t3

    __i686.get_pc_thunk.bx();
    _t3 = _t2 + 86795;
    __eax = _a4;
     *__esp = __eax;
    getprotobyname();
    if(__eax == 0) {
        caml_raise_not_found();
    }
    alloc_proto_entry(__eax, _t3, __edi, __esi);
    return;
}

alloc_passwd_entry(
    intOrPtr* __eax                        // r0
)
{// addr = 0x080583E0
    char _v32;                             // _cfa_ffffffe0
    char _v36;                             // _cfa_ffffffdc
    char _v40;                             // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    char _v48;                             // _cfa_ffffffd0
    char* _v52;                            // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    char* _v60;                            // _cfa_ffffffc4
    char* _v64;                            // _cfa_ffffffc0
    char* _v68;                            // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    intOrPtr _v76;                         // _cfa_ffffffb4
    char _v80;                             // _cfa_ffffffb0
    _unknown_ _v104;                       // _cfa_ffffff98
    _unknown_ __ebx;                       // r1
    intOrPtr* __edi;                       // r4
    intOrPtr* __esi;                       // r5
    _unknown_ __ebp;                       // r6
    intOrPtr* _t67;                        // _t67
    _unknown_ _t68;                        // _t68

    __i686.get_pc_thunk.bx();
    _t69 = _t68 + 86742;
    __esi = __eax;
    _v32 = 1;
    _v36 = 1;
    _v40 = 1;
    _v44 = 1;
    _v48 = 1;
    __edi =  *((intOrPtr*)(_t68 + 0x152be));
    _v80 =  *__edi;
     *__edi =  &_v80;
    _v72 = 1;
    _v76 = 5;
    _v68 =  &_v32;
    _v64 =  &_v36;
    _v60 =  &_v40;
    _v56 =  &_v44;
    _v52 =  &_v48;
    _v32 = caml_copy_string(_t69, __edi, __esi,  *__esi);
    _v36 = caml_copy_string(_t69, __edi, __esi,  *((intOrPtr*)(__esi + 4)));
    _v40 = caml_copy_string(_t69, __edi, __esi,  *((intOrPtr*)(__esi + 16)));
    _v44 = caml_copy_string(_t69, __edi, __esi,  *((intOrPtr*)(__esi + 20)));
    _v48 = caml_copy_string(_t69, __edi, __esi,  *((intOrPtr*)(__esi + 24)));
    _t67 = caml_alloc_small(_t69, __esi, 7, 0);
     *_t67 = _v32;
     *((intOrPtr*)(_t67 + 4)) = _v36;
     *((intOrPtr*)(_t67 + 8)) =  *((intOrPtr*)(__esi + 8)) +  *((intOrPtr*)(__esi + 8)) + 1;
     *((intOrPtr*)(_t67 + 12)) =  *((intOrPtr*)(__esi + 12)) +  *((intOrPtr*)(__esi + 12)) + 1;
     *((intOrPtr*)(_t67 + 16)) = _v40;
     *((intOrPtr*)(_t67 + 20)) = _v44;
     *((intOrPtr*)(_t67 + 24)) = _v48;
     *__edi = _v80;
    return;
}

unix_getpwuid(
    signed int _a4                         // _cfa_4
)
{// addr = 0x080584EC
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t3;                        // _t3
    _unknown_ _t4;                         // _t4
    _unknown_ _t5;                         // _t5

    __i686.get_pc_thunk.bx();
    _t3 = _a4 >> 1;
     *__esp = _t3;
    getpwuid();
    if(_t3 == 0) {
        caml_raise_not_found();
    }
    alloc_passwd_entry(_t3);
    return;
}

unix_getpwnam(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x0805851F
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2
    _unknown_ _t3;                         // _t3

    __i686.get_pc_thunk.bx();
    __eax = _a4;
     *__esp = __eax;
    getpwnam();
    if(__eax == 0) {
        caml_raise_not_found();
    }
    alloc_passwd_entry(__eax);
    return;
}

unix_gettimeofday()
{// addr = 0x08058550
    char _v20;                             // _cfa_ffffffec
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    char* _t5;                             // _t5
    _unknown_ _t6;                         // _t6
    _unknown_ _t8;                         // _t8
    _unknown_ _t9;                         // _t9
    _unknown_ _t10;                        // _t10

    __i686.get_pc_thunk.bx();
    _t10 = _t9 + 86376;
    _v40 = 0;
    _t5 =  &_v20;
     *__esp = _t5;
    gettimeofday();
    if(_t5 == 255) {
        _v40 = 0;
        uerror(_t10 + -9515, _t10, __esi, _t10 + -9515);
    }
    asm("fild dword [ebp-0x10]");
    asm("fild dword [ebp-0xc]");
    asm("fdiv dword [ebx+0xffffdae4]");
    asm("faddp st1, st0");
    asm("fstp qword [esp]");
    caml_copy_double();
    return;
}

alloc_service_entry(
    intOrPtr* __eax                        // r0
)
{// addr = 0x080585B0
    char _v32;                             // _cfa_ffffffe0
    char _v36;                             // _cfa_ffffffdc
    char _v40;                             // _cfa_ffffffd8
    char* _v52;                            // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    char* _v60;                            // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    intOrPtr _v68;                         // _cfa_ffffffbc
    char _v72;                             // _cfa_ffffffb8
    _unknown_ _v88;                        // _cfa_ffffffa8
    _unknown_ __ebx;                       // r1
    intOrPtr* __edi;                       // r4
    intOrPtr* __esi;                       // r5
    _unknown_ __ebp;                       // r6
    intOrPtr _t41;                         // _t41
    intOrPtr* _t44;                        // _t44
    _unknown_ _t45;                        // _t45

    __i686.get_pc_thunk.bx();
    _t46 = _t45 + 86278;
    __esi = __eax;
    _v32 = 1;
    _v36 = 1;
    _v40 = 1;
    __edi =  *((intOrPtr*)(_t45 + 0x150ee));
    _v72 =  *__edi;
     *__edi =  &_v72;
    _v64 = 1;
    _v68 = 3;
    _v60 =  &_v32;
    _v56 =  &_v36;
    _v52 =  &_v40;
    _v32 = caml_copy_string(_t45 + 86278, __edi, __esi,  *__esi);
    _t41 =  *((intOrPtr*)(__esi + 4));
    caml_copy_string_array(_t41);
    _v36 = _t41;
    _v40 = caml_copy_string(_t45 + 86278, __edi, __esi,  *((intOrPtr*)(__esi + 12)));
    _t44 = caml_alloc_small(_t46, __esi, 4, 0);
     *_t44 = _v32;
     *((intOrPtr*)(_t44 + 4)) = _v36;
    asm("ror dx, 0x8");
     *((intOrPtr*)(_t44 + 8)) = ( *(__esi + 8) & 0xffff) + ( *(__esi + 8) & 0xffff) + 1;
     *((intOrPtr*)(_t44 + 12)) = _v40;
     *__edi = _v72;
    return;
}

unix_getservbyport(
    signed int _a4,                        // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08058677
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t9;                        // _t9
    _unknown_ _t10;                        // _t10
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13

    __i686.get_pc_thunk.bx();
    asm("ror ax, 0x8");
    _v24 = _a8;
    _t9 = _a4 >> 1 & 0xffff;
     *__esp = _t9;
    getservbyport();
    if(_t9 == 0) {
        caml_raise_not_found();
    }
    alloc_service_entry(_t9);
    return;
}

unix_getservbyname(
    intOrPtr* _a4,                         // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080586BB
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    intOrPtr* _t5;                         // _t5
    _unknown_ _t6;                         // _t6
    _unknown_ _t7;                         // _t7

    __i686.get_pc_thunk.bx();
    _v24 = _a8;
    _t5 = _a4;
     *__esp = _t5;
    getservbyname();
    if(_t5 == 0) {
        caml_raise_not_found();
    }
    alloc_service_entry(_t5);
    return;
}

unix_getsockname(
    signed int _a4                         // _cfa_4
)
{// addr = 0x080586F4
    char _v124;                            // _cfa_ffffff84
    char _v128;                            // _cfa_ffffff80
    char* _v148;                           // _cfa_ffffff6c
    char* _v152;                           // _cfa_ffffff68
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t16;                       // _t16
    _unknown_ _t20;                        // _t20
    _unknown_ _t21;                        // _t21
    _unknown_ _t22;                        // _t22

    __i686.get_pc_thunk.bx();
    _t22 = _t21 + 85953;
    _v128 = 112;
    _v148 =  &_v128;
    _v152 =  &_v124;
    _t16 = _a4 >> 1;
     *__esp = _t16;
    getsockname();
    if(_t16 == 255) {
        _v152 = 0;
        uerror(_t22 + -9496, _t22, __esi, _t22 + -9496);
    }
    alloc_sockaddr( ?_? ( &_v124), _t22, __edi, __esi,  &_v124, _v128, -1);
    return;
}

unix_getuid(
    _unknown_ __eax                        // r0
)
{// addr = 0x0805876C
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3
    _unknown_ _t6;                         // _t6
    _unknown_ _t7;                         // _t7

    __i686.get_pc_thunk.bx();
    return getuid() + _t4 + 1;
}

alloc_tm(
    intOrPtr* __eax                        // r0
)
{// addr = 0x08058790
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    intOrPtr* __esi;                       // r5
    _unknown_ __ebp;                       // r6
    intOrPtr* _t35;                        // _t35
    _unknown_ _t36;                        // _t36
    signed int _t53;                       // _t53

    __i686.get_pc_thunk.bx();
    __esi = __eax;
    _t35 = caml_alloc_small(_t36 + 85799, __esi, 9, 0);
     *_t35 =  *__esi +  *__esi + 1;
     *((intOrPtr*)(_t35 + 4)) =  *((intOrPtr*)(__esi + 4)) +  *((intOrPtr*)(__esi + 4)) + 1;
     *((intOrPtr*)(_t35 + 8)) =  *((intOrPtr*)(__esi + 8)) +  *((intOrPtr*)(__esi + 8)) + 1;
     *((intOrPtr*)(_t35 + 12)) =  *((intOrPtr*)(__esi + 12)) +  *((intOrPtr*)(__esi + 12)) + 1;
     *((intOrPtr*)(_t35 + 16)) =  *((intOrPtr*)(__esi + 16)) +  *((intOrPtr*)(__esi + 16)) + 1;
     *((intOrPtr*)(_t35 + 20)) =  *((intOrPtr*)(__esi + 20)) +  *((intOrPtr*)(__esi + 20)) + 1;
     *((intOrPtr*)(_t35 + 24)) =  *((intOrPtr*)(__esi + 24)) +  *((intOrPtr*)(__esi + 24)) + 1;
    _t53 =  *((intOrPtr*)(__esi + 28)) +  *((intOrPtr*)(__esi + 28)) + 1;
     *(_t35 + 28) = _t53;
    asm("sbb edx, edx");
     *((intOrPtr*)(_t35 + 32)) = (_t53 & 254) + 3;
    return;
}

unix_mktime(
    _unknown_ __eax,                       // r0
    signed int* _a4                        // _cfa_4
)
{// addr = 0x0805881D
    intOrPtr _v24;                         // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    char _v56;                             // _cfa_ffffffc8
    char* _v60;                            // _cfa_ffffffc4
    char* _v64;                            // _cfa_ffffffc0
    char* _v80;                            // _cfa_ffffffb0
    char* _v84;                            // _cfa_ffffffac
    char* _v88;                            // _cfa_ffffffa8
    intOrPtr _v92;                         // _cfa_ffffffa4
    char _v96;                             // _cfa_ffffffa0
    char* _v112;                           // _cfa_ffffff90
    intOrPtr _v132;                        // _cfa_ffffff7c
    intOrPtr _v136;                        // _cfa_ffffff78
    _unknown_ __ebx;                       // r1
    char* __esi;                           // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t43;                        // _t43
    signed int* _t44;                      // _t44
    char* _t47;                            // _t47
    char* _t48;                            // _t48
    char** _t50;                           // _t50
    _unknown_ _t52;                        // _t52
    _unknown_ _t53;                        // _t53
    _unknown_ _t54;                        // _t54
    intOrPtr* _t58;                        // _t58

    __esp =  &((__esp)[0xffffffffffffffe0]);
    __i686.get_pc_thunk.bx();
    _t54 = _t53 + 85658;
    _t44 = _a4;
    _v60 = 1;
    _v64 = 1;
    _t58 =  *((intOrPtr*)(_t54 + -24));
    _v96 =  *_t58;
     *_t58 =  &_v96;
    _v88 = 1;
    _v92 = 2;
    _v84 =  &_v60;
    _v80 =  &_v64;
    _v56 =  *_t44 >> 1;
    _v52 = _t44[1] >> 1;
    _v48 = _t44[2] >> 1;
    _v44 = _t44[3] >> 1;
    _v40 = _t44[4] >> 1;
    _v36 = _t44[5] >> 1;
    _v32 = _t44[6] >> 1;
    _v28 = _t44[7] >> 1;
    _v24 = -1;
    _t47 =  &_v56;
     *__esp = _t47;
    mktime();
    __esi = _t47;
    if(_t47 == 255) {
        _v132 = 0;
        _v136 = _t54 + -9484;
        unix_error(_t54 + -9484, _t54, __esi, 34);
    }
    _t48 =  &_v56;
    alloc_tm(_t48);
    _v60 = _t48;
    _v112 = __esi;
    asm("fild dword [ebp-0x6c]");
    asm("fstp qword [esp]");
    _v64 = caml_copy_double();
    _t50 = caml_alloc_small(_t54, __esi, 2, 0);
     *_t50 = _v64;
    _t50[1] = _v60;
     *((intOrPtr*)( *((intOrPtr*)(_t54 + -24)))) = _v96;
    __esp = __esp - 128;
    return;
}

unix_localtime(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x0805892E
    char _v16;                             // _cfa_fffffff0
    signed short _v30;                     // _cfa_ffffffe2
    signed int _v32;                       // _cfa_ffffffe0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t12;                        // _t12
    intOrPtr* _t14;                        // _t14
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17

    __i686.get_pc_thunk.bx();
    _t17 = _t16 + 85386;
    asm("fld qword [eax]");
    asm("fnstcw word [ebp-0x1a]");
    _v32 = _v30 & 0xffff;
    asm("fldcw word [ebp-0x1c]");
    asm("fistp dword [ebp-0xc]");
    asm("fldcw word [ebp-0x1a]");
    _t14 =  &_v16;
     *__esp = _t14;
    localtime();
    if(_t14 == 0) {
        _v52 = 0;
        _v56 = _t17 + -9477;
        _t14 = unix_error(_t17 + -9477, _t17, __esi, 22);
    }
    alloc_tm(_t14);
    return;
}

unix_gmtime(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08058993
    char _v16;                             // _cfa_fffffff0
    signed short _v30;                     // _cfa_ffffffe2
    signed int _v32;                       // _cfa_ffffffe0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t12;                        // _t12
    intOrPtr* _t14;                        // _t14
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17

    __i686.get_pc_thunk.bx();
    _t17 = _t16 + 85285;
    asm("fld qword [eax]");
    asm("fnstcw word [ebp-0x1a]");
    _v32 = _v30 & 0xffff;
    asm("fldcw word [ebp-0x1c]");
    asm("fistp dword [ebp-0xc]");
    asm("fldcw word [ebp-0x1a]");
    _t14 =  &_v16;
     *__esp = _t14;
    gmtime();
    if(_t14 == 0) {
        _v52 = 0;
        _v56 = _t17 + -9467;
        _t14 = unix_error(_t17 + -9467, _t17, __esi, 22);
    }
    alloc_tm(_t14);
    return;
}

unix_initgroups(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x080589F8
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    intOrPtr _t8;                          // _t8
    _unknown_ _t9;                         // _t9
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13

    __i686.get_pc_thunk.bx();
    _t13 = _t12 + 85184;
    _v24 = _a8 >> 1;
    _t8 = _a4;
     *__esp = _t8;
    initgroups();
    if(_t8 == 255) {
        _v24 = 0;
        uerror(_t13 + -9460, _t13, __esi, _t13 + -9460);
    }
    return 1;
}

unix_isatty(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08058A44
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t4;                        // _t4
    _unknown_ _t7;                         // _t7
    _unknown_ _t8;                         // _t8

    __i686.get_pc_thunk.bx();
    _t4 = isatty(_a4 >> 1);
    asm("sbb eax, eax");
    return (_t4 & 254) + 3;
}

unix_convert_itimer(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __esi                         // r5
)
{// addr = 0x08058A74
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    _unknown_ _t10;                        // _t10
    _unknown_ _t13;                        // _t13

    _t8 = __ebx;
    _v12 = __ebx;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    caml_alloc_small(_t8 + 85055, __eax, 4, 254);
    asm("fild dword [esi]");
    asm("fild dword [esi+0x4]");
    asm("fld dword [ebx+0xffffdae4]");
    asm("fdiv st1, st0");
    asm("fxch st0, st1");
    asm("faddp st2, st0");
    asm("fxch st0, st1");
    asm("fstp qword [eax]");
    asm("fild dword [esi+0x8]");
    asm("fild dword [esi+0xc]");
    asm("fdivrp st2, st0");
    asm("faddp st1, st0");
    asm("fstp qword [eax+0x8]");
    return;
}

unix_getitimer(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08058ACD
    char _v28;                             // _cfa_ffffffe4
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    intOrPtr _t13;                         // _t13
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17

    __i686.get_pc_thunk.bx();
    _t18 = _t17 + 84971;
    _v40 =  &_v28;
    _t13 =  *((intOrPtr*)(_t17 + 84971 + -9428 + (_a4 >> 1) * 4));
     *__esp = _t13;
    getitimer();
    if(_t13 == 255) {
        _v40 = 0;
        uerror(_t18 + -9449, _t18, __esi, _t18 + -9449);
    }
    unix_convert_itimer( &_v28, _t18, __esi);
    return;
}

unix_set_timeval(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi                         // r5
)
{// addr = 0x08058B23
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v36;                             // _cfa_ffffffdc
    signed int _v46;                       // _cfa_ffffffd2
    signed int _v48;                       // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    char* _v68;                            // _cfa_ffffffbc
    _unknown_ __ebp;                       // r6
    intOrPtr _t29;                         // _t29
    _unknown_ _t31;                        // _t31
    _unknown_ _t32;                        // _t32
    intOrPtr _t34;                         // _t34
    _unknown_ _t35;                        // _t35
    intOrPtr* _t38;                        // _t38
    _unknown_ _t39;                        // _t39

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx();
    _t38 = __eax;
    _v68 =  &_v36;
    asm("fld qword [ebp+0x8]");
    asm("fstp qword [esp]");
    modf();
    asm("fnstcw word [ebp-0x2a]");
    _v48 = _v46 & 0xffff;
    asm("fld qword [ebp-0x20]");
    asm("fldcw word [ebp-0x2c]");
    asm("fistp dword [ebp-0x30]");
    asm("fldcw word [ebp-0x2a]");
    _t34 = _v52;
     *_t38 = _t34;
    asm("fmul dword [ebx+0xffffdae4]");
    asm("fstp qword [esp]");
    ceil();
    asm("fnstcw word [ebp-0x2a]");
    _v48 = _v46 & 0xffff;
    asm("fldcw word [ebp-0x2c]");
    asm("fistp dword [ebp-0x30]");
    asm("fldcw word [ebp-0x2a]");
    _t29 = _v52;
     *((intOrPtr*)(_t38 + 4)) = _t29;
    if(_t29 > 999999) {
         *_t38 = _t34 + 1;
         *((intOrPtr*)(_t38 + 4)) = 0;
    }
    return;
}

unix_setitimer(
    intOrPtr __edi,                        // r4
    signed int _a4,                        // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08058BB9
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v36;                             // _cfa_ffffffdc
    char _v44;                             // _cfa_ffffffd4
    char _v60;                             // _cfa_ffffffc4
    char* _v68;                            // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    intOrPtr _t25;                         // _t25
    _unknown_ _t28;                        // _t28
    intOrPtr _t29;                         // _t29
    intOrPtr _t30;                         // _t30
    _unknown_ _t31;                        // _t31
    intOrPtr* _t33;                        // _t33
    _unknown_ _t34;                        // _t34
    intOrPtr _t35;                         // _t35
    _unknown_ _t37;                        // _t37

    _v16 = _t29;
    _v12 = _t35;
    _v8 = __edi;
    __i686.get_pc_thunk.bx();
    _t30 = _t29 + 84727;
    _t36 = _a8;
    _t33 =  &_v44;
    asm("fld qword [esi]");
    asm("fstp qword [esp]");
    unix_set_timeval(_t33, _t30, _t33, _a8);
    asm("fld qword [esi+0x8]");
    asm("fstp qword [esp]");
    unix_set_timeval( &_v36, _t30, _t33, _a8);
    _v68 =  &_v60;
    _v72 = _t33;
    _t25 =  *((intOrPtr*)(_t30 + -9428 + (_a4 >> 1) * 4));
     *__esp = _t25;
    setitimer();
    if(_t25 == 255) {
        _v72 = 0;
        uerror(_t30 + -9439, _t30, _t36, _t30 + -9439);
    }
    unix_convert_itimer( &_v60, _t30, _t36);
    return;
}

unix_kill(
    _unknown_ __eax,                       // r0
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08058C44
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t6;                         // _t6
    signed int _t11;                       // _t11
    _unknown_ _t12;                        // _t12
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    _unknown_ _t16;                        // _t16

    __i686.get_pc_thunk.bx();
    _t16 = _t15 + 84596;
    _v24 = caml_convert_signal_number(_a8 >> 1);
    _t11 = _a4 >> 1;
     *__esp = _t11;
    kill();
    if(_t11 == 255) {
        _v24 = 0;
        uerror(_t16 + -9416, _t16, __esi, _t16 + -9416);
    }
    return 1;
}

unix_link(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    char* _a4,                             // _cfa_4
    char* _a8                              // _cfa_8
)
{// addr = 0x08058C9C
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char* _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t12;                        // _t12
    _unknown_ _t14;                        // _t14
    intOrPtr _t15;                         // _t15
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17
    char* _t19;                            // _t19
    _unknown_ _t20;                        // _t20

    _t15 = __ebx;
    _v12 = _t15;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t16 = _t15 + 84503;
    _t19 = _a8;
    if(link(_a4, _t19) == 255) {
        _v24 = _t19;
        uerror(_t16 + -9320, _t16, _t19, _t16 + -9320);
    }
    return 1;
}

unix_listen(
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08058CEC
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t9;                        // _t9
    _unknown_ _t10;                        // _t10
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14

    __i686.get_pc_thunk.bx();
    _t14 = _t13 + 84428;
    _v24 = _a8 >> 1;
    _t9 = _a4 >> 1;
     *__esp = _t9;
    listen();
    if(_t9 == 255) {
        _v24 = 0;
        uerror(_t14 + -9411, _t14, __esi, _t14 + -9411);
    }
    return 1;
}

unix_lockf(
    _unknown_ __eflags,                    // r9
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x08058D3C
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    short _v34;                            // _cfa_ffffffde
    signed int _v56;                       // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t19;                       // _t19
    _unknown_ _t24;                        // _t24
    _unknown_ _t25;                        // _t25
    signed int _t26;                       // _t26
    _unknown_ _t27;                        // _t27
    _unknown_ _t28;                        // _t28
    _unknown_ _t32;                        // _t32
    signed int _t38;                       // _t38

    __i686.get_pc_thunk.bx();
    _t28 = _t27 + 84347;
    _t38 = _a4 >> 1;
    _v34 = 1;
    _t19 = _a12 >> 1;
    if(__eflags >= 0) {
        _v32 = 0;
        _v28 = 0;
        _v24 = _t19;
        _v20 = _t19 >> 31;
    } else {
        _v32 = _t19;
        _v28 = _t19 >> 31;
        _t26 =  ~_t19;
        _v24 = _t26;
        _v20 = _t26 >> 31;
    }
    if(_a8 >> 1 <= 5) {
        goto __edx;
    }
     *(__errno_location()) = 22;
    _v56 = 0;
    uerror(_t28 + -9404, _t28, _t38, _t28 + -9404);
    return 1;
}

unix_lseek_64(
    intOrPtr __ebx,                        // r1
    signed int __edx,                      // r3
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x08058EF8
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    intOrPtr _t21;                         // _t21
    signed int _t26;                       // _t26
    intOrPtr _t30;                         // _t30
    _unknown_ _t32;                        // _t32
    signed int _t35;                       // _t35
    _unknown_ _t36;                        // _t36
    signed int _t39;                       // _t39
    _unknown_ _t40;                        // _t40

    __edx = __edx;
    _t30 = __ebx;
    _v16 = _t30;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx();
    _t31 = _t30 + 83896;
    _t21 = _a8;
    caml_enter_blocking_section();
    _v32 =  *((intOrPtr*)(_t30 + 83896 + -9392 + (_a12 >> 1) * 4));
    _v40 =  *((intOrPtr*)(_t21 + 4));
    _v36 =  *((intOrPtr*)(_t21 + 8));
    _t26 = _a4 >> 1;
     *__esp = _t26;
    lseek64();
    _t39 = _t26;
    _t35 = __edx;
    caml_leave_blocking_section();
    _t28 = _t39 & _t35;
    if((_t39 & _t35) == 255) {
        _v40 = 0;
        _t28 = uerror(_t31 + -9398, _t31, _t39, _t31 + -9398);
    }
    caml_copy_int64(_t28, _t31, _t39, _t39, _t35);
    return;
}

unix_lseek(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x08058F86
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    signed int _t27;                       // _t27
    signed int _t29;                       // _t29
    _unknown_ _t34;                        // _t34
    _unknown_ _t36;                        // _t36
    intOrPtr _t37;                         // _t37
    _unknown_ _t38;                        // _t38
    _unknown_ _t39;                        // _t39
    signed int _t41;                       // _t41
    signed int _t43;                       // _t43
    _unknown_ _t44;                        // _t44
    signed int _t46;                       // _t46
    _unknown_ _t47;                        // _t47

    _t37 = __ebx;
    _v16 = _t37;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx();
    _t38 = _t37 + 83754;
    caml_enter_blocking_section();
    _v32 =  *((intOrPtr*)(_t38 + -9392 + (_a12 >> 1) * 4));
    _t27 = _a8 >> 1;
    _v40 = _t27;
    _t41 = _t27 >> 31;
    _v36 = _t41;
    _t29 = _a4 >> 1;
     *__esp = _t29;
    lseek64();
    _t43 = _t29;
    _t46 = _t41;
    caml_leave_blocking_section();
    if((_t43 & _t46) == 255) {
        _v40 = 0;
        uerror(_t38 + -9398, _t38, _t46, _t38 + -9398);
    }
    if(_t46 < 0 && (_t46 > 0 || _t43 > 1073741823)) {
        _v36 = 0;
        _v40 = _t38 + -9398;
        unix_error(_t38 + -9398, _t38, _t46, 75);
    }
    return _t43 + _t43 + 1;
}

unix_mkdir(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0805903C
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    signed int _t11;                       // _t11
    _unknown_ _t12;                        // _t12
    _unknown_ _t14;                        // _t14
    intOrPtr _t15;                         // _t15
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17
    signed int _t19;                       // _t19
    _unknown_ _t20;                        // _t20

    _t15 = __ebx;
    _v12 = _t15;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t16 = _t15 + 83575;
    _t19 = _a4;
    _t11 = _a8 >> 1;
    _v24 = _t11;
     *__esp = _t19;
    mkdir();
    if(_t11 == 255) {
        _v24 = _t19;
        uerror(_t16 + -9380, _t16, _t19, _t16 + -9380);
    }
    return 1;
}

unix_mkfifo(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08059090
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    signed int _t11;                       // _t11
    _unknown_ _t12;                        // _t12
    _unknown_ _t14;                        // _t14
    intOrPtr _t15;                         // _t15
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17
    signed int _t19;                       // _t19
    _unknown_ _t20;                        // _t20

    _t15 = __ebx;
    _v12 = _t15;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t16 = _t15 + 83491;
    _t19 = _a4;
    _t11 = _a8 >> 1;
    _v24 = _t11;
     *__esp = _t19;
    mkfifo();
    if(_t11 == 255) {
        _v24 = _t19;
        uerror(_t16 + -9374, _t16, _t19, _t16 + -9374);
    }
    return 1;
}

unix_nice(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    signed int _a4                         // _cfa_4
)
{// addr = 0x080590E4
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    int _v24;                              // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t10;                        // _t10
    int* _t11;                             // _t11
    int _t14;                              // _t14
    intOrPtr _t17;                         // _t17
    _unknown_ _t18;                        // _t18
    _unknown_ _t19;                        // _t19
    int* _t21;                             // _t21
    _unknown_ _t22;                        // _t22

    _t17 = __ebx;
    _v12 = _t17;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t18 = _t17 + 83407;
    _t11 = __errno_location();
    _t21 = _t11;
     *_t11 = 0;
    _t14 = nice(_a4 >> 1);
    if(_t14 == 255 &&  *_t21 != 0) {
        _v24 = 0;
        _t14 = uerror(_t18 + -9367, _t18, _t21, _t18 + -9367);
    }
    return _t14 + _t14 + 1;
}

unix_open(
    _unknown_ __eax,                       // r0
    char* _a4,                             // _cfa_4
    char _a8,                              // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x08059144
    char* _v40;                            // _cfa_ffffffd8
    char* _v44;                            // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v84;                       // _cfa_ffffffac
    signed int _v88;                       // _cfa_ffffffa8
    _unknown_ __ebx;                       // r1
    char __edi;                            // r4
    char* __esi;                           // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t32;                        // _t32
    intOrPtr* _t33;                        // _t33
    char* _t42;                            // _t42
    _unknown_ _t44;                        // _t44
    signed int _t46;                       // _t46
    _unknown_ _t51;                        // _t51
    _unknown_ _t52;                        // _t52
    _unknown_ _t53;                        // _t53

    __i686.get_pc_thunk.bx();
    _t53 = _t52 + 83314;
    _t33 =  *((intOrPtr*)(_t53 + -24));
    __edi =  *_t33;
    _v60 = __edi;
     *_t33 =  &_v60;
    _v52 = 1;
    _v56 = 3;
    _v48 =  &_a4;
    _v44 =  &_a8;
    _v40 =  &_a12;
    _v64 = caml_convert_flag_list(_a8, _t53 + 26044);
    _t42 = caml_string_length(_a4) + 1;
    caml_stat_alloc(_t42);
    __esi = _t42;
    strcpy(__esi, _a4);
    caml_enter_blocking_section();
    _t46 = _a12 >> 1;
    _v84 = _t46;
    _v88 = _v64;
     *__esp = __esi;
    open64();
    _v64 = _t46;
    caml_leave_blocking_section();
    caml_stat_free(__esi);
    if(_v64 == 255) {
        _v88 = _a4;
        uerror(_t53 + -9362, _t53, __esi, _t53 + -9362);
    }
     *((intOrPtr*)( *((intOrPtr*)(_t53 + -24)))) = __edi;
    return _v64 + _v64 + 1;
}

unix_opendir(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08059228
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    intOrPtr _t11;                         // _t11
    _unknown_ _t14;                        // _t14
    intOrPtr _t15;                         // _t15
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17
    intOrPtr _t19;                         // _t19
    _unknown_ _t20;                        // _t20
    intOrPtr _t22;                         // _t22
    _unknown_ _t23;                        // _t23

    _t15 = __ebx;
    _t11 = __eax;
    _v16 = _t15;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx();
    _t16 = _t15 + 83080;
    _t19 = _a4;
     *__esp = _t19;
    opendir();
    _t22 = _t11;
    if(_t11 == 0) {
        _v40 = _t19;
        uerror(_t16 + -9357, _t16, _t22, _t16 + -9357);
    }
     *((intOrPtr*)(caml_alloc_small(_t16, _t22, 1, 251))) = _t22;
    return;
}

unix_pipe()
{// addr = 0x08059288
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    intOrPtr* _t14;                        // _t14
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17
    _unknown_ _t18;                        // _t18

    __i686.get_pc_thunk.bx();
    _t18 = _t17 + 82992;
    if(pipe( &_v20) == 255) {
        _v40 = 0;
        uerror(_t18 + -9349, _t18, __esi, _t18 + -9349);
    }
    _t14 = caml_alloc_small(_t18, __esi, 2, 0);
     *_t14 = _v20 + _v20 + 1;
     *((intOrPtr*)(_t14 + 4)) = _v16 + _v16 + 1;
    return;
}

unix_putenv(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    void* _a4,            // _cfa_4
    void* _a8             // _cfa_8
)
{// addr = 0x080592F0
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    int _v32;                              // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    _unknown_ _v52;                        // _cfa_ffffffcc
    void* _v56;           // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t27;                        // _t27
    int _t31;                              // _t31
    intOrPtr _t32;                         // _t32
    char* _t33;                            // _t33
    _unknown_ _t35;                        // _t35
    _unknown_ _t39;                        // _t39
    _unknown_ _t42;                        // _t42
    _unknown_ _t45;                        // _t45
    intOrPtr _t46;                         // _t46
    _unknown_ _t47;                        // _t47
    _unknown_ _t48;                        // _t48
    int _t50;                              // _t50
    _unknown_ _t51;                        // _t51
    char* _t53;                            // _t53
    _unknown_ _t54;                        // _t54

    _t46 = __ebx;
    _v16 = _t46;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx();
    _t47 = _t46 + 82880;
    _t50 = caml_string_length(_a4);
    _t31 = caml_string_length(_a8);
    _v32 = _t31;
    _t32 = _t31 + _t50;
    _v36 = _t32;
    _t33 = _t32 + 2;
    caml_stat_alloc(_t33);
    _t53 = _t33;
    memmove(_t53, _a4, _t50);
    _t53[_t50] = 61;
    memmove( &(_t53[_t50 + 1]), _a8, _v32);
    _t53[_v36 + 1] = 0;
    if(putenv(_t53) == 255) {
        _v56 = _a4;
        uerror(_t47 + -9344, _t47, _t53, _t47 + -9344);
    }
    return 1;
}

unix_read(
    signed int _a4,                        // _cfa_4
    char _a8,                              // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x080593A4
    void _v16396;                          // _cfa_ffffbff4
    char* _v16416;                         // _cfa_ffffbfe0
    intOrPtr _v16420;                      // _cfa_ffffbfdc
    intOrPtr _v16424;                      // _cfa_ffffbfd8
    char _v16428;                          // _cfa_ffffbfd4
    _unknown_ _v16436;                     // _cfa_ffffbfcc
    intOrPtr _v16440;                      // _cfa_ffffbfc8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    intOrPtr* _t25;                        // _t25
    _unknown_ _t27;                        // _t27
    _unknown_ _t36;                        // _t36
    _unknown_ _t40;                        // _t40
    _unknown_ _t41;                        // _t41
    _unknown_ _t42;                        // _t42
    int _t49;                              // _t49

    __i686.get_pc_thunk.bx();
    _t42 = _t41 + 82704;
    _t25 =  *((intOrPtr*)(_t42 + -24));
    _v16428 =  *_t25;
     *_t25 =  &_v16428;
    _v16420 = 1;
    _v16424 = 1;
    _v16416 =  &_a8;
    _t47 = _a16 >> 1;
    caml_enter_blocking_section();
    _t48 = _a16 >> 1 - 16384 > 0 ? 16384 : _t47;
    _t49 = read(_a4 >> 1,  &_v16396, _a16 >> 1 - 16384 > 0 ? 16384 : _t47);
    caml_leave_blocking_section();
    if(_t49 == 255) {
        _v16440 = 0;
        uerror(_t42 + -9337, _t42, _t49, _t42 + -9337);
    }
    memmove((_a12 >> 1) + _a8,  &_v16396, _t49);
     *((intOrPtr*)( *((intOrPtr*)(_t42 + -24)))) = _v16428;
    return _t49 + _t49 + 1;
}

unix_readdir(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x0805947C
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    intOrPtr _t6;                          // _t6
    _unknown_ _t8;                         // _t8
    _unknown_ _t10;                        // _t10
    _unknown_ _t11;                        // _t11

    __i686.get_pc_thunk.bx();
    _t11 = _t10 + 82492;
    _t6 =  *_a4;
    if(_t6 == 0) {
        _v20 = 0;
        _v24 = _t11 + -9332;
        _t6 = unix_error(_t11 + -9332, _t11, __esi, 9);
    }
     *__esp = _t6;
    readdir64();
    if(_t6 == 0) {
        caml_raise_end_of_file();
    }
    caml_copy_string(_t11, __edi, __esi, _t6 + 19);
    return;
}

unix_readlink(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    char* _a4                              // _cfa_4
)
{// addr = 0x080594D8
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char _v4108;                           // _cfa_ffffeff4
    _unknown_ _v4116;                      // _cfa_ffffefec
    char* _v4120;                          // _cfa_ffffefe8
    _unknown_ __ebp;                       // r6
    int _t15;                              // _t15
    _unknown_ _t17;                        // _t17
    intOrPtr _t19;                         // _t19
    _unknown_ _t20;                        // _t20
    _unknown_ _t21;                        // _t21
    char* _t23;                            // _t23
    _unknown_ _t24;                        // _t24

    _t19 = __ebx;
    _v12 = _t19;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t20 = _t19 + 82392;
    _t23 = _a4;
    _t15 = readlink(_t23,  &_v4108, 4095);
    if(_t15 == 255) {
        _v4120 = _t23;
        _t15 = uerror(_t20 + -9324, _t20, _t23, _t20 + -9324);
    }
     *((char*)(__ebp + _t15 + -4104)) = 0;
    caml_copy_string(_t20, __edi, _t23,  &_v4108);
    return;
}

unix_rename(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    char* _a4,                             // _cfa_4
    char* _a8                              // _cfa_8
)
{// addr = 0x08059548
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char* _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t12;                        // _t12
    _unknown_ _t14;                        // _t14
    intOrPtr _t15;                         // _t15
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17
    char* _t19;                            // _t19
    _unknown_ _t20;                        // _t20

    _t15 = __ebx;
    _v12 = _t15;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t16 = _t15 + 82283;
    _t19 = _a4;
    if(rename(_t19, _a8) == 255) {
        _v24 = _t19;
        uerror(_t16 + -9315, _t16, _t19, _t16 + -9315);
    }
    return 1;
}

unix_rewinddir(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x08059598
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    intOrPtr _t6;                          // _t6
    _unknown_ _t7;                         // _t7
    _unknown_ _t9;                         // _t9
    _unknown_ _t10;                        // _t10

    __i686.get_pc_thunk.bx();
    _t10 = _t9 + 82208;
    _t6 =  *_a4;
    if(_t6 == 0) {
        _v20 = 0;
        _v24 = _t10 + -9308;
        _t6 = unix_error(_t10 + -9308, _t10, __esi, 9);
    }
     *__esp = _t6;
    rewinddir();
    return 1;
}

unix_rmdir(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    char* _a4                              // _cfa_4
)
{// addr = 0x080595E4
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char* _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t8;                         // _t8
    _unknown_ _t10;                        // _t10
    _unknown_ _t12;                        // _t12
    intOrPtr _t13;                         // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    char* _t17;                            // _t17
    _unknown_ _t18;                        // _t18

    _t13 = __ebx;
    _v12 = _t13;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t14 = _t13 + 82127;
    _t17 = _a4;
    if(rmdir(_t17) == 255) {
        _v24 = _t17;
        uerror(_t14 + -9298, _t14, _t17, _t14 + -9298);
    }
    return 1;
}

fdlist_to_fdset(
    signed int* __eax,                     // r0
    void* __edx,          // r3
    signed int* _a4                        // _cfa_4
)
{// addr = 0x0805962C
    void* _v16;           // _cfa_fffffff0
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t16;                        // _t16
    signed int _t17;                       // _t17
    _unknown_ _t19;                        // _t19
    _unknown_ _t20;                        // _t20
    signed int* _t25;                      // _t25
    signed int* _t27;                      // _t27
    _unknown_ _t29;                        // _t29
    signed int _t30;                       // _t30
    _unknown_ _t33;                        // _t33
    signed int* _t36;                      // _t36

    _t36 = __eax;
    _v16 = __edx;
    asm("cld ");
    _t17 = memset(__edx, 0, 32 << 2);
    if(_t36 != 1) {
        _t27 = _t36;
        while(1) {
            _t30 =  *_t27;
            _t17 = _t30 >> 1;
            _t38 = _t17 >= 0 ? _t17 : _t17 + 31;
            _t39 = (_t17 >= 0 ? _t17 : _t17 + 31) >> 5;
            _v16[(_t17 >= 0 ? _t17 : _t17 + 31) >> 5] = _v16[(_t17 >= 0 ? _t17 : _t17 + 31) >> 5] | 1 << ((_t17 + (_t30 >> 31 >> 27) & 31) - (_t30 >> 31 >> 27) & 255);
            _t25 = _a4;
            if(_t17 >  *_t25) {
                 *_t25 = _t17;
            }
            _t27 = _t27[1];
            if(_t27 == 1) {
                break;
            }
        }
    }
    return;
}

fdset_to_fdlist(
    signed int* __eax,                     // r0
    _unknown_ __edx                        // r3
)
{// addr = 0x08059695
    signed int* _v32;                      // _cfa_ffffffe0
    char _v36;                             // _cfa_ffffffdc
    char* _v52;                            // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    char _v68;                             // _cfa_ffffffbc
    _unknown_ _v88;                        // _cfa_ffffffa8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int* _t29;                      // _t29
    _unknown_ _t34;                        // _t34
    intOrPtr* _t36;                        // _t36
    _unknown_ _t37;                        // _t37
    _unknown_ _t38;                        // _t38
    _unknown_ _t43;                        // _t43
    intOrPtr* _t45;                        // _t45
    signed int _t51;                       // _t51
    _unknown_ _t52;                        // _t52
    signed int _t56;                       // _t56
    signed int _t58;                       // _t58

    _t29 = __eax;
    __i686.get_pc_thunk.bx();
    _t38 = _t37 + 81953;
    _v36 = 1;
    _t45 =  *((intOrPtr*)(_t38 + -24));
    _v68 =  *_t45;
     *_t45 =  &_v68;
    _v60 = 1;
    _v64 = 2;
    _v56 =  &_v32;
    _v52 =  &_v36;
    if(_t29 != 1) {
        _v32 = _t29;
        while(1) {
            _t56 =  *_t29 >> 1;
            _t58 = _t56;
            _t50 = _t58 >= 0 ? _t56 : _t56 + 31;
            _t51 = (_t58 >= 0 ? _t56 : _t56 + 31) >> 5;
            asm("bt edx, ecx");
            if(_t58 < 0) {
                _t36 = caml_alloc_small(_t38, _t56, 2, 0);
                 *_t36 = _t56 + _t56 + 1;
                 *((intOrPtr*)(_t36 + 4)) = _v36;
                _v36 = _t36;
            }
            _t29 = _v32[1];
            if(_t29 == 1) {
                break;
            }
            _v32 = _t29;
        }
    }
     *((intOrPtr*)( *((intOrPtr*)(_t38 + -24)))) = _v68;
    return _v36;
}

unix_select(
    _unknown_ __eax,                       // r0
    _unknown_ __eflags,                    // r9
    _unknown_ _a4,                         // _cfa_4
    _unknown_ _a8,                         // _cfa_8
    _unknown_ _a12,                        // _cfa_c
    _unknown_ _a16                         // _cfa_10
)
{// addr = 0x08059754
    char _v140;                            // _cfa_ffffff74
    char _v268;                            // _cfa_fffffef4
    char _v396;                            // _cfa_fffffe74
    char _v400;                            // _cfa_fffffe70
    char _v408;                            // _cfa_fffffe68
    char* _v420;                           // _cfa_fffffe5c
    char* _v424;                           // _cfa_fffffe58
    char* _v428;                           // _cfa_fffffe54
    intOrPtr _v432;                        // _cfa_fffffe50
    intOrPtr _v436;                        // _cfa_fffffe4c
    char _v440;                            // _cfa_fffffe48
    signed short _v446;                    // _cfa_fffffe42
    signed int _v448;                      // _cfa_fffffe40
    char _v452;                            // _cfa_fffffe3c
    intOrPtr _v476;                        // _cfa_fffffe24
    char* _v480;                           // _cfa_fffffe20
    char* _v484;                           // _cfa_fffffe1c
    char* _v488;                           // _cfa_fffffe18
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t58;                        // _t58
    intOrPtr* _t59;                        // _t59
    _unknown_ _t66;                        // _t66
    intOrPtr _t71;                         // _t71
    intOrPtr* _t78;                        // _t78
    _unknown_ _t80;                        // _t80
    char _t82;                             // _t82
    _unknown_ _t83;                        // _t83
    _unknown_ _t84;                        // _t84
    char* _t98;                            // _t98
    _unknown_ _t100;                       // _t100

    _t100 = __eflags;
    __i686.get_pc_thunk.bx();
    _t84 = _t83 + 81760;
    _t59 =  *((intOrPtr*)(_t84 + -24));
    _v440 =  *_t59;
     *_t59 =  &_v440;
    _v432 = 1;
    _v436 = 3;
    _v428 =  &_a4;
    _v424 =  &_a8;
    _v420 =  &_a12;
    _v400 = -1;
    _t97 =  ?_? ( &_v400);
    fdlist_to_fdset(_a4,  &_v140,  &_v400);
    fdlist_to_fdset(_a8,  &_v268, _t97);
    fdlist_to_fdset(_a12,  &_v396, _t97);
    asm("fld qword [eax]");
    _t98 = 0;
    asm("fldz ");
    asm("fucomip st0, st1");
    if(_t100 > 0) {
        asm("fstp st0");
    } else {
        asm("fnstcw word [ebp+0xfffffe46]");
        _v448 = _v446 & 0xffff;
        asm("fldcw word [ebp+0xfffffe44]");
        asm("fist dword [ebp+0xfffffe40]");
        asm("fldcw word [ebp+0xfffffe46]");
        _t82 = _v452;
        _v408 = _t82;
        _v452 = _t82;
        asm("fild dword [ebp+0xfffffe40]");
        asm("fsubp st1, st0");
        asm("fmul dword [ebx+0xffffdae4]");
        asm("fldcw word [ebp+0xfffffe44]");
        asm("fistp dword [ebp+0xfffffe70]");
        asm("fldcw word [ebp+0xfffffe46]");
        _t98 =  &_v408;
    }
    caml_enter_blocking_section();
    _v476 = _t98;
    _v480 =  &_v396;
    _v484 =  &_v268;
    _v488 =  &_v140;
    _t71 = _v400 + 1;
     *__esp = _t71;
    select();
    _t99 = _t71;
    caml_leave_blocking_section();
    if(_t71 == 255) {
        _v488 = 0;
        uerror(_t84 + -9292, _t84, _t99, _t84 + -9292);
    }
    _a4 = fdset_to_fdlist(_a4,  &_v140);
    _a8 = fdset_to_fdlist(_a8,  &_v268);
    _a12 = fdset_to_fdlist(_a12,  &_v396);
    _t78 = caml_alloc_small(_t84, _t99, 3, 0);
     *_t78 = _a4;
     *((intOrPtr*)(_t78 + 4)) = _a8;
     *((intOrPtr*)(_t78 + 8)) = _a12;
     *((intOrPtr*)( *((intOrPtr*)(_t84 + -24)))) = _v440;
    return;
}

unix_sendto_native(
    _unknown_ __eax,                       // r0
    signed int _a4,                        // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16,                       // _cfa_10
    intOrPtr _a20,                         // _cfa_14
    signed int _a24                        // _cfa_18
)
{// addr = 0x08059930
    char _v16412;                          // _cfa_ffffbfe4
    char _v16524;                          // _cfa_ffffbf74
    char _v16528;                          // _cfa_ffffbf70
    signed int _v16544;                    // _cfa_ffffbf60
    intOrPtr _v16548;                      // _cfa_ffffbf5c
    intOrPtr _v16568;                      // _cfa_ffffbf48
    signed int _v16572;                    // _cfa_ffffbf44
    intOrPtr _v16576;                      // _cfa_ffffbf40
    char* _v16580;                         // _cfa_ffffbf3c
    signed int _v16584;                    // _cfa_ffffbf38
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t31;                        // _t31
    _unknown_ _t37;                        // _t37
    signed int _t41;                       // _t41
    _unknown_ _t42;                        // _t42
    signed int _t47;                       // _t47
    _unknown_ _t50;                        // _t50
    _unknown_ _t51;                        // _t51
    _unknown_ _t53;                        // _t53
    intOrPtr _t56;                         // _t56
    signed int _t57;                       // _t57
    signed int _t58;                       // _t58

    __i686.get_pc_thunk.bx();
    _t52 = _t51 + 81283;
    _v16548 = caml_convert_flag_list(_a20, _t51 + 0x1a36f);
    _v16580 =  &_v16528;
    _t57 =  &_v16524;
    _v16584 = _t57;
     *__esp = _a24;
    get_sockaddr(_a24, _t51 + 81283, _t53, _t57);
    _t56 = _a16 >> 1 - 16384 > 0 ? 16384 : _a16 >> 1;
    _v16580 = _t56;
    _v16584 = (_a12 >> 1) + _a8;
    _t41 =  &_v16412;
    _v16544 = _t41;
     *__esp = _t41;
    memmove();
    caml_enter_blocking_section();
    _v16568 = _v16528;
    _v16572 = _t57;
    _v16576 = _v16548;
    _v16580 = _t56;
    _v16584 = _v16544;
    _t47 = _a4 >> 1;
     *__esp = _t47;
    sendto();
    _t58 = _t47;
    caml_leave_blocking_section();
    if(_t58 == 255) {
        _v16584 = 0;
        uerror(_t52 + -9285, _t52, _t58, _t52 + -9285);
    }
    return _t58 + _t58 + 1;
}

unix_sendto(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x08059A21
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ _v28;                        // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    _unknown_ _t16;                        // _t16

    __i686.get_pc_thunk.bx();
    unix_sendto_native( *_a4,  *_a4,  *((intOrPtr*)(_t12 + 4)),  *((intOrPtr*)(_t12 + 8)),  *((intOrPtr*)(_t12 + 12)),  *((intOrPtr*)(_t12 + 16)),  *((intOrPtr*)(_t12 + 20)));
    return;
}

unix_send(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16,                       // _cfa_10
    intOrPtr _a20                          // _cfa_14
)
{// addr = 0x08059A69
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v16412;                          // _cfa_ffffbfe4
    intOrPtr _v16416;                      // _cfa_ffffbfe0
    intOrPtr _v16432;                      // _cfa_ffffbfd0
    intOrPtr _v16436;                      // _cfa_ffffbfcc
    signed int _v16440;                    // _cfa_ffffbfc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t27;                        // _t27
    _unknown_ _t31;                        // _t31
    _unknown_ _t35;                        // _t35
    signed int _t38;                       // _t38
    _unknown_ _t41;                        // _t41
    intOrPtr _t42;                         // _t42
    _unknown_ _t44;                        // _t44
    signed int _t46;                       // _t46
    _unknown_ _t47;                        // _t47
    intOrPtr _t51;                         // _t51
    signed int _t52;                       // _t52
    _unknown_ _t53;                        // _t53

    _t42 = __ebx;
    _v16 = _t42;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx();
    _t43 = _t42 + 80964;
    _v16416 = caml_convert_flag_list(_a20, _t42 + 0x1a230);
    _t51 = _a16 >> 1 - 16384 > 0 ? 16384 : _a16 >> 1;
    _v16436 = _t51;
    _v16440 = (_a12 >> 1) + _a8;
    _t46 =  &_v16412;
     *__esp = _t46;
    memmove();
    caml_enter_blocking_section();
    _v16432 = _v16416;
    _v16436 = _t51;
    _v16440 = _t46;
    _t38 = _a4 >> 1;
     *__esp = _t38;
    send();
    _t52 = _t38;
    caml_leave_blocking_section();
    if(_t52 == 255) {
        _v16440 = 0;
        uerror(_t43 + -9278, _t43, _t52, _t43 + -9278);
    }
    return _t52 + _t52 + 1;
}

unix_recvfrom(
    _unknown_ __eax,                       // r0
    signed int _a4,                        // _cfa_4
    char _a8,                              // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16,                       // _cfa_10
    intOrPtr _a20                          // _cfa_14
)
{// addr = 0x08059B29
    void _v16412;                          // _cfa_ffffbfe4
    int _v16416;                           // _cfa_ffffbfe0
    char _v16528;                          // _cfa_ffffbf70
    char* _v16532;                         // _cfa_ffffbf6c
    char* _v16548;                         // _cfa_ffffbf5c
    char* _v16552;                         // _cfa_ffffbf58
    int _v16556;                           // _cfa_ffffbf54
    intOrPtr _v16560;                      // _cfa_ffffbf50
    char _v16564;                          // _cfa_ffffbf4c
    char* _v16584;                         // _cfa_ffffbf38
    char* _v16588;                         // _cfa_ffffbf34
    intOrPtr _v16592;                      // _cfa_ffffbf30
    intOrPtr _v16596;                      // _cfa_ffffbf2c
    char* _v16600;                         // _cfa_ffffbf28
    _unknown_ __ebx;                       // r1
    intOrPtr __edi;                        // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t45;                        // _t45
    intOrPtr* _t49;                        // _t49
    _unknown_ _t54;                        // _t54
    int _t57;                              // _t57
    _unknown_ _t62;                        // _t62
    int _t64;                              // _t64
    intOrPtr* _t65;                        // _t65
    _unknown_ _t67;                        // _t67
    _unknown_ _t68;                        // _t68
    _unknown_ _t69;                        // _t69
    signed int _t76;                       // _t76
    int _t78;                              // _t78

    __i686.get_pc_thunk.bx();
    _t69 = _t68 + 80778;
    _v16416 = 1;
    __edi = caml_convert_flag_list(_a20, _t69 + 26092);
    _t49 =  *((intOrPtr*)(_t69 + -24));
    _v16564 =  *_t49;
     *_t49 =  &_v16564;
    _v16556 = 1;
    _v16560 = 2;
    _v16552 =  &_a8;
    _v16548 =  &_v16416;
    _t76 = _a16 >> 1;
    _v16532 = 112;
    caml_enter_blocking_section();
    _v16584 =  &_v16532;
    _v16588 =  &_v16528;
    _v16592 = __edi;
    _t77 = _t76 - 16384 > 0 ? 16384 : _t76;
    _v16596 = _t76 - 16384 > 0 ? 16384 : _t76;
    _v16600 =  &_v16412;
    _t57 = _a4 >> 1;
     *__esp = _t57;
    recvfrom();
    _t78 = _t57;
    caml_leave_blocking_section();
    if(_t78 == 255) {
        _v16600 = 0;
        uerror(_t69 + -9273, _t69, _t78, _t69 + -9273);
    }
    memmove((_a12 >> 1) + _a8,  &_v16412, _t78);
    _v16596 = -1;
    _v16600 = _v16532;
    _t64 =  &_v16528;
     *__esp = _t64;
    alloc_sockaddr(_t64, _t69, __edi, _t78);
    _v16416 = _t64;
    _t65 = caml_alloc_small(_t69, _t78, 2, 0);
     *_t65 = _t78 + _t78 + 1;
     *(_t65 + 4) = _v16416;
     *((intOrPtr*)( *((intOrPtr*)(_t69 + -24)))) = _v16564;
    return;
}

unix_recv(
    _unknown_ __eax,                       // r0
    signed int _a4,                        // _cfa_4
    char _a8,                              // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16,                       // _cfa_10
    intOrPtr _a20                          // _cfa_14
)
{// addr = 0x08059C97
    void _v16412;                          // _cfa_ffffbfe4
    char* _v16432;                         // _cfa_ffffbfd0
    intOrPtr _v16436;                      // _cfa_ffffbfcc
    intOrPtr _v16440;                      // _cfa_ffffbfc8
    char _v16444;                          // _cfa_ffffbfc4
    intOrPtr _v16448;                      // _cfa_ffffbfc0
    intOrPtr _v16452;                      // _cfa_ffffbfbc
    void* _v16456;        // _cfa_ffffbfb8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t29;                        // _t29
    intOrPtr _t32;                         // _t32
    intOrPtr* _t33;                        // _t33
    _unknown_ _t35;                        // _t35
    int _t38;                              // _t38
    _unknown_ _t43;                        // _t43
    _unknown_ _t47;                        // _t47
    _unknown_ _t48;                        // _t48
    _unknown_ _t49;                        // _t49
    signed int _t54;                       // _t54
    int _t56;                              // _t56

    __i686.get_pc_thunk.bx();
    _t49 = _t48 + 80412;
    _t32 = caml_convert_flag_list(_a20, _t49 + 26092);
    _t33 =  *((intOrPtr*)(_t49 + -24));
    _v16444 =  *_t33;
     *_t33 =  &_v16444;
    _v16436 = 1;
    _v16440 = 1;
    _v16432 =  &_a8;
    _t54 = _a16 >> 1;
    caml_enter_blocking_section();
    _v16448 = _t32;
    _t55 = _t54 - 16384 > 0 ? 16384 : _t54;
    _v16452 = _t54 - 16384 > 0 ? 16384 : _t54;
    _v16456 =  &_v16412;
    _t38 = _a4 >> 1;
     *__esp = _t38;
    recv();
    _t56 = _t38;
    caml_leave_blocking_section();
    if(_t56 == 255) {
        _v16456 = 0;
        uerror(_t49 + -9264, _t49, _t56, _t49 + -9264);
    }
    memmove((_a12 >> 1) + _a8,  &_v16412, _t56);
     *((intOrPtr*)( *((intOrPtr*)(_t49 + -24)))) = _v16444;
    return _t56 + _t56 + 1;
}

unix_setgid(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08059D8C
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    _unknown_ _t9;                         // _t9
    _unknown_ _t10;                        // _t10
    _unknown_ _t11;                        // _t11

    __i686.get_pc_thunk.bx();
    _t11 = _t10 + 80172;
     *__esp = _a4 >> 1;
    if(setgid() == 255) {
        _v24 = 0;
        uerror(_t11 + -9259, _t11, __esi, _t11 + -9259);
    }
    return 1;
}

unix_setgroups(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08059DD4
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v56;                       // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t15;                       // _t15
    signed int _t16;                       // _t16
    _unknown_ _t18;                        // _t18
    _unknown_ _t20;                        // _t20
    _unknown_ _t21;                        // _t21
    _unknown_ _t22;                        // _t22
    signed int _t26;                       // _t26
    intOrPtr _t27;                         // _t27

    __i686.get_pc_thunk.bx();
    _t22 = _t21 + 80098;
    _t27 = _a4;
    _t26 =  *(_t27 - 4) >> 10;
    _t15 = 0 + _t26 * 4;
    caml_stat_alloc(_t15);
    _v32 = _t15;
    if(_t26 != 0) {
        __edx = 0;
        while(1) {
             *(_t15 + __edx * 4) =  *(_t27 + __edx * 4) >> 1;
            __edx = __edx + 1;
            if(_t26 <= __edx) {
                break;
            }
        }
    }
    _t16 = _v32;
    _v56 = _t16;
     *__esp = _t26;
    setgroups();
    _t28 = _t16;
    caml_stat_free(_v32);
    if(_t16 == 255) {
        _v56 = 0;
        uerror(_t22 + -9252, _t22, _t28, _t22 + -9252);
    }
    return 1;
}

unix_setsid(
    _unknown_ __eax                        // r0
)
{// addr = 0x08059E60
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3
    _unknown_ _t6;                         // _t6
    _unknown_ _t7;                         // _t7

    __i686.get_pc_thunk.bx();
    return setsid() + _t4 + 1;
}

unix_setuid(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08059E84
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t5;                        // _t5
    _unknown_ _t6;                         // _t6
    _unknown_ _t8;                         // _t8
    _unknown_ _t9;                         // _t9
    _unknown_ _t10;                        // _t10

    __i686.get_pc_thunk.bx();
    _t10 = _t9 + 79924;
    _t5 = _a4 >> 1;
     *__esp = _t5;
    setuid();
    if(_t5 == 255) {
        _v24 = 0;
        uerror(_t10 + -9242, _t10, __esi, _t10 + -9242);
    }
    return 1;
}

unix_shutdown(
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08059ECC
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t13;                       // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17

    __i686.get_pc_thunk.bx();
    _t18 = _t17 + 79852;
    _v24 =  *((intOrPtr*)(_t17 + 79852 + -9224 + (_a8 >> 1) * 4));
    _t13 = _a4 >> 1;
     *__esp = _t13;
    shutdown();
    if(_t13 == 255) {
        _v24 = 0;
        uerror(_t18 + -9235, _t18, __esi, _t18 + -9235);
    }
    return 1;
}

decode_sigset(
    signed int* __eax                      // r0
)
{// addr = 0x08059F30
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    intOrPtr __edi;                        // r4
    signed int* __esi;                     // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t6;                         // _t6
    _unknown_ _t7;                         // _t7

    _t3 = __eax;
    __i686.get_pc_thunk.bx();
    __esi = __eax;
    __edi = __edx;
     *__esp = __edx;
    sigemptyset();
    if(__esi != 1) {
        while(1) {
            _v40 = caml_convert_signal_number( *__esi >> 1);
             *__esp = __edi;
            sigaddset();
            __esi = (__esi)[1];
            if(__esi == 1) {
                break;
            }
        }
    }
    return;
}

unix_sigsuspend(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    signed int* _a4                        // _cfa_4
)
{// addr = 0x08059F7D
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char _v140;                            // _cfa_ffffff74
    intOrPtr _v152;                        // _cfa_ffffff68
    _unknown_ __ebp;                       // r6
    _unknown_ _t9;                         // _t9
    signed int* _t10;                      // _t10
    _unknown_ _t11;                        // _t11
    _unknown_ _t14;                        // _t14
    intOrPtr _t15;                         // _t15
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17
    _unknown_ _t21;                        // _t21

    _t15 = __ebx;
    _v12 = _t15;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t16 = _t15 + 79667;
    _t10 = _a4;
    decode_sigset(_t10);
    caml_enter_blocking_section();
     *__esp =  &_v140;
    sigsuspend();
    _t20 = _t10;
    caml_leave_blocking_section();
    if(_t10 == 255 &&  *(__errno_location()) != 4) {
        _v152 = 0;
        uerror(_t16 + -9212, _t16, _t20, _t16 + -9212);
    }
    return 1;
}

encode_sigset(
    intOrPtr __eax                         // r0
)
{// addr = 0x08059FEF
    char _v32;                             // _cfa_ffffffe0
    char* _v52;                            // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    char _v64;                             // _cfa_ffffffc0
    intOrPtr _v80;                         // _cfa_ffffffb0
    intOrPtr _v104;                        // _cfa_ffffff98
    _unknown_ __ebx;                       // r1
    intOrPtr* __edi;                       // r4
    intOrPtr __esi;                        // r5
    _unknown_ __ebp;                       // r6
    intOrPtr* _t22;                        // _t22
    intOrPtr _t24;                         // _t24
    intOrPtr* _t27;                        // _t27
    _unknown_ _t30;                        // _t30
    _unknown_ _t31;                        // _t31

    __i686.get_pc_thunk.bx();
    _t31 = _t30 + 79559;
    _v80 = __eax;
    _v32 = 1;
    _t22 =  *((intOrPtr*)(_t31 + -24));
    _v64 =  *_t22;
     *_t22 =  &_v64;
    _v56 = 1;
    _v60 = 1;
    _v52 =  &_v32;
    __esi = 1;
    while(1) {
        _v104 = __esi;
        _t24 = _v80;
         *__esp = _t24;
        sigismember();
        if(_t24 > 0) {
            _t27 = caml_alloc_small(_t31, __esi, 2, 0);
            __edi = _t27;
            caml_rev_convert_signal_number(__esi);
             *__edi = _t27 + _t27 + 1;
             *((intOrPtr*)(__edi + 4)) = _v32;
            _v32 = __edi;
        }
        __esi = __esi + 1;
        if(__esi == 65) {
            break;
        }
    }
     *((intOrPtr*)( *((intOrPtr*)(_t31 + -24)))) = _v64;
    return _v32;
}

unix_sigpending()
{// addr = 0x0805A094
    char _v140;                            // _cfa_ffffff74
    intOrPtr _v152;                        // _cfa_ffffff68
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    char* _t5;                             // _t5
    _unknown_ _t7;                         // _t7
    _unknown_ _t9;                         // _t9
    _unknown_ _t10;                        // _t10
    _unknown_ _t11;                        // _t11

    __i686.get_pc_thunk.bx();
    _t11 = _t10 + 79393;
    _t5 =  &_v140;
     *__esp = _t5;
    sigpending();
    if(_t5 == 255) {
        _v152 = 0;
        uerror(_t11 + -9201, _t11, __esi, _t11 + -9201);
    }
    encode_sigset( &_v140);
    return;
}

unix_sigprocmask(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    signed int* _a8                        // _cfa_8
)
{// addr = 0x0805A0E6
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v156;                            // _cfa_ffffff64
    char _v284;                            // _cfa_fffffee4
    intOrPtr _v292;                        // _cfa_fffffedc
    char* _v296;                           // _cfa_fffffed8
    _unknown_ __ebp;                       // r6
    char* _t22;                            // _t22
    _unknown_ _t24;                        // _t24
    _unknown_ _t26;                        // _t26
    intOrPtr _t27;                         // _t27
    _unknown_ _t29;                        // _t29
    _unknown_ _t32;                        // _t32
    _unknown_ _t36;                        // _t36

    _t27 = __ebx;
    _v16 = _t27;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx();
    _t28 = _t27 + 79303;
    decode_sigset(_a8);
    caml_enter_blocking_section();
    _t22 =  &_v284;
    _v292 = _t22;
    _v296 =  &_v156;
     *__esp =  *((intOrPtr*)(_t27 + 79303 + -9176 + (_a4 >> 1) * 4));
    sigprocmask();
    _t35 = _t22;
    caml_leave_blocking_section();
    if(_t22 == 255) {
        _v296 = 0;
        uerror(_t28 + -9190, _t28, _t35, _t28 + -9190);
    }
    encode_sigset( &_v284);
    return;
}

unix_sleep(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805A174
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4
    _unknown_ _t5;                         // _t5
    _unknown_ _t6;                         // _t6
    _unknown_ _t7;                         // _t7

    __i686.get_pc_thunk.bx();
    caml_enter_blocking_section();
    sleep(_a4 >> 1);
    caml_leave_blocking_section();
    return 1;
}

unix_socket(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x0805A1A8
    signed int _v20;                       // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    intOrPtr _t21;                         // _t21
    _unknown_ _t24;                        // _t24
    _unknown_ _t25;                        // _t25

    __i686.get_pc_thunk.bx();
    _t25 = _t24 + 79120;
    _v20 = _a12 >> 1;
    _v24 =  *((intOrPtr*)( *((intOrPtr*)(_t25 + -28)) + (_a8 >> 1) * 4));
    _t21 =  *((intOrPtr*)( *((intOrPtr*)(_t25 + -32)) + (_a4 >> 1) * 4));
     *__esp = _t21;
    socket();
    if(_t21 == 255) {
        _v24 = 0;
        _t21 = uerror(_t25 + -9164, _t25, __esi, _t25 + -9164);
    }
    return _t21 + _t21 + 1;
}

get_sockaddr(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    void* _a4,            // _cfa_4
    short* _a8,                            // _cfa_8
    void* _a12            // _cfa_c
)
{// addr = 0x0805A210
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    void* _v32;           // _cfa_ffffffe0
    void* _v52;           // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t51;                        // _t51
    _unknown_ _t54;                        // _t54
    _unknown_ _t56;                        // _t56
    _unknown_ _t60;                        // _t60
    void _t65;                             // _t65
    intOrPtr _t69;                         // _t69
    _unknown_ _t70;                        // _t70
    _unknown_ _t71;                        // _t71
    signed int _t72;                       // _t72
    short* _t75;                           // _t75
    void* _t81;           // _t81
    _unknown_ _t82;                        // _t82
    _unknown_ _t84;                        // _t84
    short* _t86;                           // _t86
    _unknown_ _t88;                        // _t88

    _t69 = __ebx;
    _v16 = _t69;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx();
    _t70 = _t69 + 79008;
    _t52 = _a4;
    _t86 = _a8;
    _t81 = _t52;
    _t72 =  *(_t52 - 4) & 255;
    if((_t72 & 255) == 0) {
        _v32 =  *_t52;
        _t54 = caml_string_length( *_t52);
        _t82 = _t54;
         *_t86 = 1;
        if(_t54 > 107) {
            _v52 = _v32;
            _v56 = _t70 + -5244;
            _t54 = unix_error(_t70 + -5244, _t70, _t86, 36);
        }
        memmove(_t86 + 2, _v32, _t54 + 1);
        _t52 = _a12;
         *_a12 = _t82 + 2;
L11:
        return;
L12:
    }
    if((_t72 & 255) != 1) {
    } else {
        _v32 = _t52;
        _t60 = caml_string_length( *_t52);
        if(_t60 != 16) {
             *_t86 = 0;
             *((intOrPtr*)(_t86 + 4)) = 0;
             *((intOrPtr*)(_t86 + 8)) = 0;
             *((intOrPtr*)(_t86 + 12)) = 0;
             *_t86 = 2;
             *((intOrPtr*)(_t86 + 4)) =  *( *_v32);
            asm("ror ax, 0x8");
             *(_t86 + 2) = _t81[1] >> 1 & 65535;
            _t52 = _a12;
             *_a12 = 16;
        } else {
            _t75 = _t86;
            __ecx = 0;
            while(1) {
                 *((intOrPtr*)(_t75 + _t60)) = __ecx;
                _t60 = _t60 + 4;
                if(_t60 >= 28) {
                    break;
                }
            }
             *_t86 = 10;
            _t65 =  *_v32;
             *((intOrPtr*)(_t86 + 8)) =  *_t65;
             *((intOrPtr*)(_t86 + 12)) =  *((intOrPtr*)(_t65 + 4));
             *((intOrPtr*)(_t86 + 16)) =  *((intOrPtr*)(_t65 + 8));
             *((intOrPtr*)(_t86 + 20)) =  *((intOrPtr*)(_t65 + 12));
            asm("ror ax, 0x8");
             *(_t86 + 2) = _t81[1] >> 1 & 65535;
            _t52 = _a12;
             *_a12 = 28;
        }
    }
    goto L11;
}

alloc_inet6_addr(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x0805A34D
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    _unknown_ __ebp;                       // r6
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14
    intOrPtr* _t20;                        // _t20
    _unknown_ _t21;                        // _t21

    __eax = __eax;
    _v12 = __ebx;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t20 = _a4;
    caml_alloc_string(16);
     *__eax =  *_t20;
     *((intOrPtr*)(__eax + 4)) =  *((intOrPtr*)(_t20 + 4));
     *((intOrPtr*)(__eax + 8)) =  *((intOrPtr*)(_t20 + 8));
     *((intOrPtr*)(__eax + 12)) =  *((intOrPtr*)(_t20 + 12));
    return;
}

alloc_inet_addr(
    _unknown_ __eax,                       // r0
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x0805A393
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2
    _unknown_ _t3;                         // _t3

    __eax = __eax;
    __i686.get_pc_thunk.bx();
    caml_alloc_string(4);
     *((intOrPtr*)(__eax)) =  *_a4;
    return;
}

alloc_sockaddr(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed short* _a4,                     // _cfa_4
    int _a12                               // _cfa_c
)
{// addr = 0x0805A3BE
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    signed short* _v32;                    // _cfa_ffffffe0
    signed short** _v52;                   // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    char _v64;                             // _cfa_ffffffc0
    intOrPtr _v84;                         // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    _unknown_ __ebp;                       // r6
    _unknown_ _t65;                        // _t65
    signed int _t66;                       // _t66
    signed short* _t67;                    // _t67
    signed short* _t72;                    // _t72
    _unknown_ _t77;                        // _t77
    intOrPtr _t82;                         // _t82
    intOrPtr _t83;                         // _t83
    _unknown_ _t84;                        // _t84
    int _t85;                              // _t85
    intOrPtr* _t99;                        // _t99
    _unknown_ _t100;                       // _t100
    intOrPtr* _t101;                       // _t101
    signed short* _t103;                   // _t103
    _unknown_ _t104;                       // _t104
    intOrPtr* _t106;                       // _t106

    _t98 = __edi;
    _t82 = __ebx;
    _v16 = _t82;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx();
    _t83 = _t82 + 78578;
    _t103 = _a4;
    _t85 = _a12;
    _t66 =  *_t103 & 65535;
    if((_t66 & 65535) == 2) {
        _t67 =  &(_t103[2]);
        alloc_inet_addr(_t67, _t67);
        _v32 = _t67;
        _t99 =  *((intOrPtr*)(_t83 + -24));
        _v64 =  *_t99;
         *_t99 =  &_v64;
        _v56 = 1;
        _v60 = 1;
        _v52 =  &_v32;
        _t71 = caml_alloc_small(_t83, _t103, 2, 1);
         *_t71 = _v32;
        asm("ror dx, 0x8");
        (_t71)[1] = (_t103[1] & 0xffff) + (_t103[1] & 0xffff) + 1;
         *_t99 = _v64;
    } else {
        if((_t66 & 65535) == 10) {
            _t72 =  &(_t103[4]);
            alloc_inet6_addr(_t72, _t83, _t103, _t72);
            _v32 = _t72;
            _t101 =  *((intOrPtr*)(_t83 + -24));
            _v64 =  *_t101;
             *_t101 =  &_v64;
            _v56 = 1;
            _v60 = 1;
            _v52 =  &_v32;
            _t71 = caml_alloc_small(_t83, _t103, 2, 1);
             *_t71 = _v32;
            asm("ror dx, 0x8");
            (_t71)[1] = (_t103[1] & 0xffff) + (_t103[1] & 0xffff) + 1;
             *_t101 = _v64;
        } else {
            if((_t66 & 65535) != 1) {
                if(_t85 != 255) {
                    close(_t85);
                }
                _v84 = 0;
                _v88 = _t83 + -5244;
                _t71 = unix_error(_t83 + -5244, _t83, _t103, 97);
            } else {
                _v32 = caml_copy_string(_t83, _t98,  &(_t103[1]),  &(_t103[1]));
                _t106 =  *((intOrPtr*)(_t83 + -24));
                _v64 =  *_t106;
                 *_t106 =  &_v64;
                _v56 = 1;
                _v60 = 1;
                _v52 =  &_v32;
                 *(caml_alloc_small(_t83, _t106, 1, 0)) = _v32;
                 *_t106 = _v64;
            }
        }
    }
    return;
}

unix_socketpair(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x0805A554
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v20;                             // _cfa_ffffffec
    char* _v32;                            // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    intOrPtr _t30;                         // _t30
    intOrPtr* _t31;                        // _t31
    _unknown_ _t33;                        // _t33
    _unknown_ _t34;                        // _t34
    _unknown_ _t35;                        // _t35

    __i686.get_pc_thunk.bx();
    _t35 = _t34 + 78180;
    _v32 =  &_v20;
    _v36 = _a12 >> 1;
    _v40 =  *((intOrPtr*)( *((intOrPtr*)(_t35 + -28)) + (_a8 >> 1) * 4));
    _t30 =  *((intOrPtr*)( *((intOrPtr*)(_t35 + -32)) + (_a4 >> 1) * 4));
     *__esp = _t30;
    socketpair();
    if(_t30 == 255) {
        _v40 = 0;
        uerror(_t35 + -9157, _t35, __esi, _t35 + -9157);
    }
    _t31 = caml_alloc_small(_t35, __esi, 2, 0);
     *_t31 = _v20 + _v20 + 1;
     *((intOrPtr*)(_t31 + 4)) = _v16 + _v16 + 1;
    return;
}

unix_setsockopt_aux(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    intOrPtr _a16,                         // _cfa_10
    signed int _a20,                       // _cfa_14
    signed int _a24                        // _cfa_18
)
{// addr = 0x0805A5F0
    signed int _v16;                       // _cfa_fffffff0
    char _v20;                             // _cfa_ffffffec
    signed short _v30;                     // _cfa_ffffffe2
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    intOrPtr _v60;                         // _cfa_ffffffc4
    char* _v64;                            // _cfa_ffffffc0
    intOrPtr _v68;                         // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    intOrPtr __esi;                        // r5
    _unknown_ __ebp;                       // r6
    intOrPtr _t28;                         // _t28
    intOrPtr _t29;                         // _t29
    signed int _t34;                       // _t34
    _unknown_ _t35;                        // _t35
    _unknown_ _t36;                        // _t36
    signed int _t40;                       // _t40
    _unknown_ _t41;                        // _t41
    _unknown_ _t42;                        // _t42
    signed int _t45;                       // _t45
    signed int _t46;                       // _t46

    __i686.get_pc_thunk.bx();
    _t42 = _t41 + 78023;
    __esi = _a4;
    _t28 = _a8;
    _t46 = _a24;
    if(_t28 == 2) {
        _t45 = (_t46 ^ 1) & 1;
        _v20 = _t45;
        _t29 = 8;
        if(_t45 != 0) {
            _v16 =  *_t46 >> 1;
            _t29 = 8;
        }
    } else {
        if(_t28 < 2) {
            _v20 = _t46 >> 1;
            _t29 = 4;
        } else {
            if(_t28 != 3) {
                _v68 = 0;
                _v72 = __esi;
                _t29 = unix_error(_t28, _t42, __esi, 22);
            } else {
                __esi = __esi;
                asm("fld qword [edx]");
                asm("fnstcw word [ebp-0x1a]");
                _v32 = _v30 & 0xffff;
                asm("fldcw word [ebp-0x1c]");
                asm("fist dword [ebp-0x20]");
                asm("fldcw word [ebp-0x1a]");
                _t40 = _v36;
                _v20 = _t40;
                _v36 = _t40;
                asm("fild dword [ebp-0x20]");
                asm("fsubp st1, st0");
                asm("fmul dword [ebx+0xffffdae4]");
                asm("fldcw word [ebp-0x1c]");
                asm("fistp dword [ebp-0xc]");
                asm("fldcw word [ebp-0x1a]");
                _t29 = 8;
            }
        }
    }
    _v60 = _t29;
    _v64 =  &_v20;
    _v68 = _a16;
    _v72 = _a12;
    _t34 = _a20 >> 1;
     *__esp = _t34;
    setsockopt();
    if(_t34 == 255) {
        _v72 = 0;
        uerror(_t34, _t42, __esi, __esi);
    }
    return 1;
}

unix_setsockopt(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x0805A6EB
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ _v28;                        // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t18;                       // _t18
    _unknown_ _t20;                        // _t20
    _unknown_ _t21;                        // _t21
    _unknown_ _t22;                        // _t22

    __i686.get_pc_thunk.bx();
    _t22 = _t21 + 77773;
    _t18 = _a4 >> 1;
    unix_setsockopt_aux( *((intOrPtr*)(_t22 + -292 + _t18 * 4)), _t18,  *((intOrPtr*)((_a12 >> 1 << 3) +  *((intOrPtr*)(_t22 + -312 + _t18 * 4)))),  *((intOrPtr*)(_t29 + 4)), _a8, _a16);
    return;
}

unix_getsockopt_aux(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    signed int _a8,                        // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    intOrPtr _a16,                         // _cfa_10
    signed int _a20                        // _cfa_14
)
{// addr = 0x0805A745
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v36;                             // _cfa_ffffffdc
    char _v40;                             // _cfa_ffffffd8
    char* _v92;                            // _cfa_ffffffa4
    char* _v96;                            // _cfa_ffffffa0
    intOrPtr _v100;                        // _cfa_ffffff9c
    intOrPtr _v104;                        // _cfa_ffffff98
    _unknown_ __ebp;                       // r6
    _unknown_ _t29;                        // _t29
    _unknown_ _t30;                        // _t30
    signed int _t36;                       // _t36
    _unknown_ _t37;                        // _t37
    _unknown_ _t38;                        // _t38
    intOrPtr _t41;                         // _t41
    _unknown_ _t42;                        // _t42
    _unknown_ _t43;                        // _t43
    intOrPtr _t45;                         // _t45
    _unknown_ _t46;                        // _t46
    signed int _t48;                       // _t48
    _unknown_ _t49;                        // _t49

    _t41 = __ebx;
    _v16 = _t41;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx();
    _t42 = _t41 + 77675;
    _t45 = _a4;
    _t48 = _a8;
    if(_t48 <= 4) {
        _t29 = _t42 -  *((intOrPtr*)(_t42 + -77644 + _t48 * 4));
        goto __eax;
    }
    _v100 = 0;
    _v104 = _t45;
    unix_error(_t29, _t42, _t48, 22);
    _v92 =  &_v40;
    _v96 =  &_v36;
    _v100 = _a16;
    _v104 = _a12;
    _t36 = _a20 >> 1;
     *__esp = _t36;
    getsockopt();
    if(_t36 == 255) {
        _v104 = 0;
        _t36 = uerror(_t36, _t42, _t48, _t45);
    }
    if(_t48 > 4) {
    } else {
        _t36 = _t42 -  *((intOrPtr*)(_t42 + -77488 + _t48 * 4));
        goto __eax;
    }
    goto L6;
L7:
L6:
    _v100 = 0;
    _v104 = _t45;
    unix_error(_t36, _t42, _t48, 22);
    return 1;
    goto L7;
}

unix_getsockopt(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x0805A8F8
    _unknown_ _v28;                        // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    signed int _t16;                       // _t16
    _unknown_ _t18;                        // _t18
    _unknown_ _t19;                        // _t19
    intOrPtr _t20;                         // _t20

    __i686.get_pc_thunk.bx();
    _t20 = _t19 + 77248;
    _t16 = _a4 >> 1;
    unix_getsockopt_aux(_t20, __edi, __esi,  *((intOrPtr*)(_t20 + -272 + _t16 * 4)), _t16,  *((intOrPtr*)((_a12 >> 1 << 3) +  *((intOrPtr*)(_t20 + -312 + _t16 * 4)))),  *((intOrPtr*)(_t26 + 4)), _a8);
    return;
}

stat_aux(
    intOrPtr* __eax,                       // r0
    intOrPtr* __edx                        // r3
)
{// addr = 0x0805A94C
    char _v32;                             // _cfa_ffffffe0
    char _v36;                             // _cfa_ffffffdc
    char _v40;                             // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    char* _v52;                            // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    char* _v60;                            // _cfa_ffffffc4
    char* _v64;                            // _cfa_ffffffc0
    char* _v68;                            // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    intOrPtr _v76;                         // _cfa_ffffffb4
    char _v80;                             // _cfa_ffffffb0
    intOrPtr* _v96;                        // _cfa_ffffffa0
    _unknown_ _v112;                       // _cfa_ffffff90
    _unknown_ _v116;                       // _cfa_ffffff8c
    _unknown_ _v120;                       // _cfa_ffffff88
    _unknown_ __ebx;                       // r1
    char __edi;                            // r4
    intOrPtr* __esi;                       // r5
    _unknown_ __ebp;                       // r6
    intOrPtr* _t90;                        // _t90
    intOrPtr _t100;                        // _t100
    intOrPtr* _t101;                       // _t101
    _unknown_ _t127;                       // _t127
    _unknown_ _t128;                       // _t128

    __i686.get_pc_thunk.bx();
    _t128 = _t127 + 77162;
    _v96 = __eax;
    __esi = __edx;
    _t90 =  *((intOrPtr*)(_t128 + -24));
    __edi =  *_t90;
    _v32 = 0;
    _v36 = 0;
    _v40 = 0;
    _v44 = 0;
    _v48 = 0;
    _v80 = __edi;
     *_t90 =  &_v80;
    _v72 = 1;
    _v76 = 5;
    _v68 =  &_v32;
    _v64 =  &_v36;
    _v60 =  &_v40;
    _v56 =  &_v44;
    _v52 =  &_v48;
    asm("fild dword [esi+0x40]");
    asm("fstp qword [esp]");
    _v32 = caml_copy_double();
    asm("fild dword [esi+0x48]");
    asm("fstp qword [esp]");
    _v36 = caml_copy_double();
    asm("fild dword [esi+0x50]");
    asm("fstp qword [esp]");
    _v40 = caml_copy_double();
    if(_v96 == 0) {
        _t100 =  *((intOrPtr*)(__esi + 44)) +  *((intOrPtr*)(__esi + 44)) + 1;
    } else {
        _t100 =  *((intOrPtr*)(__esi + 44));
        caml_copy_int64(_t100, _t128, __esi, _t100,  *((intOrPtr*)(__esi + 48)));
    }
    _v44 = _t100;
    _t101 = caml_alloc_small(_t128, __esi, 12, 0);
    _v48 = _t101;
     *_t101 =  *__esi +  *__esi + 1;
     *((intOrPtr*)(_v48 + 4)) =  *((intOrPtr*)(__esi + 88)) +  *((intOrPtr*)(__esi + 88)) + 1;
    _v96 = _v48 + 8;
     *_v96 = cst_to_constr( *(__esi + 16) & 61440, _t128 + 26316, 7, 0);
     *((intOrPtr*)(_v48 + 12)) = ( *(__esi + 16) & 4095) + ( *(__esi + 16) & 4095) + 1;
     *((intOrPtr*)(_v48 + 16)) =  *((intOrPtr*)(__esi + 20)) +  *((intOrPtr*)(__esi + 20)) + 1;
     *((intOrPtr*)(_v48 + 20)) =  *((intOrPtr*)(__esi + 24)) +  *((intOrPtr*)(__esi + 24)) + 1;
     *((intOrPtr*)(_v48 + 24)) =  *((intOrPtr*)(__esi + 28)) +  *((intOrPtr*)(__esi + 28)) + 1;
     *((intOrPtr*)(_v48 + 28)) =  *((intOrPtr*)(__esi + 32)) +  *((intOrPtr*)(__esi + 32)) + 1;
     *((intOrPtr*)(_v48 + 32)) = _v44;
     *((intOrPtr*)(_v48 + 36)) = _v32;
     *((intOrPtr*)(_v48 + 40)) = _v36;
     *((intOrPtr*)(_v48 + 44)) = _v40;
     *((intOrPtr*)( *((intOrPtr*)(_t128 + -24)))) = __edi;
    return _v48;
}

unix_fstat_64(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805AAF3
    char _v108;                            // _cfa_ffffff94
    char* _v116;                           // _cfa_ffffff8c
    signed int _v120;                      // _cfa_ffffff88
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t10;                       // _t10
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    _unknown_ _t16;                        // _t16

    __i686.get_pc_thunk.bx();
    _t16 = _t15 + 76741;
    _v116 =  &_v108;
    _t10 = _a4 >> 1;
    _v120 = _t10;
     *__esp = 3;
    __fxstat64();
    if(_t10 == 255) {
        _v120 = 0;
        uerror(_t16 + -8990, _t16, __esi, _t16 + -8990);
    }
    __edx =  ?_? ( &_v108);
    stat_aux(1,  &_v108);
    return;
}

unix_lstat_64(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805AB4F
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char _v108;                            // _cfa_ffffff94
    intOrPtr _v116;                        // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    _unknown_ __ebp;                       // r6
    char* _t12;                            // _t12
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t16;                        // _t16
    intOrPtr _t17;                         // _t17
    _unknown_ _t18;                        // _t18
    _unknown_ _t19;                        // _t19
    intOrPtr _t21;                         // _t21
    _unknown_ _t22;                        // _t22

    _t17 = __ebx;
    _v12 = _t17;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t18 = _t17 + 76644;
    _t21 = _a4;
    _t12 =  &_v108;
    _v116 = _t12;
    _v120 = _t21;
     *__esp = 3;
    __lxstat64();
    if(_t12 == 255) {
        _v120 = _t21;
        uerror(_t18 + -8984, _t18, _t21, _t18 + -8984);
    }
    __edx =  ?_? ( &_v108);
    stat_aux(1,  &_v108);
    return;
}

unix_stat_64(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805ABAE
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char _v108;                            // _cfa_ffffff94
    intOrPtr _v116;                        // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    _unknown_ __ebp;                       // r6
    char* _t12;                            // _t12
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t16;                        // _t16
    intOrPtr _t17;                         // _t17
    _unknown_ _t18;                        // _t18
    _unknown_ _t19;                        // _t19
    intOrPtr _t21;                         // _t21
    _unknown_ _t22;                        // _t22

    _t17 = __ebx;
    _v12 = _t17;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t18 = _t17 + 76549;
    _t21 = _a4;
    _t12 =  &_v108;
    _v116 = _t12;
    _v120 = _t21;
     *__esp = 3;
    __xstat64();
    if(_t12 == 255) {
        _v120 = _t21;
        uerror(_t18 + -8989, _t18, _t21, _t18 + -8989);
    }
    __edx =  ?_? ( &_v108);
    stat_aux(1,  &_v108);
    return;
}

unix_fstat(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805AC0D
    intOrPtr _v60;                         // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    signed int _v92;                       // _cfa_ffffffa4
    char _v108;                            // _cfa_ffffff94
    signed int _v116;                      // _cfa_ffffff8c
    signed int _v120;                      // _cfa_ffffff88
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t17;                       // _t17
    _unknown_ _t18;                        // _t18
    _unknown_ _t19;                        // _t19
    _unknown_ _t23;                        // _t23
    _unknown_ _t25;                        // _t25
    _unknown_ _t26;                        // _t26
    _unknown_ _t27;                        // _t27

    __i686.get_pc_thunk.bx();
    _t27 = _t26 + 76459;
    _v116 =  &_v108;
    _t17 = _a4 >> 1;
    _v120 = _t17;
     *__esp = 3;
    __fxstat64();
    if(_t17 == 255) {
        _v120 = 0;
        uerror(_t27 + -8990, _t27, __esi, _t27 + -8990);
    }
    if(_v60 < 0 && (_v60 > 0 || _v64 > 1073741823)) {
        if((_v92 & 61440) == 32768) {
            _v116 = 0;
            _v120 = _t27 + -8990;
            unix_error(_t27 + -8990, _t27, __esi, 75);
        }
    }
    __edx =  ?_? ( &_v108);
    stat_aux(0,  &_v108);
    return;
}

unix_lstat(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805ACAB
    intOrPtr _v60;                         // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    signed int _v92;                       // _cfa_ffffffa4
    char _v108;                            // _cfa_ffffff94
    intOrPtr _v116;                        // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    _unknown_ __ebx;                       // r1
    intOrPtr __esi;                        // r5
    _unknown_ __ebp;                       // r6
    char* _t15;                            // _t15
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17
    _unknown_ _t21;                        // _t21
    _unknown_ _t23;                        // _t23
    _unknown_ _t24;                        // _t24
    _unknown_ _t25;                        // _t25

    __i686.get_pc_thunk.bx();
    _t25 = _t24 + 76300;
    __esi = _a4;
    _t15 =  &_v108;
    _v116 = _t15;
    _v120 = __esi;
     *__esp = 3;
    __lxstat64();
    if(_t15 == 255) {
        _v120 = __esi;
        uerror(_t25 + -8984, _t25, __esi, _t25 + -8984);
    }
    if(_v60 < 0 && (_v60 > 0 || _v64 > 1073741823)) {
        if((_v92 & 61440) == 32768) {
            _v116 = __esi;
            _v120 = _t25 + -8984;
            unix_error(_t25 + -8984, _t25, __esi, 75);
        }
    }
    __edx =  ?_? ( &_v108);
    stat_aux(0,  &_v108);
    return;
}

unix_stat(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805AD41
    intOrPtr _v60;                         // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    signed int _v92;                       // _cfa_ffffffa4
    char _v108;                            // _cfa_ffffff94
    intOrPtr _v116;                        // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    _unknown_ __ebx;                       // r1
    intOrPtr __esi;                        // r5
    _unknown_ __ebp;                       // r6
    char* _t15;                            // _t15
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17
    _unknown_ _t21;                        // _t21
    _unknown_ _t23;                        // _t23
    _unknown_ _t24;                        // _t24
    _unknown_ _t25;                        // _t25

    __i686.get_pc_thunk.bx();
    _t25 = _t24 + 76150;
    __esi = _a4;
    _t15 =  &_v108;
    _v116 = _t15;
    _v120 = __esi;
     *__esp = 3;
    __xstat64();
    if(_t15 == 255) {
        _v120 = __esi;
        uerror(_t25 + -8989, _t25, __esi, _t25 + -8989);
    }
    if(_v60 < 0 && (_v60 > 0 || _v64 > 1073741823)) {
        if((_v92 & 61440) == 32768) {
            _v116 = __esi;
            _v120 = _t25 + -8989;
            unix_error(_t25 + -8989, _t25, __esi, 75);
        }
    }
    __edx =  ?_? ( &_v108);
    stat_aux(0,  &_v108);
    return;
}

unix_string_of_inet_addr(
    _unknown_ __eax,                       // r0
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805ADD8
    char _v76;                             // _cfa_ffffffb4
    intOrPtr _v80;                         // _cfa_ffffffb0
    char* _v84;                            // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    _unknown_ __ebx;                       // r1
    intOrPtr __esi;                        // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t12;                        // _t12
    char* _t14;                            // _t14
    _unknown_ _t15;                        // _t15
    _unknown_ _t17;                        // _t17
    _unknown_ _t18;                        // _t18

    __i686.get_pc_thunk.bx();
    _t18 = _t17 + 75999;
    __esi = _a4;
    if(caml_string_length(__esi) != 16) {
        _v80 = 64;
        _t14 =  &_v76;
        _v84 = _t14;
        _v88 = __esi;
         *__esp = 2;
        inet_ntop();
    } else {
        _v80 = 64;
        _t14 =  &_v76;
        _v84 = _t14;
        _v88 = __esi;
         *__esp = 10;
        inet_ntop();
    }
    if(_t14 == 0) {
        _v88 = 0;
        _t14 = uerror(_t18 + -8978, _t18, __esi, _t18 + -8978);
    }
    caml_copy_string(_t18, __edi, __esi, _t14);
    return;
}

unix_symlink(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    char* _a4,                             // _cfa_4
    char* _a8                              // _cfa_8
)
{// addr = 0x0805AE64
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char* _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t12;                        // _t12
    _unknown_ _t14;                        // _t14
    intOrPtr _t15;                         // _t15
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17
    char* _t19;                            // _t19
    _unknown_ _t20;                        // _t20

    _t15 = __ebx;
    _v12 = _t15;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t16 = _t15 + 75855;
    _t19 = _a8;
    if(symlink(_a4, _t19) == 255) {
        _v24 = _t19;
        uerror(_t16 + -8958, _t16, _t19, _t16 + -8958);
    }
    return 1;
}

unix_tcflow(
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0805AEC0
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t13;                       // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17

    __i686.get_pc_thunk.bx();
    _t18 = _t17 + 75768;
    _v24 =  *((intOrPtr*)(_t17 + 75768 + -8868 + (_a8 >> 1) * 4));
    _t13 = _a4 >> 1;
     *__esp = _t13;
    tcflow();
    if(_t13 == 255) {
        _v24 = 0;
        uerror(_t18 + -8950, _t18, __esi, _t18 + -8950);
    }
    return 1;
}

unix_tcflush(
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0805AF15
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t13;                       // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17

    __i686.get_pc_thunk.bx();
    _t18 = _t17 + 75683;
    _v24 =  *((intOrPtr*)(_t17 + 75683 + -8852 + (_a8 >> 1) * 4));
    _t13 = _a4 >> 1;
     *__esp = _t13;
    tcflush();
    if(_t13 == 255) {
        _v24 = 0;
        uerror(_t18 + -8943, _t18, __esi, _t18 + -8943);
    }
    return 1;
}

unix_tcdrain(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805AF6A
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t5;                        // _t5
    _unknown_ _t6;                         // _t6
    _unknown_ _t8;                         // _t8
    _unknown_ _t9;                         // _t9
    _unknown_ _t10;                        // _t10

    __i686.get_pc_thunk.bx();
    _t10 = _t9 + 75598;
    _t5 = _a4 >> 1;
     *__esp = _t5;
    tcdrain();
    if(_t5 == 255) {
        _v24 = 0;
        uerror(_t10 + -8935, _t10, __esi, _t10 + -8935);
    }
    return 1;
}

unix_tcsendbreak(
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0805AFAF
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t9;                        // _t9
    _unknown_ _t10;                        // _t10
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14

    __i686.get_pc_thunk.bx();
    _t14 = _t13 + 75529;
    _v24 = _a8 >> 1;
    _t9 = _a4 >> 1;
     *__esp = _t9;
    tcsendbreak();
    if(_t9 == 255) {
        _v24 = 0;
        uerror(_t14 + -8927, _t14, __esi, _t14 + -8927);
    }
    return 1;
}

unix_tcsetattr(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x0805AFFD
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v68;                         // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    intOrPtr __edi;                        // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t73;                       // _t73
    intOrPtr _t74;                         // _t74
    signed int _t79;                       // _t79
    _unknown_ _t80;                        // _t80
    _unknown_ _t82;                        // _t82
    _unknown_ _t83;                        // _t83
    _unknown_ _t85;                        // _t85
    _unknown_ _t86;                        // _t86
    _unknown_ _t88;                        // _t88
    _unknown_ _t90;                        // _t90
    _unknown_ _t92;                        // _t92
    _unknown_ _t94;                        // _t94
    _unknown_ _t96;                        // _t96
    _unknown_ _t97;                        // _t97
    _unknown_ _t98;                        // _t98
    _unknown_ _t103;                       // _t103
    _unknown_ _t104;                       // _t104
    _unknown_ _t105;                       // _t105
    _unknown_ _t109;                       // _t109
    _unknown_ _t111;                       // _t111
    _unknown_ _t115;                       // _t115
    _unknown_ _t117;                       // _t117
    _unknown_ _t118;                       // _t118
    _unknown_ _t119;                       // _t119
    _unknown_ _t120;                       // _t120
    _unknown_ _t121;                       // _t121

    __i686.get_pc_thunk.bx();
    _t98 = _t97 + 75449;
    _v44 = _a4 >> 1;
    _v72 = _t98 + 27516;
    _t73 = _v44;
     *__esp = _t73;
    tcgetattr();
    if(_t73 == 255) {
        _v72 = 0;
        uerror(_t98 + -8915, _t98, _t118, _t98 + -8915);
    }
    _t74 =  *((intOrPtr*)(_t98 + 26364));
    if(_t74 == 4) {
        _v68 = _t98 + 27516;
        _v72 =  *((intOrPtr*)(_t98 + -8840 + (_a8 >> 1) * 4));
        _t79 = _v44;
         *__esp = _t79;
        tcsetattr();
        __eflags = _t79 - 255;
        if(_t79 == 255) {
            _v72 = 0;
            uerror(_t98 + -8915, _t98, _t118, _t98 + -8915);
        }
        return 1;
    } else {
        __edi = _a12;
        _t119 = _t98 + 26364;
        _v40 = _t98 + -8804;
        _v48 = _t98 + 27516;
        while(1) {
            _t120 = _t119 + 4;
            if(_t74 == 1) {
                goto L14;
            } else {
                goto L5;
            }
        }
    }
}

unix_tcgetattr(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805B231
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    _unknown_ _v64;                        // _cfa_ffffffc0
    intOrPtr _v88;                         // _cfa_ffffffa8
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t59;                       // _t59
    intOrPtr _t60;                         // _t60
    _unknown_ _t63;                        // _t63
    _unknown_ _t67;                        // _t67
    _unknown_ _t71;                        // _t71
    _unknown_ _t83;                        // _t83
    _unknown_ _t84;                        // _t84
    _unknown_ _t85;                        // _t85
    _unknown_ _t88;                        // _t88
    _unknown_ _t91;                        // _t91
    _unknown_ _t92;                        // _t92
    _unknown_ _t93;                        // _t93
    _unknown_ _t94;                        // _t94
    _unknown_ _t95;                        // _t95
    _unknown_ _t96;                        // _t96
    _unknown_ _t99;                        // _t99

    __i686.get_pc_thunk.bx();
    _t84 = _t83 + 74885;
    _v88 = _t84 + 27516;
    _t59 = _a4 >> 1;
     *__esp = _t59;
    tcgetattr();
    if(_t59 == 255) {
        _v88 = 0;
        _t59 = uerror(_t84 + -8905, _t84, _t95, _t84 + -8905);
    }
    caml_alloc_tuple(38);
    _v44 = _t59;
    _t60 =  *((intOrPtr*)(_t84 + 26364));
    if(_t60 == 4) {
        return _v44;
    }
    __edi = _v44;
    _t91 = _t84 + 26364;
    _v48 = -8804;
    _v52 = _t84 + 27516;
    while(1) {
        _t96 = _t91 + 4;
        if(_t60 == 1) {
            goto L12;
        } else {
            goto L5;
        }
    }
}

unix_time(
    intOrPtr __eax                         // r0
)
{// addr = 0x0805B3EC
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4
    _unknown_ _t5;                         // _t5

    __i686.get_pc_thunk.bx();
     *__esp = 0;
    time();
    _v16 = __eax;
    asm("fild dword [ebp-0xc]");
    asm("fstp qword [esp]");
    caml_copy_double();
    return;
}

unix_times(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi                         // r5
)
{// addr = 0x0805B420
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v100;                            // _cfa_ffffff9c
    intOrPtr _v120;                        // _cfa_ffffff88
    _unknown_ __ebp;                       // r6
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    _unknown_ _t16;                        // _t16
    _unknown_ _t20;                        // _t20
    char* _t22;                            // _t22
    _unknown_ _t23;                        // _t23
    _unknown_ _t26;                        // _t26

    _t18 = __ebx;
    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx();
    _t14 = caml_alloc_small(_t18 + 74384, __esi, 8, 254);
    _t22 =  &_v100;
    _v120 = _t22;
     *__esp = 0;
    getrusage();
    asm("fild dword [ebp-0x60]");
    asm("fild dword [ebp-0x5c]");
    asm("fdiv qword [eax]");
    asm("faddp st1, st0");
    asm("fstp qword [esi]");
    asm("fild dword [ebp-0x58]");
    asm("fild dword [ebp-0x54]");
    asm("fdiv qword [eax]");
    asm("faddp st1, st0");
    asm("fstp qword [esi+0x8]");
    _v120 = _t22;
     *__esp = -1;
    getrusage();
    asm("fild dword [ebp-0x60]");
    asm("fild dword [ebp-0x5c]");
    asm("fdiv qword [eax]");
    asm("faddp st1, st0");
    asm("fstp qword [esi+0x10]");
    asm("fild dword [ebp-0x58]");
    asm("fild dword [ebp-0x54]");
    asm("fdiv qword [eax]");
    asm("faddp st1, st0");
    asm("fstp qword [esi+0x18]");
    return _t14;
}

unix_truncate_64(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805B4C4
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    intOrPtr _t13;                         // _t13
    intOrPtr _t14;                         // _t14
    _unknown_ _t15;                        // _t15
    _unknown_ _t17;                        // _t17
    intOrPtr _t18;                         // _t18
    _unknown_ _t19;                        // _t19
    _unknown_ _t20;                        // _t20
    intOrPtr _t22;                         // _t22
    _unknown_ _t23;                        // _t23

    _t18 = __ebx;
    _v12 = _t18;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t19 = _t18 + 74223;
    _t22 = _a4;
    _t13 = _a8;
    _t14 =  *((intOrPtr*)(_t13 + 4));
    _v24 = _t14;
    _v20 =  *((intOrPtr*)(_t13 + 8));
     *__esp = _t22;
    truncate64();
    if(_t14 == 255) {
        _v24 = _t22;
        uerror(_t19 + -9562, _t19, _t22, _t19 + -9562);
    }
    return 1;
}

unix_truncate(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0805B51D
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    signed int _t12;                       // _t12
    _unknown_ _t13;                        // _t13
    _unknown_ _t15;                        // _t15
    intOrPtr _t16;                         // _t16
    _unknown_ _t17;                        // _t17
    _unknown_ _t18;                        // _t18
    signed int _t22;                       // _t22
    _unknown_ _t23;                        // _t23

    _t16 = __ebx;
    _v12 = _t16;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t17 = _t16 + 74134;
    _t22 = _a4;
    _t12 = _a8 >> 1;
    _v24 = _t12;
    _v20 = _t12 >> 31;
     *__esp = _t22;
    truncate64();
    if(_t12 == 255) {
        _v24 = _t22;
        uerror(_t17 + -9562, _t17, _t22, _t17 + -9562);
    }
    return 1;
}

unix_umask(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805B578
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t5;                        // _t5
    _unknown_ _t7;                         // _t7
    _unknown_ _t8;                         // _t8

    __i686.get_pc_thunk.bx();
    _t5 = _a4 >> 1;
     *__esp = _t5;
    umask();
    return _t5 + _t5 + 1;
}

unix_error_of_code(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805B5A4
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t13;                        // _t13
    intOrPtr* _t15;                        // _t15
    intOrPtr _t19;                         // _t19
    _unknown_ _t21;                        // _t21
    intOrPtr _t23;                         // _t23
    _unknown_ _t24;                        // _t24

    _t19 = __ebx;
    _v12 = _t19;
    _v8 = __esi;
    __i686.get_pc_thunk.bx();
    _t20 = _t19 + 73999;
    _t23 = _a4;
    _t15 = cst_to_constr(_t23,  *((intOrPtr*)(_t19 + 0x12107)), 68, -1);
    __edx = _t15;
    if(_t15 == 255) {
        __edx = caml_alloc_small(_t20, _t23, 1, 0);
         *__edx = _t23 + _t23 + 1;
    }
    return __edx;
}

unix_error(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x0805B60F
    char _v16;                             // _cfa_fffffff0
    char _v20;                             // _cfa_ffffffec
    char _v24;                             // _cfa_ffffffe8
    char* _v36;                            // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    char* _v44;                            // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    char _v56;                             // _cfa_ffffffc8
    intOrPtr _v68;                         // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8
    intOrPtr _v96;                         // _cfa_ffffffa0
    char* _v100;                           // _cfa_ffffff9c
    intOrPtr _v112;                        // _cfa_ffffff90
    intOrPtr _v116;                        // _cfa_ffffff8c
    char* _v128;                           // _cfa_ffffff80
    _unknown_ __ebp;                       // r6
    _unknown_ _t47;                        // _t47
    intOrPtr _t48;                         // _t48
    intOrPtr* _t53;                        // _t53
    int* _t54;                             // _t54
    _unknown_ _t56;                        // _t56
    _unknown_ _t58;                        // _t58
    intOrPtr _t61;                         // _t61
    _unknown_ _t64;                        // _t64
    _unknown_ _t65;                        // _t65
    intOrPtr _t66;                         // _t66
    _unknown_ _t67;                        // _t67
    _unknown_ _t68;                        // _t68
    intOrPtr* _t72;                        // _t72
    intOrPtr _t84;                         // _t84
    char* _t85;                            // _t85
    _unknown_ _t86;                        // _t86
    _unknown_ _t87;                        // _t87
    intOrPtr* _t88;                        // _t88
    _unknown_ _t89;                        // _t89

    _t84 = __esi;
    _t64 = __ebx;
    _push(_t64);
    __esp = __esp - 68;
    __i686.get_pc_thunk.bx();
    _t65 = _t64 + 73897;
    _t48 = _a12;
    _v16 = 1;
    _v20 = 1;
    _v24 = 1;
    _t72 =  *((intOrPtr*)(_t65 + -24));
    _v56 =  *_t72;
     *_t72 =  &_v56;
    _v48 = 1;
    _v52 = 3;
    _v44 =  &_v16;
    _v40 =  &_v20;
    _v36 =  &_v24;
    if(_t48 == 0) {
        _t48 = caml_copy_string(_t65, __edi, _t84, _t65 + -5244);
    }
    _v24 = _t48;
    _v16 = caml_copy_string(_t65, __edi, _t84, _a8);
    _v20 = unix_error_of_code(_a4, _t65, _t84, _a4);
    if( *((intOrPtr*)(_t65 + 27576)) == 0) {
        _t61 = caml_named_value(_t65 + -8652, _t65 + -8652);
         *((intOrPtr*)(_t65 + 27576)) = _t61;
        if(_t61 == 0) {
             *__esp = _t65 + -8636;
            caml_invalid_argument();
        }
    }
    _t53 = caml_alloc_small(_t65, _t84, 4, 0);
     *_t53 =  *((intOrPtr*)( *((intOrPtr*)(_t65 + 27576))));
     *((intOrPtr*)(_t53 + 4)) = _v20;
     *((intOrPtr*)(_t53 + 8)) = _v16;
     *((intOrPtr*)(_t53 + 12)) = _v24;
     *((intOrPtr*)( *((intOrPtr*)(_t65 + -24)))) = _v56;
     *__esp = _t53;
    caml_raise();
    _push(_t87);
    _t88 = __esp;
    _push(_t65);
    __esp = __esp - 20;
    __i686.get_pc_thunk.bx();
    _t66 = _t65 + 73644;
    _t54 = __errno_location();
    _v96 = _v68;
    _v100 = _v72;
    unix_error( *_t54, _t66, _t84,  *_t54);
    _push(_t88);
    __esp = __esp - 24;
    _v116 = _t66;
    _v112 = _t84;
    __i686.get_pc_thunk.bx();
    _t67 = _t66 + 73591;
    _t85 = _v100;
    if(unlink(_t85) == 255) {
        _v128 = _t85;
         *__esp = _t67 + -8572;
        L6();
    }
    return 1;
}

uerror(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    intOrPtr __esi,                        // r5
    char* _a4,                             // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805B70C
    _unknown_ _v12;                        // _cfa_fffffff4
    _unknown_ _v16;                        // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char* _v52;                            // _cfa_ffffffcc
    _unknown_ __ebp;                       // r6
    _unknown_ _t12;                        // _t12
    int* _t13;                             // _t13
    _unknown_ _t15;                        // _t15
    _unknown_ _t17;                        // _t17
    _unknown_ _t19;                        // _t19
    _unknown_ _t20;                        // _t20
    intOrPtr _t21;                         // _t21
    _unknown_ _t22;                        // _t22
    _unknown_ _t23;                        // _t23
    intOrPtr _t26;                         // _t26
    char* _t27;                            // _t27
    _unknown_ _t28;                        // _t28
    _unknown_ _t29;                        // _t29
    _unknown_ _t30;                        // _t30

    _t26 = __esi;
    _t20 = __ebx;
    _push(_t20);
    __esp = __esp - 20;
    __i686.get_pc_thunk.bx();
    _t21 = _t20 + 73644;
    _t13 = __errno_location();
    _v20 = _a8;
    _v24 = _a4;
    unix_error( *_t13, _t21, _t26,  *_t13);
    _push(_t29);
    __esp = __esp - 24;
    _v40 = _t21;
    _v36 = _t26;
    __i686.get_pc_thunk.bx();
    _t22 = _t21 + 73591;
    _t27 = _v24;
    if(unlink(_t27) == 255) {
        _v52 = _t27;
        uerror(_t22 + -8572, _t22, _t27, _t22 + -8572);
    }
    return 1;
}

unix_unlink(
    char* _a4                              // _cfa_4
)
{// addr = 0x0805B73C
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char* _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t9;                         // _t9
    _unknown_ _t11;                        // _t11
    intOrPtr _t12;                         // _t12
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14
    intOrPtr _t15;                         // _t15
    char* _t16;                            // _t16
    _unknown_ _t17;                        // _t17

    _v12 = _t12;
    _v8 = _t15;
    __i686.get_pc_thunk.bx();
    _t13 = _t12 + 73591;
    _t16 = _a4;
    if(unlink(_t16) == 255) {
        _v24 = _t16;
        uerror(_t13 + -8572, _t13, _t16, _t13 + -8572);
    }
    return 1;
}

unix_utimes(
    intOrPtr _a4,                          // _cfa_4
    _unknown_ _a8,                         // _cfa_8
    _unknown_ _a12                         // _cfa_c
)
{// addr = 0x0805B784
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v20;                             // _cfa_ffffffec
    signed short _v30;                     // _cfa_ffffffe2
    signed int _v32;                       // _cfa_ffffffe0
    char* _v36;                            // _cfa_ffffffdc
    intOrPtr _v56;                         // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t18;                        // _t18
    char* _t20;                            // _t20
    _unknown_ _t21;                        // _t21
    _unknown_ _t23;                        // _t23
    _unknown_ _t24;                        // _t24
    _unknown_ _t25;                        // _t25
    _unknown_ _t26;                        // _t26
    intOrPtr _t27;                         // _t27

    __i686.get_pc_thunk.bx();
    _t25 = _t24 + 73523;
    __esi = _a4;
    asm("fld qword [eax]");
    asm("fnstcw word [ebp-0x1a]");
    _v32 = _v30 & 0xffff;
    asm("fldcw word [ebp-0x1c]");
    asm("fistp dword [ebp-0x20]");
    asm("fldcw word [ebp-0x1a]");
    _t20 = _v36;
    _v20 = _t20;
    asm("fld qword [edx]");
    asm("fldcw word [ebp-0x1c]");
    asm("fistp dword [ebp-0x20]");
    asm("fldcw word [ebp-0x1a]");
    _t27 = _v36;
    if(_t20 != 0 || _t27 != 0) {
        _t20 =  &_v20;
    }
    _v16 = _t27;
    _v56 = _t20;
     *__esp = __esi;
    utime();
    if(_t20 == 255) {
        _v56 = __esi;
        uerror(_t25 + -8565, _t25, __esi, _t25 + -8565);
    }
    return 1;
}

alloc_process_status(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    signed int __edx,                      // r3
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    _unknown_ __eflags                     // r9
)
{// addr = 0x0805B80C
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    char* _v52;                            // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    char _v64;                             // _cfa_ffffffc0
    signed int _v80;                       // _cfa_ffffffb0
    _unknown_ _v104;                       // _cfa_ffffff98
    _unknown_ __ebp;                       // r6
    signed int _t45;                       // _t45
    signed int _t46;                       // _t46
    intOrPtr* _t51;                        // _t51
    signed int _t52;                       // _t52
    signed int _t54;                       // _t54
    intOrPtr _t55;                         // _t55
    _unknown_ _t56;                        // _t56
    _unknown_ _t57;                        // _t57
    signed int _t58;                       // _t58
    _unknown_ _t67;                        // _t67
    _unknown_ _t68;                        // _t68
    signed int _t70;                       // _t70
    intOrPtr* _t72;                        // _t72
    _unknown_ _t73;                        // _t73

    __eflags = __eflags;
    _t58 = __edx;
    _t55 = __ebx;
    _v16 = _t55;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx();
    _t56 = _t55 + 73380;
    _t67 = __eax;
    _t70 = _t58;
    _v80 = _t58 & 127;
    if(__eflags != 0) {
        __eflags = (_t58 & 255) - 127;
        if((_t58 & 255) != 127) {
            _t45 = caml_alloc_small(_t56, _t70, 1, 1);
            _v32 = _t45;
            _t46 = _v80;
            caml_rev_convert_signal_number(_t46);
             *_t45 = _t46 + _t46 + 1;
        } else {
            _t52 = caml_alloc_small(_t56, _t70, 1, 2);
            _v80 = _t52;
            _v32 = _t52;
            caml_rev_convert_signal_number(_t70 & 0xff);
             *_v80 = _t52 + _t52 + 1;
        }
    } else {
        _t54 = caml_alloc_small(_t56, _t70, 1, 0);
        _v32 = _t54;
         *_t54 = (_t70 & 0xff) + (_t70 & 0xff) + 1;
    }
    _t72 =  *((intOrPtr*)(_t56 + -24));
    _v64 =  *_t72;
     *_t72 =  &_v64;
    _v56 = 1;
    _v60 = 1;
    _v52 =  &_v32;
    _t51 = caml_alloc_small(_t56, _t72, 2, 0);
     *_t51 = _t67 + _t67 + 1;
     *(_t51 + 4) = _v32;
     *_t72 = _v64;
    return;
}

unix_waitpid(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0805B90F
    char _v16;                             // _cfa_fffffff0
    intOrPtr _v36;                         // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    intOrPtr _t13;                         // _t13
    signed int _t16;                       // _t16
    _unknown_ _t19;                        // _t19
    _unknown_ _t20;                        // _t20

    __i686.get_pc_thunk.bx();
    _t21 = _t20 + 73128;
    _t13 = caml_convert_flag_list(_a4, _t20 + 0x18794);
    caml_enter_blocking_section();
    _v36 = _t13;
    _v40 =  &_v16;
    _t16 = _a8 >> 1;
     *__esp = _t16;
    waitpid();
    _t23 = _t16;
    caml_leave_blocking_section();
    __eflags = _t16 - 255;
    if(__eflags == 0) {
        _v40 = 0;
        uerror(_t21 + -8558, _t21, _t23, _t21 + -8558);
    }
    __edx = _v16;
    alloc_process_status(_t23, _t21, _v16, __edi, _t23, __eflags);
    return;
}

unix_wait()
{// addr = 0x0805B989
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char _v16;                             // _cfa_fffffff0
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    char* _t9;                             // _t9
    _unknown_ _t12;                        // _t12
    intOrPtr _t13;                         // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    intOrPtr _t16;                         // _t16
    _unknown_ _t18;                        // _t18

    _v12 = _t13;
    _v8 = _t16;
    __i686.get_pc_thunk.bx();
    _t14 = _t13 + 73002;
    caml_enter_blocking_section();
    _t9 =  &_v16;
     *__esp = _t9;
    wait();
    _t17 = _t9;
    caml_leave_blocking_section();
    __eflags = _t9 - 255;
    if(__eflags == 0) {
        _v40 = 0;
        uerror(_t14 + -8550, _t14, _t17, _t14 + -8550);
    }
    __edx = _v16;
    alloc_process_status(_t17, _t14, _v16, __edi, _t17, __eflags);
    return;
}

unix_single_write(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    signed int _a4,                        // _cfa_4
    char _a8,                              // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x0805B9E8
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v16412;                          // _cfa_ffffbfe4
    char* _v16432;                         // _cfa_ffffbfd0
    intOrPtr _v16436;                      // _cfa_ffffbfcc
    intOrPtr _v16440;                      // _cfa_ffffbfc8
    char _v16444;                          // _cfa_ffffbfc4
    int _v16452;                           // _cfa_ffffbfbc
    int _v16456;                           // _cfa_ffffbfb8
    _unknown_ __ebp;                       // r6
    intOrPtr* _t30;                        // _t30
    _unknown_ _t34;                        // _t34
    _unknown_ _t38;                        // _t38
    _unknown_ _t43;                        // _t43
    intOrPtr _t44;                         // _t44
    _unknown_ _t45;                        // _t45
    _unknown_ _t46;                        // _t46
    _unknown_ _t51;                        // _t51
    intOrPtr _t53;                         // _t53
    signed int _t55;                       // _t55
    int _t56;                              // _t56
    _unknown_ _t57;                        // _t57

    _t44 = __ebx;
    _v16 = _t44;
    _v12 = _t53;
    _v8 = __edi;
    __i686.get_pc_thunk.bx();
    _t45 = _t44 + 72901;
    _t30 =  *((intOrPtr*)(_t45 + -24));
    _v16444 =  *_t30;
     *_t30 =  &_v16444;
    _v16436 = 1;
    _v16440 = 1;
    _v16432 =  &_a8;
    _t55 = _a16 >> 1;
    if(_t55 <= 0) {
L3:
        _t56 = 0;
    } else {
        _t58 = _t55 - 16384 > 0 ? 16384 : _t55;
        _v16452 = _t55 - 16384 > 0 ? 16384 : _t55;
        _v16456 = (_a12 >> 1) + _a8;
        _t52 =  ?_? ( &_v16412);
         *__esp =  &_v16412;
        memmove();
        caml_enter_blocking_section();
        _t56 = write(_a4 >> 1, _t52, _t58);
        caml_leave_blocking_section();
        if(_t56 != 255) {
        } else {
            _v16456 = 0;
            uerror(_t45 + -8545, _t45, _t56, _t45 + -8545);
            goto L3;
        }
L5:
    }
     *((intOrPtr*)( *((intOrPtr*)(_t45 + -24)))) = _v16444;
    return _t56 + _t56 + 1;
    goto L5;
}

unix_write(
    _unknown_ __ebx,                       // r1
    _unknown_ __esi,                       // r5
    signed int _a4,                        // _cfa_4
    char _a8,                              // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x0805BACD
    char _v16412;                          // _cfa_ffffbfe4
    char* _v16432;                         // _cfa_ffffbfd0
    intOrPtr _v16436;                      // _cfa_ffffbfcc
    intOrPtr _v16440;                      // _cfa_ffffbfc8
    char _v16444;                          // _cfa_ffffbfc4
    signed int _v16448;                    // _cfa_ffffbfc0
    signed int _v16452;                    // _cfa_ffffbfbc
    void* _v16456;        // _cfa_ffffbfb8
    signed int _v16460;                    // _cfa_ffffbfb4
    _unknown_ _v16468;                     // _cfa_ffffbfac
    signed int _v16472;                    // _cfa_ffffbfa8
    _unknown_ __edi;                       // r4
    _unknown_ __ebp;                       // r6
    intOrPtr* _t39;                        // _t39
    _unknown_ _t50;                        // _t50
    _unknown_ _t55;                        // _t55
    _unknown_ _t56;                        // _t56
    _unknown_ _t57;                        // _t57
    _unknown_ _t64;                        // _t64
    int _t66;                              // _t66
    _unknown_ _t67;                        // _t67
    signed int _t69;                       // _t69

    _t56 = __ebx;
    __i686.get_pc_thunk.bx();
    _t57 = _t56 + 72678;
    _t39 =  *((intOrPtr*)(_t57 + -24));
    _v16444 =  *_t39;
     *_t39 =  &_v16444;
    _v16436 = 1;
    _v16440 = 1;
    _v16432 =  &_a8;
    _t69 = _a16 >> 1;
    if(_t69 <= 0) {
        _v16452 = 0;
        goto L9;
    }
    _v16448 = _a12 >> 1;
    _v16460 = _a4 >> 1;
    _v16452 = 0;
    _v16456 =  &_v16412;
    while(1) {
        _t65 = _t69 - 16384 <= 0 ? _t69 : 16384;
        memmove(_v16456, _v16448 + _a8, _t69 - 16384 <= 0 ? _t69 : 16384);
        caml_enter_blocking_section();
        _t66 = write(_v16460, _v16456, _t69 - 16384 <= 0 ? _t69 : 16384);
        caml_leave_blocking_section();
        if(_t66 == 255) {
            break;
        }
L6:
        _v16452 = _v16452 + _t66;
        _t69 = _t69 - _t66;
        if(_t69 <= 0) {
            goto L9;
        }
        _v16448 = _v16448 + _t66;
    }
    _t69 = _v16452;
    if( *(__errno_location()) != 11 || _t69 <= 0) {
        _v16472 = 0;
        uerror(_t57 + -8538, _t57, _t69, _t57 + -8538);
        goto L6;
    }
L9:
     *((intOrPtr*)( *((intOrPtr*)(_t57 + -24)))) = _v16444;
    return _v16452 + _v16452 + 1;
}

cst_to_constr(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr* _a8,                         // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    intOrPtr _a16                          // _cfa_10
)
{// addr = 0x0805BC20
    intOrPtr* __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t13;                       // _t13

    __ecx = _a4;
    __esi = _a8;
    __edx = _a12;
    if(__edx <= 0) {
L6:
        return _a16 + _a16 + 1;
    }
    _t13 = 0;
    if( *__esi != __ecx) {
        while(1) {
            _t13 = _t13 + 1;
            if(__edx <= _t13) {
                break;
            }
            if( *((intOrPtr*)(__esi + _t13 * 4)) != __ecx) {
                continue;
            }
            goto L4;
        }
        goto L6;
    }
L4:
    return _t13 + _t13 + 1;
    goto L6;
    return __eax;
}

cstringvect(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805BC58
    intOrPtr _v32;                         // _cfa_ffffffe0
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    intOrPtr __esi;                        // r5
    _unknown_ __ebp;                       // r6
    intOrPtr _t14;                         // _t14
    _unknown_ _t17;                        // _t17
    _unknown_ _t18;                        // _t18
    signed int _t20;                       // _t20

    __i686.get_pc_thunk.bx();
    __esi = _a4;
    _t20 =  *(__esi - 4) >> 10;
    _t14 = 4 + _t20 * 4;
    caml_stat_alloc(_t14);
    _v32 = _t14;
    if(_t20 != 0) {
        __edx = 0;
        while(1) {
             *((intOrPtr*)(_t14 + __edx * 4)) =  *((intOrPtr*)(__esi + __edx * 4));
            __edx = __edx + 1;
            if(_t20 <= __edx) {
                break;
            }
        }
    }
     *(_v32 + _t20 * 4) = 0;
    return _v32;
}

scanmult(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx,                        // r1
    signed int* __edx,                     // r3
    intOrPtr __edi,                        // r4
    intOrPtr __esi                         // r5
)
{// addr = 0x0805BCC0
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    signed char _v29;                      // _cfa_ffffffe3
    signed int _v36;                       // _cfa_ffffffdc
    signed int* _v48;                      // _cfa_ffffffd0
    char* _v64;                            // _cfa_ffffffc0
    char* _v68;                            // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    intOrPtr _t32;                         // _t32
    signed int _t33;                       // _t33
    char* _t39;                            // _t39
    _unknown_ _t40;                        // _t40
    _unknown_ _t48;                        // _t48
    char* _t50;                            // _t50
    _unknown_ _t51;                        // _t51

    _t32 = __eax;
    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _v48 = __edx;
    _v29 = 32;
    _t39 =  &_v29;
    _v64 = _t39;
    _t50 =  &_v36;
    _v68 = _t50;
    _v72 = 134657392;
     *__esp = _t32;
    __isoc99_sscanf();
    _v64 = _t39;
    _v68 = _t50;
    _v72 = "=0x%x%c";
     *__esp = _t32;
    __isoc99_sscanf();
    _t33 = _v29 & 255;
    if((_t33 & 255) == 77) {
         *_v48 = _v36 << 20;
    } else {
        if((_t33 & 255) == 107) {
             *_v48 = _v36 << 10;
        } else {
            if((_t33 & 255) != 71) {
                 *_v48 = _v36;
            } else {
                asm("o16 nop ");
                 *_v48 = _v36 << 30;
            }
        }
    }
    return;
}

caml_main(
    _unknown_ __ebx,                       // r1
    char* __esi,                           // r5
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805BD5E
    char _v29;                             // _cfa_ffffffe3
    char _v36;                             // _cfa_ffffffdc
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    signed int _v72;                       // _cfa_ffffffb8
    char* __edi;                           // r4
    _unknown_ __ebp;                       // r6
    char* _t38;                            // _t38
    signed int _t39;                       // _t39
    signed int _t40;                       // _t40
    signed int _t47;                       // _t47
    intOrPtr _t51;                         // _t51
    _unknown_ _t53;                        // _t53
    _unknown_ _t54;                        // _t54
    signed int _t55;                       // _t55
    char* _t59;                            // _t59
    _unknown_ _t60;                        // _t60
    char* _t61;                            // _t61
    intOrPtr _t64;                         // _t64
    char* _t65;                            // _t65
    char* _t67;                            // _t67
    signed int _t70;                       // _t70

    __esi = __esi;
    caml_init_ieee_floats();
    caml_init_custom_operations();
    caml_top_of_stack =  &_v29;
    _t38 = getenv("OCAMLRUNPARAM");
    _t61 = _t38;
    if(_t38 != 0) {
L5:
        __esi = 134657480;
        __edi =  &_v36;
        while(1) {
            _t39 =  *_t61 & 255;
            if((_t39 & 255) == 0) {
                break;
            }
            _t61 =  &(_t61[1]);
            _t40 = _t39 - 79;
            if((_t40 & 255) > 39) {
            } else {
                goto L4;
            }
            continue;
L4:
            goto ( *((intOrPtr*)(__esi + (_t40 & 0xff) * 4)));
        }
L7:
        caml_init_gc(minor_heap_init, heap_size_init, heap_chunk_init, percent_free_init, max_percent_free_init);
        _t47 = 0;
        _t65 =  &caml_atom_table;
        while(1) {
L8:
             *(_t65 + _t47 * 4) = _t47;
            _t47 = _t47 + 1;
            if(_t47 == 256) {
                break;
            }
        }
        if(caml_page_table_add(_t47, 4,  &caml_atom_table,  &caml_frame_descriptors_mask) != 0) {
            caml_fatal_error("Fatal error: not enough memory for the initial page table");
L13:
            while() {
            }
        }
        _t48 = caml_data_segments;
        _t61 = 0;
        __esi = 134667644;
        __edi =  &caml_data_segments;
        if(caml_data_segments != 0) {
            goto L13;
        } else {
        }
        caml_code_area_start = caml_code_segments;
        __ecx =  *134667736;
        caml_code_area_end = __ecx;
        _t51 =  *134667740;
        if(_t51 != 0) {
            _t64 = caml_code_area_start;
            _t70 = 1;
            __edi = 134667736;
            __esi =  &caml_code_segments;
            while(1) {
                _t64 = _t64 - _t51 > 0 ? _t51 : _t64;
                __ecx = __ecx -  *((intOrPtr*)(__edi + _t70 * 8)) < 0 ?  *((intOrPtr*)(__edi + _t70 * 8)) : __ecx;
                _t70 = _t70 + 1;
                _t51 =  *((intOrPtr*)(__esi + _t70 * 8));
                if(_t51 == 0) {
                    break;
                }
            }
            caml_code_area_start = _t64;
            caml_code_area_end = __ecx;
        }
        caml_init_signals();
        caml_debugger_init();
        _t63 =  *_a4 == 0 ? 134660680 :  *_a4;
        _t54 = caml_executable_name(134660680,  *_a4 == 0 ? 134660680 :  *_a4, __esi,  &proc_self_exe.2949, 256);
        _t67 =  &proc_self_exe.2949;
        if(_t54 != 0) {
            _t67 = caml_search_exe_in_path(_t54, _t63, __edi, __esi, _t63);
        }
        _t55 = _a4;
        caml_sys_init(_t67, _t55);
        _v72 = 0;
         *__esp =  &caml_termination_jmpbuf;
        __sigsetjmp();
        if(_t55 == 0) {
            caml_start_program();
            if((_t55 & 3) != 2) {
            } else {
                 *__esp = _t55 & 252;
                caml_fatal_uncaught_exception(__esi);
                return;
            }
        } else {
            _t55 = caml_termination_hook;
            if(_t55 == 0) {
            } else {
                 *__esp = 0;
                 *_t55();
                return;
            }
L28:
        }
        return;
        goto L28;
    }
    _t59 = getenv( &M0806B57F);
    _t61 = _t59;
    if(_t59 == 0) {
    } else {
        goto L5;
    }
    goto L7;
}

caml_startup(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805C019
    _unknown_ __ebp;                       // r6

    caml_main(__ebx, __esi, _a4);
    return;
}

main(
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805C02C
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4

    __esp = __esp & 240;
    __esp = __esp - 16;
    caml_main(__ebx, __esi, _a8);
     *__esp = 1;
    caml_sys_exit(_a8, __edi);
    return 0;
}

caml_raise(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805C060
    signed int* _v40;                      // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    unsigned int _v48;                     // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    signed int _v92;                       // _cfa_ffffffa4
    signed int _v96;                       // _cfa_ffffffa0
    signed int _v100;                      // _cfa_ffffff9c
    signed int _v104;                      // _cfa_ffffff98
    char _v108;                            // _cfa_ffffff94
    char* _v144;                           // _cfa_ffffff70
    intOrPtr _v148;                        // _cfa_ffffff6c
    intOrPtr _v152;                        // _cfa_ffffff68
    char _v156;                            // _cfa_ffffff64
    signed int _v176;                      // _cfa_ffffff50
    signed int _v180;                      // _cfa_ffffff4c
    intOrPtr _v184;                        // _cfa_ffffff48
    char _v188;                            // _cfa_ffffff44
    char _v196;                            // _cfa_ffffff3c
    signed int _v200;                      // _cfa_ffffff38
    char* _v232;                           // _cfa_ffffff18
    char* _v236;                           // _cfa_ffffff14
    intOrPtr _v240;                        // _cfa_ffffff10
    intOrPtr _v244;                        // _cfa_ffffff0c
    char _v248;                            // _cfa_ffffff08
    signed int _v252;                      // _cfa_ffffff04
    signed int _v272;                      // _cfa_fffffef0
    intOrPtr _v276;                        // _cfa_fffffeec
    intOrPtr _v280;                        // _cfa_fffffee8
    char _v284;                            // _cfa_fffffee4
    signed int _v308;                      // _cfa_fffffecc
    char _v332;                            // _cfa_fffffeb4
    signed int _v336;                      // _cfa_fffffeb0
    char _v364;                            // _cfa_fffffe94
    char _v392;                            // _cfa_fffffe78
    char _v420;                            // _cfa_fffffe5c
    char* _v456;                           // _cfa_fffffe38
    intOrPtr _v460;                        // _cfa_fffffe34
    intOrPtr _v464;                        // _cfa_fffffe30
    char _v468;                            // _cfa_fffffe2c
    signed int _v472;                      // _cfa_fffffe28
    signed int _v492;                      // _cfa_fffffe14
    intOrPtr _v496;                        // _cfa_fffffe10
    intOrPtr _v500;                        // _cfa_fffffe0c
    char _v504;                            // _cfa_fffffe08
    _unknown_ _v528;                       // _cfa_fffffdf0
    signed int _v636;                      // _cfa_fffffd84
    signed int* _v700;                     // _cfa_fffffd44
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __ebp;                       // r6
    _unknown_ _t123;                       // _t123
    signed int _t128;                      // _t128
    signed int _t134;                      // _t134
    char _t138;                            // _t138
    signed int _t146;                      // _t146
    signed int* _t150;                     // _t150
    signed int _t153;                      // _t153
    signed int* _t155;                     // _t155
    signed int _t159;                      // _t159
    _unknown_ _t160;                       // _t160
    _unknown_ _t164;                       // _t164
    signed int _t165;                      // _t165
    signed int _t166;                      // _t166
    intOrPtr _t167;                        // _t167
    intOrPtr _t168;                        // _t168
    intOrPtr _t170;                        // _t170
    unsigned int _t176;                    // _t176
    signed int _t179;                      // _t179
    _unknown_ _t180;                       // _t180
    signed int* _t182;                     // _t182
    signed int _t183;                      // _t183
    _unknown_ _t184;                       // _t184
    signed int* _t185;                     // _t185
    signed int* _t186;                     // _t186
    signed int* _t187;                     // _t187
    signed int* _t188;                     // _t188
    signed int* _t189;                     // _t189
    signed int* _t190;                     // _t190
    signed int* _t191;                     // _t191
    signed int* _t192;                     // _t192
    signed int* _t193;                     // _t193
    signed int* _t194;                     // _t194
    signed int* _t195;                     // _t195
    signed int* _t196;                     // _t196
    signed int* _t197;                     // _t197
    signed int* _t198;                     // _t198
    _unknown_ _t199;                       // _t199

    _push(_t164);
    __esp = __esp - 20;
    _t165 = _a4;
    _t123 = caml_channel_mutex_unlock_exn;
    if(_t123 != 0) {
         *_t123();
    }
    _t170 = caml_exception_pointer;
    if(_t170 == 0) {
         *__esp = _t165;
        caml_fatal_uncaught_exception(_t180);
        while(1) {
L7:
            _t123 =  *_t123;
            caml_local_roots = _t123;
            if(_t123 == 0 || _t170 <= _t123) {
                break;
            }
        }
L9:
        caml_raise_exception(_t165);
        _push(_t184);
        _t185 = __esp;
        __esp = __esp - 24;
        if(array_bound_error_bucket_inited == 0) {
            array_bound_error_msg = 5372;
             *134693095 = 0;
            array_bound_error_bucket = 2048;
             *134693804 =  &caml_exn_Invalid_argument;
             *134693808 = "index out of bounds";
            array_bound_error_bucket_inited = 1;
            caml_page_table_add(_t123, 4,  &array_bound_error_msg,  &caml_last_return_address);
            array_bound_error_bucket_inited = 1;
        }
         *__esp = 134693804;
        caml_raise();
        _push(_t185);
        _t186 = __esp;
        __esp = __esp - 24;
         *__esp =  &caml_bucket_Stack_overflow;
        caml_raise();
L14:
        _push(_t186);
        _t187 = __esp;
        __esp = __esp - 24;
         *__esp =  &caml_bucket_Out_of_memory;
        caml_raise();
        _push(_t187);
        _t188 = __esp;
        _push(_t180);
        _push(_t165);
        __esp = __esp - 80;
        _t181 = _v104;
        _t166 = _v100;
        _v156 = caml_local_roots;
        _v148 = 1;
        _v152 = 1;
        _v144 =  &_v108;
        _v188 =  &_v156;
        caml_local_roots =  &_v188;
        _v180 = _t181;
        _v184 = 1;
        _v176 = _t166;
        _v200 = 0;
        _t128 = _t181 + 1;
         *__esp = _t128;
        caml_alloc_small(_t166, _t181);
         *_t128 = _v108;
        if(_t181 > 0) {
            _t179 = 0;
            while(1) {
                 *((intOrPtr*)(_t128 + 4 + _t179 * 4)) =  *((intOrPtr*)(_t166 + _t179 * 4));
                _t179 = _t179 + 1;
                if(_t179 == _t181) {
                    break;
                }
            }
        }
         *__esp = _t128;
        caml_raise();
        _push(_t188);
        _t189 = __esp;
        __esp = __esp - 104;
        _v248 = caml_local_roots;
        _v240 = 1;
        _v244 = 2;
        _v236 =  &_v200;
        _v232 =  &_v196;
        _v252 = 0;
        _v284 =  &_v248;
        caml_local_roots =  &_v284;
        _v276 = 1;
        _v280 = 1;
        _t134 =  &_v252;
        _v272 = _t134;
        caml_alloc_small(_t166, _t181, 2, 0);
        _v252 = _t134;
         *_t134 = _v200;
         *((intOrPtr*)(_v252 + 4)) = _v196;
         *__esp = _v252;
        caml_raise();
        _push(_t189);
        _t190 = __esp;
        __esp = __esp - 24;
        _v336 = _v308;
         *__esp =  &caml_exn_Sys_error;
        L19();
        _push(_t190);
        _t191 = __esp;
        __esp = __esp - 24;
        _t138 = _v332;
        caml_copy_string(_t166, __edi, _t181, _t138);
        _v364 = _t138;
         *__esp = _v336;
        L19();
        _push(_t191);
        _t192 = __esp;
        __esp = __esp - 24;
        _v392 = _v364;
         *__esp =  &caml_exn_Invalid_argument;
        L21();
        _push(_t192);
        _t193 = __esp;
        __esp = __esp - 24;
        _v420 = _v392;
         *__esp =  &caml_exn_Failure;
        L21();
        _push(_t193);
        _t194 = __esp;
        __esp = __esp - 104;
        _v468 = caml_local_roots;
        _v460 = 1;
        _v464 = 1;
        _v456 =  &_v420;
        _v472 = 0;
        _v504 =  &_v468;
        caml_local_roots =  &_v504;
        _v496 = 1;
        _v500 = 1;
        _t146 =  &_v472;
        _v492 = _t146;
        caml_alloc_small(_t166, _t181, 1, 0);
        _v472 = _t146;
         *_t146 = _v420;
         *__esp = _v472;
        caml_raise();
        _push(_t194);
        _t195 = __esp;
        __esp = __esp - 24;
         *__esp =  &caml_exn_Sys_blocked_io;
        L24();
        _push(_t195);
        _t196 = __esp;
        __esp = __esp - 24;
         *__esp =  &caml_exn_Not_found;
        L24();
        _push(_t196);
        _t197 = __esp;
        __esp = __esp - 24;
         *__esp =  &caml_exn_Division_by_zero;
        L24();
        _push(_t197);
        _t198 = __esp;
        __esp = __esp - 24;
         *__esp =  &caml_exn_End_of_file;
        L24();
        _push(_t198);
        _push(__edi);
        _push(_t181);
        _push(_t166);
        __esp = __esp - 44;
        _t148 = _v636;
        if(_t148 != 0) {
            _v96 = _v44;
            _t176 = _v48;
            _v92 = _t148;
            while(1) {
L33:
                _t181 = caml_frame_descriptors_mask;
                _t153 = _t176 >> 3 & _t181;
                _t168 = caml_frame_descriptors;
                _t166 =  *(_t168 + _t153 * 4);
                if( *_t166 == _t176) {
                    break;
                } else {
                    goto L34;
                }
                while(1) {
L34:
                    _t153 = _t153 + 1 & _t181;
                    _t166 =  *(_t168 + _t153 * 4);
                    if( *_t166 == _t176) {
                        break;
                    }
                }
                break;
            }
L35:
            if( *(_t166 + 4) != 255) {
                _t183 =  *(_t166 + 6) & 65535;
                if(_t183 > 0) {
                    __edi = _t166 + 8;
                    _v100 = _t166;
                    _t167 = _v56;
                    while(1) {
                        _t159 =  *__edi & 65535;
                        if((_t159 & 1) == 0) {
                            _t160 = _t159 + _v92;
                        } else {
                            _t160 = _v96 + (_t159 >> 1) * 4;
                        }
                        goto L41;
                    }
                }
                _v92 = _v92 + ( *(_t166 + 4) & 0xfffc);
                _t176 =  *(_v92 - 4);
                goto L33;
                do {
L33:
                    _t181 = caml_frame_descriptors_mask;
                    _t153 = _t176 >> 3 & _t181;
                    _t168 = caml_frame_descriptors;
                    _t166 =  *(_t168 + _t153 * 4);
                    if( *_t166 == _t176) {
                        break;
                    } else {
                        goto L34;
                    }
                    goto L35;
                } while(_v92 != 0);
                goto L46;
            }
            _t155 = _v92 + 8;
            _v92 =  *_t155;
            _t176 = _t155[1];
            _t148 = _t155[2];
            _v96 = _t155[2];
L46:
        }
        if(_v40 == 0) {
        } else {
            _t182 = _v40;
            _v92 = 0;
            goto L52;
            do {
L52:
                __edi = 0;
                if(_t182[1] > 0) {
                    goto L49;
                    do {
L49:
                        _t166 = _v92;
                        if(_t182[2] > 0) {
                            while(1) {
                                _t150 = 0 + _t166 * 4 +  *((intOrPtr*)(_t182 + 12 + __edi * 4));
                                _v700 = _t150;
                                _t148 =  *_t150;
                                 *__esp =  *_t150;
                                _v56();
                                _t166 = _t166 + 1;
                                if(_t182[2] <= _t166) {
                                    break;
                                }
                            }
                            goto L48;
                        }
L48:
                        __edi = __edi + 1;
                    } while(_t182[1] > __edi);
                    goto L51;
                }
L51:
                _t181 =  *_t182;
            } while( *_t182 != 0);
        }
        goto L54;
L55:
L54:
        __esp =  &((__esp)[0xb]);
        _pop(__ebx);
        _pop(__esi);
        _pop(__edi);
        return;
        goto L55;
    }
    _t123 = caml_local_roots;
    if(_t123 == 0) {
    } else {
        if(_t123 < _t170) {
            goto L7;
        } else {
        }
    }
    goto L9;
}

caml_array_bound_error()
{// addr = 0x0805C0AD
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    signed int* _v36;                      // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    unsigned int _v44;                     // _cfa_ffffffd4
    intOrPtr _v52;                         // _cfa_ffffffcc
    signed int _v72;                       // _cfa_ffffffb8
    signed int _v76;                       // _cfa_ffffffb4
    char _v80;                             // _cfa_ffffffb0
    signed int _v88;                       // _cfa_ffffffa8
    signed int _v92;                       // _cfa_ffffffa4
    signed int _v96;                       // _cfa_ffffffa0
    char* _v116;                           // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    intOrPtr _v124;                        // _cfa_ffffff84
    char _v128;                            // _cfa_ffffff80
    signed int _v148;                      // _cfa_ffffff6c
    signed int _v152;                      // _cfa_ffffff68
    intOrPtr _v156;                        // _cfa_ffffff64
    char _v160;                            // _cfa_ffffff60
    char _v168;                            // _cfa_ffffff58
    char _v172;                            // _cfa_ffffff54
    char* _v204;                           // _cfa_ffffff34
    char* _v208;                           // _cfa_ffffff30
    intOrPtr _v212;                        // _cfa_ffffff2c
    intOrPtr _v216;                        // _cfa_ffffff28
    char _v220;                            // _cfa_ffffff24
    signed int _v224;                      // _cfa_ffffff20
    char* _v244;                           // _cfa_ffffff0c
    intOrPtr _v248;                        // _cfa_ffffff08
    intOrPtr _v252;                        // _cfa_ffffff04
    char _v256;                            // _cfa_ffffff00
    signed int _v280;                      // _cfa_fffffee8
    intOrPtr _v304;                        // _cfa_fffffed0
    signed int _v308;                      // _cfa_fffffecc
    char _v336;                            // _cfa_fffffeb0
    char _v364;                            // _cfa_fffffe94
    char _v392;                            // _cfa_fffffe78
    char* _v428;                           // _cfa_fffffe54
    intOrPtr _v432;                        // _cfa_fffffe50
    intOrPtr _v436;                        // _cfa_fffffe4c
    char _v440;                            // _cfa_fffffe48
    signed int _v444;                      // _cfa_fffffe44
    char* _v464;                           // _cfa_fffffe30
    intOrPtr _v468;                        // _cfa_fffffe2c
    intOrPtr _v472;                        // _cfa_fffffe28
    char _v476;                            // _cfa_fffffe24
    _unknown_ _v500;                       // _cfa_fffffe0c
    signed int _v608;                      // _cfa_fffffda0
    signed int* _v672;                     // _cfa_fffffd60
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t122;                       // _t122
    signed int _t128;                      // _t128
    signed int _t135;                      // _t135
    signed int _t149;                      // _t149
    signed int* _t153;                     // _t153
    signed int _t156;                      // _t156
    signed int* _t158;                     // _t158
    signed int _t162;                      // _t162
    _unknown_ _t163;                       // _t163
    _unknown_ _t167;                       // _t167
    _unknown_ _t168;                       // _t168
    signed int _t169;                      // _t169
    intOrPtr _t170;                        // _t170
    intOrPtr _t171;                        // _t171
    unsigned int _t178;                    // _t178
    signed int _t181;                      // _t181
    _unknown_ _t182;                       // _t182
    signed int* _t184;                     // _t184
    signed int _t185;                      // _t185
    _unknown_ _t186;                       // _t186
    signed int* _t187;                     // _t187
    signed int* _t188;                     // _t188
    signed int* _t189;                     // _t189
    signed int* _t190;                     // _t190
    signed int* _t191;                     // _t191
    signed int* _t192;                     // _t192
    signed int* _t193;                     // _t193
    signed int* _t194;                     // _t194
    signed int* _t195;                     // _t195
    signed int* _t196;                     // _t196
    signed int* _t197;                     // _t197
    signed int* _t198;                     // _t198
    signed int* _t199;                     // _t199
    _unknown_ _t200;                       // _t200

    if(array_bound_error_bucket_inited == 0) {
        array_bound_error_msg = 5372;
         *134693095 = 0;
        array_bound_error_bucket = 2048;
         *134693804 =  &caml_exn_Invalid_argument;
         *134693808 = "index out of bounds";
        array_bound_error_bucket_inited = 1;
        caml_page_table_add(_t122, 4,  &array_bound_error_msg,  &caml_last_return_address);
        array_bound_error_bucket_inited = 1;
    }
     *__esp = 134693804;
    caml_raise();
    _push(_t186);
    _t187 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_bucket_Stack_overflow;
    caml_raise();
    _push(_t187);
    _t188 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_bucket_Out_of_memory;
    caml_raise();
    _push(_t188);
    _t189 = __esp;
    _push(_t182);
    _push(_t168);
    __esp = __esp - 80;
    _t183 = _v76;
    _t169 = _v72;
    _v128 = caml_local_roots;
    _v120 = 1;
    _v124 = 1;
    _v116 =  &_v80;
    _v160 =  &_v128;
    caml_local_roots =  &_v160;
    _v152 = _t183;
    _v156 = 1;
    _v148 = _t169;
    _t128 = caml_alloc_small(_t169, _t183, _t183 + 1, 0);
     *_t128 = _v80;
    if(_t183 > 0) {
        _t181 = 0;
        while(1) {
             *((intOrPtr*)(_t128 + 4 + _t181 * 4)) =  *((intOrPtr*)(_t169 + _t181 * 4));
            _t181 = _t181 + 1;
            if(_t181 == _t183) {
                break;
            }
        }
    }
     *__esp = _t128;
    caml_raise();
    _push(_t189);
    _t190 = __esp;
    __esp = __esp - 104;
    _v220 = caml_local_roots;
    _v212 = 1;
    _v216 = 2;
    _v208 =  &_v172;
    _v204 =  &_v168;
    _v224 = 0;
    _v256 =  &_v220;
    caml_local_roots =  &_v256;
    _v248 = 1;
    _v252 = 1;
    _v244 =  &_v224;
    _t135 = caml_alloc_small(_t169, _t183, 2, 0);
    _v224 = _t135;
     *_t135 = _v172;
     *((intOrPtr*)(_v224 + 4)) = _v168;
     *__esp = _v224;
    caml_raise();
    _push(_t190);
    _t191 = __esp;
    __esp = __esp - 24;
    _v308 = _v280;
     *__esp =  &caml_exn_Sys_error;
    L9();
    _push(_t191);
    _t192 = __esp;
    __esp = __esp - 24;
    _v336 = caml_copy_string(_t169, __edi, _t183, _v304);
     *__esp = _v308;
    L9();
    _push(_t192);
    _t193 = __esp;
    __esp = __esp - 24;
    _v364 = _v336;
     *__esp =  &caml_exn_Invalid_argument;
    L11();
    _push(_t193);
    _t194 = __esp;
    __esp = __esp - 24;
    _v392 = _v364;
     *__esp =  &caml_exn_Failure;
    L11();
    _push(_t194);
    _t195 = __esp;
    __esp = __esp - 104;
    _v440 = caml_local_roots;
    _v432 = 1;
    _v436 = 1;
    _v428 =  &_v392;
    _v444 = 0;
    _v476 =  &_v440;
    caml_local_roots =  &_v476;
    _v468 = 1;
    _v472 = 1;
    _v464 =  &_v444;
    _t149 = caml_alloc_small(_t169, _t183, 1, 0);
    _v444 = _t149;
     *_t149 = _v392;
     *__esp = _v444;
    caml_raise();
    _push(_t195);
    _t196 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Sys_blocked_io;
    L14();
    _push(_t196);
    _t197 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Not_found;
    L14();
    _push(_t197);
    _t198 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Division_by_zero;
    L14();
    _push(_t198);
    _t199 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_End_of_file;
    L14();
    _push(_t199);
    _push(__edi);
    _push(_t183);
    _push(_t169);
    __esp = __esp - 44;
    _t151 = _v608;
    if(_t151 != 0) {
        _v92 = _v40;
        _t178 = _v44;
        _v88 = _t151;
        while(1) {
L23:
            _t183 = caml_frame_descriptors_mask;
            _t156 = _t178 >> 3 & _t183;
            _t171 = caml_frame_descriptors;
            _t169 =  *(_t171 + _t156 * 4);
            if( *_t169 == _t178) {
                break;
            } else {
                goto L24;
            }
            while(1) {
L24:
                _t156 = _t156 + 1 & _t183;
                _t169 =  *(_t171 + _t156 * 4);
                if( *_t169 == _t178) {
                    break;
                }
            }
            break;
        }
L25:
        if( *(_t169 + 4) != 255) {
            _t185 =  *(_t169 + 6) & 65535;
            if(_t185 > 0) {
                __edi = _t169 + 8;
                _v96 = _t169;
                _t170 = _v52;
                while(1) {
                    _t162 =  *__edi & 65535;
                    if((_t162 & 1) == 0) {
                        _t163 = _t162 + _v88;
                    } else {
                        _t163 = _v92 + (_t162 >> 1) * 4;
                    }
                    goto L31;
                }
            }
            _v88 = _v88 + ( *(_t169 + 4) & 0xfffc);
            _t178 =  *(_v88 - 4);
            goto L23;
            do {
L23:
                _t183 = caml_frame_descriptors_mask;
                _t156 = _t178 >> 3 & _t183;
                _t171 = caml_frame_descriptors;
                _t169 =  *(_t171 + _t156 * 4);
                if( *_t169 == _t178) {
                    break;
                } else {
                    goto L24;
                }
                goto L25;
            } while(_v88 != 0);
            goto L36;
        }
        _t158 = _v88 + 8;
        _v88 =  *_t158;
        _t178 = _t158[1];
        _t151 = _t158[2];
        _v92 = _t158[2];
L36:
    }
    if(_v36 == 0) {
    } else {
        _t184 = _v36;
        _v88 = 0;
        goto L42;
        do {
L42:
            __edi = 0;
            if(_t184[1] > 0) {
                goto L39;
                do {
L39:
                    _t169 = _v88;
                    if(_t184[2] > 0) {
                        while(1) {
                            _t153 = 0 + _t169 * 4 +  *((intOrPtr*)(_t184 + 12 + __edi * 4));
                            _v672 = _t153;
                            _t151 =  *_t153;
                             *__esp =  *_t153;
                            _v52();
                            _t169 = _t169 + 1;
                            if(_t184[2] <= _t169) {
                                break;
                            }
                        }
                        goto L38;
                    }
L38:
                    __edi = __edi + 1;
                } while(_t184[1] > __edi);
                goto L41;
            }
L41:
            _t183 =  *_t184;
        } while( *_t184 != 0);
    }
    goto L44;
L45:
L44:
    __esp =  &((__esp)[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L45;
}

caml_raise_stack_overflow()
{// addr = 0x0805C127
    signed int* _v32;                      // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    char _v52;                             // _cfa_ffffffcc
    signed int _v84;                       // _cfa_ffffffac
    signed int _v88;                       // _cfa_ffffffa8
    signed int _v92;                       // _cfa_ffffffa4
    signed int _v96;                       // _cfa_ffffffa0
    char _v100;                            // _cfa_ffffff9c
    signed int _v120;                      // _cfa_ffffff88
    signed int _v124;                      // _cfa_ffffff84
    signed int _v128;                      // _cfa_ffffff80
    char _v132;                            // _cfa_ffffff7c
    char _v140;                            // _cfa_ffffff74
    char _v144;                            // _cfa_ffffff70
    char* _v176;                           // _cfa_ffffff50
    char* _v180;                           // _cfa_ffffff4c
    signed int _v184;                      // _cfa_ffffff48
    intOrPtr _v188;                        // _cfa_ffffff44
    char _v192;                            // _cfa_ffffff40
    signed int _v196;                      // _cfa_ffffff3c
    char* _v216;                           // _cfa_ffffff28
    signed int _v220;                      // _cfa_ffffff24
    signed int _v224;                      // _cfa_ffffff20
    char _v228;                            // _cfa_ffffff1c
    signed int _v252;                      // _cfa_ffffff04
    intOrPtr _v276;                        // _cfa_fffffeec
    signed int _v280;                      // _cfa_fffffee8
    char _v308;                            // _cfa_fffffecc
    char _v336;                            // _cfa_fffffeb0
    char _v364;                            // _cfa_fffffe94
    char* _v400;                           // _cfa_fffffe70
    signed int _v404;                      // _cfa_fffffe6c
    signed int _v408;                      // _cfa_fffffe68
    char _v412;                            // _cfa_fffffe64
    signed int _v416;                      // _cfa_fffffe60
    char* _v436;                           // _cfa_fffffe4c
    signed int _v440;                      // _cfa_fffffe48
    signed int _v444;                      // _cfa_fffffe44
    char _v448;                            // _cfa_fffffe40
    _unknown_ _v472;                       // _cfa_fffffe28
    signed int _v580;                      // _cfa_fffffdbc
    signed int* _v644;                     // _cfa_fffffd7c
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t125;                      // _t125
    signed int _t132;                      // _t132
    signed int _t146;                      // _t146
    signed int* _t150;                     // _t150
    signed int _t153;                      // _t153
    signed int* _t155;                     // _t155
    signed int _t159;                      // _t159
    _unknown_ _t160;                       // _t160
    _unknown_ _t164;                       // _t164
    signed int _t165;                      // _t165
    signed int _t166;                      // _t166
    intOrPtr _t167;                        // _t167
    unsigned int _t174;                    // _t174
    signed int _t177;                      // _t177
    _unknown_ _t178;                       // _t178
    signed int* _t180;                     // _t180
    signed int _t181;                      // _t181
    _unknown_ _t182;                       // _t182
    signed int* _t183;                     // _t183
    signed int* _t184;                     // _t184
    signed int* _t185;                     // _t185
    signed int* _t186;                     // _t186
    signed int* _t187;                     // _t187
    signed int* _t188;                     // _t188
    signed int* _t189;                     // _t189
    signed int* _t190;                     // _t190
    signed int* _t191;                     // _t191
    signed int* _t192;                     // _t192
    signed int* _t193;                     // _t193
    signed int* _t194;                     // _t194
    _unknown_ _t195;                       // _t195

     *__esp =  &caml_bucket_Stack_overflow;
    caml_raise();
    _push(_t182);
    _t183 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_bucket_Out_of_memory;
    caml_raise();
    _push(_t183);
    _t184 = __esp;
    _push(_t178);
    _push(_t164);
    __esp = __esp - 80;
    _t179 = _v48;
    _t165 = _v44;
    _v100 = caml_local_roots;
    _v92 = 1;
    _v96 = 1;
    _v88 =  &_v52;
    _v132 =  &_v100;
    caml_local_roots =  &_v132;
    _v124 = _t179;
    _v128 = 1;
    _v120 = _t165;
    _t125 = caml_alloc_small(_t165, _t179, _t179 + 1, 0);
     *_t125 = _v52;
    if(_t179 > 0) {
        _t177 = 0;
        while(1) {
             *((intOrPtr*)(_t125 + 4 + _t177 * 4)) =  *((intOrPtr*)(_t165 + _t177 * 4));
            _t177 = _t177 + 1;
            if(_t177 == _t179) {
                break;
            }
        }
    }
     *__esp = _t125;
    caml_raise();
    _push(_t184);
    _t185 = __esp;
    __esp = __esp - 104;
    _v192 = caml_local_roots;
    _v184 = 1;
    _v188 = 2;
    _v180 =  &_v144;
    _v176 =  &_v140;
    _v196 = 0;
    _v228 =  &_v192;
    caml_local_roots =  &_v228;
    _v220 = 1;
    _v224 = 1;
    _v216 =  &_v196;
    _t132 = caml_alloc_small(_t165, _t179, 2, 0);
    _v196 = _t132;
     *_t132 = _v144;
     *((intOrPtr*)(_v196 + 4)) = _v140;
     *__esp = _v196;
    caml_raise();
    _push(_t185);
    _t186 = __esp;
    __esp = __esp - 24;
    _v280 = _v252;
     *__esp =  &caml_exn_Sys_error;
    L6();
    _push(_t186);
    _t187 = __esp;
    __esp = __esp - 24;
    _v308 = caml_copy_string(_t165, __edi, _t179, _v276);
     *__esp = _v280;
    L6();
    _push(_t187);
    _t188 = __esp;
    __esp = __esp - 24;
    _v336 = _v308;
     *__esp =  &caml_exn_Invalid_argument;
    L8();
    _push(_t188);
    _t189 = __esp;
    __esp = __esp - 24;
    _v364 = _v336;
     *__esp =  &caml_exn_Failure;
    L8();
    _push(_t189);
    _t190 = __esp;
    __esp = __esp - 104;
    _v412 = caml_local_roots;
    _v404 = 1;
    _v408 = 1;
    _v400 =  &_v364;
    _v416 = 0;
    _v448 =  &_v412;
    caml_local_roots =  &_v448;
    _v440 = 1;
    _v444 = 1;
    _v436 =  &_v416;
    _t146 = caml_alloc_small(_t165, _t179, 1, 0);
    _v416 = _t146;
     *_t146 = _v364;
     *__esp = _v416;
    caml_raise();
    _push(_t190);
    _t191 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Sys_blocked_io;
    L11();
    _push(_t191);
    _t192 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Not_found;
    L11();
    _push(_t192);
    _t193 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Division_by_zero;
    L11();
    _push(_t193);
    _t194 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_End_of_file;
    L11();
    _push(_t194);
    _push(__edi);
    _push(_t179);
    _push(_t165);
    __esp = __esp - 44;
    _t148 = _v580;
    if(_t148 != 0) {
        _v88 = _v36;
        _t174 = _v40;
        _v84 = _t148;
        while(1) {
L20:
            _t179 = caml_frame_descriptors_mask;
            _t153 = _t174 >> 3 & _t179;
            _t167 = caml_frame_descriptors;
            _t165 =  *(_t167 + _t153 * 4);
            if( *_t165 == _t174) {
                break;
            } else {
                goto L21;
            }
            while(1) {
L21:
                _t153 = _t153 + 1 & _t179;
                _t165 =  *(_t167 + _t153 * 4);
                if( *_t165 == _t174) {
                    break;
                }
            }
            break;
        }
L22:
        if( *(_t165 + 4) != 255) {
            _t181 =  *(_t165 + 6) & 65535;
            if(_t181 > 0) {
                __edi = _t165 + 8;
                _v92 = _t165;
                _t166 = _v48;
                while(1) {
                    _t159 =  *__edi & 65535;
                    if((_t159 & 1) == 0) {
                        _t160 = _t159 + _v84;
                    } else {
                        _t160 = _v88 + (_t159 >> 1) * 4;
                    }
                    goto L28;
                }
            }
            _v84 = _v84 + ( *(_t165 + 4) & 0xfffc);
            _t174 =  *(_v84 - 4);
            goto L20;
            do {
L20:
                _t179 = caml_frame_descriptors_mask;
                _t153 = _t174 >> 3 & _t179;
                _t167 = caml_frame_descriptors;
                _t165 =  *(_t167 + _t153 * 4);
                if( *_t165 == _t174) {
                    break;
                } else {
                    goto L21;
                }
                goto L22;
            } while(_v84 != 0);
            goto L33;
        }
        _t155 = _v84 + 8;
        _v84 =  *_t155;
        _t174 = _t155[1];
        _t148 = _t155[2];
        _v88 = _t155[2];
L33:
    }
    if(_v32 == 0) {
    } else {
        _t180 = _v32;
        _v84 = 0;
        goto L39;
        do {
L39:
            __edi = 0;
            if(_t180[1] > 0) {
                goto L36;
                do {
L36:
                    _t165 = _v84;
                    if(_t180[2] > 0) {
                        while(1) {
                            _t150 = 0 + _t165 * 4 +  *((intOrPtr*)(_t180 + 12 + __edi * 4));
                            _v644 = _t150;
                            _t148 =  *_t150;
                             *__esp =  *_t150;
                            _v48();
                            _t165 = _t165 + 1;
                            if(_t180[2] <= _t165) {
                                break;
                            }
                        }
                        goto L35;
                    }
L35:
                    __edi = __edi + 1;
                } while(_t180[1] > __edi);
                goto L38;
            }
L38:
            _t179 =  *_t180;
        } while( *_t180 != 0);
    }
    goto L41;
L42:
L41:
    __esp =  &((__esp)[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L42;
}

caml_raise_out_of_memory()
{// addr = 0x0805C139
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    char _v24;                             // _cfa_ffffffe8
    signed int* _v28;                      // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    intOrPtr _v44;                         // _cfa_ffffffd4
    char* _v60;                            // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    intOrPtr _v68;                         // _cfa_ffffffbc
    char _v72;                             // _cfa_ffffffb8
    signed int _v80;                       // _cfa_ffffffb0
    signed int _v84;                       // _cfa_ffffffac
    signed int _v88;                       // _cfa_ffffffa8
    signed int _v92;                       // _cfa_ffffffa4
    signed int _v96;                       // _cfa_ffffffa0
    intOrPtr _v100;                        // _cfa_ffffff9c
    char _v104;                            // _cfa_ffffff98
    char _v112;                            // _cfa_ffffff90
    char _v116;                            // _cfa_ffffff8c
    char* _v148;                           // _cfa_ffffff6c
    char* _v152;                           // _cfa_ffffff68
    intOrPtr _v156;                        // _cfa_ffffff64
    intOrPtr _v160;                        // _cfa_ffffff60
    char _v164;                            // _cfa_ffffff5c
    signed int _v168;                      // _cfa_ffffff58
    char* _v188;                           // _cfa_ffffff44
    intOrPtr _v192;                        // _cfa_ffffff40
    intOrPtr _v196;                        // _cfa_ffffff3c
    char _v200;                            // _cfa_ffffff38
    signed int _v224;                      // _cfa_ffffff20
    intOrPtr _v248;                        // _cfa_ffffff08
    signed int _v252;                      // _cfa_ffffff04
    char _v280;                            // _cfa_fffffee8
    char _v308;                            // _cfa_fffffecc
    char _v336;                            // _cfa_fffffeb0
    char* _v372;                           // _cfa_fffffe8c
    intOrPtr _v376;                        // _cfa_fffffe88
    intOrPtr _v380;                        // _cfa_fffffe84
    char _v384;                            // _cfa_fffffe80
    signed int _v388;                      // _cfa_fffffe7c
    char* _v408;                           // _cfa_fffffe68
    intOrPtr _v412;                        // _cfa_fffffe64
    intOrPtr _v416;                        // _cfa_fffffe60
    char _v420;                            // _cfa_fffffe5c
    _unknown_ _v444;                       // _cfa_fffffe44
    signed int _v552;                      // _cfa_fffffdd8
    signed int* _v616;                     // _cfa_fffffd98
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t125;                      // _t125
    signed int _t132;                      // _t132
    signed int _t146;                      // _t146
    signed int* _t150;                     // _t150
    signed int _t153;                      // _t153
    signed int* _t155;                     // _t155
    signed int _t159;                      // _t159
    _unknown_ _t160;                       // _t160
    _unknown_ _t164;                       // _t164
    signed int _t165;                      // _t165
    intOrPtr _t166;                        // _t166
    intOrPtr _t167;                        // _t167
    unsigned int _t174;                    // _t174
    signed int _t177;                      // _t177
    _unknown_ _t178;                       // _t178
    signed int* _t180;                     // _t180
    signed int _t181;                      // _t181
    _unknown_ _t182;                       // _t182
    signed int* _t183;                     // _t183
    signed int* _t184;                     // _t184
    signed int* _t185;                     // _t185
    signed int* _t186;                     // _t186
    signed int* _t187;                     // _t187
    signed int* _t188;                     // _t188
    signed int* _t189;                     // _t189
    signed int* _t190;                     // _t190
    signed int* _t191;                     // _t191
    signed int* _t192;                     // _t192
    signed int* _t193;                     // _t193
    _unknown_ _t194;                       // _t194

     *__esp =  &caml_bucket_Out_of_memory;
    caml_raise();
    _push(_t182);
    _t183 = __esp;
    _push(_t178);
    _push(_t164);
    __esp = __esp - 80;
    _t179 = _v20;
    _t165 = _v16;
    _v72 = caml_local_roots;
    _v64 = 1;
    _v68 = 1;
    _v60 =  &_v24;
    _v104 =  &_v72;
    caml_local_roots =  &_v104;
    _v96 = _t179;
    _v100 = 1;
    _v92 = _t165;
    _t125 = caml_alloc_small(_t165, _t179, _t179 + 1, 0);
     *_t125 = _v24;
    if(_t179 > 0) {
        _t177 = 0;
        while(1) {
             *((intOrPtr*)(_t125 + 4 + _t177 * 4)) =  *((intOrPtr*)(_t165 + _t177 * 4));
            _t177 = _t177 + 1;
            if(_t177 == _t179) {
                break;
            }
        }
    }
     *__esp = _t125;
    caml_raise();
    _push(_t183);
    _t184 = __esp;
    __esp = __esp - 104;
    _v164 = caml_local_roots;
    _v156 = 1;
    _v160 = 2;
    _v152 =  &_v116;
    _v148 =  &_v112;
    _v168 = 0;
    _v200 =  &_v164;
    caml_local_roots =  &_v200;
    _v192 = 1;
    _v196 = 1;
    _v188 =  &_v168;
    _t132 = caml_alloc_small(_t165, _t179, 2, 0);
    _v168 = _t132;
     *_t132 = _v116;
     *((intOrPtr*)(_v168 + 4)) = _v112;
     *__esp = _v168;
    caml_raise();
    _push(_t184);
    _t185 = __esp;
    __esp = __esp - 24;
    _v252 = _v224;
     *__esp =  &caml_exn_Sys_error;
    L5();
    _push(_t185);
    _t186 = __esp;
    __esp = __esp - 24;
    _v280 = caml_copy_string(_t165, __edi, _t179, _v248);
     *__esp = _v252;
    L5();
    _push(_t186);
    _t187 = __esp;
    __esp = __esp - 24;
    _v308 = _v280;
     *__esp =  &caml_exn_Invalid_argument;
    L7();
    _push(_t187);
    _t188 = __esp;
    __esp = __esp - 24;
    _v336 = _v308;
     *__esp =  &caml_exn_Failure;
    L7();
    _push(_t188);
    _t189 = __esp;
    __esp = __esp - 104;
    _v384 = caml_local_roots;
    _v376 = 1;
    _v380 = 1;
    _v372 =  &_v336;
    _v388 = 0;
    _v420 =  &_v384;
    caml_local_roots =  &_v420;
    _v412 = 1;
    _v416 = 1;
    _v408 =  &_v388;
    _t146 = caml_alloc_small(_t165, _t179, 1, 0);
    _v388 = _t146;
     *_t146 = _v336;
     *__esp = _v388;
    caml_raise();
    _push(_t189);
    _t190 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Sys_blocked_io;
    L10();
    _push(_t190);
    _t191 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Not_found;
    L10();
    _push(_t191);
    _t192 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Division_by_zero;
    L10();
    _push(_t192);
    _t193 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_End_of_file;
    L10();
    _push(_t193);
    _push(__edi);
    _push(_t179);
    _push(_t165);
    __esp = __esp - 44;
    _t148 = _v552;
    if(_t148 != 0) {
        _v84 = _v32;
        _t174 = _v36;
        _v80 = _t148;
        while(1) {
L19:
            _t179 = caml_frame_descriptors_mask;
            _t153 = _t174 >> 3 & _t179;
            _t167 = caml_frame_descriptors;
            _t165 =  *(_t167 + _t153 * 4);
            if( *_t165 == _t174) {
                break;
            } else {
                goto L20;
            }
            while(1) {
L20:
                _t153 = _t153 + 1 & _t179;
                _t165 =  *(_t167 + _t153 * 4);
                if( *_t165 == _t174) {
                    break;
                }
            }
            break;
        }
L21:
        if( *(_t165 + 4) != 255) {
            _t181 =  *(_t165 + 6) & 65535;
            if(_t181 > 0) {
                __edi = _t165 + 8;
                _v88 = _t165;
                _t166 = _v44;
                while(1) {
                    _t159 =  *__edi & 65535;
                    if((_t159 & 1) == 0) {
                        _t160 = _t159 + _v80;
                    } else {
                        _t160 = _v84 + (_t159 >> 1) * 4;
                    }
                    goto L27;
                }
            }
            _v80 = _v80 + ( *(_t165 + 4) & 0xfffc);
            _t174 =  *(_v80 - 4);
            goto L19;
            do {
L19:
                _t179 = caml_frame_descriptors_mask;
                _t153 = _t174 >> 3 & _t179;
                _t167 = caml_frame_descriptors;
                _t165 =  *(_t167 + _t153 * 4);
                if( *_t165 == _t174) {
                    break;
                } else {
                    goto L20;
                }
                goto L21;
            } while(_v80 != 0);
            goto L32;
        }
        _t155 = _v80 + 8;
        _v80 =  *_t155;
        _t174 = _t155[1];
        _t148 = _t155[2];
        _v84 = _t155[2];
L32:
    }
    if(_v28 == 0) {
    } else {
        _t180 = _v28;
        _v80 = 0;
        goto L38;
        do {
L38:
            __edi = 0;
            if(_t180[1] > 0) {
                goto L35;
                do {
L35:
                    _t165 = _v80;
                    if(_t180[2] > 0) {
                        while(1) {
                            _t150 = 0 + _t165 * 4 +  *((intOrPtr*)(_t180 + 12 + __edi * 4));
                            _v616 = _t150;
                            _t148 =  *_t150;
                             *__esp =  *_t150;
                            _v44();
                            _t165 = _t165 + 1;
                            if(_t180[2] <= _t165) {
                                break;
                            }
                        }
                        goto L34;
                    }
L34:
                    __edi = __edi + 1;
                } while(_t180[1] > __edi);
                goto L37;
            }
L37:
            _t179 =  *_t180;
        } while( *_t180 != 0);
    }
    goto L40;
L41:
L40:
    __esp =  &((__esp)[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L41;
}

caml_raise_with_args(
    char _a4,                              // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x0805C14B
    signed int* _v24;                      // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    unsigned int _v32;                     // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    signed int _v76;                       // _cfa_ffffffb4
    signed int _v80;                       // _cfa_ffffffb0
    signed int _v84;                       // _cfa_ffffffac
    char _v88;                             // _cfa_ffffffa8
    char* _v120;                           // _cfa_ffffff88
    char* _v124;                           // _cfa_ffffff84
    intOrPtr _v128;                        // _cfa_ffffff80
    intOrPtr _v132;                        // _cfa_ffffff7c
    char _v136;                            // _cfa_ffffff78
    signed int _v140;                      // _cfa_ffffff74
    char* _v160;                           // _cfa_ffffff60
    intOrPtr _v164;                        // _cfa_ffffff5c
    intOrPtr _v168;                        // _cfa_ffffff58
    char _v172;                            // _cfa_ffffff54
    signed int _v196;                      // _cfa_ffffff3c
    intOrPtr _v220;                        // _cfa_ffffff24
    signed int _v224;                      // _cfa_ffffff20
    char _v252;                            // _cfa_ffffff04
    char _v280;                            // _cfa_fffffee8
    char _v308;                            // _cfa_fffffecc
    char* _v344;                           // _cfa_fffffea8
    intOrPtr _v348;                        // _cfa_fffffea4
    intOrPtr _v352;                        // _cfa_fffffea0
    char _v356;                            // _cfa_fffffe9c
    signed int _v360;                      // _cfa_fffffe98
    char* _v380;                           // _cfa_fffffe84
    intOrPtr _v384;                        // _cfa_fffffe80
    intOrPtr _v388;                        // _cfa_fffffe7c
    char _v392;                            // _cfa_fffffe78
    _unknown_ _v416;                       // _cfa_fffffe60
    signed int _v524;                      // _cfa_fffffdf4
    signed int* _v588;                     // _cfa_fffffdb4
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t125;                      // _t125
    signed int _t132;                      // _t132
    signed int _t146;                      // _t146
    signed int* _t150;                     // _t150
    signed int _t153;                      // _t153
    signed int* _t155;                     // _t155
    signed int _t159;                      // _t159
    _unknown_ _t160;                       // _t160
    _unknown_ _t164;                       // _t164
    signed int _t165;                      // _t165
    intOrPtr _t166;                        // _t166
    intOrPtr _t167;                        // _t167
    unsigned int _t174;                    // _t174
    signed int _t177;                      // _t177
    _unknown_ _t178;                       // _t178
    signed int* _t180;                     // _t180
    signed int _t181;                      // _t181
    _unknown_ _t182;                       // _t182
    signed int* _t183;                     // _t183
    signed int* _t184;                     // _t184
    signed int* _t185;                     // _t185
    signed int* _t186;                     // _t186
    signed int* _t187;                     // _t187
    signed int* _t188;                     // _t188
    signed int* _t189;                     // _t189
    signed int* _t190;                     // _t190
    signed int* _t191;                     // _t191
    signed int* _t192;                     // _t192
    _unknown_ _t193;                       // _t193

    _push(_t178);
    _push(_t164);
    __esp = __esp - 80;
    _t179 = _a8;
    _t165 = _a12;
    _v44 = caml_local_roots;
    _v36 = 1;
    _v40 = 1;
    _v32 =  &_a4;
    _v76 =  &_v44;
    caml_local_roots =  &_v76;
    _v68 = _t179;
    _v72 = 1;
    _v64 = _t165;
    _t125 = caml_alloc_small(_t165, _t179, _t179 + 1, 0);
     *_t125 = _a4;
    if(_t179 > 0) {
        _t177 = 0;
        while(1) {
             *((intOrPtr*)(_t125 + 4 + _t177 * 4)) =  *((intOrPtr*)(_t165 + _t177 * 4));
            _t177 = _t177 + 1;
            if(_t177 == _t179) {
                break;
            }
        }
    }
     *__esp = _t125;
    caml_raise();
    _push(_t182);
    _t183 = __esp;
    __esp = __esp - 104;
    _v136 = caml_local_roots;
    _v128 = 1;
    _v132 = 2;
    _v124 =  &_v88;
    _v120 =  &_v84;
    _v140 = 0;
    _v172 =  &_v136;
    caml_local_roots =  &_v172;
    _v164 = 1;
    _v168 = 1;
    _v160 =  &_v140;
    _t132 = caml_alloc_small(_t165, _t179, 2, 0);
    _v140 = _t132;
     *_t132 = _v88;
     *(_v140 + 4) = _v84;
     *__esp = _v140;
    caml_raise();
    _push(_t183);
    _t184 = __esp;
    __esp = __esp - 24;
    _v224 = _v196;
     *__esp =  &caml_exn_Sys_error;
    L4();
    _push(_t184);
    _t185 = __esp;
    __esp = __esp - 24;
    _v252 = caml_copy_string(_t165, __edi, _t179, _v220);
     *__esp = _v224;
    L4();
    _push(_t185);
    _t186 = __esp;
    __esp = __esp - 24;
    _v280 = _v252;
     *__esp =  &caml_exn_Invalid_argument;
    L6();
    _push(_t186);
    _t187 = __esp;
    __esp = __esp - 24;
    _v308 = _v280;
     *__esp =  &caml_exn_Failure;
    L6();
    _push(_t187);
    _t188 = __esp;
    __esp = __esp - 104;
    _v356 = caml_local_roots;
    _v348 = 1;
    _v352 = 1;
    _v344 =  &_v308;
    _v360 = 0;
    _v392 =  &_v356;
    caml_local_roots =  &_v392;
    _v384 = 1;
    _v388 = 1;
    _v380 =  &_v360;
    _t146 = caml_alloc_small(_t165, _t179, 1, 0);
    _v360 = _t146;
     *_t146 = _v308;
     *__esp = _v360;
    caml_raise();
    _push(_t188);
    _t189 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Sys_blocked_io;
    L9();
    _push(_t189);
    _t190 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Not_found;
    L9();
    _push(_t190);
    _t191 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Division_by_zero;
    L9();
    _push(_t191);
    _t192 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_End_of_file;
    L9();
    _push(_t192);
    _push(__edi);
    _push(_t179);
    _push(_t165);
    __esp = __esp - 44;
    _t148 = _v524;
    if(_t148 != 0) {
        _v80 = _v28;
        _t174 = _v32;
        _v76 = _t148;
        while(1) {
L18:
            _t179 = caml_frame_descriptors_mask;
            _t153 = _t174 >> 3 & _t179;
            _t167 = caml_frame_descriptors;
            _t165 =  *(_t167 + _t153 * 4);
            if( *_t165 == _t174) {
                break;
            } else {
                goto L19;
            }
            while(1) {
L19:
                _t153 = _t153 + 1 & _t179;
                _t165 =  *(_t167 + _t153 * 4);
                if( *_t165 == _t174) {
                    break;
                }
            }
            break;
        }
L20:
        if( *(_t165 + 4) != 255) {
            _t181 =  *(_t165 + 6) & 65535;
            if(_t181 > 0) {
                __edi = _t165 + 8;
                _v84 = _t165;
                _t166 = _v40;
                while(1) {
                    _t159 =  *__edi & 65535;
                    if((_t159 & 1) == 0) {
                        _t160 = _t159 + _v76;
                    } else {
                        _t160 = _v80 + (_t159 >> 1) * 4;
                    }
                    goto L26;
                }
            }
            _v76 = _v76 + ( *(_t165 + 4) & 0xfffc);
            _t174 =  *(_v76 - 4);
            goto L18;
            do {
L18:
                _t179 = caml_frame_descriptors_mask;
                _t153 = _t174 >> 3 & _t179;
                _t167 = caml_frame_descriptors;
                _t165 =  *(_t167 + _t153 * 4);
                if( *_t165 == _t174) {
                    break;
                } else {
                    goto L19;
                }
                goto L20;
            } while(_v76 != 0);
            goto L31;
        }
        _t155 = _v76 + 8;
        _v76 =  *_t155;
        _t174 = _t155[1];
        _t148 = _t155[2];
        _v80 = _t155[2];
L31:
    }
    if(_v24 == 0) {
    } else {
        _t180 = _v24;
        _v76 = 0;
        goto L37;
        do {
L37:
            __edi = 0;
            if(_t180[1] > 0) {
                goto L34;
                do {
L34:
                    _t165 = _v76;
                    if(_t180[2] > 0) {
                        while(1) {
                            _t150 = 0 + _t165 * 4 +  *((intOrPtr*)(_t180 + 12 + __edi * 4));
                            _v588 = _t150;
                            _t148 =  *_t150;
                             *__esp =  *_t150;
                            _v40();
                            _t165 = _t165 + 1;
                            if(_t180[2] <= _t165) {
                                break;
                            }
                        }
                        goto L33;
                    }
L33:
                    __edi = __edi + 1;
                } while(_t180[1] > __edi);
                goto L36;
            }
L36:
            _t179 =  *_t180;
        } while( *_t180 != 0);
    }
    goto L39;
L40:
L39:
    __esp =  &((__esp)[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L40;
}

caml_raise_with_arg(
    char _a4,                              // _cfa_4
    char _a8                               // _cfa_8
)
{// addr = 0x0805C1C7
    signed int* _v20;                      // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    unsigned int _v28;                     // _cfa_ffffffe4
    char* _v32;                            // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    char* _v68;                            // _cfa_ffffffbc
    signed int _v72;                       // _cfa_ffffffb8
    signed int _v76;                       // _cfa_ffffffb4
    signed int _v80;                       // _cfa_ffffffb0
    signed int _v104;                      // _cfa_ffffff98
    intOrPtr _v128;                        // _cfa_ffffff80
    signed int _v132;                      // _cfa_ffffff7c
    char _v160;                            // _cfa_ffffff60
    char _v188;                            // _cfa_ffffff44
    char _v216;                            // _cfa_ffffff28
    char* _v252;                           // _cfa_ffffff04
    signed int _v256;                      // _cfa_ffffff00
    signed int _v260;                      // _cfa_fffffefc
    char _v264;                            // _cfa_fffffef8
    signed int _v268;                      // _cfa_fffffef4
    char* _v288;                           // _cfa_fffffee0
    signed int _v292;                      // _cfa_fffffedc
    signed int _v296;                      // _cfa_fffffed8
    char _v300;                            // _cfa_fffffed4
    _unknown_ _v324;                       // _cfa_fffffebc
    signed int _v432;                      // _cfa_fffffe50
    signed int* _v496;                     // _cfa_fffffe10
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t105;                      // _t105
    signed int _t119;                      // _t119
    signed int* _t123;                     // _t123
    signed int _t126;                      // _t126
    signed int* _t128;                     // _t128
    signed int _t132;                      // _t132
    _unknown_ _t133;                       // _t133
    signed int _t137;                      // _t137
    signed int _t138;                      // _t138
    unsigned int _t143;                    // _t143
    signed int* _t147;                     // _t147
    signed int _t148;                      // _t148
    _unknown_ _t149;                       // _t149
    signed int* _t150;                     // _t150
    signed int* _t151;                     // _t151
    signed int* _t152;                     // _t152
    signed int* _t153;                     // _t153
    signed int* _t154;                     // _t154
    signed int* _t155;                     // _t155
    signed int* _t156;                     // _t156
    signed int* _t157;                     // _t157
    signed int* _t158;                     // _t158
    _unknown_ _t159;                       // _t159

    _v44 = caml_local_roots;
    _v36 = 1;
    _v40 = 2;
    _v32 =  &_a4;
    _v28 =  &_a8;
    _v48 = 0;
    _v80 =  &_v44;
    caml_local_roots =  &_v80;
    _v72 = 1;
    _v76 = 1;
    _v68 =  &_v48;
    _t105 = caml_alloc_small(_t137, _t146, 2, 0);
    _v48 = _t105;
     *_t105 = _a4;
     *((intOrPtr*)(_v48 + 4)) = _a8;
     *__esp = _v48;
    caml_raise();
    _push(_t149);
    _t150 = __esp;
    __esp = __esp - 24;
    _v132 = _v104;
     *__esp =  &caml_exn_Sys_error;
    caml_raise_with_arg();
    _push(_t150);
    _t151 = __esp;
    __esp = __esp - 24;
    _v160 = caml_copy_string(_t137, __edi, _t146, _v128);
     *__esp = _v132;
    caml_raise_with_arg();
    _push(_t151);
    _t152 = __esp;
    __esp = __esp - 24;
    _v188 = _v160;
     *__esp =  &caml_exn_Invalid_argument;
    L2();
    _push(_t152);
    _t153 = __esp;
    __esp = __esp - 24;
    _v216 = _v188;
     *__esp =  &caml_exn_Failure;
    L2();
    _push(_t153);
    _t154 = __esp;
    __esp = __esp - 104;
    _v264 = caml_local_roots;
    _v256 = 1;
    _v260 = 1;
    _v252 =  &_v216;
    _v268 = 0;
    _v300 =  &_v264;
    caml_local_roots =  &_v300;
    _v292 = 1;
    _v296 = 1;
    _v288 =  &_v268;
    _t119 = caml_alloc_small(_t137, _t146, 1, 0);
    _v268 = _t119;
     *_t119 = _v216;
     *__esp = _v268;
    caml_raise();
    _push(_t154);
    _t155 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Sys_blocked_io;
    L5();
    _push(_t155);
    _t156 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Not_found;
    L5();
    _push(_t156);
    _t157 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Division_by_zero;
    L5();
    _push(_t157);
    _t158 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_End_of_file;
    L5();
    _push(_t158);
    _push(__edi);
    _push(_t146);
    _push(_t137);
    __esp = __esp - 44;
    _t121 = _v432;
    if(_t121 != 0) {
        _v76 = _v24;
        _t143 = _v28;
        _v72 = _t121;
        while(1) {
L14:
            _t146 = caml_frame_descriptors_mask;
            _t126 = _t143 >> 3 & _t146;
            __ecx = caml_frame_descriptors;
            _t137 =  *(__ecx + _t126 * 4);
            if( *_t137 == _t143) {
                break;
            } else {
                goto L15;
            }
            while(1) {
L15:
                _t126 = _t126 + 1 & _t146;
                _t137 =  *(__ecx + _t126 * 4);
                if( *_t137 == _t143) {
                    break;
                }
            }
            break;
        }
L16:
        if( *(_t137 + 4) != 255) {
            _t148 =  *(_t137 + 6) & 65535;
            if(_t148 > 0) {
                __edi = _t137 + 8;
                _v80 = _t137;
                _t138 = _v36;
                while(1) {
                    _t132 =  *__edi & 65535;
                    if((_t132 & 1) == 0) {
                        _t133 = _t132 + _v72;
                    } else {
                        _t133 = _v76 + (_t132 >> 1) * 4;
                    }
                    goto L22;
                }
            }
            _v72 = _v72 + ( *(_t137 + 4) & 0xfffc);
            _t143 =  *(_v72 - 4);
            goto L14;
            do {
L14:
                _t146 = caml_frame_descriptors_mask;
                _t126 = _t143 >> 3 & _t146;
                __ecx = caml_frame_descriptors;
                _t137 =  *(__ecx + _t126 * 4);
                if( *_t137 == _t143) {
                    break;
                } else {
                    goto L15;
                }
                goto L16;
            } while(_v72 != 0);
            goto L27;
        }
        _t128 = _v72 + 8;
        _v72 =  *_t128;
        _t143 = _t128[1];
        _t121 = _t128[2];
        _v76 = _t128[2];
L27:
    }
    if(_v20 == 0) {
    } else {
        _t147 = _v20;
        _v72 = 0;
        goto L33;
        do {
L33:
            __edi = 0;
            if(_t147[1] > 0) {
                goto L30;
                do {
L30:
                    _t137 = _v72;
                    if(_t147[2] > 0) {
                        while(1) {
                            _t123 = 0 + _t137 * 4 +  *((intOrPtr*)(_t147 + 12 + __edi * 4));
                            _v496 = _t123;
                            _t121 =  *_t123;
                             *__esp =  *_t123;
                            _v36();
                            _t137 = _t137 + 1;
                            if(_t147[2] <= _t137) {
                                break;
                            }
                        }
                        goto L29;
                    }
L29:
                    __edi = __edi + 1;
                } while(_t147[1] > __edi);
                goto L32;
            }
L32:
            _t146 =  *_t147;
        } while( *_t147 != 0);
    }
    goto L35;
L36:
L35:
    __esp =  &((__esp)[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L36;
}

caml_raise_sys_error(
    unsigned int _a4                       // _cfa_4
)
{// addr = 0x0805C248
    signed int* _v16;                      // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    unsigned int _v24;                     // _cfa_ffffffe8
    intOrPtr _v32;                         // _cfa_ffffffe0
    char _v52;                             // _cfa_ffffffcc
    signed int _v68;                       // _cfa_ffffffbc
    signed int _v72;                       // _cfa_ffffffb8
    signed int _v76;                       // _cfa_ffffffb4
    char _v80;                             // _cfa_ffffffb0
    char _v108;                            // _cfa_ffffff94
    char* _v144;                           // _cfa_ffffff70
    intOrPtr _v148;                        // _cfa_ffffff6c
    intOrPtr _v152;                        // _cfa_ffffff68
    char _v156;                            // _cfa_ffffff64
    signed int _v160;                      // _cfa_ffffff60
    char* _v180;                           // _cfa_ffffff4c
    intOrPtr _v184;                        // _cfa_ffffff48
    intOrPtr _v188;                        // _cfa_ffffff44
    char _v192;                            // _cfa_ffffff40
    _unknown_ _v216;                       // _cfa_ffffff28
    signed int _v324;                      // _cfa_fffffebc
    signed int* _v388;                     // _cfa_fffffe7c
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t88;                       // _t88
    signed int* _t92;                      // _t92
    signed int _t95;                       // _t95
    signed int* _t97;                      // _t97
    signed int _t101;                      // _t101
    _unknown_ _t102;                       // _t102
    signed int _t106;                      // _t106
    intOrPtr _t107;                        // _t107
    unsigned int _t110;                    // _t110
    signed int* _t114;                     // _t114
    signed int _t115;                      // _t115
    _unknown_ _t116;                       // _t116
    signed int* _t117;                     // _t117
    signed int* _t118;                     // _t118
    signed int* _t119;                     // _t119
    signed int* _t120;                     // _t120
    signed int* _t121;                     // _t121
    signed int* _t122;                     // _t122
    signed int* _t123;                     // _t123
    signed int* _t124;                     // _t124
    _unknown_ _t125;                       // _t125

    _v24 = _a4;
     *__esp =  &caml_exn_Sys_error;
    caml_raise_with_arg();
    _push(_t116);
    _t117 = __esp;
    __esp = __esp - 24;
    _v52 = caml_copy_string(_t106, __edi, _t113, _v20);
     *__esp = _v24;
    caml_raise_with_arg();
    _push(_t117);
    _t118 = __esp;
    __esp = __esp - 24;
    _v80 = _v52;
     *__esp =  &caml_exn_Invalid_argument;
    L1();
    _push(_t118);
    _t119 = __esp;
    __esp = __esp - 24;
    _v108 = _v80;
     *__esp =  &caml_exn_Failure;
    L1();
    _push(_t119);
    _t120 = __esp;
    __esp = __esp - 104;
    _v156 = caml_local_roots;
    _v148 = 1;
    _v152 = 1;
    _v144 =  &_v108;
    _v160 = 0;
    _v192 =  &_v156;
    caml_local_roots =  &_v192;
    _v184 = 1;
    _v188 = 1;
    _v180 =  &_v160;
    _t88 = caml_alloc_small(_t106, _t113, 1, 0);
    _v160 = _t88;
     *_t88 = _v108;
     *__esp = _v160;
    caml_raise();
    _push(_t120);
    _t121 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Sys_blocked_io;
    L4();
    _push(_t121);
    _t122 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Not_found;
    L4();
    _push(_t122);
    _t123 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Division_by_zero;
    L4();
    _push(_t123);
    _t124 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_End_of_file;
    L4();
    _push(_t124);
    _push(__edi);
    _push(_t113);
    _push(_t106);
    __esp = __esp - 44;
    _t90 = _v324;
    if(_t90 != 0) {
        _v72 = _v20;
        _t110 = _v24;
        _v68 = _t90;
        while(1) {
L13:
            _t113 = caml_frame_descriptors_mask;
            _t95 = _t110 >> 3 & _t113;
            __ecx = caml_frame_descriptors;
            _t106 =  *(__ecx + _t95 * 4);
            if( *_t106 == _t110) {
                break;
            } else {
                goto L14;
            }
            while(1) {
L14:
                _t95 = _t95 + 1 & _t113;
                _t106 =  *(__ecx + _t95 * 4);
                if( *_t106 == _t110) {
                    break;
                }
            }
            break;
        }
L15:
        if( *(_t106 + 4) != 255) {
            _t115 =  *(_t106 + 6) & 65535;
            if(_t115 > 0) {
                __edi = _t106 + 8;
                _v76 = _t106;
                _t107 = _v32;
                while(1) {
                    _t101 =  *__edi & 65535;
                    if((_t101 & 1) == 0) {
                        _t102 = _t101 + _v68;
                    } else {
                        _t102 = _v72 + (_t101 >> 1) * 4;
                    }
                    goto L21;
                }
            }
            _v68 = _v68 + ( *(_t106 + 4) & 0xfffc);
            _t110 =  *(_v68 - 4);
            goto L13;
            do {
L13:
                _t113 = caml_frame_descriptors_mask;
                _t95 = _t110 >> 3 & _t113;
                __ecx = caml_frame_descriptors;
                _t106 =  *(__ecx + _t95 * 4);
                if( *_t106 == _t110) {
                    break;
                } else {
                    goto L14;
                }
                goto L15;
            } while(_v68 != 0);
            goto L26;
        }
        _t97 = _v68 + 8;
        _v68 =  *_t97;
        _t110 = _t97[1];
        _t90 = _t97[2];
        _v72 = _t97[2];
L26:
    }
    if(_v16 == 0) {
    } else {
        _t114 = _v16;
        _v68 = 0;
        goto L32;
        do {
L32:
            __edi = 0;
            if(_t114[1] > 0) {
                goto L29;
                do {
L29:
                    _t106 = _v68;
                    if(_t114[2] > 0) {
                        while(1) {
                            _t92 = 0 + _t106 * 4 +  *((intOrPtr*)(_t114 + 12 + __edi * 4));
                            _v388 = _t92;
                            _t90 =  *_t92;
                             *__esp =  *_t92;
                            _v32();
                            _t106 = _t106 + 1;
                            if(_t114[2] <= _t106) {
                                break;
                            }
                        }
                        goto L28;
                    }
L28:
                    __edi = __edi + 1;
                } while(_t114[1] > __edi);
                goto L31;
            }
L31:
            _t113 =  *_t114;
        } while( *_t114 != 0);
    }
    goto L34;
L35:
L34:
    __esp =  &((__esp)[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L35;
}

caml_raise_with_string(
    signed int _a4,                        // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805C261
    signed int* _v12;                      // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    unsigned int _v20;                     // _cfa_ffffffec
    char _v24;                             // _cfa_ffffffe8
    intOrPtr _v28;                         // _cfa_ffffffe4
    char _v52;                             // _cfa_ffffffcc
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    signed int _v72;                       // _cfa_ffffffb8
    char _v80;                             // _cfa_ffffffb0
    char* _v116;                           // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    intOrPtr _v124;                        // _cfa_ffffff84
    char _v128;                            // _cfa_ffffff80
    signed int _v132;                      // _cfa_ffffff7c
    char* _v152;                           // _cfa_ffffff68
    intOrPtr _v156;                        // _cfa_ffffff64
    intOrPtr _v160;                        // _cfa_ffffff60
    char _v164;                            // _cfa_ffffff5c
    _unknown_ _v188;                       // _cfa_ffffff44
    signed int _v296;                      // _cfa_fffffed8
    signed int* _v360;                     // _cfa_fffffe98
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t85;                       // _t85
    signed int* _t89;                      // _t89
    signed int _t92;                       // _t92
    signed int* _t94;                      // _t94
    signed int _t98;                       // _t98
    _unknown_ _t99;                        // _t99
    signed int _t103;                      // _t103
    intOrPtr _t104;                        // _t104
    unsigned int _t107;                    // _t107
    signed int* _t111;                     // _t111
    signed int _t112;                      // _t112
    _unknown_ _t113;                       // _t113
    signed int* _t114;                     // _t114
    signed int* _t115;                     // _t115
    signed int* _t116;                     // _t116
    signed int* _t117;                     // _t117
    signed int* _t118;                     // _t118
    signed int* _t119;                     // _t119
    signed int* _t120;                     // _t120
    _unknown_ _t121;                       // _t121

    _v24 = caml_copy_string(_t103, __edi, _t110, _a8);
     *__esp = _a4;
    caml_raise_with_arg();
    _push(_t113);
    _t114 = __esp;
    __esp = __esp - 24;
    _v52 = _v24;
     *__esp =  &caml_exn_Invalid_argument;
    caml_raise_with_string();
    _push(_t114);
    _t115 = __esp;
    __esp = __esp - 24;
    _v80 = _v52;
     *__esp =  &caml_exn_Failure;
    caml_raise_with_string();
    _push(_t115);
    _t116 = __esp;
    __esp = __esp - 104;
    _v128 = caml_local_roots;
    _v120 = 1;
    _v124 = 1;
    _v116 =  &_v80;
    _v132 = 0;
    _v164 =  &_v128;
    caml_local_roots =  &_v164;
    _v156 = 1;
    _v160 = 1;
    _v152 =  &_v132;
    _t85 = caml_alloc_small(_t103, _t110, 1, 0);
    _v132 = _t85;
     *_t85 = _v80;
     *__esp = _v132;
    caml_raise();
    _push(_t116);
    _t117 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Sys_blocked_io;
    L3();
    _push(_t117);
    _t118 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Not_found;
    L3();
    _push(_t118);
    _t119 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Division_by_zero;
    L3();
    _push(_t119);
    _t120 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_End_of_file;
    L3();
    _push(_t120);
    _push(__edi);
    _push(_t110);
    _push(_t103);
    __esp = __esp - 44;
    _t87 = _v296;
    if(_t87 != 0) {
        _v68 = _v16;
        _t107 = _v20;
        _v64 = _t87;
        while(1) {
L12:
            _t110 = caml_frame_descriptors_mask;
            _t92 = _t107 >> 3 & _t110;
            __ecx = caml_frame_descriptors;
            _t103 =  *(__ecx + _t92 * 4);
            if( *_t103 == _t107) {
                break;
            } else {
                goto L13;
            }
            while(1) {
L13:
                _t92 = _t92 + 1 & _t110;
                _t103 =  *(__ecx + _t92 * 4);
                if( *_t103 == _t107) {
                    break;
                }
            }
            break;
        }
L14:
        if( *(_t103 + 4) != 255) {
            _t112 =  *(_t103 + 6) & 65535;
            if(_t112 > 0) {
                __edi = _t103 + 8;
                _v72 = _t103;
                _t104 = _v28;
                while(1) {
                    _t98 =  *__edi & 65535;
                    if((_t98 & 1) == 0) {
                        _t99 = _t98 + _v64;
                    } else {
                        _t99 = _v68 + (_t98 >> 1) * 4;
                    }
                    goto L20;
                }
            }
            _v64 = _v64 + ( *(_t103 + 4) & 0xfffc);
            _t107 =  *(_v64 - 4);
            goto L12;
            do {
L12:
                _t110 = caml_frame_descriptors_mask;
                _t92 = _t107 >> 3 & _t110;
                __ecx = caml_frame_descriptors;
                _t103 =  *(__ecx + _t92 * 4);
                if( *_t103 == _t107) {
                    break;
                } else {
                    goto L13;
                }
                goto L14;
            } while(_v64 != 0);
            goto L25;
        }
        _t94 = _v64 + 8;
        _v64 =  *_t94;
        _t107 = _t94[1];
        _t87 = _t94[2];
        _v68 = _t94[2];
L25:
    }
    if(_v12 == 0) {
    } else {
        _t111 = _v12;
        _v64 = 0;
        goto L31;
        do {
L31:
            __edi = 0;
            if(_t111[1] > 0) {
                goto L28;
                do {
L28:
                    _t103 = _v64;
                    if(_t111[2] > 0) {
                        while(1) {
                            _t89 = 0 + _t103 * 4 +  *((intOrPtr*)(_t111 + 12 + __edi * 4));
                            _v360 = _t89;
                            _t87 =  *_t89;
                             *__esp =  *_t89;
                            _v28();
                            _t103 = _t103 + 1;
                            if(_t111[2] <= _t103) {
                                break;
                            }
                        }
                        goto L27;
                    }
L27:
                    __edi = __edi + 1;
                } while(_t111[1] > __edi);
                goto L30;
            }
L30:
            _t110 =  *_t111;
        } while( *_t111 != 0);
    }
    goto L33;
L34:
L33:
    __esp =  &((__esp)[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L34;
}

caml_invalid_argument(
    char _a4                               // _cfa_4
)
{// addr = 0x0805C281
    signed int* _v8;                       // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    unsigned int _v16;                     // _cfa_fffffff0
    char _v24;                             // _cfa_ffffffe8
    char _v52;                             // _cfa_ffffffcc
    signed int _v60;                       // _cfa_ffffffc4
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    char* _v88;                            // _cfa_ffffffa8
    intOrPtr _v92;                         // _cfa_ffffffa4
    intOrPtr _v96;                         // _cfa_ffffffa0
    char _v100;                            // _cfa_ffffff9c
    signed int _v104;                      // _cfa_ffffff98
    char* _v124;                           // _cfa_ffffff84
    intOrPtr _v128;                        // _cfa_ffffff80
    intOrPtr _v132;                        // _cfa_ffffff7c
    char _v136;                            // _cfa_ffffff78
    _unknown_ _v160;                       // _cfa_ffffff60
    signed int _v268;                      // _cfa_fffffef4
    signed int* _v332;                     // _cfa_fffffeb4
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t79;                       // _t79
    signed int* _t83;                      // _t83
    signed int _t86;                       // _t86
    signed int* _t88;                      // _t88
    signed int _t92;                       // _t92
    _unknown_ _t93;                        // _t93
    signed int _t97;                       // _t97
    intOrPtr _t98;                         // _t98
    unsigned int _t101;                    // _t101
    signed int* _t105;                     // _t105
    signed int _t106;                      // _t106
    _unknown_ _t107;                       // _t107
    signed int* _t108;                     // _t108
    signed int* _t109;                     // _t109
    signed int* _t110;                     // _t110
    signed int* _t111;                     // _t111
    signed int* _t112;                     // _t112
    signed int* _t113;                     // _t113
    _unknown_ _t114;                       // _t114

    _v24 = _a4;
     *__esp =  &caml_exn_Invalid_argument;
    caml_raise_with_string();
    _push(_t107);
    _t108 = __esp;
    __esp = __esp - 24;
    _v52 = _v24;
     *__esp =  &caml_exn_Failure;
    caml_raise_with_string();
    _push(_t108);
    _t109 = __esp;
    __esp = __esp - 104;
    _v100 = caml_local_roots;
    _v92 = 1;
    _v96 = 1;
    _v88 =  &_v52;
    _v104 = 0;
    _v136 =  &_v100;
    caml_local_roots =  &_v136;
    _v128 = 1;
    _v132 = 1;
    _v124 =  &_v104;
    _t79 = caml_alloc_small(_t97, _t104, 1, 0);
    _v104 = _t79;
     *_t79 = _v52;
     *__esp = _v104;
    caml_raise();
    _push(_t109);
    _t110 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Sys_blocked_io;
    L2();
    _push(_t110);
    _t111 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Not_found;
    L2();
    _push(_t111);
    _t112 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Division_by_zero;
    L2();
    _push(_t112);
    _t113 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_End_of_file;
    L2();
    _push(_t113);
    _push(__edi);
    _push(_t104);
    _push(_t97);
    __esp = __esp - 44;
    _t81 = _v268;
    if(_t81 != 0) {
        _v64 = _v12;
        _t101 = _v16;
        _v60 = _t81;
        while(1) {
L11:
            _t104 = caml_frame_descriptors_mask;
            _t86 = _t101 >> 3 & _t104;
            __ecx = caml_frame_descriptors;
            _t97 =  *(__ecx + _t86 * 4);
            if( *_t97 == _t101) {
                break;
            } else {
                goto L12;
            }
            while(1) {
L12:
                _t86 = _t86 + 1 & _t104;
                _t97 =  *(__ecx + _t86 * 4);
                if( *_t97 == _t101) {
                    break;
                }
            }
            break;
        }
L13:
        if( *(_t97 + 4) != 255) {
            _t106 =  *(_t97 + 6) & 65535;
            if(_t106 > 0) {
                __edi = _t97 + 8;
                _v68 = _t97;
                _t98 = _v24;
                while(1) {
                    _t92 =  *__edi & 65535;
                    if((_t92 & 1) == 0) {
                        _t93 = _t92 + _v60;
                    } else {
                        _t93 = _v64 + (_t92 >> 1) * 4;
                    }
                    goto L19;
                }
            }
            _v60 = _v60 + ( *(_t97 + 4) & 0xfffc);
            _t101 =  *(_v60 - 4);
            goto L11;
            do {
L11:
                _t104 = caml_frame_descriptors_mask;
                _t86 = _t101 >> 3 & _t104;
                __ecx = caml_frame_descriptors;
                _t97 =  *(__ecx + _t86 * 4);
                if( *_t97 == _t101) {
                    break;
                } else {
                    goto L12;
                }
                goto L13;
            } while(_v60 != 0);
            goto L24;
        }
        _t88 = _v60 + 8;
        _v60 =  *_t88;
        _t101 = _t88[1];
        _t81 = _t88[2];
        _v64 = _t88[2];
L24:
    }
    if(_v8 == 0) {
    } else {
        _t105 = _v8;
        _v60 = 0;
        goto L30;
        do {
L30:
            __edi = 0;
            if(_t105[1] > 0) {
                goto L27;
                do {
L27:
                    _t97 = _v60;
                    if(_t105[2] > 0) {
                        while(1) {
                            _t83 = 0 + _t97 * 4 +  *((intOrPtr*)(_t105 + 12 + __edi * 4));
                            _v332 = _t83;
                            _t81 =  *_t83;
                             *__esp =  *_t83;
                            _v24();
                            _t97 = _t97 + 1;
                            if(_t105[2] <= _t97) {
                                break;
                            }
                        }
                        goto L26;
                    }
L26:
                    __edi = __edi + 1;
                } while(_t105[1] > __edi);
                goto L29;
            }
L29:
            _t104 =  *_t105;
        } while( *_t105 != 0);
    }
    goto L32;
L33:
L32:
    __esp =  &((__esp)[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L33;
}

caml_failwith(
    char _a4                               // _cfa_4
)
{// addr = 0x0805C29A
    signed int* _v4;                       // _cfa_fffffffc
    signed int _v8;                        // _cfa_fffffff8
    unsigned int _v12;                     // _cfa_fffffff4
    intOrPtr _v20;                         // _cfa_ffffffec
    char _v24;                             // _cfa_ffffffe8
    signed int _v56;                       // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    char _v72;                             // _cfa_ffffffb8
    signed int _v76;                       // _cfa_ffffffb4
    char* _v96;                            // _cfa_ffffffa0
    signed int _v100;                      // _cfa_ffffff9c
    signed int _v104;                      // _cfa_ffffff98
    char _v108;                            // _cfa_ffffff94
    _unknown_ _v132;                       // _cfa_ffffff7c
    signed int _v240;                      // _cfa_ffffff10
    signed int* _v304;                     // _cfa_fffffed0
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t76;                       // _t76
    signed int* _t80;                      // _t80
    signed int _t83;                       // _t83
    signed int* _t85;                      // _t85
    signed int _t89;                       // _t89
    _unknown_ _t90;                        // _t90
    signed int _t94;                       // _t94
    intOrPtr _t95;                         // _t95
    unsigned int _t98;                     // _t98
    signed int* _t102;                     // _t102
    signed int _t103;                      // _t103
    _unknown_ _t104;                       // _t104
    signed int* _t105;                     // _t105
    signed int* _t106;                     // _t106
    signed int* _t107;                     // _t107
    signed int* _t108;                     // _t108
    signed int* _t109;                     // _t109
    _unknown_ _t110;                       // _t110

    _v24 = _a4;
     *__esp =  &caml_exn_Failure;
    caml_raise_with_string();
    _push(_t104);
    _t105 = __esp;
    __esp = __esp - 104;
    _v72 = caml_local_roots;
    _v64 = 1;
    _v68 = 1;
    _v60 =  &_v24;
    _v76 = 0;
    _v108 =  &_v72;
    caml_local_roots =  &_v108;
    _v100 = 1;
    _v104 = 1;
    _v96 =  &_v76;
    _t76 = caml_alloc_small(_t94, _t101, 1, 0);
    _v76 = _t76;
     *_t76 = _v24;
     *__esp = _v76;
    caml_raise();
    _push(_t105);
    _t106 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Sys_blocked_io;
    L1();
    _push(_t106);
    _t107 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Not_found;
    L1();
    _push(_t107);
    _t108 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Division_by_zero;
    L1();
    _push(_t108);
    _t109 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_End_of_file;
    L1();
    _push(_t109);
    _push(__edi);
    _push(_t101);
    _push(_t94);
    __esp = __esp - 44;
    _t78 = _v240;
    if(_t78 != 0) {
        _v60 = _v8;
        _t98 = _v12;
        _v56 = _t78;
        while(1) {
L10:
            _t101 = caml_frame_descriptors_mask;
            _t83 = _t98 >> 3 & _t101;
            __ecx = caml_frame_descriptors;
            _t94 =  *(__ecx + _t83 * 4);
            if( *_t94 == _t98) {
                break;
            } else {
                goto L11;
            }
            while(1) {
L11:
                _t83 = _t83 + 1 & _t101;
                _t94 =  *(__ecx + _t83 * 4);
                if( *_t94 == _t98) {
                    break;
                }
            }
            break;
        }
L12:
        if( *(_t94 + 4) != 255) {
            _t103 =  *(_t94 + 6) & 65535;
            if(_t103 > 0) {
                __edi = _t94 + 8;
                _v64 = _t94;
                _t95 = _v20;
                while(1) {
                    _t89 =  *__edi & 65535;
                    if((_t89 & 1) == 0) {
                        _t90 = _t89 + _v56;
                    } else {
                        _t90 = _v60 + (_t89 >> 1) * 4;
                    }
                    goto L18;
                }
            }
            _v56 = _v56 + ( *(_t94 + 4) & 0xfffc);
            _t98 =  *(_v56 - 4);
            goto L10;
            do {
L10:
                _t101 = caml_frame_descriptors_mask;
                _t83 = _t98 >> 3 & _t101;
                __ecx = caml_frame_descriptors;
                _t94 =  *(__ecx + _t83 * 4);
                if( *_t94 == _t98) {
                    break;
                } else {
                    goto L11;
                }
                goto L12;
            } while(_v56 != 0);
            goto L23;
        }
        _t85 = _v56 + 8;
        _v56 =  *_t85;
        _t98 = _t85[1];
        _t78 = _t85[2];
        _v60 = _t85[2];
L23:
    }
    if(_v4 == 0) {
    } else {
        _t102 = _v4;
        _v56 = 0;
        goto L29;
        do {
L29:
            __edi = 0;
            if(_t102[1] > 0) {
                goto L26;
                do {
L26:
                    _t94 = _v56;
                    if(_t102[2] > 0) {
                        while(1) {
                            _t80 = 0 + _t94 * 4 +  *((intOrPtr*)(_t102 + 12 + __edi * 4));
                            _v304 = _t80;
                            _t78 =  *_t80;
                             *__esp =  *_t80;
                            _v20();
                            _t94 = _t94 + 1;
                            if(_t102[2] <= _t94) {
                                break;
                            }
                        }
                        goto L25;
                    }
L25:
                    __edi = __edi + 1;
                } while(_t102[1] > __edi);
                goto L28;
            }
L28:
            _t101 =  *_t102;
        } while( *_t102 != 0);
    }
    goto L31;
L32:
L31:
    __esp =  &((__esp)[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L32;
}

caml_raise_constant(
    char _a4                               // _cfa_4
)
{// addr = 0x0805C2B3
    signed int* _v0;                       // _cfa_0
    signed int _v4;                        // _cfa_fffffffc
    unsigned int _v8;                      // _cfa_fffffff8
    intOrPtr _v16;                         // _cfa_fffffff0
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    char* _v68;                            // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    intOrPtr _v76;                         // _cfa_ffffffb4
    char _v80;                             // _cfa_ffffffb0
    _unknown_ _v104;                       // _cfa_ffffff98
    signed int _v212;                      // _cfa_ffffff2c
    signed int* _v276;                     // _cfa_fffffeec
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t73;                       // _t73
    signed int* _t77;                      // _t77
    signed int _t80;                       // _t80
    signed int* _t82;                      // _t82
    signed int _t86;                       // _t86
    _unknown_ _t87;                        // _t87
    signed int _t91;                       // _t91
    intOrPtr _t92;                         // _t92
    unsigned int _t95;                     // _t95
    signed int* _t99;                      // _t99
    signed int _t100;                      // _t100
    _unknown_ _t101;                       // _t101
    signed int* _t102;                     // _t102
    signed int* _t103;                     // _t103
    signed int* _t104;                     // _t104
    signed int* _t105;                     // _t105
    _unknown_ _t106;                       // _t106

    _v44 = caml_local_roots;
    _v36 = 1;
    _v40 = 1;
    _v32 =  &_a4;
    _v48 = 0;
    _v80 =  &_v44;
    caml_local_roots =  &_v80;
    _v72 = 1;
    _v76 = 1;
    _v68 =  &_v48;
    _t73 = caml_alloc_small(_t91, _t98, 1, 0);
    _v48 = _t73;
     *_t73 = _a4;
     *__esp = _v48;
    caml_raise();
    _push(_t101);
    _t102 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Sys_blocked_io;
    caml_raise_constant();
    _push(_t102);
    _t103 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Not_found;
    caml_raise_constant();
    _push(_t103);
    _t104 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Division_by_zero;
    caml_raise_constant();
    _push(_t104);
    _t105 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_End_of_file;
    caml_raise_constant();
    _push(_t105);
    _push(__edi);
    _push(_t98);
    _push(_t91);
    __esp = __esp - 44;
    _t75 = _v212;
    if(_t75 != 0) {
        _v56 = _v4;
        _t95 = _v8;
        _v52 = _t75;
        while(1) {
L9:
            _t98 = caml_frame_descriptors_mask;
            _t80 = _t95 >> 3 & _t98;
            __ecx = caml_frame_descriptors;
            _t91 =  *(__ecx + _t80 * 4);
            if( *_t91 == _t95) {
                break;
            } else {
                goto L10;
            }
            while(1) {
L10:
                _t80 = _t80 + 1 & _t98;
                _t91 =  *(__ecx + _t80 * 4);
                if( *_t91 == _t95) {
                    break;
                }
            }
            break;
        }
L11:
        if( *(_t91 + 4) != 255) {
            _t100 =  *(_t91 + 6) & 65535;
            if(_t100 > 0) {
                __edi = _t91 + 8;
                _v60 = _t91;
                _t92 = _v16;
                while(1) {
                    _t86 =  *__edi & 65535;
                    if((_t86 & 1) == 0) {
                        _t87 = _t86 + _v52;
                    } else {
                        _t87 = _v56 + (_t86 >> 1) * 4;
                    }
                    goto L17;
                }
            }
            _v52 = _v52 + ( *(_t91 + 4) & 0xfffc);
            _t95 =  *(_v52 - 4);
            goto L9;
            do {
L9:
                _t98 = caml_frame_descriptors_mask;
                _t80 = _t95 >> 3 & _t98;
                __ecx = caml_frame_descriptors;
                _t91 =  *(__ecx + _t80 * 4);
                if( *_t91 == _t95) {
                    break;
                } else {
                    goto L10;
                }
                goto L11;
            } while(_v52 != 0);
            goto L22;
        }
        _t82 = _v52 + 8;
        _v52 =  *_t82;
        _t95 = _t82[1];
        _t75 = _t82[2];
        _v56 = _t82[2];
L22:
    }
    if(_v0 == 0) {
    } else {
        _t99 = _v0;
        _v52 = 0;
        goto L28;
        do {
L28:
            __edi = 0;
            if(_t99[1] > 0) {
                goto L25;
                do {
L25:
                    _t91 = _v52;
                    if(_t99[2] > 0) {
                        while(1) {
                            _t77 = 0 + _t91 * 4 +  *((intOrPtr*)(_t99 + 12 + __edi * 4));
                            _v276 = _t77;
                            _t75 =  *_t77;
                             *__esp =  *_t77;
                            _v16();
                            _t91 = _t91 + 1;
                            if(_t99[2] <= _t91) {
                                break;
                            }
                        }
                        goto L24;
                    }
L24:
                    __edi = __edi + 1;
                } while(_t99[1] > __edi);
                goto L27;
            }
L27:
            _t98 =  *_t99;
        } while( *_t99 != 0);
    }
    goto L30;
L31:
L30:
    __esp =  &((__esp)[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L31;
}

caml_raise_sys_blocked_io(
    signed int* _a4                        // _cfa_4
)
{// addr = 0x0805C325
    signed int _v0;                        // _cfa_0
    unsigned int _v4;                      // _cfa_fffffffc
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    signed int _v104;                      // _cfa_ffffff98
    signed int* _v168;                     // _cfa_ffffff58
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int* _t53;                      // _t53
    signed int _t56;                       // _t56
    signed int* _t58;                      // _t58
    signed int _t62;                       // _t62
    _unknown_ _t63;                        // _t63
    signed int _t67;                       // _t67
    intOrPtr _t68;                         // _t68
    unsigned int _t70;                     // _t70
    signed int* _t74;                      // _t74
    signed int _t75;                       // _t75
    _unknown_ _t76;                        // _t76
    signed int* _t77;                      // _t77
    signed int* _t78;                      // _t78
    signed int* _t79;                      // _t79
    _unknown_ _t80;                        // _t80

     *__esp =  &caml_exn_Sys_blocked_io;
    caml_raise_constant();
    _push(_t76);
    _t77 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Not_found;
    caml_raise_constant();
    _push(_t77);
    _t78 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Division_by_zero;
    caml_raise_constant();
    _push(_t78);
    _t79 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_End_of_file;
    caml_raise_constant();
    _push(_t79);
    _push(__edi);
    _push(_t73);
    _push(_t67);
    __esp = __esp - 44;
    _t51 = _v104;
    if(_t51 != 0) {
        _v52 = _v0;
        _t70 = _v4;
        _v48 = _t51;
        while(1) {
L8:
            _t73 = caml_frame_descriptors_mask;
            _t56 = _t70 >> 3 & _t73;
            __ecx = caml_frame_descriptors;
            _t67 =  *(__ecx + _t56 * 4);
            if( *_t67 == _t70) {
                break;
            } else {
                goto L9;
            }
            while(1) {
L9:
                _t56 = _t56 + 1 & _t73;
                _t67 =  *(__ecx + _t56 * 4);
                if( *_t67 == _t70) {
                    break;
                }
            }
            break;
        }
L10:
        if( *(_t67 + 4) != 255) {
            _t75 =  *(_t67 + 6) & 65535;
            if(_t75 > 0) {
                __edi = _t67 + 8;
                _v56 = _t67;
                _t68 = _v12;
                while(1) {
                    _t62 =  *__edi & 65535;
                    if((_t62 & 1) == 0) {
                        _t63 = _t62 + _v48;
                    } else {
                        _t63 = _v52 + (_t62 >> 1) * 4;
                    }
                    goto L16;
                }
            }
            _v48 = _v48 + ( *(_t67 + 4) & 0xfffc);
            _t70 =  *(_v48 - 4);
            goto L8;
            do {
L8:
                _t73 = caml_frame_descriptors_mask;
                _t56 = _t70 >> 3 & _t73;
                __ecx = caml_frame_descriptors;
                _t67 =  *(__ecx + _t56 * 4);
                if( *_t67 == _t70) {
                    break;
                } else {
                    goto L9;
                }
                goto L10;
            } while(_v48 != 0);
            goto L21;
        }
        _t58 = _v48 + 8;
        _v48 =  *_t58;
        _t70 = _t58[1];
        _t51 = _t58[2];
        _v52 = _t58[2];
L21:
    }
    if(_a4 == 0) {
    } else {
        _t74 = _a4;
        _v48 = 0;
        goto L27;
        do {
L27:
            __edi = 0;
            if(_t74[1] > 0) {
                goto L24;
                do {
L24:
                    _t67 = _v48;
                    if(_t74[2] > 0) {
                        while(1) {
                            _t53 = 0 + _t67 * 4 +  *((intOrPtr*)(_t74 + 12 + __edi * 4));
                            _v168 = _t53;
                            _t51 =  *_t53;
                             *__esp =  *_t53;
                            _v12();
                            _t67 = _t67 + 1;
                            if(_t74[2] <= _t67) {
                                break;
                            }
                        }
                        goto L23;
                    }
L23:
                    __edi = __edi + 1;
                } while(_t74[1] > __edi);
                goto L26;
            }
L26:
            _t73 =  *_t74;
        } while( *_t74 != 0);
    }
    goto L29;
L30:
L29:
    __esp =  &((__esp)[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L30;
}

caml_raise_not_found(
    signed int _a4,                        // _cfa_4
    signed int* _a8                        // _cfa_8
)
{// addr = 0x0805C337
    unsigned int _v0;                      // _cfa_0
    intOrPtr _v8;                          // _cfa_fffffff8
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    signed int _v76;                       // _cfa_ffffffb4
    signed int* _v140;                     // _cfa_ffffff74
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int* _t53;                      // _t53
    signed int _t56;                       // _t56
    signed int* _t58;                      // _t58
    signed int _t62;                       // _t62
    _unknown_ _t63;                        // _t63
    signed int _t67;                       // _t67
    intOrPtr _t68;                         // _t68
    unsigned int _t70;                     // _t70
    signed int* _t74;                      // _t74
    signed int _t75;                       // _t75
    _unknown_ _t76;                        // _t76
    signed int* _t77;                      // _t77
    signed int* _t78;                      // _t78
    _unknown_ _t79;                        // _t79

     *__esp =  &caml_exn_Not_found;
    caml_raise_constant();
    _push(_t76);
    _t77 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Division_by_zero;
    caml_raise_constant();
    _push(_t77);
    _t78 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_End_of_file;
    caml_raise_constant();
    _push(_t78);
    _push(__edi);
    _push(_t73);
    _push(_t67);
    __esp = __esp - 44;
    _t51 = _v76;
    if(_t51 != 0) {
        _v48 = _a4;
        _t70 = _v0;
        _v44 = _t51;
        while(1) {
L7:
            _t73 = caml_frame_descriptors_mask;
            _t56 = _t70 >> 3 & _t73;
            __ecx = caml_frame_descriptors;
            _t67 =  *(__ecx + _t56 * 4);
            if( *_t67 == _t70) {
                break;
            } else {
                goto L8;
            }
            while(1) {
L8:
                _t56 = _t56 + 1 & _t73;
                _t67 =  *(__ecx + _t56 * 4);
                if( *_t67 == _t70) {
                    break;
                }
            }
            break;
        }
L9:
        if( *(_t67 + 4) != 255) {
            _t75 =  *(_t67 + 6) & 65535;
            if(_t75 > 0) {
                __edi = _t67 + 8;
                _v52 = _t67;
                _t68 = _v8;
                while(1) {
                    _t62 =  *__edi & 65535;
                    if((_t62 & 1) == 0) {
                        _t63 = _t62 + _v44;
                    } else {
                        _t63 = _v48 + (_t62 >> 1) * 4;
                    }
                    goto L15;
                }
            }
            _v44 = _v44 + ( *(_t67 + 4) & 0xfffc);
            _t70 =  *(_v44 - 4);
            goto L7;
            do {
L7:
                _t73 = caml_frame_descriptors_mask;
                _t56 = _t70 >> 3 & _t73;
                __ecx = caml_frame_descriptors;
                _t67 =  *(__ecx + _t56 * 4);
                if( *_t67 == _t70) {
                    break;
                } else {
                    goto L8;
                }
                goto L9;
            } while(_v44 != 0);
            goto L20;
        }
        _t58 = _v44 + 8;
        _v44 =  *_t58;
        _t70 = _t58[1];
        _t51 = _t58[2];
        _v48 = _t58[2];
L20:
    }
    if(_a8 == 0) {
    } else {
        _t74 = _a8;
        _v44 = 0;
        goto L26;
        do {
L26:
            __edi = 0;
            if(_t74[1] > 0) {
                goto L23;
                do {
L23:
                    _t67 = _v44;
                    if(_t74[2] > 0) {
                        while(1) {
                            _t53 = 0 + _t67 * 4 +  *((intOrPtr*)(_t74 + 12 + __edi * 4));
                            _v140 = _t53;
                            _t51 =  *_t53;
                             *__esp =  *_t53;
                            _v8();
                            _t67 = _t67 + 1;
                            if(_t74[2] <= _t67) {
                                break;
                            }
                        }
                        goto L22;
                    }
L22:
                    __edi = __edi + 1;
                } while(_t74[1] > __edi);
                goto L25;
            }
L25:
            _t73 =  *_t74;
        } while( *_t74 != 0);
    }
    goto L28;
L29:
L28:
    __esp =  &((__esp)[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L29;
}

caml_raise_zero_divide(
    unsigned int _a4,                      // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int* _a12                       // _cfa_c
)
{// addr = 0x0805C349
    intOrPtr _v4;                          // _cfa_fffffffc
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    signed int* _v112;                     // _cfa_ffffff90
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int* _t53;                      // _t53
    signed int _t56;                       // _t56
    signed int* _t58;                      // _t58
    signed int _t62;                       // _t62
    _unknown_ _t63;                        // _t63
    signed int _t67;                       // _t67
    intOrPtr _t68;                         // _t68
    unsigned int _t70;                     // _t70
    signed int* _t74;                      // _t74
    signed int _t75;                       // _t75
    _unknown_ _t76;                        // _t76
    signed int* _t77;                      // _t77
    _unknown_ _t78;                        // _t78

     *__esp =  &caml_exn_Division_by_zero;
    caml_raise_constant();
    _push(_t76);
    _t77 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_End_of_file;
    caml_raise_constant();
    _push(_t77);
    _push(__edi);
    _push(_t73);
    _push(_t67);
    __esp = __esp - 44;
    _t51 = _v48;
    if(_t51 != 0) {
        _v44 = _a8;
        _t70 = _a4;
        _v40 = _t51;
        while(1) {
L6:
            _t73 = caml_frame_descriptors_mask;
            _t56 = _t70 >> 3 & _t73;
            __ecx = caml_frame_descriptors;
            _t67 =  *(__ecx + _t56 * 4);
            if( *_t67 == _t70) {
                break;
            } else {
                goto L7;
            }
            while(1) {
L7:
                _t56 = _t56 + 1 & _t73;
                _t67 =  *(__ecx + _t56 * 4);
                if( *_t67 == _t70) {
                    break;
                }
            }
            break;
        }
L8:
        if( *(_t67 + 4) != 255) {
            _t75 =  *(_t67 + 6) & 65535;
            if(_t75 > 0) {
                __edi = _t67 + 8;
                _v48 = _t67;
                _t68 = _v4;
                while(1) {
                    _t62 =  *__edi & 65535;
                    if((_t62 & 1) == 0) {
                        _t63 = _t62 + _v40;
                    } else {
                        _t63 = _v44 + (_t62 >> 1) * 4;
                    }
                    goto L14;
                }
            }
            _v40 = _v40 + ( *(_t67 + 4) & 0xfffc);
            _t70 =  *(_v40 - 4);
            goto L6;
            do {
L6:
                _t73 = caml_frame_descriptors_mask;
                _t56 = _t70 >> 3 & _t73;
                __ecx = caml_frame_descriptors;
                _t67 =  *(__ecx + _t56 * 4);
                if( *_t67 == _t70) {
                    break;
                } else {
                    goto L7;
                }
                goto L8;
            } while(_v40 != 0);
            goto L19;
        }
        _t58 = _v40 + 8;
        _v40 =  *_t58;
        _t70 = _t58[1];
        _t51 = _t58[2];
        _v44 = _t58[2];
L19:
    }
    if(_a12 == 0) {
    } else {
        _t74 = _a12;
        _v40 = 0;
        goto L25;
        do {
L25:
            __edi = 0;
            if(_t74[1] > 0) {
                goto L22;
                do {
L22:
                    _t67 = _v40;
                    if(_t74[2] > 0) {
                        while(1) {
                            _t53 = 0 + _t67 * 4 +  *((intOrPtr*)(_t74 + 12 + __edi * 4));
                            _v112 = _t53;
                            _t51 =  *_t53;
                             *__esp =  *_t53;
                            _v4();
                            _t67 = _t67 + 1;
                            if(_t74[2] <= _t67) {
                                break;
                            }
                        }
                        goto L21;
                    }
L21:
                    __edi = __edi + 1;
                } while(_t74[1] > __edi);
                goto L24;
            }
L24:
            _t73 =  *_t74;
        } while( *_t74 != 0);
    }
    goto L27;
L28:
L27:
    __esp =  &((__esp)[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L28;
}

caml_raise_end_of_file(
    unsigned int _a8,                      // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int* _a16                       // _cfa_10
)
{// addr = 0x0805C35B
    intOrPtr _v0;                          // _cfa_0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    signed int* _v84;                      // _cfa_ffffffac
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int* _t53;                      // _t53
    signed int _t56;                       // _t56
    signed int* _t58;                      // _t58
    signed int _t62;                       // _t62
    _unknown_ _t63;                        // _t63
    signed int _t67;                       // _t67
    intOrPtr _t68;                         // _t68
    unsigned int _t70;                     // _t70
    signed int* _t74;                      // _t74
    signed int _t75;                       // _t75
    _unknown_ _t76;                        // _t76
    _unknown_ _t77;                        // _t77

     *__esp =  &caml_exn_End_of_file;
    caml_raise_constant();
    _push(_t76);
    _push(__edi);
    _push(_t73);
    _push(_t67);
    __esp = __esp - 44;
    _t51 = _v20;
    if(_t51 != 0) {
        _v40 = _a12;
        _t70 = _a8;
        _v36 = _t51;
        while(1) {
L5:
            _t73 = caml_frame_descriptors_mask;
            _t56 = _t70 >> 3 & _t73;
            __ecx = caml_frame_descriptors;
            _t67 =  *(__ecx + _t56 * 4);
            if( *_t67 == _t70) {
                break;
            } else {
                goto L6;
            }
            while(1) {
L6:
                _t56 = _t56 + 1 & _t73;
                _t67 =  *(__ecx + _t56 * 4);
                if( *_t67 == _t70) {
                    break;
                }
            }
            break;
        }
L7:
        if( *(_t67 + 4) != 255) {
            _t75 =  *(_t67 + 6) & 65535;
            if(_t75 > 0) {
                __edi = _t67 + 8;
                _v44 = _t67;
                _t68 = _v0;
                while(1) {
                    _t62 =  *__edi & 65535;
                    if((_t62 & 1) == 0) {
                        _t63 = _t62 + _v36;
                    } else {
                        _t63 = _v40 + (_t62 >> 1) * 4;
                    }
                    goto L13;
                }
            }
            _v36 = _v36 + ( *(_t67 + 4) & 0xfffc);
            _t70 =  *(_v36 - 4);
            goto L5;
            do {
L5:
                _t73 = caml_frame_descriptors_mask;
                _t56 = _t70 >> 3 & _t73;
                __ecx = caml_frame_descriptors;
                _t67 =  *(__ecx + _t56 * 4);
                if( *_t67 == _t70) {
                    break;
                } else {
                    goto L6;
                }
                goto L7;
            } while(_v36 != 0);
            goto L18;
        }
        _t58 = _v36 + 8;
        _v36 =  *_t58;
        _t70 = _t58[1];
        _t51 = _t58[2];
        _v40 = _t58[2];
L18:
    }
    if(_a16 == 0) {
    } else {
        _t74 = _a16;
        _v36 = 0;
        goto L24;
        do {
L24:
            __edi = 0;
            if(_t74[1] > 0) {
                goto L21;
                do {
L21:
                    _t67 = _v36;
                    if(_t74[2] > 0) {
                        while(1) {
                            _t53 = 0 + _t67 * 4 +  *((intOrPtr*)(_t74 + 12 + __edi * 4));
                            _v84 = _t53;
                            _t51 =  *_t53;
                             *__esp =  *_t53;
                            _v0();
                            _t67 = _t67 + 1;
                            if(_t74[2] <= _t67) {
                                break;
                            }
                        }
                        goto L20;
                    }
L20:
                    __edi = __edi + 1;
                } while(_t74[1] > __edi);
                goto L23;
            }
L23:
            _t73 =  *_t74;
        } while( *_t74 != 0);
    }
    goto L26;
L27:
L26:
    __esp =  &((__esp)[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L27;
}

caml_do_local_roots(
    intOrPtr* _a4,                         // _cfa_4
    signed int _a8,                        // _cfa_8
    unsigned int _a12,                     // _cfa_c
    signed int _a16,                       // _cfa_10
    intOrPtr* _a20                         // _cfa_14
)
{// addr = 0x0805C370
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    intOrPtr* _v40;                        // _cfa_ffffffd8
    signed int* _v56;                      // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int* _t53;                      // _t53
    signed int _t56;                       // _t56
    signed int* _t58;                      // _t58
    signed int _t62;                       // _t62
    signed int* _t63;                      // _t63
    signed int _t67;                       // _t67
    intOrPtr* _t68;                        // _t68
    intOrPtr* _t69;                        // _t69
    unsigned int _t71;                     // _t71
    signed int _t74;                       // _t74
    signed short* _t75;                    // _t75
    intOrPtr* _t76;                        // _t76
    signed int _t77;                       // _t77
    signed int _t78;                       // _t78

    _t51 = _a8;
    if(_t51 != 0) {
        _v36 = _a16;
        _t71 = _a12;
        _v32 = _t51;
        while(1) {
L4:
            _t77 = caml_frame_descriptors_mask;
            _t56 = _t71 >> 3 & _t77;
            __ecx = caml_frame_descriptors;
            _t68 =  *((intOrPtr*)(__ecx + _t56 * 4));
            if( *_t68 == _t71) {
                break;
            } else {
                goto L5;
            }
            while(1) {
L5:
                _t56 = _t56 + 1 & _t77;
                _t68 =  *((intOrPtr*)(__ecx + _t56 * 4));
                if( *_t68 == _t71) {
                    break;
                }
            }
            break;
        }
L6:
        if( *(_t68 + 4) != 255) {
            _t78 =  *(_t68 + 6) & 65535;
            if(_t78 > 0) {
                _t75 = _t68 + 8;
                _v40 = _t68;
                _t69 = _a4;
                while(1) {
                    _t62 =  *_t75 & 65535;
                    if((_t62 & 1) == 0) {
                        _t63 = _t62 + _v32;
                    } else {
                        _t63 = _v36 + (_t62 >> 1) * 4;
                    }
                    _v56 = _t63;
                     *__esp =  *_t63;
                     *_t69();
                    _t78 = _t78 - 1;
                    if(_t78 <= 0) {
                        break;
                    }
                    _t75 =  &(_t75[1]);
                }
                _t68 = _v40;
            }
            _v32 = _v32 + ( *(_t68 + 4) & 0xfffc);
            _t71 =  *(_v32 - 4);
            goto L4;
            do {
L4:
                _t77 = caml_frame_descriptors_mask;
                _t56 = _t71 >> 3 & _t77;
                __ecx = caml_frame_descriptors;
                _t68 =  *((intOrPtr*)(__ecx + _t56 * 4));
                if( *_t68 == _t71) {
                    break;
                } else {
                    goto L5;
                }
                goto L6;
            } while(_v32 != 0);
            goto L17;
        }
        _t58 = _v32 + 8;
        _v32 =  *_t58;
        _t71 = _t58[1];
        _t51 = _t58[2];
        _v36 = _t58[2];
L17:
    }
    if(_a20 == 0) {
    } else {
        _t76 = _a20;
        _v32 = 0;
        goto L23;
        do {
L23:
            _t74 = 0;
            if( *((intOrPtr*)(_t76 + 4)) > 0) {
                goto L20;
                do {
L20:
                    _t67 = _v32;
                    if( *((intOrPtr*)(_t76 + 8)) > 0) {
                        while(1) {
                            _t53 = 0 + _t67 * 4 +  *((intOrPtr*)(_t76 + 12 + _t74 * 4));
                            _v56 = _t53;
                            _t51 =  *_t53;
                             *__esp =  *_t53;
                            _a4();
                            _t67 = _t67 + 1;
                            if( *((intOrPtr*)(_t76 + 8)) <= _t67) {
                                break;
                            }
                        }
                        goto L19;
                    }
L19:
                    _t74 = _t74 + 1;
                } while( *((intOrPtr*)(_t76 + 4)) > _t74);
                goto L22;
            }
L22:
            _t76 =  *_t76;
        } while(_t76 != 0);
    }
    goto L25;
L26:
L25:
    return;
    goto L26;
}

caml_stack_usage()
{// addr = 0x0805C497
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    intOrPtr* _t1;                         // _t1
    _unknown_ _t2;                         // _t2
    signed int _t5;                        // _t5

    _t5 = caml_top_of_stack - caml_bottom_of_stack >> 2;
    _t1 = caml_stack_usage_hook;
    if(_t1 != 0) {
         *_t1();
        _t5 = _t5 + _t1;
    }
    return;
}

cons(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __esi                         // r5
)
{// addr = 0x0805C4C2
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    _unknown_ __ebp;                       // r6
    _unknown_ _t8;                         // _t8
    _unknown_ _t11;                        // _t11

    __eax = __eax;
    _v12 = __ebx;
    _v8 = __esi;
    caml_stat_alloc(8);
     *__eax = __eax;
     *((intOrPtr*)(__eax + 4)) = __edx;
    return;
}

caml_register_dyn_global(
    _unknown_ __eax,                       // r0
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x0805C4ED
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2
    intOrPtr* _t3;                         // _t3

    _t3 = _a4;
    cons(_t3, __ebx, __esi);
    caml_dyn_globals = _t3;
    return;
}

caml_register_frametable(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x0805C508
    _unknown_ __ebp;                       // r6
    intOrPtr* _t2;                         // _t2

    _t2 = _a4;
    cons(_t2, __ebx, __esi);
    frametables = _t2;
    _t3 = caml_frame_descriptors;
    if(caml_frame_descriptors != 0) {
        caml_stat_free(_t3);
        caml_frame_descriptors = 0;
        return;
    }
    return;
}

caml_init_frame_descriptors()
{// addr = 0x0805C53E
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr* _v36;                        // _cfa_ffffffdc
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    intOrPtr* _t28;                        // _t28
    signed int _t29;                       // _t29
    intOrPtr* _t30;                        // _t30
    intOrPtr _t32;                         // _t32
    intOrPtr _t34;                         // _t34
    signed int _t37;                       // _t37
    unsigned int* _t41;                    // _t41
    intOrPtr _t43;                         // _t43
    _unknown_ _t45;                        // _t45
    signed int _t47;                       // _t47
    signed int _t48;                       // _t48
    signed int _t49;                       // _t49
    intOrPtr _t50;                         // _t50
    unsigned int** _t53;                   // _t53
    signed int _t55;                       // _t55
    _unknown_ _t56;                        // _t56
    intOrPtr* _t57;                        // _t57
    unsigned int* _t58;                    // _t58
    char* _t59;                            // _t59

    if(inited.3139 == 0) {
        _t44 = caml_frametable;
        if(caml_frametable != 0) {
            _t49 = 0;
            _t59 =  &caml_frametable;
            while(1) {
                caml_register_frametable(_t44);
                _t49 = _t49 + 1;
                _t44 =  *((intOrPtr*)(_t59 + _t49 * 4));
                if( *((intOrPtr*)(_t59 + _t49 * 4)) == 0) {
                    break;
                }
            }
        }
        inited.3139 = 1;
    }
    _t28 = frametables;
    if(_t28 == 0) {
L23:
        caml_stat_alloc(16);
        caml_frame_descriptors = _t28;
    } else {
        _t55 = 0;
        while(1) {
            _t55 = _t55 +  *((intOrPtr*)( *_t28));
            _t28 =  *((intOrPtr*)(_t28 + 4));
            if(_t28 == 0) {
                break;
            }
        }
        _t56 = _t55 + _t55;
        if(_t56 <= 4) {
            goto L23;
        } else {
            _t48 = 4;
            while(1) {
                _t48 = _t48 + _t48;
                if(_t48 >= _t56) {
                    break;
                }
            }
            _t43 = 0 + _t48 * 4;
            caml_stat_alloc(_t43);
            caml_frame_descriptors = _t43;
            if(_t48 > 0) {
                goto L24;
            } else {
                goto L14;
            }
L25:
            return;
L26:
        }
    }
L24:
    _t29 = 0;
    while(1) {
         *(caml_frame_descriptors + _t29 * 4) = 0;
        _t29 = _t29 + 1;
        if(_t29 >= 4) {
            break;
        }
    }
L14:
    caml_frame_descriptors_mask = 3;
    _t30 = frametables;
    _v36 = _t30;
    if(_t30 == 0) {
    } else {
        goto L15;
        do {
L15:
            _t57 =  *_v36;
            _t32 =  *_t57;
            _v32 = _t32;
            if(_t32 <= 0) {
                goto L21;
            }
            _t58 = _t57 + 4;
            __edi = 0;
            while(1) {
                _t47 = caml_frame_descriptors_mask;
                _t37 =  *_t58 >> 3 & _t47;
                _t50 = caml_frame_descriptors;
                _t53 = _t50 + _t37 * 4;
                if( *_t53 == 0) {
                    break;
                }
                while(1) {
L18:
                    _t37 = _t37 + 1 & _t47;
                    _t53 = _t50 + _t37 * 4;
                    if( *_t53 == 0) {
                        break;
                    }
                }
                break;
            }
L19:
             *_t53 = _t58;
            _t41 = (_t58[1] & 1) != 0 ? (_t58 + 11 + (_t58[1] & 65535) * 2 & 252) + 8 : _t58 + 11 + (_t58[1] & 65535) * 2 & 252;
            __edi = __edi + 1;
            if(__edi == _v32) {
                goto L21;
            }
            _t58 = _t41;
            _t47 = caml_frame_descriptors_mask;
            _t37 =  *_t58 >> 3 & _t47;
            _t50 = caml_frame_descriptors;
            _t53 = _t50 + _t37 * 4;
            if( *_t53 == 0) {
                break;
            }
            goto L18;
L21:
            _t34 =  *((intOrPtr*)(_v36 + 4));
            _v36 = _t34;
        } while(_t34 != 0);
        return;
    }
    goto L25;
}

caml_do_roots(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x0805C695
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    intOrPtr* _v72;                        // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t30;                       // _t30
    intOrPtr* _t36;                        // _t36
    signed int _t40;                       // _t40
    signed int _t41;                       // _t41
    intOrPtr* _t42;                        // _t42
    signed int _t44;                       // _t44
    intOrPtr* _t45;                        // _t45
    signed int _t48;                       // _t48
    signed int _t49;                       // _t49
    char _t61;                             // _t61
    _unknown_ _t62;                        // _t62
    unsigned int* _t63;                    // _t63
    unsigned int* _t64;                    // _t64

    _t61 = caml_globals;
    if(_t61 != 0) {
        _v32 = 0;
        goto L4;
        do {
L4:
            _t64 = _t61 - 4;
            _t44 = 0;
            _t49 = 0;
            if( *_t64 >> 10 != 0) {
                while(1) {
                    _t45 = _t61 + _t44 * 4;
                    _v72 = _t45;
                     *__esp =  *_t45;
                    _a4();
                    _t49 = _t49 + 1;
                    _t44 = _t49;
                    if(_t49 >=  *_t64 >> 10) {
                        break;
                    }
                }
                goto L3;
            }
L3:
            _v32 = _v32 + 1;
            _t61 =  *((intOrPtr*)( &caml_globals + _v32 * 4));
        } while(_t61 != 0);
    }
    _t30 = caml_dyn_globals;
    _v32 = _t30;
    if(_t30 == 0) {
    } else {
        goto L7;
        do {
L7:
            _t62 =  *_v32;
            _t63 = _t62 - 4;
            if( *_t63 >> 10 == 0) {
            } else {
                _t41 = 0;
                _t48 = 0;
                while(1) {
                    _t42 = _t62 + _t41 * 4;
                    _v72 = _t42;
                     *__esp =  *_t42;
                    _a4();
                    _t48 = _t48 + 1;
                    _t41 = _t48;
                    if( *_t63 >> 10 <= _t48) {
                        break;
                    }
                }
            }
            goto L10;
L10:
            _t40 =  *(_v32 + 4);
            _v32 = _t40;
        } while(_t40 != 0);
    }
    goto L11;
L15:
    return;
L16:
L11:
    if(caml_frame_descriptors == 0) {
        caml_init_frame_descriptors();
    }
    caml_do_local_roots(_a4, caml_bottom_of_stack, caml_last_return_address, caml_gc_regs, caml_local_roots);
    caml_scan_global_roots(_a4);
    caml_final_do_strong_roots(_a4);
    _t36 = caml_scan_roots_hook;
    if(_t36 == 0) {
    } else {
         *__esp = _a4;
         *_t36();
        return;
    }
    goto L15;
}

caml_darken_all_roots()
{// addr = 0x0805C7B6
    _unknown_ __ebp;                       // r6

    caml_do_roots(caml_darken);
    return;
}

caml_oldify_local_roots()
{// addr = 0x0805C7CA
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t83;                       // _t83
    signed int _t85;                       // _t85
    intOrPtr* _t86;                        // _t86
    signed int _t89;                       // _t89
    signed int* _t91;                      // _t91
    signed int _t96;                       // _t96
    signed int _t101;                      // _t101
    signed int _t102;                      // _t102
    signed int _t103;                      // _t103
    signed int _t104;                      // _t104
    signed int _t105;                      // _t105
    intOrPtr* _t106;                       // _t106
    signed int _t107;                      // _t107
    signed int _t108;                      // _t108
    signed int _t109;                      // _t109
    signed int _t110;                      // _t110
    intOrPtr _t111;                        // _t111
    unsigned int _t114;                    // _t114
    signed int _t118;                      // _t118
    signed int* _t119;                     // _t119
    signed int _t122;                      // _t122
    signed int _t133;                      // _t133
    signed short* _t134;                   // _t134
    _unknown_ _t135;                       // _t135
    intOrPtr _t136;                        // _t136
    intOrPtr* _t137;                       // _t137
    signed int _t138;                      // _t138
    signed int _t139;                      // _t139
    unsigned int* _t140;                   // _t140
    unsigned int* _t141;                   // _t141

    _v32 = caml_globals_scanned;
    _t83 = caml_globals_inited;
    if(_v32 > _t83) {
L12:
        caml_globals_scanned = _t83;
        _t109 = caml_dyn_globals;
        _v32 = _t109;
        if(_t109 == 0) {
            goto L21;
        }
        goto L13;
    }
    _t136 =  *((intOrPtr*)(_v32 * 4 +  &caml_globals));
    if(_t136 != 0) {
        goto L10;
        do {
L10:
            _t141 = _t136 - 4;
            _t103 = 0;
            _t108 = 0;
            if( *_t141 >> 10 != 0) {
                goto L3;
                do {
L3:
                    _t129 = _t136 + _t103 * 4;
                    _t104 =  *(_t136 + _t103 * 4);
                    if((_t104 & 1) == 0) {
                        if(_t104 < caml_young_end) {
                            if(_t104 > caml_young_start) {
                                caml_oldify_one(_t104, _t108, _t136, _t141, _t104, _t129);
                            }
                        }
                    }
                    _t108 = _t108 + 1;
                    _t103 = _t108;
                } while(_t108 <  *_t141 >> 10);
            } else {
            }
            _v32 = _v32 + 1;
            _t83 = caml_globals_inited;
            if(_t83 < _v32) {
                goto L12;
            }
            goto L9;
            do {
                goto L13;
L20:
                _t122 =  *(_v32 + 4);
                _v32 = _t122;
            } while(_t122 != 0);
L21:
            if(caml_frame_descriptors == 0) {
                caml_init_frame_descriptors();
            }
            _t110 = caml_bottom_of_stack;
            _v32 = _t110;
            _t114 = caml_last_return_address;
            _v36 = caml_gc_regs;
            if(_t110 == 0) {
L40:
                _t137 = caml_local_roots;
                _v32 = 0;
                if(_t137 != 0) {
                    goto L51;
                    do {
L51:
                        _t133 = 0;
                        if( *((intOrPtr*)(_t137 + 4)) > 0) {
                            goto L48;
                            do {
L48:
                                _t105 = _v32;
                                if( *((intOrPtr*)(_t137 + 8)) > 0) {
                                    while(1) {
                                        _t116 = 0 + _t105 * 4 +  *((intOrPtr*)(_t137 + 12 + _t133 * 4));
                                        _t85 =  *(0 + _t105 * 4 +  *((intOrPtr*)(_t137 + 12 + _t133 * 4)));
                                        if((_t85 & 1) == 0 && _t85 < caml_young_end && _t85 > caml_young_start) {
                                            caml_oldify_one(_t85, _t105, _t133, _t137, _t85, _t116);
                                        }
                                        _t105 = _t105 + 1;
                                        if( *((intOrPtr*)(_t137 + 8)) <= _t105) {
                                            break;
                                        }
                                    }
                                    goto L47;
                                }
L47:
                                _t133 = _t133 + 1;
                            } while( *((intOrPtr*)(_t137 + 4)) > _t133);
                            goto L50;
                        }
L50:
                        _t137 =  *_t137;
                    } while(_t137 != 0);
L53:
                    caml_scan_global_young_roots(caml_oldify_one);
                    caml_final_do_young_roots(caml_oldify_one);
                    _t86 = caml_scan_roots_hook;
                    if(_t86 == 0) {
                        return;
                    }
                     *__esp = caml_oldify_one;
                     *_t86();
                    return;
                }
            } else {
                while(1) {
L24:
                    _t138 = caml_frame_descriptors_mask;
                    _t89 = _t114 >> 3 & _t138;
                    _t111 = caml_frame_descriptors;
                    _t106 =  *((intOrPtr*)(_t111 + _t89 * 4));
                    if( *_t106 == _t114) {
                        break;
                    }
                    while(1) {
L25:
                        _t89 = _t89 + 1 & _t138;
                        _t106 =  *((intOrPtr*)(_t111 + _t89 * 4));
                        if( *_t106 == _t114) {
                            break;
                        }
                    }
                    break;
                }
L26:
                if( *(_t106 + 4) == 255) {
L39:
                    _t91 = _v32 + 8;
                    _v32 =  *_t91;
                    _t114 = _t91[1];
                    _v36 = _t91[2];
                }
                _t139 =  *(_t106 + 6) & 65535;
                if(_t139 <= 0) {
L38:
                    _v32 = _v32 + ( *(_t106 + 4) & 0xfffc);
                    _t114 =  *(_v32 - 4);
                    goto L24;
                    do {
L24:
                        _t138 = caml_frame_descriptors_mask;
                        _t89 = _t114 >> 3 & _t138;
                        _t111 = caml_frame_descriptors;
                        _t106 =  *((intOrPtr*)(_t111 + _t89 * 4));
                        if( *_t106 == _t114) {
                            break;
                        }
                        goto L25;
                    } while(_v32 != 0);
                    goto L40;
                }
                _t134 = _t106 + 8;
                while(1) {
                    _t118 =  *_t134 & 65535;
                    if((_t118 & 1) == 0) {
                        _t119 = _t118 + _v32;
                    } else {
                        _t119 = _v36 + (_t118 >> 1) * 4;
                    }
                    _t96 =  *_t119;
                    if((_t96 & 1) == 0 && _t96 < caml_young_end && _t96 > caml_young_start) {
                        caml_oldify_one(_t96, _t106, _t134, _t139, _t96, _t119);
                    }
                    _t139 = _t139 - 1;
                    if(_t139 <= 0) {
                        break;
                    }
                    _t134 =  &(_t134[1]);
                }
                goto L38;
            }
            goto L53;
L9:
            _t136 =  *((intOrPtr*)( &caml_globals + _v32 * 4));
        } while(_t136 != 0);
    } else {
    }
    goto L12;
L13:
    _t135 =  *_v32;
    _t140 = _t135 - 4;
    if( *_t140 >> 10 == 0) {
        goto L20;
    }
    _t101 = 0;
    _t107 = 0;
    while(1) {
        _t123 = _t135 + _t101 * 4;
        _t102 =  *(_t135 + _t101 * 4);
        if((_t102 & 1) == 0 && _t102 < caml_young_end && _t102 > caml_young_start) {
            caml_oldify_one(_t102, _t107, _t135, _t140, _t102, _t123);
        }
        _t107 = _t107 + 1;
        _t101 = _t107;
        if(_t107 >=  *_t140 >> 10) {
            break;
        }
    }
    goto L20;
}

caml_iterate_global_roots(
    intOrPtr* __eax,                       // r0
    _unknown_ __edx                        // r3
)
{// addr = 0x0805CA50
    intOrPtr* _v24;                        // _cfa_ffffffe8
    intOrPtr* __ebx;                       // r1
    intOrPtr* __esi;                       // r5
    _unknown_ __ebp;                       // r6
    intOrPtr* _t5;                         // _t5

    __edx = __edx;
    __esi = __eax;
    __ebx =  *((intOrPtr*)(__edx + 4));
    if(__ebx != 0) {
        while(1) {
            _t5 =  *__ebx;
            _v24 = _t5;
             *__esp =  *_t5;
             *__esi();
            __ebx =  *((intOrPtr*)(__ebx + 4));
            if(__ebx == 0) {
                break;
            }
        }
    }
    return;
}

caml_scan_global_roots(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x0805CA7C
    intOrPtr* __ebx;                       // r1
    _unknown_ __ebp;                       // r6

    __ebx = _a4;
    caml_iterate_global_roots(_a4,  &caml_global_roots);
    caml_iterate_global_roots(__ebx,  &caml_global_roots_young);
    caml_iterate_global_roots(__ebx,  &caml_global_roots_old);
    return;
}

caml_insert_global_root(
    intOrPtr __eax,                        // r0
    _unknown_ __edx                        // r3
)
{// addr = 0x0805CAB0
    char _v96;                             // _cfa_ffffffa0
    signed int _v112;                      // _cfa_ffffff90
    intOrPtr _v116;                        // _cfa_ffffff8c
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    intOrPtr _t32;                         // _t32
    signed int _t33;                       // _t33
    signed int _t34;                       // _t34
    signed int _t36;                       // _t36
    signed int _t38;                       // _t38
    intOrPtr* _t40;                        // _t40
    _unknown_ _t41;                        // _t41
    signed int _t43;                       // _t43
    intOrPtr _t44;                         // _t44
    intOrPtr _t46;                         // _t46
    signed int _t49;                       // _t49
    char* _t50;                            // _t50
    intOrPtr _t53;                         // _t53
    char* _t54;                            // _t54
    signed int _t55;                       // _t55
    char* _t56;                            // _t56

    _t32 = __eax;
    _v116 = _t32;
    _t41 = __edx;
    _t53 = _t32;
    _t33 =  *(_t32 + 72);
    _v112 = _t33;
    _t43 = _t33;
    _t46 = _t53;
    if(_t33 >= 0) {
L6:
        _t34 =  *(_t46 + 4);
        if(_t34 == 0 ||  *_t34 != _t41) {
            _t36 = _t34 * random_seed + 25173;
            random_seed = _t36;
            _t55 = 0;
            if((_t36 & -1073741824) != -1073741824) {
L10:
                if(_v112 >= _t55) {
L15:
                    _t34 = 8 + _t55 * 4;
                    caml_stat_alloc(_t34);
                     *_t34 = _t41;
                    if(_t55 >= 0) {
                        goto L18;
                    }
                    goto L16;
                }
                goto L11;
L16:
                _t49 = 0;
                _t54 =  &_v96;
                while(1) {
                    _t44 =  *((intOrPtr*)(_t54 + _t49 * 4));
                     *(_t34 + 4 + _t49 * 4) =  *(_t44 + 4 + _t49 * 4);
                     *(_t44 + 4 + _t49 * 4) = _t34;
                    _t49 = _t49 + 1;
                    if(_t49 > _t55) {
                        break;
                    }
                }
                goto L18;
            } else {
                goto L9;
            }
            while(1) {
L9:
                _t55 = _t55 + 1;
                _t36 = _t36 << 2;
                if((_t36 & -1073741824) != -1073741824) {
                    break;
                }
            }
            goto L10;
L11:
            _t38 = _v112 + 1;
            if(_t38 > _t55) {
L14:
                 *(_v116 + 72) = _t55;
                goto L15;
            }
            _t50 =  &_v96;
            while(1) {
                 *((intOrPtr*)(_t50 + _t38 * 4)) = _t53;
                _t38 = _t38 + 1;
                if(_t38 > _t55) {
                    break;
                }
            }
            goto L14;
        }
L18:
        return;
    } else {
        _t56 =  &_v96;
        while(1) {
L2:
            _t40 =  *((intOrPtr*)(_t46 + 4 + _t43 * 4));
            if(_t40 == 0 ||  *_t40 >= _t41) {
                break;
            }
            _t46 = _t40;
        }
         *((intOrPtr*)(_t56 + _t43 * 4)) = _t46;
        _t43 = _t43 - 1;
        if(_t43 != 255) {
            goto L2;
        }
        goto L6;
    }
}

caml_register_generational_global_root(
    unsigned int* _a4                      // _cfa_4
)
{// addr = 0x0805CB97
    _unknown_ __ebp;                       // r6
    unsigned int _t10;                     // _t10

    __edx = _a4;
    _t10 =  *__edx;
    if((_t10 & 1) != 0) {
L6:
        return;
    }
    if(_t10 >= caml_young_end || _t10 <= caml_young_start) {
        if(( *( *((intOrPtr*)((_t10 >> 23) * 4 +  &caml_page_table)) + _t10) & 1) != 0) {
            caml_insert_global_root( &caml_global_roots_old, __edx);
            return;
        }
    } else {
        caml_insert_global_root( &caml_global_roots_young, __edx);
        return;
    }
    goto L6;
}

caml_register_global_root(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805CBEA
    _unknown_ __ebp;                       // r6

    __edx = _a4;
    __eax =  ?_? ( &caml_global_roots);
    caml_insert_global_root( &caml_global_roots, _a4);
    return;
}

caml_scan_global_young_roots(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x0805CBFF
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t8;                        // _t8
    intOrPtr* _t10;                        // _t10
    intOrPtr* _t11;                        // _t11
    intOrPtr* _t12;                        // _t12
    signed int _t15;                       // _t15

    _t10 = _a4;
    caml_iterate_global_roots(_t10,  &caml_global_roots);
    _t7 = _t10;
    caml_iterate_global_roots(_t10,  &caml_global_roots_young);
    _t11 =  *134693956;
    if(_t11 != 0) {
        while(1) {
            caml_insert_global_root( &caml_global_roots_old,  *_t11);
            _t11 =  *((intOrPtr*)(_t11 + 4));
            if(_t11 == 0) {
                break;
            }
        }
        _t7 =  *134693956;
        if(_t7 == 0) {
        } else {
            while(1) {
                _t12 =  *((intOrPtr*)(_t7 + 4));
                caml_stat_free(_t7);
                if(_t12 == 0) {
                    break;
                }
                _t7 = _t12;
            }
        }
    }
    _t15 =  *134694024;
    if(_t15 >= 0) {
    } else {
        _t8 = 0;
        __ecx = 134693956;
        while(1) {
             *(__ecx + _t8 * 4) = 0;
            _t8 = _t8 + 1;
            if(_t8 > _t15) {
                break;
            }
        }
    }
    goto L8;
L9:
L8:
     *134694024 = 0;
    return;
    goto L9;
}

caml_delete_global_root(
    signed int __eax                       // r0
)
{// addr = 0x0805CC8C
    char _v96;                             // _cfa_ffffffa0
    signed int _v112;                      // _cfa_ffffff90
    signed int __ebx;                      // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t33;                       // _t33
    signed int _t34;                       // _t34
    signed int _t35;                       // _t35
    signed int _t36;                       // _t36
    intOrPtr* _t37;                        // _t37
    _unknown_ _t38;                        // _t38
    intOrPtr _t39;                         // _t39
    char* _t40;                            // _t40
    char* _t41;                            // _t41
    signed int _t43;                       // _t43

    _t33 = __eax;
    __ebx = _t33;
    _t36 = _t33;
    _t34 =  *(_t33 + 72);
    _v112 = _t34;
    if(_t34 >= 0) {
L6:
        _t37 =  *((intOrPtr*)(_t36 + 4));
        if(_t37 == 0 ||  *_t37 != _t38) {
L19:
            return;
L20:
        } else {
            if(_v112 >= 0) {
L13:
                caml_stat_free(_t37);
                _t34 =  *(__ebx + 72);
                if(_t34 <= 0 ||  *((intOrPtr*)(__ebx + 4 + _t34 * 4)) != 0) {
                    goto L19;
                } else {
                    while(1) {
                        _t34 = _t34 - 1;
                        if(_t34 <= 0) {
                            break;
                        }
                        if( *((intOrPtr*)(__ebx + 4 + _t34 * 4)) == 0) {
                            continue;
                        }
                         *(__ebx + 72) = _t34;
                        return;
                    }
                     *(__ebx + 72) = _t34;
                    return;
                }
                goto L20;
            }
            _t35 = 0;
            _t40 =  &_v96;
            while(1) {
                _t39 =  *((intOrPtr*)(_t40 + _t35 * 4));
                if( *((intOrPtr*)(_t39 + 4 + _t35 * 4)) == _t37) {
                     *((intOrPtr*)(_t39 + 4 + _t35 * 4)) =  *((intOrPtr*)(_t37 + 4 + _t35 * 4));
                }
                _t35 = _t35 + 1;
                if( *(__ebx + 72) < _t35) {
                    break;
                }
            }
            goto L13;
        }
    } else {
        _t43 = _t34;
        _t41 =  &_v96;
        goto L2;
        do {
            while(1) {
L2:
                _t34 =  *(_t36 + 4 + _t43 * 4);
                if(_t34 == 0 ||  *_t34 >= _t38) {
                    break;
                } else {
                    _t36 = _t34;
                    continue;
                }
            }
             *(_t41 + _t43 * 4) = _t36;
            _t43 = _t43 - 1;
        } while(_t43 != 255);
        goto L6;
    }
}

caml_modify_generational_global_root(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    _unknown_ __eflags,                    // r9
    char** _a4,                            // _cfa_4
    unsigned int _a8                       // _cfa_8
)
{// addr = 0x0805CD29
    intOrPtr _v8;                          // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    unsigned int _t34;                     // _t34
    _unknown_ _t35;                        // _t35
    signed int _t37;                       // _t37
    intOrPtr _t40;                         // _t40
    _unknown_ _t41;                        // _t41
    _unknown_ _t42;                        // _t42
    intOrPtr _t45;                         // _t45
    _unknown_ _t51;                        // _t51
    char** _t54;                           // _t54
    _unknown_ _t55;                        // _t55

     *__esp = __ebx;
    _v8 = __esi;
    _t54 = _a4;
    _t34 = _a8;
    _t27 =  *_t54;
    _t37 = _t34 & 1;
    if(__eflags != 0 || _t34 >= caml_young_end || _t34 <= caml_young_start) {
        __eflags = _t27 & 1;
        if((_t27 & 1) == 0) {
            __eflags = _t37;
            if(_t37 == 0) {
                goto L17;
            }
            goto L13;
        }
        goto L7;
L13:
        __eflags = _t27 - caml_young_end;
        if(_t27 >= caml_young_end) {
L20:
            _t27 = _t27 >> 12 & 2047;
            _t40 =  *((intOrPtr*)((_t27 >> 23) * 4 +  &caml_page_table));
            __eflags =  *(_t40 + _t27) & 1;
            if(( *(_t40 + _t27) & 1) != 0) {
                _t27 =  &caml_global_roots_old;
                caml_delete_global_root( &caml_global_roots_old);
            }
            goto L17;
        }
        __eflags = _t27 - caml_young_start;
        if(_t27 <= caml_young_start) {
            goto L20;
        }
        _t27 =  ?_? ( &caml_global_roots_young);
        caml_delete_global_root( &caml_global_roots_young);
    } else {
        if((_t27 & 1) != 0) {
L8:
            __eflags = _t34 - caml_young_end;
            if(_t34 >= caml_young_end) {
L18:
                _t27 = _t34 >> 12 & 2047;
                _t45 =  *((intOrPtr*)((_t34 >> 23) * 4 +  &caml_page_table));
                __eflags =  *(_t45 + _t27) & 1;
                if(( *(_t45 + _t27) & 1) != 0) {
                    _t27 =  &caml_global_roots_old;
                    caml_insert_global_root( &caml_global_roots_old, _t54);
                }
                goto L17;
            }
            goto L9;
        }
        if(( *( *((intOrPtr*)(( &caml_global_roots_old >> 23) * 4 +  &caml_page_table)) + _t27) & 1) != 0) {
            caml_delete_global_root( &caml_global_roots_old);
            _t27 =  ?_? ( &caml_global_roots_young);
            caml_insert_global_root( &caml_global_roots_young, _t54);
        }
L17:
         *_t54 = _t34;
        return;
L9:
        __eflags = _t34 - caml_young_start;
        if(_t34 <= caml_young_start) {
            goto L18;
        }
        _t27 =  ?_? ( &caml_global_roots_young);
        caml_insert_global_root( &caml_global_roots_young, _t54);
    }
L7:
    __eflags = _t37;
    if(_t37 != 0) {
        goto L17;
    }
    goto L8;
}

caml_remove_generational_global_root(
    unsigned int* _a4                      // _cfa_4
)
{// addr = 0x0805CE36
    _unknown_ __ebp;                       // r6
    unsigned int _t10;                     // _t10

    _t10 =  *_a4;
    if((_t10 & 1) != 0) {
L6:
        return;
    }
    if(_t10 >= caml_young_end || _t10 <= caml_young_start) {
        if(( *( *((intOrPtr*)((_t10 >> 23) * 4 +  &caml_page_table)) + _t10) & 1) != 0) {
            caml_delete_global_root( &caml_global_roots_old);
            return;
        }
    } else {
        caml_delete_global_root( &caml_global_roots_young);
        return;
    }
    goto L6;
}

caml_remove_global_root(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x0805CE89
    _unknown_ __ebp;                       // r6

    __eax =  ?_? ( &caml_global_roots);
    caml_delete_global_root( &caml_global_roots);
    return;
}

caml_record_signal(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805CEA0
    _unknown_ __ebp;                       // r6

     *((intOrPtr*)(_a4 * 4 +  &caml_pending_signals)) = 1;
    caml_signals_are_pending = 1;
    caml_young_limit = caml_young_end;
    return;
}

caml_enter_blocking_section_default()
{// addr = 0x0805CEC7
    _unknown_ __ebp;                       // r6

    caml_async_signal_mode = 1;
    return;
}

caml_leave_blocking_section_default()
{// addr = 0x0805CED6
    _unknown_ __ebp;                       // r6

    caml_async_signal_mode = 0;
    return;
}

caml_try_leave_blocking_section_default()
{// addr = 0x0805CEE5
    _unknown_ __ebp;                       // r6

    asm("xchg [0x80744f8], eax");
    return 0;
}

caml_urge_major_slice()
{// addr = 0x0805CEF2
    _unknown_ __ebp;                       // r6

    caml_force_major_slice = 1;
    caml_young_limit = caml_young_end;
    return;
}

caml_convert_signal_number(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805CF0B
    _unknown_ __ebp;                       // r6
    signed int _t4;                        // _t4

    _t4 = _a4;
    if(_t4 >= 0 || _t4 <= 234) {
        return _t4;
    } else {
        return  *((intOrPtr*)( !_t4 * 4 +  &posix_signals));
    }
}

caml_rev_convert_signal_number(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805CF25
    _unknown_ __ebp;                       // r6
    intOrPtr _t6;                          // _t6
    _unknown_ _t8;                         // _t8

    _t6 = _a4;
    __edx = 1;
    __ecx =  &posix_signals;
    if(_t6 == 6) {
L3:
        return;
    }
L2:
    while( *((intOrPtr*)(__ecx + __edx * 4)) != _t6) {
        goto L4;
    }
    goto L3;
L4:
    __edx = __edx + 1;
    if(__edx != 21) {
        goto L2;
    }
    return;
}

caml_execute_signal(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805CF53
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v156;                            // _cfa_ffffff64
    signed int _v164;                      // _cfa_ffffff5c
    signed int _v168;                      // _cfa_ffffff58
    _unknown_ __ebp;                       // r6
    _unknown_ _t24;                        // _t24
    signed int _t28;                       // _t28
    signed int _t32;                       // _t32
    _unknown_ _t33;                        // _t33
    signed int _t35;                       // _t35
    _unknown_ _t36;                        // _t36
    signed int _t39;                       // _t39
    _unknown_ _t40;                        // _t40

    _t24 = __eax;
    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t32 = _a4;
    _t39 =  &_v156;
     *__esp = _t39;
    sigemptyset();
    _v168 = _t32;
     *__esp = _t39;
    sigaddset();
    _v164 = _t39;
    _v168 = _t39;
     *__esp = 0;
    sigprocmask();
    caml_rev_convert_signal_number(_t32);
    _v168 = _t24 + _t24 + 1;
     *__esp =  *(caml_signal_handlers + _t32 * 4);
    _t28 = caml_callback_exn(__esp);
    _t35 = _t28;
    if(_a8 != 0) {
        if((_t28 & 3) != 2) {
        } else {
            _v168 = _t32;
             *__esp =  &_v156;
            sigdelset();
            _v164 = 0;
            _v168 = _t39;
             *__esp = 2;
            sigprocmask();
            goto L5;
        }
    } else {
        _v164 = 0;
        _v168 = _t39;
         *__esp = 2;
        sigprocmask();
        if((_t35 & 3) != 2) {
        } else {
L5:
             *__esp = _t35 & 252;
            caml_raise();
        }
L7:
    }
    return;
    goto L7;
}

caml_process_pending_signals(
    _unknown_ __ebx                        // r1
)
{// addr = 0x0805D02C
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t6;                         // _t6
    signed int _t7;                        // _t7

    __eax = caml_signals_are_pending;
    if(caml_signals_are_pending != 0) {
        caml_signals_are_pending = 0;
        _t7 = 0;
        __esi =  &caml_pending_signals;
        while(1) {
            __eax =  *(__esi + _t7 * 4);
            if(__eax != 0) {
                 *(__esi + _t7 * 4) = 0;
                caml_execute_signal(__eax, _t7, __edi, __esi, _t7, 0);
            }
            _t7 = _t7 + 1;
            if(_t7 == 65) {
                break;
            }
        }
    }
    return;
}

caml_install_signal_handler(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0805D07E
    char* _v44;                            // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    char* _v84;                            // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    intOrPtr _v92;                         // _cfa_ffffffa4
    char _v96;                             // _cfa_ffffffa0
    _unknown_ _v120;                       // _cfa_ffffff88
    _unknown_ __ebp;                       // r6
    _unknown_ _t35;                        // _t35
    signed int _t43;                       // _t43
    intOrPtr* _t44;                        // _t44
    _unknown_ _t48;                        // _t48
    char* _t49;                            // _t49
    intOrPtr _t50;                         // _t50
    signed int _t53;                       // _t53

    _t49 = caml_local_roots;
    _v60 = _t49;
    _v52 = 1;
    _v56 = 2;
    _v48 =  &_a4;
    _v44 =  &_a8;
    _v64 = 0;
    _v96 =  &_v60;
    caml_local_roots =  &_v96;
    _v88 = 1;
    _v92 = 1;
    _v84 =  &_v64;
    _t43 = caml_convert_signal_number(_a4 >> 1);
    _t53 = _t43;
    if(_t43 > 64) {
         *__esp = "Sys.signal: unavailable signal";
        caml_invalid_argument();
    }
    __ecx = _a8;
    _t50 = 2;
    if(__ecx - 1 <= 2) {
        _t50 =  *((intOrPtr*)(134657776 + __ecx * 4));
    }
    _t44 = caml_set_signal_action(_t43, _t50);
    if(_t44 == 1) {
        _v64 = 3;
    } else {
        if(_t44 == 2) {
            _t44 = caml_alloc_small(_t49, _t53, 1, 0);
            _v64 = _t44;
             *_t44 =  *((intOrPtr*)(caml_signal_handlers + _t53 * 4));
        } else {
            if(_t44 != 0) {
                 *__esp = 1;
                _t44 = caml_sys_error(_t44);
            } else {
                _v64 = 1;
            }
        }
    }
    if((_a8 & 1) == 0) {
        if(caml_signal_handlers == 0) {
            caml_alloc(_t53, 65, 0);
            caml_signal_handlers = _t44;
            caml_register_global_root( &caml_signal_handlers);
        }
        caml_modify(_t49, (_t53 << 2) + caml_signal_handlers,  *_a8);
    }
    caml_process_pending_signals(_t49);
    caml_local_roots = _t49;
    return _v64;
}

caml_leave_blocking_section()
{// addr = 0x0805D1CA
    _unknown_ __ebp;                       // r6

    caml_leave_blocking_section_hook();
    caml_process_pending_signals(__ebx);
    return;
}

caml_enter_blocking_section()
{// addr = 0x0805D1DD
    _unknown_ __ebp;                       // r6

    while(1) {
        caml_process_pending_signals(__ebx);
        caml_enter_blocking_section_hook();
        if(caml_signals_are_pending == 0) {
            break;
        }
        caml_leave_blocking_section_hook();
    }
    return;
}

caml_init_signals()
{// addr = 0x0805D210
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    char _v24;                             // _cfa_ffffffe8
    intOrPtr _v32;                         // _cfa_ffffffe0
    char _v160;                            // _cfa_ffffff60
    char _v164;                            // _cfa_ffffff5c
    intOrPtr _v180;                        // _cfa_ffffff4c
    intOrPtr _v184;                        // _cfa_ffffff48
    char* __ebx;                           // r1
    _unknown_ __ebp;                       // r6
    char* _t13;                            // _t13

    _v24 =  &sig_alt_stack;
    _v16 = 8192;
    _v20 = 0;
    _v164 = segv_handler;
    _v32 = 1207959552;
    __ebx =  &_v164;
     *__esp =  &_v160;
    sigemptyset();
    system_stack_top = __ebx;
    _v184 = 0;
    _t13 =  &_v24;
     *__esp = _t13;
    sigaltstack();
    if(_t13 == 0) {
        _v180 = 0;
        _v184 = __ebx;
         *__esp = 11;
        sigaction();
        return;
    }
    return;
}

caml_set_signal_action(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805D292
    intOrPtr _v20;                         // _cfa_ffffffec
    char _v148;                            // _cfa_ffffff6c
    char _v152;                            // _cfa_ffffff68
    char _v292;                            // _cfa_fffffedc
    char* _v308;                           // _cfa_fffffecc
    char* _v312;                           // _cfa_fffffec8
    _unknown_ __ebp;                       // r6
    intOrPtr _t18;                         // _t18
    intOrPtr _t21;                         // _t21

    _t18 = _a8;
    if(_t18 == 0) {
        _v152 = 0;
        _v20 = 0;
    } else {
        if(_t18 != 1) {
            _v152 = handle_signal;
            _v20 = 0;
        } else {
            _v152 = 1;
            _v20 = 0;
        }
    }
     *__esp =  &_v148;
    sigemptyset();
    _v308 =  &_v292;
    _v312 =  &_v152;
    _t21 = _a4;
     *__esp = _t21;
    sigaction();
    _t22 = -1;
    if(_t21 != 255) {
        _t22 = 2;
        if(_v292 == handle_signal) {
        } else {
            return 2;
        }
    }
    return _t22;
}

segv_handler(
    signed int _a92                        // _cfa_5c
)
{// addr = 0x0805D33F
    char _v28;                             // _cfa_ffffffe4
    intOrPtr _v36;                         // _cfa_ffffffdc
    char _v164;                            // _cfa_ffffff5c
    char _v168;                            // _cfa_ffffff58
    intOrPtr _v180;                        // _cfa_ffffff4c
    char* _v184;                           // _cfa_ffffff48
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    char* _t17;                            // _t17
    intOrPtr _t18;                         // _t18
    signed int _t21;                       // _t21

    _t21 = _a92;
    if((_t21 & 3) == 0) {
        _t17 =  &_v28;
        _v184 = _t17;
         *__esp = 3;
        getrlimit64();
        if(_t17 == 0) {
            _t18 = system_stack_top;
            if(_t21 < _t18 && _t21 >= _t18 - _v28 + -8192) {
                caml_raise_stack_overflow();
            }
        }
    }
    _v168 = 0;
    _v36 = 0;
     *__esp =  &_v164;
    sigemptyset();
    _v180 = 0;
    _v184 =  &_v168;
     *__esp = 11;
    sigaction();
    return;
}

handle_signal(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805D3C9
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4
    _unknown_ _t5;                         // _t5

    __ebx = _a4;
    if(__ebx <= 64) {
        caml_try_leave_blocking_section_hook();
        if(__eax == 0) {
            caml_record_signal(__ebx);
            return;
        }
        caml_execute_signal(__eax, __ebx, __edi, _t4, __ebx, 1);
        caml_enter_blocking_section_hook();
        return;
        goto L5;
    }
    return;
L5:
}

caml_garbage_collection()
{// addr = 0x0805D40B
    _unknown_ __ebp;                       // r6

    __eax = caml_young_start;
    caml_young_limit = __eax;
    if(__eax > caml_young_ptr) {
L2:
        caml_minor_collection(__ebx, __esi);
    } else {
        __eax = caml_force_major_slice;
        if(caml_force_major_slice == 0) {
        } else {
            goto L2;
        }
L4:
    }
    caml_process_pending_signals(__ebx);
    return;
    goto L4;
}

caml_ext_table_free(
    intOrPtr* _a4,                         // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805D438
    signed int __ebx;                      // r1
    intOrPtr* __esi;                       // r5
    _unknown_ __ebp;                       // r6

    __esi = _a4;
    if(_a8 == 0 ||  *__esi <= 0) {
L4:
        caml_stat_free( *((intOrPtr*)(__esi + 8)));
        return;
    } else {
        __ebx = 0;
        while(1) {
            caml_stat_free( *((intOrPtr*)( *((intOrPtr*)(__esi + 8)) + __ebx * 4)));
            __ebx = __ebx + 1;
            if( *__esi <= __ebx) {
                break;
            }
        }
        goto L4;
    }
}

caml_ext_table_add(
    signed int* _a4,                       // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805D47A
    signed int _v24;                       // _cfa_ffffffe8
    signed int* __ebx;                     // r1
    _unknown_ __ebp;                       // r6
    signed int _t12;                       // _t12
    signed int _t15;                       // _t15

    __ebx = _a4;
    _t12 = (__ebx)[1];
    if( *__ebx >= _t12) {
        (__ebx)[1] = _t12 + _t12;
        _v24 = _t12 << 3;
        _t15 = (__ebx)[2];
         *__esp = _t15;
        caml_stat_resize();
        (__ebx)[2] = _t15;
    }
     *((intOrPtr*)((__ebx)[2] +  *__ebx * 4)) = _a8;
     *__ebx =  *__ebx + 1;
    return;
}

caml_ext_table_init(
    intOrPtr* _a4,                         // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0805D4BA
    intOrPtr* __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t5;                        // _t5
    signed int _t6;                        // _t6

    __ebx = _a4;
    _t5 = _a8;
     *__ebx = 0;
     *(__ebx + 4) = _t5;
    _t6 = _t5 << 2;
    caml_stat_alloc(_t6);
     *(__ebx + 8) = _t6;
    return;
}

caml_aligned_malloc(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    void** _a12           // _cfa_c
)
{// addr = 0x0805D4E4
    intOrPtr __ebx;                        // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t8;                         // _t8
    void* _t12;           // _t12

    __ebx = _a8;
    _t12 = malloc(_a4 + 4096);
    if(_t12 != 0) {
         *_a12 = _t12;
        return (_t12 + __ebx & -4096) + 4096 - __ebx;
    }
    return 0;
}

caml_fatal_error_arg2(
    char* _a4,                             // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    char* _a12,                            // _cfa_c
    intOrPtr _a16                          // _cfa_10
)
{// addr = 0x0805D524
    intOrPtr _v0;                          // _cfa_0
    char* _v4;                             // _cfa_fffffffc
    intOrPtr _v20;                         // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8
    intOrPtr _v48;                         // _cfa_ffffffd0
    char* _v52;                            // _cfa_ffffffcc
    signed int _v80;                       // _cfa_ffffffb0
    intOrPtr _v104;                        // _cfa_ffffff98
    _unknown_ _v108;                       // _cfa_ffffff94
    _unknown_ __ebp;                       // r6
    _unknown_ _t25;                        // _t25
    _unknown_ _t29;                        // _t29
    _unknown_ _t30;                        // _t30
    _unknown_ _t34;                        // _t34
    _unknown_ _t35;                        // _t35
    _unknown_ _t38;                        // _t38
    _unknown_ _t39;                        // _t39
    signed int _t40;                       // _t40
    _unknown_ _t44;                        // _t44
    _unknown_ _t46;                        // _t46
    _unknown_ _t47;                        // _t47
    _unknown_ _t48;                        // _t48
    _unknown_ _t49;                        // _t49
    _unknown_ _t50;                        // _t50

    _v20 = _a8;
    fprintf(__imp__stderr, _a4);
    _v20 = _a16;
    fprintf(__imp__stderr, _a12);
    exit(2);
    _push(_t47);
    _t48 = __esp;
    __esp = __esp - 24;
    _v48 = _v20;
    fprintf(__imp__stderr, _v24);
    exit(2);
    _push(_t48);
    _t49 = __esp;
    __esp = __esp - 24;
    fputs(_v52, __imp__stderr);
    exit(2);
    _push(_t49);
    __esp = __esp - 24;
    _t40 = _v80;
    if(_t40 >= 0 || (caml_verb_gc & _t40) != 0) {
        _v104 = _v0;
        fprintf(__imp__stderr, _v4);
        fflush(__imp__stderr);
        return;
    }
    return;
}

caml_fatal_error_arg(
    char* _a4,                             // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805D56C
    char* _v0;                             // _cfa_0
    intOrPtr _v20;                         // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8
    signed int _v52;                       // _cfa_ffffffcc
    char* _v76;                            // _cfa_ffffffb4
    _unknown_ _v80;                        // _cfa_ffffffb0
    _unknown_ __ebp;                       // r6
    _unknown_ _t17;                        // _t17
    _unknown_ _t18;                        // _t18
    _unknown_ _t21;                        // _t21
    _unknown_ _t22;                        // _t22
    signed int _t23;                       // _t23
    _unknown_ _t27;                        // _t27
    _unknown_ _t29;                        // _t29
    _unknown_ _t30;                        // _t30
    _unknown_ _t31;                        // _t31
    _unknown_ _t32;                        // _t32

    _v20 = _a8;
    fprintf(__imp__stderr, _a4);
    exit(2);
    _push(_t30);
    _t31 = __esp;
    __esp = __esp - 24;
    fputs(_v24, __imp__stderr);
    exit(2);
    _push(_t31);
    __esp = __esp - 24;
    _t23 = _v52;
    if(_t23 >= 0 || (caml_verb_gc & _t23) != 0) {
        _v76 = _a4;
        fprintf(__imp__stderr, _v0);
        fflush(__imp__stderr);
        return;
    }
    return;
}

caml_fatal_error(
    char* _a4,                             // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805D599
    signed int _v24;                       // _cfa_ffffffe8
    intOrPtr _v48;                         // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ __ebp;                       // r6
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13
    signed int _t14;                       // _t14
    _unknown_ _t18;                        // _t18
    _unknown_ _t20;                        // _t20
    _unknown_ _t21;                        // _t21
    _unknown_ _t22;                        // _t22

    fputs(_a4, __imp__stderr);
    exit(2);
    _push(_t21);
    __esp = __esp - 24;
    _t14 = _v24;
    if(_t14 >= 0 || (caml_verb_gc & _t14) != 0) {
        _v48 = _a8;
        fprintf(__imp__stderr, _a4);
        fflush(__imp__stderr);
        return;
    }
    return;
}

caml_gc_message(
    signed int _a4,                        // _cfa_4
    char* _a8,                             // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x0805D5BF
    intOrPtr _v20;                         // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    signed int _t8;                        // _t8
    _unknown_ _t12;                        // _t12
    _unknown_ _t14;                        // _t14

    _t8 = _a4;
    if(_t8 >= 0 || (caml_verb_gc & _t8) != 0) {
        _v20 = _a12;
        fprintf(__imp__stderr, _a8);
        fflush(__imp__stderr);
        return;
    }
    return;
}

allocate_block(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr* __ecx,                       // r2
    intOrPtr __edx,                        // r3
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x0805D600
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    _unknown_ __ebp;                       // r6
    _unknown_ _t21;                        // _t21
    signed int _t25;                       // _t25
    _unknown_ _t27;                        // _t27
    intOrPtr* _t28;                        // _t28
    intOrPtr* _t31;                        // _t31
    _unknown_ _t38;                        // _t38
    signed int _t45;                       // _t45
    _unknown_ _t46;                        // _t46
    unsigned int* _t48;                    // _t48
    _unknown_ _t49;                        // _t49
    intOrPtr _t50;                         // _t50
    intOrPtr _t51;                         // _t51

    _t28 = __ecx;
    _t21 = __eax;
    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _v20 = __edx;
    _t31 = _a4;
    _t48 = _t31 - 4;
    _t25 =  *_t48 >> 10;
    if(_t25 >= _t21 + 1) {
        caml_fl_cur_size = caml_fl_cur_size - _t21;
         *_t48 = (_t25 - _t21 << 10) + 512;
        goto L8;
    }
    caml_fl_cur_size = caml_fl_cur_size +  !_t25;
     *_t28 =  *_t31;
    _t43 = caml_fl_merge == _t31 ? _t28 : caml_fl_merge;
    caml_fl_merge = caml_fl_merge == _t31 ? _t28 : caml_fl_merge;
     *_t48 = 0;
    if(caml_allocation_policy != 1) {
        goto L8;
    }
    _t45 = _v20 + 1;
    _t50 = flp_size;
    if(_t45 >= _t50 ||  *((intOrPtr*)(_t45 * 4 +  &flp)) != _t31) {
        _t51 = _t50 - 1;
        if(_t51 != _v20) {
            goto L8;
        }
        _t29 = _t28 == 134693128 ? 0 : _t28;
        beyond = _t28 == 134693128 ? 0 : _t28;
        flp_size = _t51;
    } else {
         *((intOrPtr*)(_t45 * 4 +  &flp)) = _t28;
    }
L10:
    return _t31 + (_t25 - _t21) * 4;
L8:
    if(caml_allocation_policy == 0) {
        fl_prev = _t28;
    }
    goto L10;
}

caml_fl_init_merge()
{// addr = 0x0805D6D2
    _unknown_ __ebp;                       // r6

    last_fragment = 0;
    caml_fl_merge = 134693128;
    return;
}

truncate_flp(
    _unknown_ __eax                        // r0
)
{// addr = 0x0805D6EB
    char* __esi;                           // r5
    _unknown_ __ebp;                       // r6
    signed int _t7;                        // _t7
    signed int _t8;                        // _t8
    signed int _t9;                        // _t9

    __eax = __eax;
    if(__eax == 134693128) {
        flp_size = 0;
        beyond = 0;
        return;
    }
    _t8 = flp_size;
    if(_t8 > 0) {
        _t9 = _t8 - 1;
        __esi =  &flp;
        if(__eax <=  *((intOrPtr*)( *((intOrPtr*)(_t9 * 4 +  &flp))))) {
            while(_t9 > 0) {
                _t7 = _t9 - 1;
                if(__eax <=  *((intOrPtr*)( *((intOrPtr*)(__esi + _t7 * 4))))) {
                    _t9 = _t7;
                    continue;
                }
                flp_size = _t9;
                goto L10;
            }
            flp_size = _t9;
        } else {
        }
    }
L10:
    if(__eax > beyond) {
    } else {
        goto L11;
    }
    goto L12;
L13:
L12:
    return;
    goto L13;
L11:
    beyond = 0;
    return;
}

caml_fl_reset()
{// addr = 0x0805D760
    _unknown_ __ebp;                       // r6

     *134693128 = 0;
    __eax = caml_allocation_policy;
    if(__eax == 0) {
        fl_prev = 134693128;
    } else {
        if(__eax != 1) {
        } else {
            __eax = 134693128;
            truncate_flp(134693128);
        }
L6:
    }
    caml_fl_cur_size = 0;
    caml_fl_init_merge();
    return;
    goto L6;
}

caml_fl_merge_block(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805D7A4
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int* _v28;                      // _cfa_ffffffe4
    signed int* _v32;                      // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t42;                       // _t42
    _unknown_ _t47;                        // _t47
    signed int _t55;                       // _t55
    signed int* _t57;                      // _t57
    signed int _t62;                       // _t62
    _unknown_ _t66;                        // _t66
    unsigned int _t70;                     // _t70
    signed int _t72;                       // _t72
    unsigned int* _t73;                    // _t73
    signed int _t79;                       // _t79
    signed int _t80;                       // _t80
    signed int _t82;                       // _t82
    signed int _t84;                       // _t84
    signed int _t87;                       // _t87

    _t80 = _a4;
    _t42 = _t80 - 4;
    _v20 = _t42;
    _t87 =  *_t42;
    caml_fl_cur_size = caml_fl_cur_size + (_t87 >> 10) + 1;
    _t57 = caml_fl_merge;
    _v28 = _t57;
    _v24 =  *_t57;
    if(caml_allocation_policy == 1) {
        truncate_flp(_t57);
    }
    _t79 = _t80 - 4;
    if(_t79 != last_fragment) {
L5:
        _t79 = _t80;
    } else {
        _t55 = ( *_v20 >> 10) + 1;
        if(_t55 > 4194303) {
            goto L5;
        }
        _t87 = _t55 << 10;
         *(_t79 - 4) = _t87;
        caml_fl_cur_size = caml_fl_cur_size + 1;
    }
    _t82 = _t87 >> 10;
    _t66 = _t79 + _t82 * 4;
    _t47 = _v24 - 4;
    if(_t47 == _t66) {
        _v20 =  *_v24;
        _t70 =  *(_v24 - 4);
        _v36 = _t70;
        _t72 = _t82 + (_t70 >> 10) + 1;
        if(_t72 <= 4194303) {
             *_v28 = _v20;
            if(caml_allocation_policy == 0) {
                _t52 = fl_prev == _v24 ? _t57 : fl_prev;
                fl_prev = fl_prev == _v24 ? _t57 : fl_prev;
            }
            _t87 = (_t72 << 10) + 512;
             *(_t79 - 4) = _t87;
            _t47 = _t79 + (_t87 >> 10) * 4;
            _v24 = _v20;
        }
    } else {
        _t47 = _t66;
    }
    _t73 = _t57 - 4;
    _t84 =  *_t73 >> 10;
    _v20 = _t84;
    _v32 =  &(_t57[_t84]);
    if(_v32 != _t79 - 4) {
L15:
        if(_t87 >> 10 == 0) {
            last_fragment = _t79;
            caml_fl_cur_size = caml_fl_cur_size - 1;
            return _t47;
        }
    } else {
        _t62 = _t84 + (_t87 >> 10) + 1;
        if(_t62 > 4194302) {
            goto L15;
        }
         *_t73 = (_t62 << 10) + 512;
        return _t47;
    }
     *(_t79 - 4) = _t87 & -769 | 512;
     *_t79 = _v24;
     *_v28 = _t79;
    caml_fl_merge = _t79;
    return _t47;
}

caml_fl_add_blocks(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805D909
    signed int* __ebx;                     // r1
    _unknown_ __ebp;                       // r6
    signed int _t9;                        // _t9
    signed int* _t12;                      // _t12
    signed int* _t16;                      // _t16
    signed int* _t17;                      // _t17
    signed int _t19;                       // _t19

    _t9 = _a4;
    caml_fl_cur_size = caml_fl_cur_size + ( *(_t9 - 4) >> 10) + 1;
    _t16 = fl_last;
    if(_t9 <= _t16) {
        _t12 =  *134693128;
        if(_t12 == 0 || _t9 <= _t12) {
            __ebx = 134693128;
            goto L14;
        } else {
            while(1) {
L11:
                _t19 =  *_t12;
                if(_t19 == 0 || _t9 <= _t19) {
                    break;
                }
                goto L10;
            }
            __ebx = _t12;
            _t12 = _t19;
L14:
            _t17 = _t9 + 4;
             *( *_t17) = _t12;
             *__ebx = _t9;
            if(__ebx == caml_fl_merge && _t9 < caml_gc_sweep_hp) {
                caml_fl_merge =  *_t17;
            }
            if(caml_allocation_policy != 1) {
                goto L19;
            } else {
                truncate_flp(_t9);
                return;
            }
            goto L20;
        }
L10:
        _t12 = _t19;
        goto L11;
    }
     *_t16 = _t9;
    if(_t16 == caml_fl_merge) {
        if(_t9 < caml_gc_sweep_hp) {
            caml_fl_merge = _t9;
        }
    }
    if(caml_allocation_policy != 1) {
L19:
        return;
L20:
    }
    _t9 = flp_size;
    if(_t9 > 999) {
        goto L19;
    }
     *(_t9 * 4 +  &flp) = _t16;
    flp_size = _t9 + 1;
    return;
    goto L20;
}

caml_make_free_blocks(
    signed int* _a4,                       // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x0805D9C9
    _unknown_ __ebx;                       // r1
    intOrPtr __edi;                        // r4
    signed int* __esi;                     // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t12;                        // _t12
    signed int _t13;                       // _t13
    intOrPtr _t16;                         // _t16

    __esi = _a4;
    __edi = _a8;
    if(__edi != 0) {
        while(1) {
            _t13 = __edi - 4194304 <= 0 ? __edi : 4194304;
            _t9 = _t13 - 1 << 10;
             *__esi = _t13 - 1 << 10;
            _t16 = _a12;
            if(_t16 != 0) {
                caml_fl_merge_block( &((__esi)[1]));
            }
            __edi = __edi - _t13;
            if(_t16 == 0) {
                break;
            }
            __esi =  &((__esi)[_t13]);
        }
    }
    return;
}

caml_set_allocation_policy(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805DA14
    _unknown_ __ebp;                       // r6

    __eax = _a4;
    if(__eax == 0) {
        fl_prev = 134693128;
    } else {
        if(__eax != 1) {
        } else {
            flp_size = 0;
            beyond = 0;
        }
L6:
    }
    caml_allocation_policy = __eax;
    return;
    goto L6;
}

caml_fl_allocate(
    _unknown_ __eax,                       // r0
    _unknown_ __edx,                       // r3
    _unknown_ __esi,                       // r5
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805DA4C
    void _v4028;                           // _cfa_fffff044
    unsigned int _v4032;                   // _cfa_fffff040
    signed int _v4036;                     // _cfa_fffff03c
    signed int _v4040;                     // _cfa_fffff038
    signed int _v4044;                     // _cfa_fffff034
    _unknown_ _v4052;                      // _cfa_fffff02c
    _unknown_ _v4056;                      // _cfa_fffff028
    _unknown_ __ebp;                       // r6
    _unknown_ _t91;                        // _t91
    intOrPtr _t92;                         // _t92
    signed int _t102;                      // _t102
    signed int _t103;                      // _t103
    intOrPtr* _t104;                       // _t104
    _unknown_ _t111;                       // _t111
    _unknown_ _t116;                       // _t116
    _unknown_ _t121;                       // _t121
    _unknown_ _t123;                       // _t123
    _unknown_ _t128;                       // _t128
    _unknown_ _t137;                       // _t137
    signed int _t139;                      // _t139
    _unknown_ _t140;                       // _t140
    signed int _t149;                      // _t149
    signed int _t150;                      // _t150
    signed int _t151;                      // _t151
    signed int _t152;                      // _t152
    unsigned int _t154;                    // _t154
    signed int _t155;                      // _t155
    signed int _t156;                      // _t156
    signed int _t157;                      // _t157
    intOrPtr _t160;                        // _t160
    signed int _t161;                      // _t161
    signed int _t162;                      // _t162
    unsigned int _t163;                    // _t163
    unsigned int _t165;                    // _t165
    _unknown_ _t169;                       // _t169
    intOrPtr _t170;                        // _t170
    signed int _t171;                      // _t171
    signed int _t172;                      // _t172
    _unknown_ _t173;                       // _t173
    _unknown_ _t174;                       // _t174
    signed int _t175;                      // _t175
    signed int _t178;                      // _t178
    signed int _t181;                      // _t181
    char* _t184;                           // _t184
    intOrPtr _t186;                        // _t186
    _unknown_ _t189;                       // _t189
    _unknown_ _t202;                       // _t202
    signed int _t203;                      // _t203
    unsigned int _t205;                    // _t205
    intOrPtr _t207;                        // _t207
    char* _t208;                           // _t208
    _unknown_ _t209;                       // _t209
    signed int _t210;                      // _t210
    unsigned int _t212;                    // _t212
    unsigned int _t214;                    // _t214
    unsigned int _t215;                    // _t215

    _t209 = __esi;
    _t92 = _a4;
    _t170 = caml_allocation_policy;
    if(_t170 == 0) {
        _t157 = fl_prev;
        _t171 =  *_t157;
        if(_t171 == 0) {
L11:
            fl_last = _t157;
            _t158 = 134693128;
            _t172 =  *_t158;
            _t210 = fl_prev;
            if(_t158 == _t210) {
                goto L69;
            }
            goto L12;
        }
        goto L6;
L12:
        _t144 =  *(_t172 - 4) >> 10;
        if(_t92 >  *(_t172 - 4) >> 10) {
            while(1) {
                _t158 = _t172;
                _t172 =  *_t172;
                if(_t210 == _t172) {
                    break;
                }
                _t144 =  *(_t172 - 4) >> 10;
                if(_t92 >  *(_t172 - 4) >> 10) {
                    continue;
                }
L15:
                _t203 = allocate_block(_t92 + 1, _t144, _t158, 0, _t202, _t210, _t172);
                goto L70;
            }
            goto L69;
        }
        goto L15;
    }
    if(_t170 != 1) {
L69:
        _t203 = 0;
        goto L70;
    }
    _t175 = flp_size;
    _v4032 = _t175;
    if(_t175 <= 0) {
L21:
        if(_v4032 != 0) {
            _t160 =  *((intOrPtr*)( *((intOrPtr*)(134702428 + _v4032 * 4))));
            _t205 =  *(_t160 - 4) >> 10;
            _t161 = beyond != 0 ? beyond : _t160;
        } else {
            _t161 = 134693128;
            _t205 = 0;
        }
        _t178 = 0;
        while(1) {
            _t149 = flp_size;
            if(_t149 > 999) {
                break;
            }
            _t178 =  *_t161;
            if(_t178 != 0) {
                _t212 =  *(_t178 - 4) >> 10;
                if(_t205 >= _t212) {
L31:
                    _t161 = _t178;
                    continue;
                }
                goto L28;
            }
            fl_last = _t161;
            _t167 = _t161 == 134693128 ? 0 : _t161;
            beyond = _t161 == 134693128 ? 0 : _t161;
            _t203 = 0;
            goto L70;
L28:
             *(_t149 * 4 +  &flp) = _t161;
            _t150 = flp_size;
            _t206 = _t150 + 1;
            flp_size = _t150 + 1;
            if(_t92 > _t212) {
                _t205 = _t212;
                goto L31;
            }
            beyond = _t178;
            _t203 = allocate_block(_t92 + 1, _t150, _t161, _t150, _t206, _t212, _t178);
            goto L44;
        }
        beyond = _t178;
        _t162 = _t178;
        if(_t178 == 0) {
            _t162 =  *(134702428 + _t149 * 4);
        }
        _t214 =  *( *( *134706428) - 4) >> 10;
        _t181 =  *_t162;
        if(_t181 == 0) {
L43:
            fl_last = _t162;
            _t203 = 0;
        } else {
            while(1) {
                _t154 =  *(_t181 - 4) >> 10;
                if(_t214 <= _t154) {
                    break;
                }
                beyond = _t181;
L40:
                _t155 =  *_t181;
                if(_t155 == 0) {
                    _t162 = _t181;
                    goto L43;
                }
L41:
                _t162 = _t181;
                _t181 = _t155;
            }
            if(_t92 > _t154) {
                goto L40;
            }
            _t203 = allocate_block(_t92 + 1, _t154, _t162, flp_size, _t205, _t214, _t181);
        }
        goto L70;
    }
    _t168 = flp;
    _t200 =  *flp;
    _t156 = 0;
    _t208 =  &flp;
    if(_t92 >  *( *flp - 4) >> 10) {
        while(1) {
            _t156 = _t156 + 1;
            if(_t156 >= _v4032) {
                break;
            }
            _t168 =  *((intOrPtr*)(_t208 + _t156 * 4));
            _t200 =  *((intOrPtr*)( *((intOrPtr*)(_t208 + _t156 * 4))));
            _t212 =  *( *((intOrPtr*)( *((intOrPtr*)(_t208 + _t156 * 4)))) - 4) >> 10;
            if(_t92 > _t212) {
                continue;
            }
            goto L19;
        }
    } else {
L19:
        _t203 = allocate_block(_t92 + 1, _t156, _t168, _t156, _t208, _t212, _t200);
L44:
        _t102 = flp_size;
        if(_t150 >= _t102) {
            goto L70;
        }
        _t163 = 0;
        if(_t150 > 0) {
            _t163 =  *( *((intOrPtr*)( *((intOrPtr*)(134702428 + _t150 * 4)))) - 4) >> 10;
        }
        _t103 = _t102 - 1;
        if(_t103 != _t150) {
            _t184 =  &flp;
            _t104 =  *((intOrPtr*)(_t184 + _t150 * 4));
            _v4036 = 0;
            _v4032 = _t212;
            _t215 = _t163;
            _v4040 = _t150;
            _t151 = 0;
            _v4044 = _t203;
            _t207 =  *((intOrPtr*)(_t184 + 4 + _t150 * 4));
L56:
            while(_t207 != _t104) {
                goto L52;
            }
L57:
            _v4036 = _t151;
            _t152 = _v4040;
            _t203 = _v4044;
            _t106 = flp_size - 1;
            if(flp_size - 1 + _v4036 > 1000) {
L62:
                _t108 = _v4036 + _t152;
                if(_v4036 + _t152 > 999) {
L66:
                    if(_t152 != 1000) {
                        memmove(_t152 * 4 +  &flp,  &_v4028, 1000 - _t152 << 2);
                    }
L68:
                    flp_size = 999;
                    beyond =  *( *134706428);
                    goto L70;
                }
                goto L63;
            }
            if(_v4036 == 1) {
L60:
                memmove(_t152 * 4 +  &flp,  &_v4028, _v4036 << 2);
                goto L61;
            }
            memmove((_v4036 + _t152) * 4 +  &flp, 134702436 + _t152 * 4, _t106 - _t152 << 2);
            if(_v4036 <= 0) {
                goto L61;
            }
            goto L60;
L61:
            flp_size = _v4036 + flp_size - 1;
            goto L70;
L63:
            if(_v4036 == 1) {
L65:
                memmove(_t152 * 4 +  &flp,  &_v4028, _v4036 << 2);
                goto L68;
            }
            memmove(_t108 * 4 +  &flp, 134702436 + _t152 * 4, 1000 - _t152 - _v4036 << 2);
            if(_v4036 <= 0) {
                goto L68;
            }
            goto L65;
        } else {
            _t139 =  *( *(_t103 * 4 +  &flp));
            if(_t163 <  *(_t139 - 4) >> 10) {
                beyond = 0;
            } else {
                beyond = _t139;
                flp_size = flp_size - 1;
            }
            goto L70;
        }
L52:
        _t186 =  *_t104;
        _t165 =  *(_t186 - 4) >> 10;
        if(_t215 >= _t165) {
L55:
            _t104 = _t186;
            goto L56;
        }
         *((intOrPtr*)(__ebp + -4024 + _t151 * 4)) = _t104;
        _t151 = _t151 + 1;
        if(_v4032 <= _t165) {
            goto L57;
        }
        _t215 = _t165;
        goto L55;
    }
    goto L21;
L70:
    return _t203;
L6:
    _t147 =  *(_t171 - 4) >> 10;
    if(_t92 >  *(_t171 - 4) >> 10) {
        while(1) {
            _t157 = _t171;
            _t171 =  *_t171;
            if(_t171 == 0) {
                break;
            }
            _t147 =  *(_t171 - 4) >> 10;
            if( *(_t171 - 4) >> 10 < _t92) {
                continue;
            }
            goto L9;
        }
        goto L11;
    }
L9:
    _t203 = allocate_block(_t92 + 1, _t147, _t157, 0, _t202, _t209, _t171);
    goto L70;
}

clip_heap_chunk_size(
    _unknown_ __eax                        // r0
)
{// addr = 0x0805DED0
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    _t2 = __eax;
    _t3 = _t2 - 8191 <= 0 ? 8192 : _t2;
    _t4 = (_t2 - 8191 <= 0 ? 8192 : _t2) + 4095;
    _t5 = (_t2 - 8191 <= 0 ? 8192 : _t2) + 4095 & -4096;
    return (_t2 - 8191 <= 0 ? 8192 : _t2) + 4095 & -4096;
}

caml_init_major_heap(
    _unknown_ __eax,                       // r0
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805DEEC
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t9;                         // _t9
    unsigned int _t11;                     // _t11
    void* _t17;           // _t17

    _t11 = clip_heap_chunk_size(_a4);
    caml_stat_heap_size = _t11;
    caml_stat_top_heap_size = _t11;
    caml_alloc_for_heap(_t11, _t11);
    caml_heap_start = _t11;
    if(_t11 == 0) {
        caml_fatal_error("Fatal error: not enough memory for the initial heap.\n");
    }
     *((intOrPtr*)(_t11 - 4)) = 0;
    caml_stat_heap_chunks = 1;
    if(caml_page_table_add(caml_heap_start, 1, caml_heap_start, _t12 + caml_stat_heap_size) != 0) {
        caml_fatal_error("Fatal error: not enough memory for the initial page table.\n");
    }
    caml_fl_init_merge();
    caml_make_free_blocks(caml_heap_start, caml_stat_heap_size >> 2, 1);
    caml_gc_phase = 2;
    gray_vals_size = 2048;
    _t17 = malloc(8192);
    gray_vals = _t17;
    if(_t17 == 0) {
        caml_fatal_error("Fatal error: not enough memory for the gray cache.\n");
    }
    gray_vals_cur = _t17;
    gray_vals_end =  &(_t17[gray_vals_size]);
    heap_is_pure = 1;
    caml_allocated_words = 0;
    asm("fldz ");
    asm("fstp qword [0x807b100]");
    return;
}

caml_round_heap_chunk_size(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805DFEF
    intOrPtr __ebx;                        // r1
    _unknown_ __ebp;                       // r6

    __ebx = _a4;
    _t4 = __ebx - caml_major_heap_increment >= 0 ? __ebx : caml_major_heap_increment;
    if(__ebx > clip_heap_chunk_size(__ebx - caml_major_heap_increment >= 0 ? __ebx : caml_major_heap_increment)) {
        caml_raise_out_of_memory();
        return;
    }
    return;
}

start_cycle()
{// addr = 0x0805E017
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    caml_gc_message(1, "Starting new major GC cycle\n", 0);
    caml_darken_all_roots();
    caml_gc_phase = 0;
    caml_gc_subphase = 10;
    markhp = 0;
    return;
}

realloc_gray_vals()
{// addr = 0x0805E05E
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    unsigned int _t13;                     // _t13
    void* _t19;           // _t19
    signed int _t25;                       // _t25
    signed int _t31;                       // _t31

    _t25 = gray_vals_size;
    _t13 = caml_stat_heap_size;
    _t14 = _t13 >= 0 ? _t13 + 127 : _t13;
    _t15 = (_t13 >= 0 ? _t13 + 127 : _t13) >> 7;
    _t33 = (_t13 >= 0 ? _t13 + 127 : _t13) >> 7 - _t25;
    if((_t13 >= 0 ? _t13 + 127 : _t13) >> 7 <= _t25) {
L4:
        gray_vals_cur =  &(gray_vals[_t25 >> 1]);
        heap_is_pure = 0;
        return;
    }
    caml_gc_message(8, "Growing gray_vals to %luk bytes\n", _t25 << 2 >> 9);
    _t19 = realloc(gray_vals, gray_vals_size << 3);
    if(_t19 != 0) {
        gray_vals = _t19;
        _t31 = gray_vals_size;
        gray_vals_cur =  &(_t19[_t31]);
        gray_vals_size = _t31 + _t31;
        gray_vals_end = _t19 + _t31 * 8;
        return;
    }
    caml_gc_message(8, "No room for growing gray_vals\n", 0);
    gray_vals_cur = gray_vals;
    heap_is_pure = 0;
    return;
    goto L4;
    return;
}

mark_slice(
    intOrPtr __eax                         // r0
)
{// addr = 0x0805E133
    signed int _v32;                       // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    unsigned int _v48;                     // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t162;                      // _t162
    signed int _t164;                      // _t164
    unsigned int _t166;                    // _t166
    unsigned int _t169;                    // _t169
    unsigned int _t171;                    // _t171
    signed int _t173;                      // _t173
    signed int _t175;                      // _t175
    signed int _t177;                      // _t177
    signed int _t178;                      // _t178
    signed int _t181;                      // _t181
    signed int _t184;                      // _t184
    signed int _t192;                      // _t192
    signed int _t198;                      // _t198
    unsigned int _t200;                    // _t200
    signed int _t204;                      // _t204
    signed int* _t205;                     // _t205
    unsigned int _t207;                    // _t207
    signed int _t210;                      // _t210
    signed int _t214;                      // _t214
    unsigned int _t218;                    // _t218
    signed int _t219;                      // _t219
    signed int _t223;                      // _t223
    signed int _t224;                      // _t224
    signed int _t225;                      // _t225
    _unknown_ _t227;                       // _t227
    signed int _t228;                      // _t228
    signed int _t230;                      // _t230
    signed int _t233;                      // _t233
    unsigned int _t235;                    // _t235
    unsigned int _t236;                    // _t236

    _t160 = __eax;
    _v40 = __eax;
    caml_gc_message(64, "Marking %ld words\n", _t160);
    _t161 = caml_gc_subphase;
    caml_gc_message(64, "Subphase = %ld\n", caml_gc_subphase);
    _t230 = gray_vals_cur;
    if(_v40 <= 0) {
L74:
        gray_vals_cur = _t230;
        return;
    } else {
        goto L1;
    }
    do {
L1:
        if(gray_vals >= _t230) {
L22:
            _t162 = markhp;
            if(_t162 == 0) {
                if(heap_is_pure != 0) {
                    _t161 = caml_gc_subphase;
                    if(_t161 == 11) {
                        _t161 =  *weak_prev;
                        _v56 = _t161;
                        if(_t161 == 0) {
L65:
                            caml_gc_subphase = 12;
                            weak_prev =  &caml_weak_list_head;
                            goto L73;
                        }
                        goto L41;
                    }
                    goto L33;
L41:
                    _v44 = _t161;
                    _t169 =  *(_t161 - 4) >> 10;
                    _v52 = _t169;
                    if(_t169 <= 1) {
L64:
                        weak_prev = _v56;
                        _t161 =  !_v52;
                        _v40 = _v40 +  !_v52;
                        goto L73;
                    }
                    _v36 = 1;
                    _v60 = _t230;
                    goto L43;
                    do {
L43:
                        _t171 =  *((intOrPtr*)(_v44 + _v36 * 4));
                        _t228 = caml_weak_none;
                        if(_t171 == _t228 || (_t171 & 1) != 0 || ( *( *((intOrPtr*)((_t171 >> 23) * 4 +  &caml_page_table)) + (_t171 >> 12 & 2047)) & 1) == 0) {
                            goto L62;
                        } else {
                            _t218 = _t171 - 4;
                            if( *_t218 != 250) {
L60:
                                if(( *_t218 & 768) == 0) {
L61:
                                     *((intOrPtr*)(_v44 + _v36 * 4)) = _t228;
                                }
                                goto L62;
                            }
                            _t173 =  *_t171;
                            if((_t173 & 1) == 0) {
                                while(1) {
                                    _v48 = _t218;
                                    _t219 = _t173;
                                    _t233 = _t173 >> 23;
                                    _t184 = _t173 >> 12 & 2047;
                                    if(( *( *((intOrPtr*)(_t233 * 4 +  &caml_page_table)) + _t184) & 7) == 0) {
                                        break;
                                    }
                                    _t218 = _t219 - 4;
                                    _v32 = _t218;
                                    _t192 =  *_t218 & 255;
                                    if((_t192 & 255) == 250 || (_t192 & 255) == 246 || (_t192 & 255) == 253) {
                                        break;
                                    } else {
                                         *(_v44 + _v36 * 4) = _t173;
                                        _t228 = caml_weak_none;
                                        if(_t173 != _t228) {
                                            if((_t173 & 1) != 0 || ( *( *((intOrPtr*)(_t233 * 4 +  &caml_page_table)) + _t184) & 1) == 0) {
                                                goto L62;
                                            } else {
                                                if( *_v32 != 250) {
                                                    goto L60;
                                                }
                                                _t173 =  *_t173;
                                                if((_t173 & 1) != 0) {
                                                    goto L60;
                                                }
                                                continue;
                                            }
                                            goto L63;
                                        }
                                        goto L62;
                                    }
                                    goto L60;
                                }
                                _t218 = _v48;
                                goto L60;
                            }
                            goto L60;
                        }
                        break;
L62:
                        _v36 = _v36 + 1;
                    } while(_v36 != _v52);
L63:
                    _t230 = _v60;
                    goto L64;
                }
                heap_is_pure = 1;
                _t177 = caml_heap_start;
                chunk = _t177;
                markhp = _t177;
                _t161 = _t177 +  *((intOrPtr*)(_t177 - 8));
                limit = _t177 +  *((intOrPtr*)(_t177 - 8));
                goto L73;
L33:
                if(_t161 > 11) {
                    asm("o16 nop ");
                    if(_t161 == 12) {
                        _t210 = weak_prev;
                        _t161 =  *_t210;
                        if(_t161 == 0) {
                            gray_vals_cur = _t230;
                            caml_final_update();
                            _t230 = gray_vals_cur;
                            caml_gc_subphase = 13;
                        } else {
                            if(( *(_t161 - 4) & 768) != 0) {
                                weak_prev = _t161;
                            } else {
                                 *_t210 = _t161;
                            }
                            _v40 = _v40 - 1;
                        }
                        goto L73;
                    }
                    goto L37;
                }
                if(_t161 == 10) {
                    caml_gc_subphase = 11;
                    weak_prev =  &caml_weak_list_head;
                }
                goto L73;
L37:
                if(_t161 != 13) {
                    goto L73;
                }
                gray_vals_cur = _t230;
                caml_gc_sweep_hp = caml_heap_start;
                caml_fl_init_merge();
                caml_gc_phase = 1;
                _t175 = caml_heap_start;
                chunk = _t175;
                caml_gc_sweep_hp = _t175;
                limit = _t175 +  *((intOrPtr*)(_t175 - 8));
                _t161 = caml_fl_cur_size;
                caml_fl_size_at_phase_change = caml_fl_cur_size;
                goto L74;
            } else {
                if(_t162 != limit) {
                    if(( *_t162 & 768) == 256) {
                         *_t230 = _t162 + 4;
                        _t230 = _t230 + 4;
                    }
                    _t178 = markhp;
                    _t214 =  *_t178 >> 10;
                    _t161 = _t178 + 4 + _t214 * 4;
                    markhp = _t178 + 4 + _t214 * 4;
                } else {
                    _t161 =  *(chunk - 4);
                    chunk = _t161;
                    if(_t161 != 0) {
                        markhp = _t161;
                        limit = _t161;
                    } else {
                        markhp = 0;
                    }
                }
            }
            goto L73;
        }
        _t230 = _t230 - 4;
        _t227 =  *_t230;
        _t205 = _t227 - 4;
        _t164 =  *_t205;
         *_t205 = _t164;
        _t207 = _t164 >> 10;
        _v32 = _t207;
        if((_t164 & 255) > 250) {
L21:
            _t161 =  !_v32;
            _v40 = _v40 +  !_v32;
            goto L73;
        }
        if(_t207 == 0) {
        } else {
            _t181 = 0;
            _v56 = _t230;
            goto L5;
            do {
                _t181 = _t181 + 1;
                if(_v32 > _t181) {
L5:
                    _t166 =  *(_t227 + _t181 * 4);
                    if((_t166 & 1) != 0) {
                        continue;
                    }
                    _t235 = _t166;
                    if(( *( *((intOrPtr*)((_t166 >> 23) * 4 +  &caml_page_table)) + (_t166 >> 12 & 2047)) & 1) == 0) {
                        continue;
                    }
                    _t223 =  *(_t166 - 4);
                    _t198 = _t223 & 0xff;
                    if(_t198 != 250) {
                        if(_t198 == 249) {
                            _t236 = _t235 - 0 + (_t223 >> 10) * 4;
                            _t166 = _t236;
                            _t223 =  *(_t236 - 4);
                        }
L16:
                        if((_t223 & 3) == 0) {
L17:
                             *(_t166 - 4) = _t223;
                            _t224 = _v56;
                             *_t224 = _t166;
                            _t225 = _t224 + 4;
                            _v56 = _t225;
                            if(_t225 >= gray_vals_end) {
                                gray_vals_cur = _t225;
                                realloc_gray_vals();
                                _v56 = gray_vals_cur;
                            }
                        }
                        continue;
                    }
                    _t200 =  *_t166;
                    _v36 = _t200;
                    if((_t200 & 1) != 0) {
L13:
                         *(_t227 + _t181 * 4) = _v36;
                        goto L16;
                    }
                    _v48 = _t200;
                    if(( *( *((intOrPtr*)((_t200 >> 23) * 4 +  &caml_page_table)) + (_t200 >> 12 & 2047)) & 7) == 0) {
                        goto L16;
                    }
                    _t204 =  *(_v48 - 4) & 255;
                    if((_t204 & 255) == 250 || (_t204 & 255) == 246 || (_t204 & 255) == 253) {
                        goto L16;
                    } else {
                        goto L13;
                    }
                    goto L17;
                } else {
                    _t230 = _v56;
                }
                goto L21;
            } while();
        }
        goto L21;
L73:
    } while(_v40 > 0);
    goto L74;
}

caml_darken(
    unsigned int _a4                       // _cfa_4
)
{// addr = 0x0805E580
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    unsigned int _t38;                     // _t38
    unsigned int _t40;                     // _t40
    unsigned int _t41;                     // _t41
    signed int _t45;                       // _t45
    signed int _t49;                       // _t49
    unsigned int _t50;                     // _t50

    _t38 = _a4;
    if((_t38 & 1) == 0) {
        _t40 = _t38;
        if(( *( *((intOrPtr*)((_t38 >> 23) * 4 +  &caml_page_table)) + (_t38 >> 12 & 2047)) & 1) == 0) {
        } else {
            _t49 =  *(_t38 - 4);
            _t45 = _t49 & 0xff;
            if(_t45 == 249) {
                _t41 = _t40 - 0 + (_t49 >> 10) * 4;
                _t38 = _t41;
                _t49 =  *(_t41 - 4);
                _t45 = _t49 & 0xff;
            }
            if((_t49 & 3) != 0) {
            } else {
                if(_t45 > 250) {
                     *(_t38 - 4) = _t49;
                    return;
                }
                 *(_t38 - 4) = _t49;
                _t50 = gray_vals_cur;
                 *_t50 = _t38;
                _t38 = _t50 + 4;
                gray_vals_cur = _t38;
                if(_t38 < gray_vals_end) {
                } else {
                    realloc_gray_vals();
                    return;
                }
            }
        }
    }
    return;
}

sweep_slice(
    signed int __eax                       // r0
)
{// addr = 0x0805E610
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    signed int __esi;                      // r5
    _unknown_ __ebp;                       // r6
    signed int _t18;                       // _t18
    signed int* _t20;                      // _t20
    signed int* _t23;                      // _t23
    signed int _t26;                       // _t26
    signed int _t29;                       // _t29
    _unknown_ _t33;                        // _t33

    _t16 = __eax;
    __esi = __eax;
    caml_gc_message(64, "Sweeping %ld words\n", _t18 +  *((intOrPtr*)(_t18 - 8)));
    if(__esi <= 0) {
L15:
        return;
    } else {
        goto L1;
    }
    do {
L1:
        _t20 = caml_gc_sweep_hp;
        _t33 = _t20 - limit;
        if(_t33 >= 0) {
            _t18 =  *(chunk - 4);
            chunk = _t18;
            if(_t18 != 0) {
                caml_gc_sweep_hp = _t18;
                _t16 = _t18 +  *((intOrPtr*)(_t18 - 8));
                limit = _t18 +  *((intOrPtr*)(_t18 - 8));
                goto L14;
            }
            caml_stat_major_collections = caml_stat_major_collections + 1;
            caml_gc_phase = 2;
            return;
        } else {
            _t23 = _t20;
            _t16 =  *_t20;
            _t26 = _t16 >> 10;
            __esi = __esi +  !_t26;
            caml_gc_sweep_hp = _t20 + 4 + _t26 * 4;
            _t29 = _t16 & 768;
            if(_t33 == 0) {
                if((_t16 & 255) == 255) {
                    _t16 =  *(_t20[1] + 4);
                    if(_t16 != 0) {
                         *__esp =  &(_t23[1]);
                         *_t16();
                    }
                }
                caml_fl_merge_block( &(_t20[1]));
                caml_gc_sweep_hp = _t16;
            } else {
                if(_t29 != 512) {
                     *_t20 = _t16;
                } else {
                    caml_fl_merge =  &(_t20[1]);
                }
            }
        }
L14:
    } while(__esi > 0);
    goto L15;
}

caml_finish_major_cycle()
{// addr = 0x0805E6F1
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4
    _unknown_ _t5;                         // _t5

    if(caml_gc_phase == 2) {
        start_cycle();
    }
    if(caml_gc_phase == 0) {
        while(1) {
            mark_slice(2147483647);
            if(caml_gc_phase != 0) {
                break;
            }
        }
    }
    if(caml_gc_phase != 1) {
    } else {
        while(1) {
            sweep_slice(2147483647);
            if(caml_gc_phase != 1) {
                break;
            }
        }
    }
    goto L6;
L7:
L6:
    _v20 = caml_allocated_words;
    _v16 = 0;
    asm("fild qword [ebp-0x10]");
    asm("fadd qword [0x807aa50]");
    asm("fstp qword [0x807aa50]");
    caml_allocated_words = 0;
    return;
    goto L7;
}

caml_major_collection_slice(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805E768
    unsigned int _v32;                     // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    signed int _v38;                       // _cfa_ffffffda
    signed int _v40;                       // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    intOrPtr _t83;                         // _t83
    signed int _t84;                       // _t84
    _unknown_ _t85;                        // _t85
    _unknown_ _t86;                        // _t86
    _unknown_ _t87;                        // _t87
    _unknown_ _t88;                        // _t88
    unsigned int _t89;                     // _t89
    unsigned int _t92;                     // _t92
    _unknown_ _t93;                        // _t93
    _unknown_ _t94;                        // _t94
    _unknown_ _t95;                        // _t95
    _unknown_ _t96;                        // _t96
    _unknown_ _t97;                        // _t97
    _unknown_ _t98;                        // _t98
    intOrPtr _t101;                        // _t101

    _t83 = _a4;
    if(caml_gc_phase == 2) {
        start_cycle();
    }
    _t66 = caml_allocated_words;
    _t89 = caml_percent_free;
    _v36 = _t89 + 100;
    _v32 = 0;
    asm("fild qword [ebp-0x20]");
    _v36 = _t89;
    _v32 = 0;
    asm("fild qword [ebp-0x20]");
    _v36 = caml_allocated_words;
    _v32 = 0;
    asm("fild qword [ebp-0x20]");
    asm("fmul dword [0x806b8cc]");
    asm("fmul st0, st2");
    _v36 = caml_stat_heap_size >> 2;
    _v32 = 0;
    asm("fild qword [ebp-0x20]");
    asm("fdivp st1, st0");
    asm("fdiv st0, st1");
    asm("fmul dword [0x806b8d0]");
    asm("fstp qword [ebp-0x30]");
    _t92 = caml_dependent_size;
    if(_t92 != 0) {
        _v36 = caml_dependent_allocated;
        _v32 = 0;
        asm("fild qword [ebp-0x20]");
        asm("fmulp st2, st0");
        _v36 = _t92;
        _v32 = 0;
        asm("fild qword [ebp-0x20]");
        asm("fdivp st2, st0");
        asm("fdivp st1, st0");
    } else {
        asm("fstp st0");
        asm("fstp st0");
        asm("fldz ");
    }
    asm("fld qword [ebp-0x30]");
    asm("fxch st0, st1");
    asm("fucomi st0, st1");
    asm("fcmovbe st0, st1");
    asm("fstp st1");
    asm("fld qword [0x807b100]");
    asm("fucomi st0, st1");
    asm("fcmovbe st0, st1");
    asm("fstp st1");
    asm("fstp qword [ebp-0x30]");
    caml_gc_message(64, "allocated_words = %lu\n", _t66);
    asm("fld qword [0x806b4f0]");
    asm("fmul qword [0x807b100]");
    asm("fnstcw word [ebp-0x22]");
    _v40 = _v38 & 0xffff;
    asm("fldcw word [ebp-0x24]");
    asm("fistp qword [ebp-0x20]");
    asm("fldcw word [ebp-0x22]");
    caml_gc_message(64, "extra_heap_resources = %luu\n", _v36);
    asm("fld qword [0x806b4f0]");
    asm("fmul qword [ebp-0x30]");
    asm("fnstcw word [ebp-0x22]");
    _v40 = _v38 & 0xffff;
    asm("fldcw word [ebp-0x24]");
    asm("fistp qword [ebp-0x20]");
    asm("fldcw word [ebp-0x22]");
    caml_gc_message(64, "amount of work to do = %luu\n", _v36);
    if(caml_gc_phase != 0) {
        _v36 = caml_stat_heap_size >> 2;
        _v32 = 0;
        asm("fild qword [ebp-0x20]");
        asm("fmul qword [ebp-0x30]");
        asm("fmul dword [0x806b8d8]");
        asm("fdiv dword [0x806b8cc]");
        asm("fnstcw word [ebp-0x22]");
        _v40 = _v38 & 0xffff;
        asm("fldcw word [ebp-0x24]");
        asm("fistp dword [ebp-0x28]");
        asm("fldcw word [ebp-0x22]");
        _t101 = _v44;
    } else {
        _v36 = caml_stat_heap_size >> 2;
        _v32 = 0;
        asm("fild qword [ebp-0x20]");
        asm("fmul qword [ebp-0x30]");
        asm("fmul dword [0x806b8d4]");
        _v36 = caml_percent_free + 100;
        _v32 = 0;
        asm("fild qword [ebp-0x20]");
        asm("fdivp st1, st0");
        asm("fnstcw word [ebp-0x22]");
        _v40 = _v38 & 0xffff;
        asm("fldcw word [ebp-0x24]");
        asm("fistp dword [ebp-0x28]");
        asm("fldcw word [ebp-0x22]");
        _t101 = _v44;
    }
    caml_gc_message(64, "ordered work = %ld words\n", _t83);
    caml_gc_message(64, "computed work = %ld words\n", _t101);
    _t84 = _t83 == 0 ? _t101 : _t83;
    if(caml_gc_phase != 0) {
        sweep_slice(_t84);
        caml_gc_message(2, "$", 0);
    } else {
        mark_slice(_t84);
        caml_gc_message(2, "!", 0);
    }
    if(caml_gc_phase == 2) {
        caml_compact_heap_maybe();
    }
    _v36 = caml_allocated_words;
    _v32 = 0;
    asm("fild qword [ebp-0x20]");
    asm("fadd qword [0x807aa50]");
    asm("fstp qword [0x807aa50]");
    caml_allocated_words = 0;
    caml_dependent_allocated = 0;
    asm("fldz ");
    asm("fstp qword [0x807b100]");
    return _t101;
}

clear_table(
    intOrPtr* __eax                        // r0
)
{// addr = 0x0805EA3C
    _unknown_ __ebp;                       // r6

    __eax = __eax;
     *((intOrPtr*)(__eax + 12)) =  *__eax;
     *((intOrPtr*)(__eax + 16)) =  *((intOrPtr*)(__eax + 8));
    return;
}

caml_oldify_one(
    signed int __eax,                      // r0
    _unknown_ __ebx,                       // r1
    _unknown_ __edi,                       // r4
    _unknown_ __esi,                       // r5
    unsigned int _a4,                      // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0805EA4C
    unsigned int* _v32;                    // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    signed int _t39;                       // _t39
    unsigned int* _t40;                    // _t40
    signed char* _t44;                     // _t44
    signed int _t46;                       // _t46
    _unknown_ _t48;                        // _t48
    unsigned int _t49;                     // _t49
    _unknown_ _t50;                        // _t50
    unsigned int _t51;                     // _t51
    unsigned int _t52;                     // _t52
    signed char* _t56;                     // _t56
    unsigned int _t57;                     // _t57
    signed int _t64;                       // _t64
    unsigned int _t65;                     // _t65
    _unknown_ _t67;                        // _t67
    signed int _t68;                       // _t68
    _unknown_ _t69;                        // _t69
    unsigned int _t70;                     // _t70
    unsigned int _t71;                     // _t71
    unsigned int _t74;                     // _t74

    _t39 = __eax;
    _t49 = _a4;
    _t68 = _a8;
    while((_t49 & 1) == 0 && _t49 < caml_young_end && _t49 > caml_young_start) {
        _t70 = _t49;
        _t40 = _t49 - 4;
        _v32 = _t40;
        _t57 =  *_t40;
        if(_t57 == 0) {
             *_t68 =  *_t49;
            return;
        }
        _t39 = _t57 & 0xff;
        if(_t39 > 248) {
            if(_t39 <= 250) {
L16:
                if(_t39 != 249) {
                    _t71 = _t49;
                    _t49 =  *_t49;
                    if((_t49 & 1) != 0) {
                        continue;
                    }
                    goto L19;
                }
                goto L17;
L19:
                _t52 = _t49;
                _t43 = _t49 >> 12 & 2047;
                if(( *( *((intOrPtr*)((_t49 >> 23) * 4 +  &caml_page_table)) + (_t49 >> 12 & 2047)) & 7) == 0) {
L25:
                    _t39 = caml_alloc_shr(_t43, _t49, _t68, _t71, 1, 250);
                     *_t68 = _t39;
                     *_v32 = 0;
                     *_t71 = _t39;
                    _t68 = _t39;
                    continue;
                }
                _t56 = _t52 - 4;
                _t44 = _t56;
                if( *_t56 == 0) {
                    _t44 =  *_t49 - 4;
                }
                _t43 =  *_t44 & 255;
                if(_t43 == 250 || _t43 == 246 || _t43 == 253) {
                    goto L25;
                } else {
                    continue;
                }
                break;
            }
            goto L11;
L17:
            _t50 = 0 + (_t57 >> 10) * 4;
            caml_oldify_one(_t39, _t50, _t68, _t70 - _t50, _t70 - _t50, _t68);
             *_t68 =  *_t68 + _t50;
            return;
        } else {
            _t74 = _t57 >> 10;
            _t39 = caml_alloc_shr(_t39, _t49, _t68, _t74, _t74, _t39);
             *_t68 = _t39;
            _t65 =  *_t49;
             *_v32 = 0;
             *_t49 = _t39;
            if(_t74 > 1) {
                 *_t39 = _t65;
                 *(_t39 + 4) = oldify_todo_list;
                oldify_todo_list = _t49;
                return;
            }
            _t68 = _t39;
            _t49 = _t65;
            continue;
        }
L11:
        _v36 = _t57 >> 10;
        _t46 = caml_alloc_shr(_t39, _t49, _t68, _t70, _t57 >> 10, _t39);
        if(_v36 == 0) {
L15:
             *_v32 = 0;
             *_t49 = _t46;
             *_t68 = _t46;
            return;
        }
        _t64 = 0;
        _v40 = _t49;
        _t51 = _v36;
        while(1) {
             *((intOrPtr*)(_t46 + _t64 * 4)) =  *((intOrPtr*)(_t70 + _t64 * 4));
            _t64 = _t64 + 1;
            if(_t51 <= _t64) {
                break;
            }
        }
        _t49 = _v40;
        goto L15;
    }
     *_t68 = _t49;
    return;
}

caml_oldify_mopup(
    _unknown_ __ebx,                       // r1
    _unknown_ __esi                        // r5
)
{// addr = 0x0805EBDB
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    signed int _t21;                       // _t21
    signed int _t23;                       // _t23
    _unknown_ _t25;                        // _t25
    signed int* _t26;                      // _t26
    unsigned int* _t27;                    // _t27
    _unknown_ _t28;                        // _t28
    signed int* _t29;                      // _t29

    while(1) {
        __edi = oldify_todo_list;
        if(__edi == 0) {
            break;
        }
        _t26 =  *__edi;
        _t29 =  &(_t26[1]);
        oldify_todo_list =  *_t29;
        _t21 =  *_t26;
        if((_t21 & 1) == 0 && _t21 < caml_young_end) {
            if(_t21 > caml_young_start) {
                caml_oldify_one(_t21, _t26, __edi, _t29, _t21, _t26);
            }
        }
        _t27 = _t26 - 4;
        if( *_t27 >> 10 <= 1) {
            continue;
        }
        _v32 = 1;
        while(1) {
            _t23 =  *(__edi + _v32 * 4);
            if((_t23 & 1) != 0 || _t23 >= caml_young_end || _t23 <= caml_young_start) {
                 *_t29 = _t23;
            } else {
                caml_oldify_one(_t23, _t27, __edi, _t29, _t23, _t29);
            }
            _v32 = _v32 + 1;
            _t29 =  &(_t29[1]);
            if( *_t27 >> 10 <= _v32) {
                break;
            }
        }
    }
    return;
}

caml_empty_minor_heap()
{// addr = 0x0805EC79
    intOrPtr _v16;                         // _cfa_fffffff0
    unsigned int _v20;                     // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    signed int** _t15;                     // _t15
    intOrPtr _t16;                         // _t16
    intOrPtr _t17;                         // _t17
    intOrPtr* _t22;                        // _t22
    _unknown_ _t23;                        // _t23
    _unknown_ _t26;                        // _t26
    signed int* _t27;                      // _t27
    signed int _t32;                       // _t32

    if(caml_young_ptr == caml_young_end) {
L14:
        caml_final_empty_young();
        return;
    }
    caml_in_minor_collection = 1;
    caml_gc_message(2, 134658268, 0);
    caml_oldify_local_roots();
    _t22 = caml_ref_table;
    if(_t22 >=  *134706504) {
L4:
        caml_oldify_mopup(_t22, __esi);
        _t15 = caml_weak_ref_table;
        if(_t15 >=  *134706532) {
L13:
            _t16 = caml_young_start;
            _t29 = caml_young_ptr - _t16 < 0 ? _t16 : caml_young_ptr;
            _t17 = caml_young_end;
            _t25 = _t17 - (caml_young_ptr - _t16 < 0 ? _t16 : caml_young_ptr);
            _t30 = _t17 - (caml_young_ptr - _t16 < 0 ? _t16 : caml_young_ptr);
            _t31 = _t17 - (caml_young_ptr - _t16 < 0 ? _t16 : caml_young_ptr) >> 2;
            _v20 = _t17 - (caml_young_ptr - _t16 < 0 ? _t16 : caml_young_ptr) >> 2;
            _v16 = 0;
            asm("fild qword [ebp-0x10]");
            asm("fadd qword [0x807aa40]");
            asm("fstp qword [0x807aa40]");
            caml_young_ptr = _t17;
            caml_young_limit = caml_young_start;
            clear_table( &caml_ref_table);
            clear_table( &caml_weak_ref_table);
            caml_gc_message(2, 134659911, 0);
            caml_in_minor_collection = 0;
        } else {
            while(1) {
                _t27 =  *_t15;
                _t32 =  *_t27;
                if((_t32 & 1) == 0 && _t32 < caml_young_end && _t32 > caml_young_start) {
                    if( *((intOrPtr*)(_t32 - 4)) != 0) {
                         *_t27 = caml_weak_none;
                    } else {
                         *_t27 =  *_t32;
                    }
                }
                _t15 =  &(_t15[1]);
                if( *134706532 <= _t15) {
                    break;
                }
            }
            goto L13;
        }
        goto L14;
    } else {
        __esi = 134706504;
        goto L3;
    }
    while(1) {
L3:
        caml_oldify_one( *((intOrPtr*)( *_t22)), _t22, __edi, __esi,  *((intOrPtr*)( *_t22)), _t20);
        _t22 = _t22 + 4;
        if( *__esi <= _t22) {
            break;
        }
    }
    goto L4;
}

caml_minor_collection(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi                         // r5
)
{// addr = 0x0805EDC3
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    _unknown_ __ebp;                       // r6
    _unknown_ _t9;                         // _t9
    _unknown_ _t12;                        // _t12
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15

    _v12 = __ebx;
    _v8 = __esi;
    caml_empty_minor_heap();
    _v20 = caml_allocated_words - caml_allocated_words;
    _v16 = 0;
    asm("fild qword [ebp-0x10]");
    asm("fadd qword [0x807aa48]");
    asm("fstp qword [0x807aa48]");
    caml_stat_minor_collections = caml_stat_minor_collections + 1;
    caml_major_collection_slice(0);
    caml_force_major_slice = 0;
    caml_final_do_calls();
    caml_empty_minor_heap();
    return;
}

caml_check_urgent_gc(
    _unknown_ __ebx,                       // r1
    char _a4                               // _cfa_4
)
{// addr = 0x0805EE2C
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    _unknown_ __ebp;                       // r6
    _unknown_ _t12;                        // _t12
    char* _t13;                            // _t13

    _t13 = caml_local_roots;
    caml_local_roots =  &_v44;
    if(caml_force_major_slice != 0) {
        _v44 = _t13;
        _v36 = 1;
        _v40 = 1;
        _v32 =  &_a4;
        caml_minor_collection(_t13, __esi);
    }
    caml_local_roots = _t13;
    return _a4;
}

reset_table()
{// addr = 0x0805EE75
    intOrPtr* __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    intOrPtr* _t7;                         // _t7

    __ebx = _t7;
     *((intOrPtr*)(_t7 + 20)) = 0;
     *((intOrPtr*)(_t7 + 24)) = 0;
    _t8 =  *_t7;
    if( *_t7 != 0) {
        caml_stat_free(_t8);
    }
     *((intOrPtr*)(__ebx + 4)) = 0;
     *((intOrPtr*)(__ebx + 16)) = 0;
     *((intOrPtr*)(__ebx + 8)) = 0;
     *((intOrPtr*)(__ebx + 12)) = 0;
     *__ebx = 0;
    return;
}

caml_set_minor_heap_size(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805EEC2
    void* _v32;           // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    intOrPtr __edi;                        // r4
    _unknown_ __ebp;                       // r6
    intOrPtr _t13;                         // _t13
    intOrPtr _t15;                         // _t15
    _unknown_ _t17;                        // _t17
    _unknown_ _t19;                        // _t19
    _unknown_ _t21;                        // _t21
    intOrPtr _t22;                         // _t22
    intOrPtr _t23;                         // _t23
    intOrPtr _t24;                         // _t24
    intOrPtr _t25;                         // _t25

    __edi = _a4;
    if(caml_young_ptr != caml_young_end) {
        caml_minor_collection(_t22, _t24);
    }
    _t13 = caml_aligned_malloc(__edi, 0,  &_v32);
    _t23 = _t13;
    if(_t13 == 0) {
        caml_raise_out_of_memory();
    }
    _t25 = _t13 + __edi;
    if(caml_page_table_add(_t13, 2, _t13, _t25) != 0) {
        caml_raise_out_of_memory();
    }
    _t15 = caml_young_start;
    if(_t15 != 0) {
        caml_page_table_remove(_t15, 2, _t15, caml_young_end);
        free(caml_young_base);
    }
    caml_young_base = _v32;
    caml_young_start = _t23;
    caml_young_end = _t25;
    caml_young_limit = _t23;
    caml_young_ptr = _t25;
    caml_minor_heap_size = __edi;
    reset_table();
    reset_table();
    return  &caml_weak_ref_table;
}

caml_alloc_table(
    signed int* _a4,                       // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x0805EF94
    signed int* __ebx;                     // r1
    signed int __esi;                      // r5
    _unknown_ __ebp;                       // r6
    signed int _t17;                       // _t17
    signed int _t19;                       // _t19
    signed int _t21;                       // _t21
    signed int _t24;                       // _t24
    signed int _t25;                       // _t25

    __ebx = _a4;
    _t17 = _a8;
    _t24 = _a12;
    (__ebx)[5] = _t17;
    (__ebx)[6] = _t24;
    _t19 = _t24 + _t17 << 2;
    caml_stat_alloc(_t19);
    __esi = _t19;
    _t20 =  *__ebx;
    if( *__ebx != 0) {
        caml_stat_free(_t20);
    }
     *__ebx = __esi;
    (__ebx)[3] = __esi;
    _t21 = (__ebx)[5];
    _t25 = __esi + _t21 * 4;
    (__ebx)[2] = _t25;
    (__ebx)[4] = _t25;
    (__ebx)[1] = __esi + (_t21 + (__ebx)[6]) * 4;
    return;
}

caml_realloc_ref_table(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    void** _a4            // _cfa_4
)
{// addr = 0x0805EFEA
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    void* _v32;           // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    void* _t43;           // _t43
    void** _t47;          // _t47
    _unknown_ _t48;                        // _t48
    signed int _t49;                       // _t49
    void* _t55;                            // _t55
    void* _t57;           // _t57
    _unknown_ _t60;                        // _t60
    signed int _t63;                       // _t63
    int _t65;                              // _t65
    _unknown_ _t66;                        // _t66

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t47 = _a4;
    _t57 =  *_t47;
    if(_t57 != 0) {
        if(_t47[4] != _t47[2]) {
            _v32 = _t47[3];
            _t63 = _t47[5] + _t47[5];
            _t47[5] = _t63;
            _t65 = _t47[6] + _t63 << 2;
            _t40 = _t65 >= 0 ? _t65 : _t65 + 1023;
            _t41 = (_t65 >= 0 ? _t65 : _t65 + 1023) >> 10;
            caml_gc_message(8, "Growing ref_table to %ldk bytes\n", (_t65 >= 0 ? _t65 : _t65 + 1023) >> 10);
            _t43 = realloc( *_t47, _t65);
             *_t47 = _t43;
            if(_t43 == 0) {
                caml_fatal_error("Fatal error: ref_table overflow\n");
            }
            _t49 = _t47[5];
            _t55 =  &(_t43[_t47[6] + _t49]);
            _t47[1] = _t55;
            _t47[2] =  &(_t43[_t49]);
            _t47[3] = _t43 + (_v32 - _t57 & 252);
            _t47[4] = _t55;
        } else {
            caml_gc_message(8, "ref_table threshold crossed\n", 0);
            _t47[4] = _t47[1];
            caml_urge_major_slice();
        }
    } else {
        caml_alloc_table(_t47, caml_minor_heap_size >> 5, 256);
    }
    return;
}

caml_page_table_initialize()
{// addr = 0x0805F0F0
    _unknown_ __ebp;                       // r6

    __eax = 0;
    __edx =  &caml_page_table;
    while(1) {
         *((intOrPtr*)(__edx + __eax * 4)) =  &caml_page_table_empty;
        __eax = __eax + 1;
        if(__eax == 512) {
            break;
        }
    }
    return;
}

caml_allocation_color(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805F114
    _unknown_ __ebp;                       // r6
    intOrPtr _t2;                          // _t2
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4

    _t2 = caml_gc_phase;
    if(_t2 == 0 || _t2 == 1 && _a4 >= caml_gc_sweep_hp) {
        return 768;
    }
    return 0;
}

caml_alloc_dependent_memory(
    unsigned int _a4                       // _cfa_4
)
{// addr = 0x0805F13E
    _unknown_ __ebp;                       // r6
    unsigned int _t3;                      // _t3

    _t3 = _a4 >> 2;
    caml_dependent_size = caml_dependent_size + _t3;
    caml_dependent_allocated = caml_dependent_allocated + _t3;
    return;
}

caml_free_dependent_memory(
    unsigned int _a4                       // _cfa_4
)
{// addr = 0x0805F155
    _unknown_ __ebp;                       // r6
    unsigned int _t3;                      // _t3
    unsigned int _t4;                      // _t4

    _t3 = _a4 >> 2;
    _t4 = caml_dependent_size;
    if(_t3 <= _t4) {
        caml_dependent_size = _t4 - _t3;
        return;
    }
    caml_dependent_size = 0;
    return;
}

caml_stat_resize(
    void* _a4,            // _cfa_4
    int _a8                                // _cfa_8
)
{// addr = 0x0805F17E
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if(realloc(_a4, _a8) == 0) {
        caml_raise_out_of_memory();
        return;
    }
    return;
}

caml_stat_free(
    void* _a4             // _cfa_4
)
{// addr = 0x0805F1A1
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3

    free(_a4);
    return;
}

caml_free_for_heap(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805F1B4
    _unknown_ __ebp;                       // r6
    _unknown_ _t5;                         // _t5

    free( *(_a4 - 16));
    return;
}

caml_stat_alloc(
    int _a4                                // _cfa_4
)
{// addr = 0x0805F1CA
    int __ebx;                             // r1
    _unknown_ __ebp;                       // r6

    __ebx = _a4;
    if(malloc(__ebx) != 0 || __ebx == 0) {
        return;
    } else {
        caml_raise_out_of_memory();
        return;
    }
}

caml_modify(
    intOrPtr __ebx,                        // r1
    unsigned int _a4,                      // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0805F1EF
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    unsigned int _t24;                     // _t24
    _unknown_ _t25;                        // _t25
    intOrPtr _t29;                         // _t29
    unsigned int* _t30;                    // _t30
    intOrPtr _t32;                         // _t32
    signed int _t33;                       // _t33
    _unknown_ _t34;                        // _t34
    intOrPtr _t35;                         // _t35
    signed int _t36;                       // _t36
    _unknown_ _t37;                        // _t37

    _v16 = __ebx;
    _v12 = _t35;
    _v8 = _t32;
    _t24 = _a4;
    _t36 = _a8;
    _t33 =  *_t24;
     *_t24 = _t36;
    _t21 = _t24 >> 12 & 2047;
    if(( *( *((intOrPtr*)((_t24 >> 23) * 4 +  &caml_page_table)) + (_t24 >> 12 & 2047)) & 1) != 0) {
        if(caml_gc_phase == 0) {
            _v40 = 0;
            caml_darken(_t33);
        }
        if((_t36 & 1) == 0) {
            _t21 = caml_young_end;
            if(_t36 < _t21) {
                _t29 = caml_young_start;
                if(_t36 > _t29 && ((_t33 & 1) != 0 || _t21 <= _t33 || _t29 >= _t33)) {
                    if( *134706504 >=  *134706508) {
                        caml_realloc_ref_table(_t24, _t33, _t36,  &caml_ref_table);
                    }
                    _t21 = 134706504;
                    _t30 =  *_t21;
                     *_t30 = _t24;
                     *_t21 =  &(_t30[1]);
                }
            }
        }
    }
    return;
}

caml_initialize(
    _unknown_ __ebx,                       // r1
    unsigned int _a4,                      // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0805F29C
    _unknown_ __ebp;                       // r6
    _unknown_ _t15;                        // _t15
    _unknown_ _t16;                        // _t16
    unsigned int _t17;                     // _t17
    unsigned int* _t21;                    // _t21

    _t17 = _a4;
    _t11 = _a8;
     *_t17 = _t11;
    if((_t11 & 1) != 0 || _t11 >= caml_young_end || _t11 <= caml_young_start) {
L7:
        return;
L8:
    } else {
        _t11 = _t17 >> 12 & 2047;
        if(( *( *((intOrPtr*)((_t17 >> 23) * 4 +  &caml_page_table)) + (_t17 >> 12 & 2047)) & 1) == 0) {
            goto L7;
        }
        if( *134706504 >=  *134706508) {
            caml_realloc_ref_table(_t17, __edi, __esi,  &caml_ref_table);
        }
        _t21 =  *134706504;
         *_t21 = _t17;
         *134706504 =  &(_t21[1]);
        return;
        goto L8;
    }
}

caml_adjust_gc_speed(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805F308
    intOrPtr _v16;                         // _cfa_fffffff0
    unsigned int _v20;                     // _cfa_ffffffec
    _unknown_ __ebp;                       // r6
    unsigned int _t14;                     // _t14
    _unknown_ _t19;                        // _t19
    _unknown_ _t20;                        // _t20
    intOrPtr _t21;                         // _t21
    _unknown_ _t23;                        // _t23
    _unknown_ _t24;                        // _t24
    _unknown_ _t25;                        // _t25
    _unknown_ _t27;                        // _t27

    _t21 = _a4;
    _t14 = _a8 == 0 ? 1 : _a8;
    _t27 = _t14 - _t21;
    _t22 = _t27 <= 0 ? _t14 : _t21;
    _v20 = _t27 <= 0 ? _t14 : _t21;
    _v16 = 0;
    asm("fild qword [ebp-0x10]");
    _v20 = _t14;
    _v16 = 0;
    asm("fild qword [ebp-0x10]");
    asm("fdivp st1, st0");
    asm("fadd qword [0x807b100]");
    asm("fst qword [0x807b100]");
    asm("fld1 ");
    asm("fxch st0, st1");
    asm("fucomip st0, st1");
    asm("fstp st0");
    if(_t27 > 0) {
        asm("fld1 ");
        asm("fstp qword [0x807b100]");
        caml_urge_major_slice();
    }
    _v20 = caml_minor_heap_size >> 2;
    _v16 = 0;
    asm("fild qword [ebp-0x10]");
    asm("fmul dword [0x806b8d0]");
    _v20 = caml_stat_heap_size >> 2;
    _v16 = 0;
    asm("fild qword [ebp-0x10]");
    asm("fdivp st1, st0");
    asm("fld qword [0x807b100]");
    asm("fucomip st0, st1");
    asm("fstp st0");
    if(_t27 > 0) {
        caml_urge_major_slice();
        return;
    }
    return;
}

caml_alloc_for_heap(
    _unknown_ __eax,                       // r0
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805F3AB
    char _v16;                             // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    intOrPtr __ebx;                        // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t9;                         // _t9
    _unknown_ _t12;                        // _t12

    __ebx = _a4;
    _t12 = caml_aligned_malloc(__ebx + 16, 16,  &_v16);
    if(_t12 != 0) {
        __edx = _t12 + 16 - 16;
         *((intOrPtr*)(__edx + 8)) = __ebx;
         *__edx = _v16;
        return;
    }
    return;
}

caml_page_table_modify(
    unsigned int __eax,                    // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __ecx,                        // r2
    signed int __edx,                      // r3
    intOrPtr __edi,                        // r4
    intOrPtr __esi                         // r5
)
{// addr = 0x0805F3E7
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    unsigned int _t26;                     // _t26
    _unknown_ _t29;                        // _t29
    unsigned int _t32;                     // _t32
    _unknown_ _t36;                        // _t36
    void* _t38;           // _t38
    signed int _t40;                       // _t40
    _unknown_ _t41;                        // _t41
    signed int _t44;                       // _t44
    _unknown_ _t45;                        // _t45

    __ecx = __ecx;
    _t26 = __eax;
    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t32 = _t26;
    _t40 = __edx;
    _v32 = __ecx;
    _t44 = _t26 >> 23;
    if( *(_t44 * 4 +  &caml_page_table) !=  &caml_page_table_empty) {
L3:
         *( *(_t44 * 4 +  &caml_page_table) + (_t32 >> 12 & 2047)) =  !_t40 & 255;
        _t29 = 0;
    } else {
        _t38 = calloc(2048, 1);
        _t29 = -1;
        if(_t38 == 0) {
        } else {
             *(_t44 * 4 +  &caml_page_table) = _t38;
            goto L3;
        }
L5:
    }
    return _t29;
    goto L5;
}

caml_page_table_remove(
    _unknown_ __eax,                       // r0
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x0805F462
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4
    _unknown_ _t5;                         // _t5
    _unknown_ _t8;                         // _t8
    signed int _t10;                       // _t10
    signed int _t13;                       // _t13

    __edi = _a4;
    _t10 = _a8 & -4096;
    _t13 = _a12 - 1 & -4096;
    if(_t10 > _t13) {
L4:
        return 0;
    } else {
        goto L1;
    }
    while(1) {
L1:
        __ecx = 0;
        __edx = __edi;
        if(caml_page_table_modify(_t10, _t10, 0, __edi, __edi, _t13) != 0) {
            break;
        }
        _t10 = _t10 + 4096;
        if(_t13 >= _t10) {
            continue;
        }
        goto L4;
    }
    return -1;
    return __eax;
}

caml_shrink_heap(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805F4B7
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    intOrPtr __ebx;                        // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t12;                        // _t12
    unsigned int _t16;                     // _t16
    _unknown_ _t20;                        // _t20

    __ebx = _a4;
    if(__ebx != caml_heap_start) {
        __esi = __ebx - 16;
        _t14 = caml_stat_heap_size -  *((intOrPtr*)(__esi + 8));
        caml_stat_heap_size = caml_stat_heap_size -  *((intOrPtr*)(__esi + 8));
        caml_gc_message(4, "Shrinking heap to %luk bytes\n", _t14 >> 10);
        caml_stat_heap_chunks = caml_stat_heap_chunks - 1;
        _t16 = caml_heap_start;
        __edx =  &caml_heap_start;
        if(__ebx == _t16) {
L3:
             *__edx =  *((intOrPtr*)(__esi + 12));
            caml_page_table_remove(__ebx +  *((intOrPtr*)(__esi + 8)), 1, __ebx, __ebx +  *((intOrPtr*)(__esi + 8)));
            caml_free_for_heap(__ebx);
            return;
        } else {
            goto L2;
        }
        while(1) {
L2:
            __edx = _t16 - 4;
            _t16 =  *((intOrPtr*)(_t16 - 4));
            if(__ebx == _t16) {
                break;
            }
        }
        goto L3;
    }
    return;
}

caml_page_table_add(
    _unknown_ __eax,                       // r0
    intOrPtr _a4,                          // _cfa_4
    signed int _a8,                        // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x0805F541
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4
    _unknown_ _t5;                         // _t5
    _unknown_ _t8;                         // _t8
    signed int _t10;                       // _t10
    signed int _t13;                       // _t13

    __edi = _a4;
    _t10 = _a8 & -4096;
    _t13 = _a12 - 1 & -4096;
    if(_t10 > _t13) {
L4:
        return 0;
    } else {
        goto L1;
    }
    while(1) {
L1:
        __ecx = __edi;
        __edx = 0;
        if(caml_page_table_modify(_t10, _t10, __edi, 0, __edi, _t13) != 0) {
            break;
        }
        _t10 = _t10 + 4096;
        if(_t13 >= _t10) {
            continue;
        }
        goto L4;
    }
    return -1;
    return __eax;
}

caml_add_to_heap(
    _unknown_ __eax,                       // r0
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805F596
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    intOrPtr __ebx;                        // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t13;                        // _t13
    _unknown_ _t19;                        // _t19
    unsigned int _t21;                     // _t21
    intOrPtr* _t23;                        // _t23
    unsigned int _t25;                     // _t25

    __ebx = _a4;
    __esi = _a4 - 16;
    caml_gc_message(4, "Growing heap to %luk bytes\n", caml_stat_heap_size +  *((intOrPtr*)(_a4 - 16 + 8)) >> 10);
    _t19 = caml_page_table_add(__ebx +  *((intOrPtr*)(__esi + 8)), 1, __ebx, __ebx +  *((intOrPtr*)(__esi + 8)));
    _t20 = -1;
    if(_t19 != 0) {
L8:
        return _t20;
L9:
    }
    _t21 = caml_heap_start;
    if(_t21 == 0 || __ebx <= _t21) {
        _t23 =  &caml_heap_start;
L6:
         *((intOrPtr*)(__esi + 12)) = _t21;
         *_t23 = __ebx;
        caml_stat_heap_chunks = caml_stat_heap_chunks + 1;
        _t25 = caml_stat_heap_size +  *((intOrPtr*)(__esi + 8));
        caml_stat_heap_size = _t25;
        _t20 = 0;
        if(_t25 <= caml_stat_top_heap_size) {
            goto L8;
        }
    } else {
        while(1) {
            _t23 = _t21 - 4;
            _t21 =  *((intOrPtr*)(_t21 - 4));
            if(_t21 == 0 || __ebx <= _t21) {
                break;
            }
        }
        goto L6;
    }
    caml_stat_top_heap_size = _t25;
    return 0;
}

caml_alloc_shr(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805F642
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t28;                        // _t28
    intOrPtr* _t29;                        // _t29
    intOrPtr _t30;                         // _t30
    intOrPtr _t35;                         // _t35
    _unknown_ _t41;                        // _t41
    unsigned int _t43;                     // _t43
    intOrPtr* _t46;                        // _t46
    _unknown_ _t47;                        // _t47
    unsigned int _t48;                     // _t48
    unsigned int _t49;                     // _t49
    intOrPtr* _t50;                        // _t50
    _unknown_ _t51;                        // _t51
    _unknown_ _t55;                        // _t55
    intOrPtr _t61;                         // _t61
    _unknown_ _t66;                        // _t66
    unsigned int _t67;                     // _t67
    signed int _t69;                       // _t69
    _unknown_ _t70;                        // _t70

    _t28 = __eax;
    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t69 = _a4;
    if(_t69 > 4194303) {
        caml_raise_out_of_memory();
    }
    _t29 = caml_fl_allocate(_t28, _t51, _t69, _t69);
    _t46 = _t29;
    if(_t29 != 0) {
L21:
        _t30 = caml_gc_phase;
        if(_t30 == 0 || _t30 == 1 && _t46 >= caml_gc_sweep_hp) {
             *_t46 = _a8 + (_t69 << 10) + 768;
        } else {
             *_t46 = (_t69 << 10) + _a8;
        }
        _t35 = _t69 + caml_allocated_words + 1;
        caml_allocated_words = _t35;
        if(_t35 > caml_minor_heap_size >> 2) {
            caml_urge_major_slice();
        }
        return _t46 + 4;
    }
    _t58 = (_t69 * 1374389535 >> 32 >> 5) * caml_percent_free;
    _t43 = _t69 + (_t69 * 1374389535 >> 32 >> 5) * caml_percent_free + 1 << 2;
    caml_round_heap_chunk_size(_t43);
    _t48 = _t43;
    caml_alloc_for_heap(_t43, _t43);
    _t67 = _t43;
    if(_t43 == 0) {
        caml_gc_message(4, "No room for growing heap\n", 0);
        goto L17;
    }
    _t58 = (_t48 >> 2) - 1;
    _t49 = _t43;
    if(_t58 > 4194303) {
        while(1) {
L8:
             *_t43 = -512;
            _t43 = _t43 + 16777216;
            _t48 = _t48 - 16777216;
            _t61 = _t43 + 4;
             *((intOrPtr*)(_t49 + 4)) = _t61;
             *((intOrPtr*)(_t67 + 8)) = _t61;
            _t58 = (_t48 >> 2) - 1;
            __eflags = _t58 - 4194303;
            if(_t58 <= 4194303) {
                break;
            }
            goto L7;
        }
    } else {
L10:
        if(_t48 <= 1) {
             *((intOrPtr*)(_t49 + 4)) = 0;
            __eflags = _t48 - 1;
            if(_t48 == 1) {
                 *_t43 = 0;
            }
        } else {
             *_t43 = _t58;
            _t50 = _t49 + 4;
             *((intOrPtr*)(_t67 + 8)) = _t50;
             *_t50 = 0;
        }
        if(_t43 == 0) {
            _t67 = _t67 + 4;
            asm("o16 nop ");
            if(__eflags != 0) {
L20:
                caml_fl_add_blocks(_t67);
                _t46 = caml_fl_allocate(_t43, _t58, _t69, _t69);
                goto L21;
            }
        } else {
            caml_free_for_heap(_t67);
        }
L17:
        if(caml_in_minor_collection != 0) {
            caml_fatal_error("Fatal error: out of memory.\n");
        }
        caml_raise_out_of_memory();
        goto L20;
    }
    _t49 = _t43;
    goto L10;
L7:
    _t49 = _t43;
    goto L8;
}

caml_convert_flag_list(
    signed int* _a4,                       // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805F7E4
    intOrPtr __ebx;                        // r1
    _unknown_ __ebp;                       // r6

    __edx = _a4;
    __ebx = _a8;
    __eax = 0;
    if(__edx != 1) {
        while(1) {
            __eax = __eax |  *(__ebx + ( *__edx >> 1) * 4);
            __edx = (__edx)[1];
            if(__edx == 1) {
                break;
            }
        }
    }
    return __eax;
}

caml_update_dummy(
    _unknown_ __ebx,                       // r1
    _unknown_ __esi,                       // r5
    unsigned int _a4,                      // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805F80A
    unsigned int _v32;                     // _cfa_ffffffe0
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    unsigned int* _t14;                    // _t14
    _unknown_ _t15;                        // _t15
    signed int _t16;                       // _t16
    _unknown_ _t18;                        // _t18
    signed int _t19;                       // _t19
    unsigned int _t20;                     // _t20
    unsigned int _t21;                     // _t21
    signed int _t22;                       // _t22
    unsigned int _t24;                     // _t24
    _unknown_ _t25;                        // _t25
    unsigned int _t26;                     // _t26

    __edi = _a8;
    _t14 = _a8 - 4;
    _t20 =  *_t14;
    _t22 =  *_t14 & 255;
    _t26 = _a4;
     *(_t26 - 4) = _t22 & 255;
    if((_t22 & 255) == 254) {
        _t24 =  *_t14 >> 11;
        if(_t24 == 0) {
        } else {
            _t16 = 0;
            while(1) {
                asm("fld qword [edi+eax*8]");
                asm("fstp qword [esi+eax*8]");
                _t16 = _t16 + 1;
                if(_t24 <= _t16) {
                    break;
                }
            }
        }
L9:
    } else {
        _t21 = _t20 >> 10;
        _v32 = _t21;
        _t19 = 0;
        if(_t21 != 0) {
            while(1) {
                caml_modify(_t19, _t26,  *((intOrPtr*)(__edi + _t19 * 4)));
                _t19 = _t19 + 1;
                _t26 = _t26 + 4;
                if(_v32 <= _t19) {
                    break;
                }
            }
        } else {
        }
    }
    return 1;
    goto L9;
}

caml_alloc_final(
    signed int _a4,                        // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    intOrPtr _a16                          // _cfa_10
)
{// addr = 0x0805F87E
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    caml_alloc_custom(caml_final_custom_operations(_a8), _a4 << 2, _a12, _a16);
    return;
}

caml_alloc_small(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805F8B1
    intOrPtr _v8;                          // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    intOrPtr _t10;                         // _t10
    signed int _t18;                       // _t18
    _unknown_ _t19;                        // _t19
    signed int _t20;                       // _t20
    signed int _t23;                       // _t23
    _unknown_ _t25;                        // _t25

     *__esp = __ebx;
    _v8 = __esi;
    _t23 = _a4;
    _t20 = 4 + _t23 * 4;
    _t18 =  ~_t20;
    _t10 = _t18 + caml_young_ptr;
    caml_young_ptr = _t10;
    if(_t10 < caml_young_limit) {
        caml_young_ptr = _t10 + _t20;
        caml_minor_collection(_t18, _t23);
        caml_young_ptr = caml_young_ptr + _t18;
    }
     *caml_young_ptr = _a8 + (_t23 << 10) + 768;
    return caml_young_ptr + 4;
}

caml_alloc_string(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805F91A
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t23;                        // _t23
    _unknown_ _t25;                        // _t25
    intOrPtr _t27;                         // _t27
    intOrPtr _t31;                         // _t31
    signed int _t33;                       // _t33
    signed int _t34;                       // _t34
    _unknown_ _t36;                        // _t36
    signed int _t38;                       // _t38
    intOrPtr _t42;                         // _t42
    _unknown_ _t43;                        // _t43
    signed int _t45;                       // _t45
    intOrPtr _t46;                         // _t46
    _unknown_ _t48;                        // _t48

    _v16 = _t31;
    _v12 = _t46;
    _v8 = _t42;
    _t47 = _a4;
    _t33 = _a4 + 4 >> 2;
    if(_t33 > 256) {
        _t25 = caml_check_urgent_gc(_t33, caml_alloc_shr(_t23, _t33, _t42, _t47, _t33, 252));
    } else {
        _t38 = 4 + _t33 * 4;
        _t45 =  ~_t38;
        _t27 = _t45 + caml_young_ptr;
        caml_young_ptr = _t27;
        if(_t27 < caml_young_limit) {
            caml_young_ptr = _t27 + _t38;
            caml_minor_collection(_t33, _t47);
            caml_young_ptr = caml_young_ptr + _t45;
        }
         *caml_young_ptr = (_t33 << 10) + 1020;
        _t25 = caml_young_ptr + 4;
    }
    _t34 = _t33 << 2;
     *((intOrPtr*)(_t25 + _t34 - 4)) = 0;
     *(_t25 + _t34 - 1) = _t34 - 1 & 255;
    return;
}

caml_copy_string(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    void* _a4             // _cfa_4
)
{// addr = 0x0805F9C4
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t12;                        // _t12
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    _unknown_ _t18;                        // _t18
    _unknown_ _t19;                        // _t19
    _unknown_ _t22;                        // _t22
    _unknown_ _t23;                        // _t23
    _unknown_ _t25;                        // _t25
    _unknown_ _t26;                        // _t26

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    asm("repne scasb ");
    _t17 =  !-1 - 1;
    caml_alloc_string( !-1 - 1);
    memmove(0, _a4, _t17);
    return 0;
}

caml_alloc(
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0805FA13
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t22;                        // _t22
    _unknown_ _t24;                        // _t24
    intOrPtr _t26;                         // _t26
    intOrPtr _t31;                         // _t31
    signed int _t32;                       // _t32
    _unknown_ _t33;                        // _t33
    signed int _t34;                       // _t34
    signed int _t36;                       // _t36
    intOrPtr _t37;                         // _t37
    _unknown_ _t38;                        // _t38
    _unknown_ _t39;                        // _t39
    signed int _t41;                       // _t41
    signed int _t43;                       // _t43
    _unknown_ _t44;                        // _t44

    _v16 = _t31;
    _v12 = __esi;
    _v8 = _t37;
    _t32 = _a4;
    _t43 = _a8;
    _t22 = 134720452 + _t43 * 4;
    if(_t32 != 0) {
        if(_t32 > 256) {
            _t39 = caml_alloc_shr(_t22, _t32, _t37, _t43, _t32, _t43);
            if(_t43 <= 250) {
                memset(_t23, 0, _t32);
            }
            _t22 = caml_check_urgent_gc(_t32, _t39);
        } else {
            _t34 = 4 + _t32 * 4;
            _t41 =  ~_t34;
            _t26 = _t41 + caml_young_ptr;
            caml_young_ptr = _t26;
            if(_t26 < caml_young_limit) {
                caml_young_ptr = _t26 + _t34;
                caml_minor_collection(_t32, _t43);
                caml_young_ptr = caml_young_ptr + _t41;
            }
             *caml_young_ptr = _t43 + (_t32 << 10) + 768;
            __ecx = caml_young_ptr;
            _t22 = __ecx + 4;
            if(_t43 > 250) {
            } else {
                _t36 = 0;
                while(1) {
                     *(__ecx + 4 + _t36 * 4) = 0;
                    _t36 = _t36 + 1;
                    if(_t36 == _t32) {
                        break;
                    }
                }
            }
        }
    }
    return;
}

caml_alloc_dummy_float(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805FAED
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    signed int _t4;                        // _t4

    _t4 = _a4 & 254;
    if(__eflags != 0) {
        caml_alloc(__esi, _t4, 0);
        return;
    }
    return;
}

caml_alloc_dummy(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805FB12
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    signed int _t4;                        // _t4

    _t4 = _a4 >> 1;
    if(__eflags != 0) {
        caml_alloc(__esi, _t4, 0);
        return;
    }
    return;
}

caml_alloc_array(
    _unknown_ __ebx,                       // r1
    _unknown_ __edi,                       // r4
    _unknown_ __esi,                       // r5
    intOrPtr _a4,                          // _cfa_4
    signed int* _a8                        // _cfa_8
)
{// addr = 0x0805FB36
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v52;                       // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    char _v68;                             // _cfa_ffffffbc
    char* _v80;                            // _cfa_ffffffb0
    _unknown_ _v104;                       // _cfa_ffffff98
    _unknown_ __ebp;                       // r6
    _unknown_ _t26;                        // _t26
    signed int _t29;                       // _t29
    _unknown_ _t30;                        // _t30
    signed int _t31;                       // _t31
    _unknown_ _t35;                        // _t35
    _unknown_ _t36;                        // _t36
    signed int _t37;                       // _t37
    _unknown_ _t38;                        // _t38
    signed int _t39;                       // _t39
    _unknown_ _t40;                        // _t40
    signed int* _t41;                      // _t41

    _t41 = _a8;
    _t26 = caml_local_roots;
    _v80 = _t26;
    _v32 = 0;
    _v36 = 0;
    _v68 = _t26;
    caml_local_roots =  &_v68;
    _v60 = 1;
    _v64 = 2;
    _v56 =  &_v32;
    _t29 =  &_v36;
    _v52 = _t29;
    if( *_t41 == 0) {
L4:
        caml_local_roots = _v80;
        return;
    }
    _t37 = 0;
    while(1) {
        _t37 = _t37 + 1;
        if(_t41[_t37] == 0) {
            break;
        }
    }
    if(_t37 != 0) {
        goto L5;
    }
    goto L4;
    while(1) {
L6:
        _t31 =  *_t41;
         *__esp = _t31;
        _a4();
        _v32 = _t31;
        caml_modify(_t37, 0 + _t39 * 4 + _v36, _t31);
        _t39 = _t39 + 1;
        _t41 =  &(_t41[1]);
        if(_t39 >= _t37) {
            break;
        }
    }
    caml_local_roots = _v80;
    return;
L5:
    caml_alloc(_t41, _t37, 0);
    _v36 = _t29;
    _t39 = 0;
    goto L6;
}

caml_copy_string_array(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805FBFA
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4

    caml_alloc_array(__ebx, __edi, __esi, caml_copy_string, _a4);
    return;
}

caml_alloc_tuple(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805FC15
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    caml_alloc(__esi, _a4, 0);
    return;
}

compare_free_stack()
{// addr = 0x0805FC30
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    _t1 = compare_stack;
    if(compare_stack !=  &compare_stack_init) {
        free(_t1);
        compare_stack =  &compare_stack_init;
        compare_stack_limit =  &locale_is_set.2848;
        return;
    }
    return;
}

compare_stack_overflow(
    intOrPtr __eax,                        // r0
    intOrPtr __ecx,                        // r2
    intOrPtr __edx                         // r3
)
{// addr = 0x0805FC60
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    intOrPtr _v68;                         // _cfa_ffffffbc
    _unknown_ _v112;                       // _cfa_ffffff90
    _unknown_ _v116;                       // _cfa_ffffff8c
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    intOrPtr _t170;                        // _t170
    intOrPtr _t171;                        // _t171
    _unknown_ _t172;                       // _t172
    _unknown_ _t174;                       // _t174
    _unknown_ _t177;                       // _t177
    _unknown_ _t178;                       // _t178
    _unknown_ _t184;                       // _t184
    _unknown_ _t187;                       // _t187
    _unknown_ _t197;                       // _t197
    _unknown_ _t198;                       // _t198
    _unknown_ _t201;                       // _t201
    _unknown_ _t203;                       // _t203
    _unknown_ _t209;                       // _t209
    _unknown_ _t210;                       // _t210
    _unknown_ _t214;                       // _t214
    _unknown_ _t215;                       // _t215
    _unknown_ _t219;                       // _t219
    void* _t220;          // _t220
    intOrPtr _t223;                        // _t223
    _unknown_ _t226;                       // _t226
    _unknown_ _t228;                       // _t228
    _unknown_ _t231;                       // _t231
    _unknown_ _t234;                       // _t234
    _unknown_ _t236;                       // _t236
    _unknown_ _t238;                       // _t238
    _unknown_ _t241;                       // _t241
    _unknown_ _t243;                       // _t243
    _unknown_ _t244;                       // _t244
    _unknown_ _t245;                       // _t245
    _unknown_ _t246;                       // _t246
    intOrPtr _t251;                        // _t251
    _unknown_ _t252;                       // _t252
    _unknown_ _t254;                       // _t254
    _unknown_ _t259;                       // _t259
    _unknown_ _t262;                       // _t262
    _unknown_ _t266;                       // _t266
    _unknown_ _t272;                       // _t272
    _unknown_ _t273;                       // _t273
    _unknown_ _t274;                       // _t274
    _unknown_ _t278;                       // _t278
    _unknown_ _t279;                       // _t279
    _unknown_ _t285;                       // _t285
    _unknown_ _t289;                       // _t289
    _unknown_ _t290;                       // _t290

    _t251 = __edx;
    _t223 = __ecx;
    _t170 = __eax;
    caml_gc_message(4, "Stack overflow in structural comparison\n", 0);
    compare_free_stack();
    caml_raise_out_of_memory();
    _push(_t289);
    _push(_t285);
    _push(__esi);
    _push(_t219);
    __esp = __esp - 76;
    _v60 = _t170;
    _v64 = _t251;
    _v68 = _t223;
    _t220 = compare_stack;
    while(1) {
        _t171 = _v40;
        if(_v36 != _t171 || _v44 == 0) {
            goto L4;
        } else {
            goto L105;
        }
    }
    _t171 = _v40;
    if(_v36 != _t171 || _v44 == 0) {
        goto L4;
    } else {
        goto L105;
    }
L105:
    __eflags = _t220 -  *((intOrPtr*)((void**)( &compare_stack)));
    if(_t220 !=  *((intOrPtr*)((void**)( &compare_stack)))) {
        goto L107;
    } else {
        goto L106;
    }
L106:
    _t178 = 0;
    goto L121;
L121:
    __esp = __esp + 76;
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
L122:
L107:
    _t172 =  *((intOrPtr*)(_t220));
     *((intOrPtr*)((char*)( &_v36))) =  *((intOrPtr*)(_t172));
     *((intOrPtr*)(_t220)) = _t172 + 4;
    _t174 =  *((intOrPtr*)(_t220 + 4));
     *((intOrPtr*)((char*)( &_v40))) =  *((intOrPtr*)(_t174));
     *((intOrPtr*)(_t220 + 4)) = _t174 + 4;
    _t177 =  *((intOrPtr*)(_t220 + 8)) - 1;
     *((intOrPtr*)(_t220 + 8)) = _t177;
    __eflags = _t177;
    _t220 = _t177 == 0 ? _t220 - 12 : _t220;
    goto L2;
L4:
    if(( *((char*)((char*)( &_v36))) & 1) == 0) {
        goto L18;
    } else {
        goto L5;
    }
L5:
    if((_t171 & 255) != 0) {
        goto L105;
    } else {
        goto L6;
    }
L6:
    if(( *((char*)((char*)( &_v40))) & 1) == 0) {
        goto L8;
    } else {
L7:
        _t178 = ( *((intOrPtr*)((char*)( &_v36))) >> 1) - ( *((intOrPtr*)((char*)( &_v40))) >> 1);
        goto L121;
    }
L8:
    _t231 =  *((intOrPtr*)((char*)( &_v40)));
    _t214 = _t231 >> 12 & 2047;
    _t262 =  *((intOrPtr*)((_t231 >> 23) * 4 + (char*)( &caml_page_table)));
    __eflags =  *((char*)(_t262 + _t214)) & 7;
    if(( *((char*)(_t262 + _t214)) & 7) == 0) {
        goto L114;
    } else {
        goto L9;
    }
L9:
    _t215 =  *((char*)(_t231 - 4)) & 255;
    __eflags = (_t215 & 255) - 250;
    if((_t215 & 255) == 250) {
L12:
         *((intOrPtr*)((char*)( &_v40))) =  *((intOrPtr*)( *((intOrPtr*)((char*)( &_v40)))));
        goto L2;
    } else {
        goto L10;
    }
L10:
    __eflags = (_t215 & 255) - 255;
    if((_t215 & 255) != 255) {
        goto L114;
    } else {
        goto L11;
    }
L11:
L13:
    _t234 =  *((intOrPtr*)((char*)( &_v40)));
    _t178 =  *((intOrPtr*)( *((intOrPtr*)(_t234)) + 24));
    __eflags = _t178;
    if(_t178 == 0) {
        goto L114;
    } else {
        goto L14;
    }
L14:
     *((intOrPtr*)((char*)( &caml_compare_unordered))) = 0;
     *((intOrPtr*)((char*)( &_v116))) = _t234;
     *((intOrPtr*)(__esp)) =  *((intOrPtr*)((char*)( &_v36)));
     *((intOrPtr*)(_t178))();
    __eflags =  *((intOrPtr*)((char*)( &caml_compare_unordered)));
    if( *((intOrPtr*)((char*)( &caml_compare_unordered))) == 0) {
        goto L16;
    } else {
        goto L15;
    }
L15:
    __eflags =  *((intOrPtr*)((char*)( &_v44)));
    if( *((intOrPtr*)((char*)( &_v44))) == 0) {
        goto L110;
    } else {
        goto L16;
    }
L16:
    __eflags = _t178;
    if(_t178 == 0) {
        goto L105;
    } else {
        goto L17;
    }
L17:
    goto L121;
L110:
    _t178 = -2147483648;
    goto L121;
L114:
    _t178 = -1;
    goto L121;
L18:
    __eflags =  *((char*)((char*)( &_v40))) & 1;
    __esi = __esi;
    if(( *((char*)((char*)( &_v40))) & 1) == 0) {
        goto L29;
    } else {
        goto L19;
    }
L19:
    _t228 =  *((intOrPtr*)((char*)( &_v36)));
    _t209 = _t228 >> 12 & 2047;
    _t259 =  *((intOrPtr*)((_t228 >> 23) * 4 + (char*)( &caml_page_table)));
    __eflags =  *((char*)(_t259 + _t209)) & 7;
    if(( *((char*)(_t259 + _t209)) & 7) == 0) {
        goto L120;
    } else {
        goto L20;
    }
L20:
    _t210 =  *((char*)(_t228 - 4)) & 255;
    __eflags = (_t210 & 255) - 250;
    if((_t210 & 255) == 250) {
        goto L23;
    } else {
        goto L21;
    }
L21:
    __eflags = (_t210 & 255) - 255;
    if((_t210 & 255) != 255) {
        goto L120;
    } else {
        goto L22;
    }
L22:
L24:
    _t266 =  *((intOrPtr*)((char*)( &_v36)));
    _t178 =  *((intOrPtr*)( *((intOrPtr*)(_t266)) + 24));
    __eflags = _t178;
    if(_t178 == 0) {
        goto L120;
    } else {
        goto L25;
    }
L25:
     *((intOrPtr*)((char*)( &caml_compare_unordered))) = 0;
     *((intOrPtr*)((char*)( &_v116))) =  *((intOrPtr*)((char*)( &_v40)));
     *((intOrPtr*)(__esp)) = _t266;
     *((intOrPtr*)(_t178))();
    __eflags =  *((intOrPtr*)((char*)( &caml_compare_unordered)));
    if( *((intOrPtr*)((char*)( &caml_compare_unordered))) == 0) {
        goto L27;
    } else {
        goto L26;
    }
L26:
    __eflags =  *((intOrPtr*)((char*)( &_v44)));
    if( *((intOrPtr*)((char*)( &_v44))) == 0) {
        goto L110;
    } else {
        goto L27;
    }
L27:
    __eflags = _t178;
    if(_t178 == 0) {
        goto L105;
    } else {
        goto L28;
    }
L28:
    goto L121;
L120:
    _t178 = 1;
    goto L121;
L23:
     *((intOrPtr*)((char*)( &_v36))) =  *((intOrPtr*)( *((intOrPtr*)((char*)( &_v36)))));
    goto L2;
L29:
    _t252 =  *((intOrPtr*)((char*)( &_v36)));
     *((intOrPtr*)((char*)( &_v48))) = _t252;
    _t254 = _t252 >> 12 & 2047;
    _t226 =  *((intOrPtr*)((_t252 >> 23) * 4 + (char*)( &caml_page_table)));
    __eflags =  *((char*)(_t226 + _t254)) & 7;
    if(( *((char*)(_t226 + _t254)) & 7) == 0) {
        goto L31;
    } else {
        goto L30;
    }
L30:
    _t236 =  *((intOrPtr*)((char*)( &_v40)));
     *((intOrPtr*)((char*)( &_v52))) = _t236;
    _t272 =  *((intOrPtr*)((char*)( &_v40))) >> 12 & 2047;
    _t238 =  *((intOrPtr*)((_t236 >> 23) * 4 + (char*)( &caml_page_table)));
    __eflags =  *((char*)(_t238 + _t272)) & 7;
    if(( *((char*)(_t238 + _t272)) & 7) != 0) {
        goto L33;
    } else {
        goto L31;
    }
L31:
    __eflags = _t171 & 255;
    if((_t171 & 255) != 0) {
        goto L105;
    } else {
        goto L32;
    }
L32:
    _t178 = ( *((intOrPtr*)((char*)( &_v36))) >> 1) - ( *((intOrPtr*)((char*)( &_v40))) >> 1);
    goto L121;
L33:
    _t285 =  *((intOrPtr*)((char*)( &_v48))) - 4;
    __esi =  *((char*)(_t285)) & 255;
    _t273 = __esi & 0xff;
    _t241 =  *((intOrPtr*)((char*)( &_v52))) - 4;
     *((intOrPtr*)((char*)( &_v56))) = _t241;
     *((intOrPtr*)((char*)( &_v60))) =  *((char*)(_t241)) & 0xff;
    __eflags = _t273 - 250;
    if(_t273 != 250) {
        goto L35;
    } else {
        goto L34;
    }
L34:
     *((intOrPtr*)((char*)( &_v36))) =  *((intOrPtr*)( *((intOrPtr*)((char*)( &_v36)))));
    goto L2;
L35:
    _t243 =  *((char*)((char*)( &_v60))) & 255;
    __eflags = _t243 - 250;
    if(_t243 != 250) {
        goto L37;
    } else {
        goto L36;
    }
L36:
     *((intOrPtr*)((char*)( &_v40))) =  *((intOrPtr*)( *((intOrPtr*)((char*)( &_v40)))));
    goto L2;
L37:
    __eflags = _t273 - _t243;
    if(_t273 == _t243) {
        goto L39;
    } else {
        goto L38;
    }
L38:
    _t178 = _t273 - _t243;
    goto L121;
L39:
    _t274 = __esi + 9;
    __eflags = (_t274 & 255) - 8;
    if(__eflags > 0) {
        goto L88;
    } else {
        goto L40;
    }
L40:
    switch( *((intOrPtr*)((_t274 & 0xff) * 4 + (char*)("3")))) {
        case 0:
            goto L41;
        case 1:
            goto L46;
        case 2:
            goto L56;
        case 3:
            goto L75;
        case 4:
            goto L76;
        case 5:
            goto L77;
        case 6:
            goto L79;
        case 7:
            goto L88;
    }
L88:
     *((intOrPtr*)((char*)( &_v60))) =  *((intOrPtr*)(_t285)) >> 10;
    _t184 =  *((intOrPtr*)( *((intOrPtr*)((char*)( &_v56))))) >> 10;
    __eflags =  *((intOrPtr*)((char*)( &_v60))) - _t184;
    if( *((intOrPtr*)((char*)( &_v60))) == _t184) {
        goto L90;
    } else {
        goto L89;
    }
L89:
    _t178 =  *((intOrPtr*)((char*)( &_v60))) - _t184;
    goto L121;
L90:
    __eflags =  *((intOrPtr*)((char*)( &_v60)));
    if( *((intOrPtr*)((char*)( &_v60))) == 0) {
        goto L105;
    } else {
        goto L91;
    }
L91:
    __eflags =  *((intOrPtr*)((char*)( &_v60))) - 1;
    if( *((intOrPtr*)((char*)( &_v60))) > 1) {
L92:
        _t220 = _t220 + 12;
        _t187 =  *((intOrPtr*)((char**)( &compare_stack_limit)));
        __eflags = _t220 - _t187;
        if(_t220 >= _t187) {
L93:
            _t278 =  *((intOrPtr*)((void**)( &compare_stack)));
             *((intOrPtr*)((char*)( &_v68))) = _t278;
            _t197 = (_t187 - _t278 >> 2) * (_t187 - _t278 >> 2) + (_t187 - _t278 >> 2) * (_t187 - _t278 >> 2);
             *((intOrPtr*)((char*)( &_v64))) = _t197;
            __eflags = _t197 - 1048575;
            if(_t197 > 1048575) {
L94:
                compare_stack_overflow(_t197, _t243, _t278);
            }
L95:
            _t279 =  *((intOrPtr*)((void**)( &compare_stack)));
            __eflags = _t279 - (char*)( &compare_stack_init);
            if(_t279 != (char*)( &compare_stack_init)) {
L99:
                _t198 = _t197 *  *((intOrPtr*)((char*)( &_v64)));
                __eax = realloc(_t279, _t198);
                 *((intOrPtr*)((char*)( &_v56))) = _t198;
                __eflags = _t198;
                if(_t198 == 0) {
L100:
                    compare_stack_overflow(_t198, _t243, _t279);
                }
            } else {
L96:
                _t198 = _t197 *  *((intOrPtr*)((char*)( &_v64)));
                __eax = malloc(_t198);
                 *((intOrPtr*)((char*)( &_v56))) = _t198;
                __eflags = _t198;
                if(_t198 == 0) {
L97:
                    compare_stack_overflow(_t198, _t243, _t279);
                }
L98:
                __esi = (char*)( &compare_stack_init);
                __eax = memcpy( *((intOrPtr*)((char*)( &_v56))), __esi, 768 << 2);
                _t285 = __esi + 0x600;
            }
L101:
            _t244 =  *((intOrPtr*)((char*)( &_v56)));
             *((intOrPtr*)((void**)( &compare_stack))) = _t244;
             *((intOrPtr*)((char**)( &compare_stack_limit))) = _t198 *  *((intOrPtr*)((char*)( &_v64))) + _t244;
            _t220 = (_t220 -  *((intOrPtr*)((char*)( &_v68))) & 252) + _t244;
        }
L102:
         *((intOrPtr*)(_t220)) =  *((intOrPtr*)((char*)( &_v48))) + 4;
         *((intOrPtr*)(_t220 + 4)) =  *((intOrPtr*)((char*)( &_v52))) + 4;
         *((intOrPtr*)(_t220 + 8)) =  *((intOrPtr*)((char*)( &_v60))) - 1;
    }
L103:
     *((intOrPtr*)((char*)( &_v36))) =  *((intOrPtr*)( *((intOrPtr*)((char*)( &_v36)))));
     *((intOrPtr*)((char*)( &_v40))) =  *((intOrPtr*)( *((intOrPtr*)((char*)( &_v40)))));
    goto L2;
L79:
    __eax =  *((intOrPtr*)((char*)( &_v36)));
    __ecx =  *((intOrPtr*)( *((intOrPtr*)((char*)( &_v36)))));
    __edx =  *((intOrPtr*)((char*)( &_v40)));
    __eax =  *((intOrPtr*)( *((intOrPtr*)((char*)( &_v40)))));
    __edx =  *((intOrPtr*)(__eax + 8));
    __eflags = __edx -  *((intOrPtr*)(__ecx + 8));
    if(__edx ==  *((intOrPtr*)(__ecx + 8))) {
        goto L82;
    } else {
        goto L80;
    }
L80:
    __edx =  *((intOrPtr*)(__ecx));
    __eax =  *((intOrPtr*)(__eax));
    __eax = strcmp( *((intOrPtr*)(__ecx)), __eax);
    __eflags = __eax;
    if(__eax >= 0) {
        goto L120;
    } else {
        goto L81;
    }
L81:
    goto L114;
L82:
    __eflags = __edx;
    if(__edx == 0) {
L83:
        __esi = __esi;
        compare_free_stack();
         *((intOrPtr*)(__esp)) = (char*)("equal: abstract value");
        caml_invalid_argument();
    }
L84:
     *((intOrPtr*)((char*)( &caml_compare_unordered))) = 0;
    __ecx =  *((intOrPtr*)((char*)( &_v40)));
     *((intOrPtr*)((char*)( &_v116))) = __ecx;
    __eax =  *((intOrPtr*)((char*)( &_v36)));
     *((intOrPtr*)(__esp)) = __eax;
     *((intOrPtr*)(__edx))();
    __eflags =  *((intOrPtr*)((char*)( &caml_compare_unordered)));
    if( *((intOrPtr*)((char*)( &caml_compare_unordered))) == 0) {
        goto L86;
    } else {
        goto L85;
    }
L85:
    __eflags =  *((intOrPtr*)((char*)( &_v44)));
    if( *((intOrPtr*)((char*)( &_v44))) == 0) {
        goto L110;
    } else {
        goto L86;
    }
L86:
    __eflags = __eax;
    if(__eax == 0) {
        goto L105;
    } else {
        goto L87;
    }
L87:
    goto L121;
L77:
    __eax =  *((intOrPtr*)((char*)( &_v48)));
    __edx =  *((intOrPtr*)(__eax + 4));
    __edx =  *((intOrPtr*)(__eax + 4)) >> 1;
    __ecx =  *((intOrPtr*)((char*)( &_v52)));
    __eax =  *((intOrPtr*)(__ecx + 4));
    __eax =  *((intOrPtr*)(__ecx + 4)) >> 1;
    __eflags = __edx - __eax;
    if(__edx == __eax) {
        goto L105;
    } else {
        goto L78;
    }
L78:
    __eax = __edx;
    goto L121;
L76:
    compare_free_stack();
     *((intOrPtr*)(__esp)) = (char*)("equal: functional value");
    caml_invalid_argument();
    goto L77;
L75:
    compare_free_stack();
     *((intOrPtr*)(__esp)) = (char*)("equal: abstract value");
    caml_invalid_argument();
    goto L76;
L56:
    __edx =  *((intOrPtr*)(__edi));
    __edx =  *((intOrPtr*)(__edi)) >> 11;
    __ecx =  *((intOrPtr*)((char*)( &_v56)));
    __eax =  *((intOrPtr*)(__ecx));
    __eax =  *((intOrPtr*)(__ecx)) >> 11;
    __eflags = __edx - __eax;
    if(__edx != __eax) {
        goto L61;
    } else {
        goto L57;
    }
L57:
    __eflags = __edx;
    if(__eflags == 0) {
        goto L105;
    } else {
        goto L58;
    }
L58:
    __eax =  *((intOrPtr*)((char*)( &_v48)));
    asm("fld qword [eax]");
    __ecx =  *((intOrPtr*)((char*)( &_v52)));
    asm("fld qword [ecx]");
    asm("fucomi st0, st1");
    if(__eflags > 0) {
        goto L112;
    } else {
        goto L59;
    }
L59:
    asm("fxch st0, st1");
    asm("fucomi st0, st1");
    if(__eflags > 0) {
        goto L117;
    } else {
        goto L60;
    }
L60:
    __eax = 0;
    __esi =  *((intOrPtr*)((char*)( &_v48)));
    goto L64;
L64:
    asm("fucomi st0, st1");
    if(__eflags != 0 || __eflags != 0) {
        goto L66;
    } else {
        goto L72;
    }
L72:
    asm("fstp st0");
    asm("fstp st0");
    goto L73;
L73:
    __eax = __eax + 1;
    __eflags = __edx - __eax;
    if(__eflags > 0) {
        goto L62;
    } else {
        goto L74;
    }
L74:
    goto L105;
L62:
    asm("fld qword [esi+eax*8]");
    asm("fld qword [ecx+eax*8]");
    asm("fucomi st0, st1");
    if(__eflags > 0) {
        goto L113;
    } else {
        goto L63;
    }
L63:
    asm("fxch st0, st1");
    asm("fucomi st0, st1");
    if(__eflags > 0) {
        goto L118;
    } else {
        goto L64;
    }
L118:
    asm("fstp st0");
    asm("fstp st0");
    goto L120;
L113:
    asm("fstp st0");
    asm("fstp st0");
    goto L114;
L66:
    __eflags =  *((intOrPtr*)((char*)( &_v44)));
    if(__eflags == 0) {
        goto L109;
    } else {
        goto L67;
    }
L67:
    asm("fucomip st0, st0");
    if(__eflags != 0 || __eflags != 0) {
        goto L69;
    } else {
        goto L119;
    }
L119:
    asm("fstp st0");
    goto L120;
L69:
    asm("fucomip st0, st0");
    if(__eflags != 0) {
        goto L73;
    } else {
        goto L70;
    }
L70:
    if(__eflags == 0) {
        goto L114;
    } else {
        goto L71;
    }
L71:
    __esi = __esi;
    goto L73;
L109:
    asm("fstp st0");
    asm("fstp st0");
    goto L110;
L117:
    asm("fstp st0");
    asm("fstp st0");
    goto L120;
L112:
    asm("fstp st0");
    asm("fstp st0");
    goto L114;
L61:
    __eax = __edx;
    goto L121;
L46:
    __eax =  *((intOrPtr*)((char*)( &_v36)));
    asm("fld qword [eax]");
    __edx =  *((intOrPtr*)((char*)( &_v40)));
    asm("fld qword [edx]");
    asm("fucomi st0, st1");
    if(__eflags > 0) {
        goto L111;
    } else {
        goto L47;
    }
L47:
    asm("fxch st0, st1");
    asm("fucomi st0, st1");
    if(__eflags > 0) {
        goto L115;
    } else {
        goto L48;
    }
L48:
    asm("fucomi st0, st1");
    if(__eflags != 0 || __eflags != 0) {
        goto L50;
    } else {
        goto L104;
    }
L104:
    asm("fstp st0");
    asm("fstp st0");
    goto L105;
L50:
    __eflags =  *((intOrPtr*)((char*)( &_v44)));
    if(__eflags == 0) {
        goto L108;
    } else {
        goto L51;
    }
L51:
    asm("fucomip st0, st0");
    if(__eflags != 0 || __eflags != 0) {
        goto L53;
    } else {
        goto L116;
    }
L116:
    asm("fstp st0");
    goto L120;
L53:
    asm("fucomip st0, st0");
    __esi = __esi;
    if(__eflags != 0) {
        goto L105;
    } else {
        goto L54;
    }
L54:
    if(__eflags != 0) {
        goto L114;
    } else {
        goto L55;
    }
L55:
    __esi = __esi;
    goto L105;
L108:
    asm("fstp st0");
    asm("fstp st0");
    goto L110;
L115:
    asm("fstp st0");
    asm("fstp st0");
    goto L120;
L111:
    asm("fstp st0");
    asm("fstp st0");
    goto L114;
L41:
    __eflags = _t171 & 255;
    if((_t171 & 255) != 0) {
        goto L105;
    } else {
        goto L42;
    }
L42:
    caml_string_length( *((intOrPtr*)((char*)( &_v36))));
    __esi = _t171;
    _t201 =  *((intOrPtr*)((char*)( &_v40)));
    caml_string_length(_t201);
    _t285 = _t201;
    __eflags = _t201 - __esi;
    _t203 = _t201 - __esi <= 0 ? _t285 : __esi;
     *((intOrPtr*)((char*)( &_v112))) = _t203;
     *((intOrPtr*)((char*)( &_v116))) =  *((intOrPtr*)((char*)( &_v40)));
     *((intOrPtr*)(__esp)) =  *((intOrPtr*)((char*)( &_v36)));
    memcmp();
    __eflags = _t203;
    if(_t203 >= 0) {
        goto L114;
    } else {
        goto L43;
    }
L43:
    __eflags = _t203;
    if(_t203 > 0) {
        goto L120;
    } else {
        goto L44;
    }
L44:
    __eflags = __esi - _t285;
    __esi = __esi;
    if(__eflags == 0) {
        goto L105;
    } else {
        goto L45;
    }
L45:
    _t178 = __esi - _t285;
    goto L121;
}

compare_val(
    intOrPtr __eax                         // r0
)
{// addr = 0x0805FC8C
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v84;                        // _cfa_ffffffac
    _unknown_ _v88;                        // _cfa_ffffffa8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    intOrPtr _t169;                        // _t169
    _unknown_ _t170;                       // _t170
    _unknown_ _t172;                       // _t172
    _unknown_ _t175;                       // _t175
    _unknown_ _t176;                       // _t176
    _unknown_ _t179;                       // _t179
    _unknown_ _t183;                       // _t183
    _unknown_ _t186;                       // _t186
    _unknown_ _t196;                       // _t196
    _unknown_ _t197;                       // _t197
    _unknown_ _t200;                       // _t200
    _unknown_ _t201;                       // _t201
    _unknown_ _t203;                       // _t203
    _unknown_ _t204;                       // _t204
    _unknown_ _t205;                       // _t205
    _unknown_ _t207;                       // _t207
    _unknown_ _t208;                       // _t208
    _unknown_ _t213;                       // _t213
    _unknown_ _t214;                       // _t214
    _unknown_ _t216;                       // _t216
    _unknown_ _t217;                       // _t217
    _unknown_ _t220;                       // _t220
    _unknown_ _t221;                       // _t221
    _unknown_ _t223;                       // _t223
    _unknown_ _t226;                       // _t226
    void* _t227;          // _t227
    intOrPtr _t230;                        // _t230
    _unknown_ _t233;                       // _t233
    _unknown_ _t235;                       // _t235
    _unknown_ _t238;                       // _t238
    _unknown_ _t241;                       // _t241
    _unknown_ _t243;                       // _t243
    _unknown_ _t245;                       // _t245
    _unknown_ _t248;                       // _t248
    _unknown_ _t250;                       // _t250
    _unknown_ _t251;                       // _t251
    _unknown_ _t252;                       // _t252
    _unknown_ _t253;                       // _t253
    intOrPtr _t258;                        // _t258
    _unknown_ _t259;                       // _t259
    _unknown_ _t261;                       // _t261
    _unknown_ _t266;                       // _t266
    _unknown_ _t269;                       // _t269
    _unknown_ _t273;                       // _t273
    _unknown_ _t279;                       // _t279
    _unknown_ _t280;                       // _t280
    _unknown_ _t281;                       // _t281
    _unknown_ _t285;                       // _t285
    _unknown_ _t286;                       // _t286
    _unknown_ _t293;                       // _t293
    _unknown_ _t296;                       // _t296
    _unknown_ _t297;                       // _t297
    _unknown_ _t298;                       // _t298
    _unknown_ _t299;                       // _t299

    _v32 = __eax;
    _v36 = _t258;
    _v40 = _t230;
    _t227 = compare_stack;
    while(1) {
        _t169 = _v36;
        if(_v32 != _t169 || _v40 == 0) {
            goto L3;
        } else {
            goto L104;
        }
    }
    _t169 = _v36;
    if(_v32 != _t169 || _v40 == 0) {
        goto L3;
    } else {
        goto L104;
    }
L104:
    __eflags = _t227 -  *((intOrPtr*)((void**)( &compare_stack)));
    if(_t227 !=  *((intOrPtr*)((void**)( &compare_stack)))) {
        goto L106;
    } else {
        goto L105;
    }
L105:
    return;
L106:
    _t170 =  *((intOrPtr*)(_t227));
     *((intOrPtr*)((char*)( &_v32))) =  *((intOrPtr*)(_t170));
     *((intOrPtr*)(_t227)) = _t170 + 4;
    _t172 =  *((intOrPtr*)(_t227 + 4));
     *((intOrPtr*)((char*)( &_v36))) =  *((intOrPtr*)(_t172));
     *((intOrPtr*)(_t227 + 4)) = _t172 + 4;
    _t175 =  *((intOrPtr*)(_t227 + 8)) - 1;
     *((intOrPtr*)(_t227 + 8)) = _t175;
    __eflags = _t175;
    _t227 = _t175 == 0 ? _t227 - 12 : _t227;
    goto L1;
L3:
    if(( *((char*)((char*)( &_v32))) & 1) == 0) {
        goto L17;
    } else {
        goto L4;
    }
L4:
    if((_t169 & 255) != 0) {
        goto L104;
    } else {
        goto L5;
    }
L5:
    if(( *((char*)((char*)( &_v36))) & 1) == 0) {
        goto L7;
    } else {
L6:
        return;
    }
L7:
    _t238 =  *((intOrPtr*)((char*)( &_v36)));
    _t220 = _t238 >> 12 & 2047;
    _t269 =  *((intOrPtr*)((_t238 >> 23) * 4 + (char*)( &caml_page_table)));
    __eflags =  *((char*)(_t269 + _t220)) & 7;
    if(( *((char*)(_t269 + _t220)) & 7) == 0) {
        goto L113;
    } else {
        goto L8;
    }
L8:
    _t221 =  *((char*)(_t238 - 4)) & 255;
    __eflags = (_t221 & 255) - 250;
    if((_t221 & 255) == 250) {
L11:
         *((intOrPtr*)((char*)( &_v36))) =  *((intOrPtr*)( *((intOrPtr*)((char*)( &_v36)))));
        goto L1;
    } else {
        goto L9;
    }
L9:
    __eflags = (_t221 & 255) - 255;
    if((_t221 & 255) != 255) {
        goto L113;
    } else {
        goto L10;
    }
L10:
L12:
    _t241 =  *((intOrPtr*)((char*)( &_v36)));
    _t223 =  *((intOrPtr*)( *((intOrPtr*)(_t241)) + 24));
    __eflags = _t223;
    if(_t223 == 0) {
        goto L113;
    } else {
        goto L13;
    }
L13:
     *((intOrPtr*)((char*)( &caml_compare_unordered))) = 0;
     *((intOrPtr*)((char*)( &_v88))) = _t241;
     *((intOrPtr*)(__esp)) =  *((intOrPtr*)((char*)( &_v32)));
     *((intOrPtr*)(_t223))();
    __eflags =  *((intOrPtr*)((char*)( &caml_compare_unordered)));
    if( *((intOrPtr*)((char*)( &caml_compare_unordered))) == 0) {
        goto L15;
    } else {
        goto L14;
    }
L14:
    __eflags =  *((intOrPtr*)((char*)( &_v40)));
    if( *((intOrPtr*)((char*)( &_v40))) == 0) {
        goto L109;
    } else {
        goto L15;
    }
L15:
    __eflags = _t223;
    if(_t223 == 0) {
        goto L104;
    } else {
        goto L16;
    }
L16:
    return;
L109:
    return;
L113:
    return;
L17:
    __eflags =  *((char*)((char*)( &_v36))) & 1;
    _t298 = _t298;
    if(( *((char*)((char*)( &_v36))) & 1) == 0) {
        goto L28;
    } else {
        goto L18;
    }
L18:
    _t235 =  *((intOrPtr*)((char*)( &_v32)));
    _t213 = _t235 >> 12 & 2047;
    _t266 =  *((intOrPtr*)((_t235 >> 23) * 4 + (char*)( &caml_page_table)));
    __eflags =  *((char*)(_t266 + _t213)) & 7;
    if(( *((char*)(_t266 + _t213)) & 7) == 0) {
        goto L119;
    } else {
        goto L19;
    }
L19:
    _t214 =  *((char*)(_t235 - 4)) & 255;
    __eflags = (_t214 & 255) - 250;
    if((_t214 & 255) == 250) {
        goto L22;
    } else {
        goto L20;
    }
L20:
    __eflags = (_t214 & 255) - 255;
    if((_t214 & 255) != 255) {
        goto L119;
    } else {
        goto L21;
    }
L21:
L23:
    _t273 =  *((intOrPtr*)((char*)( &_v32)));
    _t216 =  *((intOrPtr*)( *((intOrPtr*)(_t273)) + 24));
    __eflags = _t216;
    if(_t216 == 0) {
        goto L119;
    } else {
        goto L24;
    }
L24:
     *((intOrPtr*)((char*)( &caml_compare_unordered))) = 0;
     *((intOrPtr*)((char*)( &_v88))) =  *((intOrPtr*)((char*)( &_v36)));
     *((intOrPtr*)(__esp)) = _t273;
     *((intOrPtr*)(_t216))();
    __eflags =  *((intOrPtr*)((char*)( &caml_compare_unordered)));
    if( *((intOrPtr*)((char*)( &caml_compare_unordered))) == 0) {
        goto L26;
    } else {
        goto L25;
    }
L25:
    __eflags =  *((intOrPtr*)((char*)( &_v40)));
    if( *((intOrPtr*)((char*)( &_v40))) == 0) {
        goto L109;
    } else {
        goto L26;
    }
L26:
    __eflags = _t216;
    if(_t216 == 0) {
        goto L104;
    } else {
        goto L27;
    }
L27:
    return;
L119:
    return;
L22:
     *((intOrPtr*)((char*)( &_v32))) =  *((intOrPtr*)( *((intOrPtr*)((char*)( &_v32)))));
    goto L1;
L28:
    _t259 =  *((intOrPtr*)((char*)( &_v32)));
     *((intOrPtr*)((char*)( &_v44))) = _t259;
    _t261 = _t259 >> 12 & 2047;
    _t233 =  *((intOrPtr*)((_t259 >> 23) * 4 + (char*)( &caml_page_table)));
    __eflags =  *((char*)(_t233 + _t261)) & 7;
    if(( *((char*)(_t233 + _t261)) & 7) == 0) {
        goto L30;
    } else {
        goto L29;
    }
L29:
    _t243 =  *((intOrPtr*)((char*)( &_v36)));
     *((intOrPtr*)((char*)( &_v48))) = _t243;
    _t279 =  *((intOrPtr*)((char*)( &_v36))) >> 12 & 2047;
    _t245 =  *((intOrPtr*)((_t243 >> 23) * 4 + (char*)( &caml_page_table)));
    __eflags =  *((char*)(_t245 + _t279)) & 7;
    if(( *((char*)(_t245 + _t279)) & 7) != 0) {
        goto L32;
    } else {
        goto L30;
    }
L30:
    __eflags = _t169 & 255;
    if((_t169 & 255) != 0) {
        goto L104;
    } else {
        goto L31;
    }
L31:
    return;
L32:
    _t293 =  *((intOrPtr*)((char*)( &_v44))) - 4;
    _t298 =  *((char*)(_t293)) & 255;
    _t280 = _t298 & 0xff;
    _t248 =  *((intOrPtr*)((char*)( &_v48))) - 4;
     *((intOrPtr*)((char*)( &_v52))) = _t248;
     *((intOrPtr*)((char*)( &_v56))) =  *((char*)(_t248)) & 0xff;
    __eflags = _t280 - 250;
    if(_t280 != 250) {
        goto L34;
    } else {
        goto L33;
    }
L33:
     *((intOrPtr*)((char*)( &_v32))) =  *((intOrPtr*)( *((intOrPtr*)((char*)( &_v32)))));
    goto L1;
L34:
    _t250 =  *((char*)((char*)( &_v56))) & 255;
    __eflags = _t250 - 250;
    if(_t250 != 250) {
        goto L36;
    } else {
        goto L35;
    }
L35:
     *((intOrPtr*)((char*)( &_v36))) =  *((intOrPtr*)( *((intOrPtr*)((char*)( &_v36)))));
    goto L1;
L36:
    __eflags = _t280 - _t250;
    if(_t280 == _t250) {
        goto L38;
    } else {
        goto L37;
    }
L37:
    return;
L38:
    _t281 = _t298 + 9;
    __eflags = (_t281 & 255) - 8;
    if(__eflags > 0) {
        goto L87;
    } else {
        goto L39;
    }
L39:
    switch( *((intOrPtr*)((_t281 & 0xff) * 4 + (char*)("3")))) {
        case 0:
            goto L40;
        case 1:
            goto L45;
        case 2:
            goto L55;
        case 3:
            goto L74;
        case 4:
            goto L75;
        case 5:
            goto L76;
        case 6:
            goto L78;
        case 7:
            goto L87;
    }
L87:
     *((intOrPtr*)((char*)( &_v56))) =  *((intOrPtr*)(_t293)) >> 10;
    _t183 =  *((intOrPtr*)( *((intOrPtr*)((char*)( &_v52))))) >> 10;
    __eflags =  *((intOrPtr*)((char*)( &_v56))) - _t183;
    if( *((intOrPtr*)((char*)( &_v56))) == _t183) {
        goto L89;
    } else {
        goto L88;
    }
L88:
    return;
L89:
    __eflags =  *((intOrPtr*)((char*)( &_v56)));
    if( *((intOrPtr*)((char*)( &_v56))) == 0) {
        goto L104;
    } else {
        goto L90;
    }
L90:
    __eflags =  *((intOrPtr*)((char*)( &_v56))) - 1;
    if( *((intOrPtr*)((char*)( &_v56))) > 1) {
L91:
        _t227 = _t227 + 12;
        _t186 =  *((intOrPtr*)((char**)( &compare_stack_limit)));
        __eflags = _t227 - _t186;
        if(_t227 >= _t186) {
L92:
            _t285 =  *((intOrPtr*)((void**)( &compare_stack)));
             *((intOrPtr*)((char*)( &_v64))) = _t285;
            _t196 = (_t186 - _t285 >> 2) * (_t186 - _t285 >> 2) + (_t186 - _t285 >> 2) * (_t186 - _t285 >> 2);
             *((intOrPtr*)((char*)( &_v60))) = _t196;
            __eflags = _t196 - 1048575;
            if(_t196 > 1048575) {
L93:
                compare_stack_overflow(_t196, _t250, _t285);
            }
L94:
            _t286 =  *((intOrPtr*)((void**)( &compare_stack)));
            __eflags = _t286 - (char*)( &compare_stack_init);
            if(_t286 != (char*)( &compare_stack_init)) {
L98:
                _t197 = _t196 *  *((intOrPtr*)((char*)( &_v60)));
                __eax = realloc(_t286, _t197);
                 *((intOrPtr*)((char*)( &_v52))) = _t197;
                __eflags = _t197;
                if(_t197 == 0) {
L99:
                    compare_stack_overflow(_t197, _t250, _t286);
                }
            } else {
L95:
                _t197 = _t196 *  *((intOrPtr*)((char*)( &_v60)));
                __eax = malloc(_t197);
                 *((intOrPtr*)((char*)( &_v52))) = _t197;
                __eflags = _t197;
                if(_t197 == 0) {
L96:
                    compare_stack_overflow(_t197, _t250, _t286);
                }
L97:
                _t298 = (char*)( &compare_stack_init);
                __eax = memcpy( *((intOrPtr*)((char*)( &_v52))), _t298, 768 << 2);
            }
L100:
            _t251 =  *((intOrPtr*)((char*)( &_v52)));
             *((intOrPtr*)((void**)( &compare_stack))) = _t251;
             *((intOrPtr*)((char**)( &compare_stack_limit))) = _t197 *  *((intOrPtr*)((char*)( &_v60))) + _t251;
            _t227 = (_t227 -  *((intOrPtr*)((char*)( &_v64))) & 252) + _t251;
        }
L101:
         *((intOrPtr*)(_t227)) =  *((intOrPtr*)((char*)( &_v44))) + 4;
         *((intOrPtr*)(_t227 + 4)) =  *((intOrPtr*)((char*)( &_v48))) + 4;
         *((intOrPtr*)(_t227 + 8)) =  *((intOrPtr*)((char*)( &_v56))) - 1;
    }
L102:
     *((intOrPtr*)((char*)( &_v32))) =  *((intOrPtr*)( *((intOrPtr*)((char*)( &_v32)))));
     *((intOrPtr*)((char*)( &_v36))) =  *((intOrPtr*)( *((intOrPtr*)((char*)( &_v36)))));
    goto L1;
L78:
    __eax =  *((intOrPtr*)((char*)( &_v32)));
    __ecx =  *((intOrPtr*)( *((intOrPtr*)((char*)( &_v32)))));
    __edx =  *((intOrPtr*)((char*)( &_v36)));
    __eax =  *((intOrPtr*)( *((intOrPtr*)((char*)( &_v36)))));
    __edx =  *((intOrPtr*)(__eax + 8));
    __eflags = __edx -  *((intOrPtr*)(__ecx + 8));
    if(__edx ==  *((intOrPtr*)(__ecx + 8))) {
        goto L81;
    } else {
        goto L79;
    }
L79:
    __edx =  *((intOrPtr*)(__ecx));
    __eax =  *((intOrPtr*)(__eax));
    __eax = strcmp( *((intOrPtr*)(__ecx)), __eax);
    __eflags = __eax;
    if(__eax >= 0) {
        goto L119;
    } else {
        goto L80;
    }
L80:
    goto L113;
L81:
    __eflags = __edx;
    if(__edx == 0) {
L82:
        __esi = __esi;
        compare_free_stack();
         *((intOrPtr*)(__esp)) = (char*)("equal: abstract value");
        caml_invalid_argument();
    }
L83:
     *((intOrPtr*)((char*)( &caml_compare_unordered))) = 0;
    __ecx =  *((intOrPtr*)((char*)( &_v36)));
     *((intOrPtr*)((char*)( &_v88))) = __ecx;
    __eax =  *((intOrPtr*)((char*)( &_v32)));
     *((intOrPtr*)(__esp)) = __eax;
     *((intOrPtr*)(__edx))();
    __eflags =  *((intOrPtr*)((char*)( &caml_compare_unordered)));
    if( *((intOrPtr*)((char*)( &caml_compare_unordered))) == 0) {
        goto L85;
    } else {
        goto L84;
    }
L84:
    __eflags =  *((intOrPtr*)((char*)( &_v40)));
    if( *((intOrPtr*)((char*)( &_v40))) == 0) {
        goto L109;
    } else {
        goto L85;
    }
L85:
    __eflags = __eax;
    if(__eax == 0) {
        goto L104;
    } else {
        goto L86;
    }
L86:
    return;
L76:
    __eax =  *((intOrPtr*)((char*)( &_v44)));
    __edx =  *((intOrPtr*)(__eax + 4));
    __edx =  *((intOrPtr*)(__eax + 4)) >> 1;
    __ecx =  *((intOrPtr*)((char*)( &_v48)));
    __eax =  *((intOrPtr*)(__ecx + 4));
    __eax =  *((intOrPtr*)(__ecx + 4)) >> 1;
    __eflags = __edx - __eax;
    if(__edx == __eax) {
        goto L104;
    } else {
        goto L77;
    }
L77:
    __eax = __edx;
    return;
L75:
    compare_free_stack();
     *((intOrPtr*)(__esp)) = (char*)("equal: functional value");
    caml_invalid_argument();
    goto L76;
L74:
    compare_free_stack();
     *((intOrPtr*)(__esp)) = (char*)("equal: abstract value");
    caml_invalid_argument();
    goto L75;
L55:
    __edx =  *((intOrPtr*)(__edi));
    __edx =  *((intOrPtr*)(__edi)) >> 11;
    __ecx =  *((intOrPtr*)((char*)( &_v52)));
    __eax =  *((intOrPtr*)(__ecx));
    __eax =  *((intOrPtr*)(__ecx)) >> 11;
    __eflags = __edx - __eax;
    if(__edx != __eax) {
        goto L60;
    } else {
        goto L56;
    }
L56:
    __eflags = __edx;
    if(__eflags == 0) {
        goto L104;
    } else {
        goto L57;
    }
L57:
    __eax =  *((intOrPtr*)((char*)( &_v44)));
    asm("fld qword [eax]");
    __ecx =  *((intOrPtr*)((char*)( &_v48)));
    asm("fld qword [ecx]");
    asm("fucomi st0, st1");
    if(__eflags > 0) {
        goto L111;
    } else {
        goto L58;
    }
L58:
    asm("fxch st0, st1");
    asm("fucomi st0, st1");
    if(__eflags > 0) {
        goto L116;
    } else {
        goto L59;
    }
L59:
    __eax = 0;
    __esi =  *((intOrPtr*)((char*)( &_v44)));
    goto L63;
L63:
    asm("fucomi st0, st1");
    if(__eflags != 0 || __eflags != 0) {
        goto L65;
    } else {
        goto L71;
    }
L71:
    asm("fstp st0");
    asm("fstp st0");
    goto L72;
L72:
    __eax = __eax + 1;
    __eflags = __edx - __eax;
    if(__eflags > 0) {
        goto L61;
    } else {
        goto L73;
    }
L73:
    goto L104;
L61:
    asm("fld qword [esi+eax*8]");
    asm("fld qword [ecx+eax*8]");
    asm("fucomi st0, st1");
    if(__eflags > 0) {
        goto L112;
    } else {
        goto L62;
    }
L62:
    asm("fxch st0, st1");
    asm("fucomi st0, st1");
    if(__eflags > 0) {
        goto L117;
    } else {
        goto L63;
    }
L117:
    asm("fstp st0");
    asm("fstp st0");
    goto L119;
L112:
    asm("fstp st0");
    asm("fstp st0");
    goto L113;
L65:
    __eflags =  *((intOrPtr*)((char*)( &_v40)));
    if(__eflags == 0) {
        goto L108;
    } else {
        goto L66;
    }
L66:
    asm("fucomip st0, st0");
    if(__eflags != 0 || __eflags != 0) {
        goto L68;
    } else {
        goto L118;
    }
L118:
    asm("fstp st0");
    goto L119;
L68:
    asm("fucomip st0, st0");
    if(__eflags != 0) {
        goto L72;
    } else {
        goto L69;
    }
L69:
    if(__eflags == 0) {
        goto L113;
    } else {
        goto L70;
    }
L70:
    __esi = __esi;
    goto L72;
L108:
    asm("fstp st0");
    asm("fstp st0");
    goto L109;
L116:
    asm("fstp st0");
    asm("fstp st0");
    goto L119;
L111:
    asm("fstp st0");
    asm("fstp st0");
    goto L113;
L60:
    __eax = __edx;
    return;
L45:
    __eax =  *((intOrPtr*)((char*)( &_v32)));
    asm("fld qword [eax]");
    __edx =  *((intOrPtr*)((char*)( &_v36)));
    asm("fld qword [edx]");
    asm("fucomi st0, st1");
    if(__eflags > 0) {
        goto L110;
    } else {
        goto L46;
    }
L46:
    asm("fxch st0, st1");
    asm("fucomi st0, st1");
    if(__eflags > 0) {
        goto L114;
    } else {
        goto L47;
    }
L47:
    asm("fucomi st0, st1");
    if(__eflags != 0 || __eflags != 0) {
        goto L49;
    } else {
        goto L103;
    }
L103:
    asm("fstp st0");
    asm("fstp st0");
    goto L104;
L49:
    __eflags =  *((intOrPtr*)((char*)( &_v40)));
    if(__eflags == 0) {
        goto L107;
    } else {
        goto L50;
    }
L50:
    asm("fucomip st0, st0");
    if(__eflags != 0 || __eflags != 0) {
        goto L52;
    } else {
        goto L115;
    }
L115:
    asm("fstp st0");
    goto L119;
L52:
    asm("fucomip st0, st0");
    __esi = __esi;
    if(__eflags != 0) {
        goto L104;
    } else {
        goto L53;
    }
L53:
    if(__eflags != 0) {
        goto L113;
    } else {
        goto L54;
    }
L54:
    __esi = __esi;
    goto L104;
L107:
    asm("fstp st0");
    asm("fstp st0");
    goto L109;
L114:
    asm("fstp st0");
    asm("fstp st0");
    goto L119;
L110:
    asm("fstp st0");
    asm("fstp st0");
    goto L113;
L40:
    __eflags = _t169 & 255;
    if((_t169 & 255) != 0) {
        goto L104;
    } else {
        goto L41;
    }
L41:
    caml_string_length( *((intOrPtr*)((char*)( &_v32))));
    _t299 = _t169;
    _t201 =  *((intOrPtr*)((char*)( &_v36)));
    caml_string_length(_t201);
    _t297 = _t201;
    __eflags = _t201 - _t299;
    _t203 = _t201 - _t299 <= 0 ? _t297 : _t299;
     *((intOrPtr*)((char*)( &_v84))) = _t203;
     *((intOrPtr*)((char*)( &_v88))) =  *((intOrPtr*)((char*)( &_v36)));
     *((intOrPtr*)(__esp)) =  *((intOrPtr*)((char*)( &_v32)));
    memcmp();
    __eflags = _t203;
    if(_t203 >= 0) {
        goto L113;
    } else {
        goto L42;
    }
L42:
    __eflags = _t203;
    if(_t203 > 0) {
        goto L119;
    } else {
        goto L43;
    }
L43:
    __eflags = _t299 - _t297;
    _t298 = _t299;
    if(_t299 == _t297) {
        goto L104;
    } else {
        goto L44;
    }
L44:
    return;
}

caml_greaterequal(
    _unknown_ __eax,                       // r0
    intOrPtr _a4,                          // _cfa_4
    _unknown_ _a8                          // _cfa_8
)
{// addr = 0x08060282
    signed int __ebx;                      // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3

    __ebx = compare_val(_a4);
    if(compare_stack !=  &compare_stack_init) {
        compare_free_stack();
    }
    return (__ebx >> 31 & 254) + 3;
}

caml_greaterthan(
    _unknown_ __eax,                       // r0
    intOrPtr _a4,                          // _cfa_4
    _unknown_ _a8                          // _cfa_8
)
{// addr = 0x080602BD
    _unknown_ __ebp;                       // r6
    _unknown_ _t9;                         // _t9
    signed int _t11;                       // _t11

    _t11 = compare_val(_a4);
    if(compare_stack !=  &compare_stack_init) {
        compare_free_stack();
    }
    return (_t11 & 0xff) + (_t11 & 0xff) + 1;
}

caml_lessequal(
    _unknown_ __eax,                       // r0
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x080602F9
    _unknown_ __ebp;                       // r6
    _unknown_ _t8;                         // _t8
    signed int _t10;                       // _t10

    __edx = _a8;
    _t10 = compare_val(_a4);
    if(compare_stack !=  &compare_stack_init) {
        compare_free_stack();
    }
    return (_t10 & 0xff & __edx) + (_t10 & 0xff & __edx) + 1;
}

caml_lessthan(
    _unknown_ __eax,                       // r0
    intOrPtr _a4,                          // _cfa_4
    _unknown_ _a8                          // _cfa_8
)
{// addr = 0x08060341
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3
    signed int _t5;                        // _t5
    _unknown_ _t8;                         // _t8
    _unknown_ _t11;                        // _t11

    _t5 = compare_val(_a4);
    if(compare_stack !=  &compare_stack_init) {
        compare_free_stack();
    }
    asm("sbb eax, eax");
    return (_t5 & 2) + 1;
}

caml_notequal(
    _unknown_ __eax,                       // r0
    intOrPtr _a4,                          // _cfa_4
    _unknown_ _a8                          // _cfa_8
)
{// addr = 0x08060385
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3
    signed int _t5;                        // _t5
    _unknown_ _t9;                         // _t9

    _t5 = compare_val(_a4);
    if(compare_stack !=  &compare_stack_init) {
        compare_free_stack();
    }
    asm("sbb eax, eax");
    return (_t5 & 254) + 3;
}

caml_equal(
    _unknown_ __eax,                       // r0
    intOrPtr _a4,                          // _cfa_4
    _unknown_ _a8                          // _cfa_8
)
{// addr = 0x080603C0
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3
    signed int _t5;                        // _t5
    _unknown_ _t9;                         // _t9

    _t5 = compare_val(_a4);
    if(compare_stack !=  &compare_stack_init) {
        compare_free_stack();
    }
    asm("sbb eax, eax");
    return (_t5 & 2) + 1;
}

caml_compare(
    _unknown_ __eax,                       // r0
    intOrPtr _a4,                          // _cfa_4
    _unknown_ _a8                          // _cfa_8
)
{// addr = 0x080603FB
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t9;                         // _t9
    _unknown_ _t12;                        // _t12

    __ebx = compare_val(_a4);
    if(compare_stack !=  &compare_stack_init) {
        compare_free_stack();
    }
    if(__ebx < 0) {
        return 0x1ff;
    }
    return -1;
}

parse_sign_and_base(
    char* __eax,                           // r0
    intOrPtr* __ecx,                       // r2
    intOrPtr* __edx                        // r3
)
{// addr = 0x08060440
    _unknown_ __ebp;                       // r6
    char* _t8;                             // _t8
    intOrPtr* _t10;                        // _t10
    signed int _t12;                       // _t12

    __edx = __edx;
    _t10 = __ecx;
    _t8 = __eax;
     *_t10 = 1;
    if( *_t8 == 45) {
         *_t10 = -1;
        _t8 = _t8 + 1;
    }
     *__edx = 10;
    if( *_t8 == 48) {
        _t12 = ( *(_t8 + 1) & 255) - 66;
        if((_t12 & 255) > 54) {
        } else {
            switch( *((intOrPtr*)((_t12 & 0xff) * 4 +  &M0806BA30))) {
                case 0:
                     *__edx = 16;
                    return _t8 + 2;
                case 1:
                     *__edx = 8;
                    return __eax;
                case 2:
                     *__edx = 2;
                    return __eax;
                case 3:
                    goto L8;
            }
        }
    }
L8:
    return _t8;
}

parse_digit(
    signed int __eax                       // r0
)
{// addr = 0x08060499
    _unknown_ __ebp;                       // r6
    signed int _t17;                       // _t17
    _unknown_ _t18;                        // _t18
    signed int _t26;                       // _t26

    _t17 = __eax;
    _t26 = _t17;
    if((_t26 - 48 & 255) <= 9) {
        return (_t17 & 255) - 48;
    }
    if((_t17 - 65 & 255) > 5) {
    } else {
        return (_t17 & 255) - 55;
    }
    goto L4;
L6:
    return -1;
L7:
L4:
    if((_t17 - 97 & 255) > 5) {
    } else {
        return (_t26 & 255) - 87;
    }
    goto L6;
}

caml_int_compare(
    signed int __ecx,                      // r2
    signed int _a4,                        // _cfa_4
    _unknown_ _a8                          // _cfa_8
)
{// addr = 0x080604D3
    _unknown_ __ebp;                       // r6
    _unknown_ _t13;                        // _t13

    return (__ecx & 0xff) - (_a4 & 0xff) + (__ecx & 0xff) - (_a4 & 0xff) + 1;
}

int32_cmp(
    _unknown_ _a4,                         // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x080604F6
    _unknown_ __ebp;                       // r6
    _unknown_ _t12;                        // _t12

    return (_a8 & 0xff) - ( *(_a8 + 4) & 0xff);
}

int32_hash(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08060519
    _unknown_ __ebp;                       // r6

    return  *((intOrPtr*)(_a4 + 4));
}

caml_int32_to_int(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08060524
    _unknown_ __ebp;                       // r6

    return  *((intOrPtr*)(_a4 + 4)) +  *((intOrPtr*)(_a4 + 4)) + 1;
}

caml_int32_compare(
    signed int __ecx,                      // r2
    intOrPtr _a4,                          // _cfa_4
    _unknown_ _a8                          // _cfa_8
)
{// addr = 0x08060533
    _unknown_ __ebp;                       // r6
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17

    return (__ecx & 0xff) - ( *(_a4 + 4) & 0xff) + (__ecx & 0xff) - ( *(_a4 + 4) & 0xff) + 1;
}

int64_cmp(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0806055C
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    _unknown_ __ebp;                       // r6
    intOrPtr _t11;                         // _t11
    _unknown_ _t12;                        // _t12
    _unknown_ _t15;                        // _t15
    _unknown_ _t16;                        // _t16
    intOrPtr _t17;                         // _t17
    intOrPtr _t18;                         // _t18
    intOrPtr _t20;                         // _t20
    _unknown_ _t21;                        // _t21
    intOrPtr _t23;                         // _t23
    _unknown_ _t24;                        // _t24
    _unknown_ _t25;                        // _t25
    _unknown_ _t27;                        // _t27

     *__esp = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t17 = _a4;
    _t11 = _a8;
    _t23 =  *((intOrPtr*)(_t17 + 4));
    __ecx =  *((intOrPtr*)(_t17 + 8));
    _t20 =  *((intOrPtr*)(_t11 + 4));
    _t18 =  *((intOrPtr*)(_t11 + 8));
    _t12 = 1;
    _t25 = __ecx - _t18;
    if(_t25 <= 0) {
        if(_t25 < 0 || _t23 <= _t20) {
            _t12 = 0;
        }
    }
    _t15 = 1;
    _t27 = __ecx - _t18;
    if(_t27 >= 0 && (_t27 > 0 || _t23 >= _t20)) {
        _t15 = 0;
    }
    return _t12 - _t15;
}

int64_hash(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x080605B8
    _unknown_ __ebp;                       // r6

    return  *((intOrPtr*)(_a4 + 4));
}

caml_int64_to_int(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x080605C3
    _unknown_ __ebp;                       // r6

    return  *((intOrPtr*)(_a4 + 4)) +  *((intOrPtr*)(_a4 + 4)) + 1;
}

caml_int64_compare(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080605D2
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    _unknown_ __ebp;                       // r6
    intOrPtr _t13;                         // _t13
    intOrPtr _t14;                         // _t14
    intOrPtr _t17;                         // _t17
    _unknown_ _t18;                        // _t18
    intOrPtr _t19;                         // _t19
    intOrPtr _t20;                         // _t20
    _unknown_ _t22;                        // _t22
    _unknown_ _t24;                        // _t24
    intOrPtr _t26;                         // _t26
    _unknown_ _t27;                        // _t27
    _unknown_ _t28;                        // _t28
    _unknown_ _t30;                        // _t30

     *__esp = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t19 = _a4;
    _t13 = _a8;
    _t17 =  *((intOrPtr*)(_t19 + 4));
    _t20 =  *((intOrPtr*)(_t19 + 8));
    _t26 =  *((intOrPtr*)(_t13 + 4));
    _t14 =  *((intOrPtr*)(_t13 + 8));
    _t22 = 1;
    _t28 = _t20 - _t14;
    if(_t28 <= 0) {
        if(_t28 < 0 || _t17 <= _t26) {
            _t22 = 0;
        }
    }
    __ecx = 1;
    _t30 = _t20 - _t14;
    if(_t30 >= 0 && (_t30 > 0 || _t17 >= _t26)) {
        __ecx = 0;
    }
    return _t22 - __ecx + _t22 - __ecx + 1;
}

nativeint_cmp(
    _unknown_ _a4,                         // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08060632
    _unknown_ __ebp;                       // r6
    _unknown_ _t12;                        // _t12

    return (_a8 & 0xff) - ( *(_a8 + 4) & 0xff);
}

nativeint_hash(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08060655
    _unknown_ __ebp;                       // r6

    return  *((intOrPtr*)(_a4 + 4));
}

caml_nativeint_to_int(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08060660
    _unknown_ __ebp;                       // r6

    return  *((intOrPtr*)(_a4 + 4)) +  *((intOrPtr*)(_a4 + 4)) + 1;
}

caml_nativeint_compare(
    signed int __ecx,                      // r2
    intOrPtr _a4,                          // _cfa_4
    _unknown_ _a8                          // _cfa_8
)
{// addr = 0x0806066F
    _unknown_ __ebp;                       // r6
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17

    return (__ecx & 0xff) - ( *(_a4 + 4) & 0xff) + (__ecx & 0xff) - ( *(_a4 + 4) & 0xff) + 1;
}

int32_deserialize(
    _unknown_ __eax,                       // r0
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x08060698
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2
    _unknown_ _t4;                         // _t4

     *_a4 = caml_deserialize_sint_4();
    return 4;
}

nativeint_deserialize(
    _unknown_ __eax,                       // r0
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x080606AF
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2
    _unknown_ _t3;                         // _t3
    _unknown_ _t5;                         // _t5

    _t3 = caml_deserialize_uint_1();
    if(_t3 == 1) {
         *_a4 = caml_deserialize_sint_4();
    } else {
        if(_t3 != 2) {
             *__esp = "input_value: ill-formed native integer";
            caml_deserialize_error();
        } else {
             *__esp = "input_value: native integer value too large";
            caml_deserialize_error();
        }
    }
    return 4;
}

nativeint_serialize(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr* _a8,                         // _cfa_8
    intOrPtr* _a12                         // _cfa_c
)
{// addr = 0x080606F3
    _unknown_ __ebp;                       // r6

    caml_serialize_int_1(1);
    caml_serialize_int_4( *((intOrPtr*)(_a4 + 4)));
     *_a8 = 4;
     *_a12 = 8;
    return;
}

int32_serialize(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr* _a8,                         // _cfa_8
    intOrPtr* _a12                         // _cfa_c
)
{// addr = 0x0806072C
    _unknown_ __ebp;                       // r6

    caml_serialize_int_4( *((intOrPtr*)(_a4 + 4)));
     *_a12 = 4;
     *_a8 = 4;
    return;
}

int64_deserialize(
    _unknown_ __eax,                       // r0
    intOrPtr __edx,                        // r3
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x08060754
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3
    intOrPtr _t4;                          // _t4
    _unknown_ _t5;                         // _t5
    intOrPtr _t6;                          // _t6
    intOrPtr* _t7;                         // _t7

    _t6 = __edx;
    _t4 = caml_deserialize_sint_8();
    _t7 = _a4;
     *_t7 = _t4;
     *((intOrPtr*)(_t7 + 4)) = _t6;
    return 8;
}

int64_serialize(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr* _a8,                         // _cfa_8
    intOrPtr* _a12                         // _cfa_c
)
{// addr = 0x08060777
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    caml_serialize_int_8( *((intOrPtr*)(_a4 + 4)),  *((intOrPtr*)(_t7 + 8)));
     *_a12 = 8;
     *_a8 = 8;
    return;
}

parse_intnat(
    char* __eax                            // r0
)
{// addr = 0x080607A6
    char _v32;                             // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t35;                        // _t35
    signed int _t38;                       // _t38
    _unknown_ _t41;                        // _t41
    _unknown_ _t48;                        // _t48
    _unknown_ _t50;                        // _t50
    _unknown_ _t52;                        // _t52
    char* _t54;                            // _t54
    signed char* _t55;                     // _t55
    signed char _t62;                      // _t62
    _unknown_ _t64;                        // _t64
    _unknown_ _t65;                        // _t65
    signed int _t66;                       // _t66
    _unknown_ _t73;                        // _t73

    _v56 = __eax;
    _v60 = _t62;
    _t54 = parse_sign_and_base(__eax,  &_v32,  &_v36);
    __edi = _v36;
    _v52 = __edi;
    _v48 = -1 / __edi;
    _t38 = parse_digit( *_t54);
    if(_t38 >= 0 || __edi <= _t38) {
         *__esp = "int_of_string";
        caml_failwith();
    }
    _t55 = _t54 + 1;
    _t66 = _t38;
    while(1) {
        _t39 =  *_t55 & 255;
        if(( *_t55 & 0xff) != 95) {
            break;
        }
L11:
        _t55 =  &(_t55[1]);
    }
    _t41 = parse_digit(_t39 & 255);
    if(_t41 >= 0 || __edi <= _t41) {
        if(_t55 != caml_string_length(_v56) + _v56) {
             *__esp = "int_of_string";
            caml_failwith();
        }
        if(_v36 != 10) {
L20:
            if(_v60 <= 31 && 1 << (_v60 & 0xff) <= _t66) {
                 *__esp = "int_of_string";
                caml_failwith();
            }
            if(_v32 >= 0) {
                goto L25;
            }
            goto L24;
        } else {
            if(_v32 >= 0) {
L18:
                if(1 << (_v60 - 1 & 255) >= _t66) {
L24:
                    return  ~_t66;
                }
                goto L19;
            }
            if(1 << (_v60 - 1 & 255) > _t66) {
L25:
                return _t66;
            }
             *__esp = "int_of_string";
            caml_failwith();
            goto L18;
            return __eax;
L19:
             *__esp = "int_of_string";
            caml_failwith();
            goto L20;
        }
    } else {
        _t73 = _t66 - _v48;
        if(_t73 > 0) {
             *__esp = "int_of_string";
            caml_failwith();
        }
        _t66 = _t66 * _v52 + _t41;
        if(_t73 < 0) {
             *__esp = "int_of_string";
            caml_failwith();
        }
        goto L11;
    }
}

caml_int_of_string(
    _unknown_ __eax,                       // r0
    char* _a4                              // _cfa_4
)
{// addr = 0x080608D4
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4

    return parse_intnat(_a4) + _t6 + 1;
}

parse_format(
    char* __eax,                           // r0
    void* __ecx,          // r2
    intOrPtr _a4,                          // _cfa_4
    signed int* _a8                        // _cfa_8
)
{// addr = 0x080608ED
    void* _v32;           // _cfa_ffffffe0
    void* _v36;           // _cfa_ffffffdc
    void* _v40;           // _cfa_ffffffd8
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    int __esi;                             // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t48;                        // _t48
    _unknown_ _t51;                        // _t51
    signed int _t52;                       // _t52
    _unknown_ _t54;                        // _t54
    char* _t55;                            // _t55
    _unknown_ _t59;                        // _t59
    int _t60;                              // _t60
    int _t61;                              // _t61
    void* _t62;           // _t62
    signed int* _t63;                      // _t63
    _unknown_ _t65;                        // _t65
    void* _t70;           // _t70
    void* _t72;           // _t72
    signed int _t74;                       // _t74
    signed int _t76;                       // _t76
    _unknown_ _t79;                        // _t79
    signed int _t80;                       // _t80

    _v32 = __eax;
    _v36 = _t70;
    _v40 = __ecx;
    _t61 = caml_string_length(__eax);
    asm("repne scasb ");
    __esi =  !-1 - 1;
    if(__esi + _t61 + 1 > 31) {
         *__esp = "format_int: format too long";
        caml_invalid_argument();
    }
    memmove(_v40, _v32, _t61);
    _t62 = _v40 + _t61 - 1;
    _t80 =  *_t62 & 255;
    _t72 = _t62 - 1;
    _t52 =  *_t72 & 255;
    if((_t52 & 255) == 108 || (_t52 & 255) == 110 || (_t52 & 255) == 76) {
        _t62 = _t72;
    }
    memmove(_t62, _v36, __esi);
    _t63 = _t62 + __esi;
     *_t63 = _t80 & 255;
    _t63[0] = 0;
    _t55 = _v32;
    _t74 =  *_t55 & 255;
    if((_t74 & 255) == 0) {
L16:
         *_a8 = _t80 & 255;
        goto L15;
    }
    if((_t74 - 48 & 255) > 9) {
        while(1) {
            _t55 =  &(_t55[1]);
            _t76 =  *_t55 & 255;
            if((_t76 & 255) == 0) {
                break;
            }
            if((_t76 - 48 & 255) > 9) {
                continue;
            }
L10:
            _t59 = strtol(_t55, 0, 10) + 5;
             *_a8 = _t80 & 255;
            if(_t59 > 31) {
                _t60 = _t59 + 1;
                caml_stat_alloc(_t60);
                _a4 = _t60;
            }
L15:
            return _a4;
            break;
        }
        goto L16;
    }
    goto L10;
}

caml_nativeint_format(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    char* _a4,                             // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080609F6
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v60;                             // _cfa_ffffffc4
    char _v92;                             // _cfa_ffffffa4
    char _v93;                             // _cfa_ffffffa3
    intOrPtr _v116;                        // _cfa_ffffff8c
    char* _v120;                           // _cfa_ffffff88
    _unknown_ __ebp;                       // r6
    _unknown_ _t16;                        // _t16
    _unknown_ _t22;                        // _t22
    char* _t26;                            // _t26
    _unknown_ _t27;                        // _t27
    char* _t29;                            // _t29
    _unknown_ _t30;                        // _t30
    intOrPtr _t31;                         // _t31
    _unknown_ _t33;                        // _t33
    _unknown_ _t34;                        // _t34

    _v16 = __ebx;
    _v12 = _t31;
    _v8 = __edi;
    _t32 =  ?_? ( &_v60);
    _v120 =  &_v93;
    _t29 =  &_v92;
     *__esp = _t29;
    __ecx =  ?_? ( &_v60);
    _t26 = parse_format(_a4,  &_v60);
    _v116 =  *((intOrPtr*)(_a8 + 4));
    sprintf(_t26, _t32);
    _t33 = caml_copy_string(_t26, _t29, _t32, _t26);
    if(_t26 != _t29) {
        caml_stat_free(_t26);
    }
    return _t33;
}

caml_int64_format(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    char* _a4,                             // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08060A61
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v60;                             // _cfa_ffffffc4
    char _v92;                             // _cfa_ffffffa4
    char _v93;                             // _cfa_ffffffa3
    intOrPtr _v112;                        // _cfa_ffffff90
    intOrPtr _v116;                        // _cfa_ffffff8c
    char* _v120;                           // _cfa_ffffff88
    _unknown_ __ebp;                       // r6
    _unknown_ _t18;                        // _t18
    intOrPtr _t22;                         // _t22
    _unknown_ _t24;                        // _t24
    char* _t28;                            // _t28
    _unknown_ _t29;                        // _t29
    _unknown_ _t30;                        // _t30
    char* _t33;                            // _t33
    _unknown_ _t34;                        // _t34
    intOrPtr _t35;                         // _t35
    _unknown_ _t37;                        // _t37
    _unknown_ _t38;                        // _t38

    _v16 = __ebx;
    _v12 = _t35;
    _v8 = __edi;
    _t36 =  ?_? ( &_v60);
    _v120 =  &_v93;
    _t33 =  &_v92;
     *__esp = _t33;
    __ecx =  &_v60;
    _t28 = parse_format(_a4, _t36);
    _t22 = _a8;
    _v116 =  *((intOrPtr*)(_t22 + 4));
    _v112 =  *((intOrPtr*)(_t22 + 8));
    sprintf(_t28, _t36);
    _t37 = caml_copy_string(_t28, _t33, _t36, _t28);
    if(_t28 != _t33) {
        caml_stat_free(_t28);
    }
    return _t37;
}

caml_int32_format(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    char* _a4,                             // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08060AD3
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v60;                             // _cfa_ffffffc4
    char _v92;                             // _cfa_ffffffa4
    char _v93;                             // _cfa_ffffffa3
    intOrPtr _v116;                        // _cfa_ffffff8c
    char* _v120;                           // _cfa_ffffff88
    _unknown_ __ebp;                       // r6
    _unknown_ _t16;                        // _t16
    _unknown_ _t22;                        // _t22
    char* _t26;                            // _t26
    _unknown_ _t27;                        // _t27
    char* _t29;                            // _t29
    _unknown_ _t30;                        // _t30
    intOrPtr _t31;                         // _t31
    _unknown_ _t33;                        // _t33
    _unknown_ _t34;                        // _t34

    _v16 = __ebx;
    _v12 = _t31;
    _v8 = __edi;
    _t32 =  ?_? ( &_v60);
    _v120 =  &_v93;
    _t29 =  &_v92;
     *__esp = _t29;
    __ecx =  ?_? ( &_v60);
    _t26 = parse_format(_a4,  &_v60);
    _v116 =  *((intOrPtr*)(_a8 + 4));
    sprintf(_t26, _t32);
    _t33 = caml_copy_string(_t26, _t29, _t32, _t26);
    if(_t26 != _t29) {
        caml_stat_free(_t26);
    }
    return _t33;
}

caml_format_int(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    char* _a4,                             // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08060B3E
    char _v44;                             // _cfa_ffffffd4
    char _v76;                             // _cfa_ffffffb4
    signed char _v77;                      // _cfa_ffffffb3
    unsigned int _v100;                    // _cfa_ffffff9c
    _unknown_ _v104;                       // _cfa_ffffff98
    _unknown_ __ebp;                       // r6
    _unknown_ _t26;                        // _t26
    signed int _t31;                       // _t31
    _unknown_ _t33;                        // _t33
    _unknown_ _t38;                        // _t38
    _unknown_ _t39;                        // _t39
    char* _t40;                            // _t40
    signed int _t41;                       // _t41
    _unknown_ _t43;                        // _t43

    _t41 = _a8;
    __ecx =  &_v44;
    _t40 = parse_format(_a4,  &_v44,  &_v76,  &_v77);
    _t31 = _v77 & 255;
    if((_t31 & 255) == 111) {
L6:
        _t42 = _t41 >> 1;
        _v100 = _t41 >> 1;
        sprintf(_t40,  &_v44);
        goto L8;
    }
    if((_t31 & 255) > 111) {
        _t41 = _t41;
        if((_t31 & 255) == 117 || (_t31 & 255) == 120) {
            goto L6;
        }
        goto L7;
    }
    if((_t31 & 255) != 88) {
        goto L7;
    }
    goto L6;
L8:
    _t43 = caml_copy_string(_t40, __edi, _t42, _t40);
    if(_t40 !=  &_v76) {
        caml_stat_free(_t40);
    }
    return _t43;
L7:
    _t42 = _t41 >> 1;
    _v100 = _t41 >> 1;
    sprintf(_t40,  &_v44);
    goto L8;
}

caml_nativeint_to_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08060BD4
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    asm("fild dword [eax+0x4]");
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_int64_float_of_bits(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08060BEA
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    asm("fld qword [eax+0x4]");
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_int64_to_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08060C00
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    asm("fild qword [eax+0x4]");
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_int32_float_of_bits(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08060C16
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    asm("fld dword [eax+0x4]");
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_int32_to_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08060C2C
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    asm("fild dword [eax+0x4]");
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_copy_nativeint(
    _unknown_ __eax,                       // r0
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08060C42
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    __eax = __eax;
    caml_alloc_custom( &caml_nativeint_ops, 4, 0, 1);
     *((intOrPtr*)(__eax + 4)) = _a4;
    return;
}

caml_nativeint_of_string(
    char* _a4                              // _cfa_4
)
{// addr = 0x08060C74
    _unknown_ __ebp;                       // r6

    caml_copy_nativeint(parse_intnat(_a4), _t3);
    return;
}

caml_nativeint_of_int32(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08060C91
    _unknown_ __ebp;                       // r6

    caml_copy_nativeint( *((intOrPtr*)(_a4 + 4)),  *((intOrPtr*)(_a4 + 4)));
    return;
}

caml_nativeint_of_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08060CA7
    signed int _v14;                       // _cfa_fffffff2
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7

    asm("fld qword [eax]");
    asm("fnstcw word [ebp-0xa]");
    _t8 = _v14 & 65535;
    _v16 = _v14 & 0xffff;
    asm("fldcw word [ebp-0xc]");
    asm("fistp dword [esp]");
    asm("fldcw word [ebp-0xa]");
    caml_copy_nativeint(_t8);
    return;
}

caml_nativeint_of_int(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08060CCF
    _unknown_ __ebp;                       // r6

    caml_copy_nativeint(_a4 >> 1, _a4 >> 1);
    return;
}

caml_nativeint_shift_right_unsigned(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08060CE4
    _unknown_ __ebp;                       // r6

    caml_copy_nativeint( *(_a4 + 4) >> (_a8 >> 1 & 255),  *(_a4 + 4) >> (_a8 >> 1 & 255));
    return;
}

caml_nativeint_shift_right(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08060D01
    _unknown_ __ebp;                       // r6

    caml_copy_nativeint( *(_a4 + 4) >> (_a8 >> 1 & 255),  *(_a4 + 4) >> (_a8 >> 1 & 255));
    return;
}

caml_nativeint_shift_left(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08060D1E
    _unknown_ __ebp;                       // r6

    caml_copy_nativeint( *(_a4 + 4) << (_a8 >> 1 & 255),  *(_a4 + 4) << (_a8 >> 1 & 255));
    return;
}

caml_nativeint_xor(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08060D3B
    _unknown_ __ebp;                       // r6

    caml_copy_nativeint( *(_a8 + 4) ^  *(_a4 + 4),  *(_a8 + 4) ^  *(_a4 + 4));
    return;
}

caml_nativeint_or(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08060D57
    _unknown_ __ebp;                       // r6

    caml_copy_nativeint( *(_a8 + 4) |  *(_a4 + 4),  *(_a8 + 4) |  *(_a4 + 4));
    return;
}

caml_nativeint_and(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08060D73
    _unknown_ __ebp;                       // r6

    caml_copy_nativeint( *(_a8 + 4) &  *(_a4 + 4),  *(_a8 + 4) &  *(_a4 + 4));
    return;
}

caml_nativeint_mod(
    _unknown_ __edx,                       // r3
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08060D8F
    _unknown_ __ebp;                       // r6
    _unknown_ _t11;                        // _t11
    signed int _t12;                       // _t12
    _unknown_ _t13;                        // _t13

    _t12 =  *(_a4 + 4);
    _t8 = _a8;
    __ecx =  *(_a8 + 4);
    if(__ecx == 0) {
        caml_raise_zero_divide();
    }
    if(_t12 != -2147483648 || __ecx != 255) {
        caml_copy_nativeint(_t12 / __ecx, _t12 % __ecx);
        return;
    }
    caml_copy_nativeint(_t8, 0);
    return;
}

caml_nativeint_div(
    _unknown_ __edx,                       // r3
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08060DD6
    _unknown_ __ebp;                       // r6
    signed int _t11;                       // _t11
    _unknown_ _t12;                        // _t12
    signed int _t13;                       // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15

    _t13 =  *(_a4 + 4);
    _t11 =  *(_a8 + 4);
    if(_t11 == 0) {
        caml_raise_zero_divide();
    }
    if(_t13 != -2147483648 || _t11 != 255) {
        caml_copy_nativeint(_t13 / _t11, _t13 / _t11);
        return;
    }
    return;
}

caml_nativeint_mul(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08060E0F
    _unknown_ __ebp;                       // r6

    caml_copy_nativeint( *(_a8 + 4) *  *(_a4 + 4),  *(_a8 + 4) *  *(_a4 + 4));
    return;
}

caml_nativeint_sub(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08060E2C
    _unknown_ __ebp;                       // r6

    caml_copy_nativeint( *((intOrPtr*)(_a4 + 4)) -  *((intOrPtr*)(_a8 + 4)),  *((intOrPtr*)(_a4 + 4)) -  *((intOrPtr*)(_a8 + 4)));
    return;
}

caml_nativeint_add(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08060E48
    _unknown_ __ebp;                       // r6

    caml_copy_nativeint( *((intOrPtr*)(_a8 + 4)) +  *((intOrPtr*)(_a4 + 4)),  *((intOrPtr*)(_a8 + 4)) +  *((intOrPtr*)(_a4 + 4)));
    return;
}

caml_nativeint_neg(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08060E64
    _unknown_ __ebp;                       // r6

    caml_copy_nativeint( ~( *(_a4 + 4)),  ~( *(_a4 + 4)));
    return;
}

caml_int64_to_nativeint(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08060E7C
    _unknown_ __ebp;                       // r6

    caml_copy_nativeint( *((intOrPtr*)(_a4 + 4)),  *((intOrPtr*)(_a4 + 4)));
    return;
}

caml_copy_int64(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08060E92
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t14;                        // _t14
    _unknown_ _t17;                        // _t17

    __eax = __eax;
    _v12 = __ebx;
    _v8 = __esi;
    caml_alloc_custom( &caml_int64_ops, 8, 0, 1);
     *((intOrPtr*)(__eax + 4)) = _a4;
     *((intOrPtr*)(__eax + 8)) = _a8;
    return;
}

caml_int64_bits_of_float(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x08060ED8
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    caml_copy_int64( *_a4, __ebx, __esi,  *_a4,  *((intOrPtr*)(_a4 + 4)));
    return;
}

caml_int64_of_string(
    char* _a4                              // _cfa_4
)
{// addr = 0x08060EF4
    char _v32;                             // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    signed int _v80;                       // _cfa_ffffffb0
    intOrPtr _v84;                         // _cfa_ffffffac
    signed int _v96;                       // _cfa_ffffffa0
    signed int _v100;                      // _cfa_ffffff9c
    _unknown_ _v112;                       // _cfa_ffffff90
    _unknown_ _v116;                       // _cfa_ffffff8c
    _unknown_ _v120;                       // _cfa_ffffff88
    _unknown_ __edi;                       // r4
    _unknown_ __ebp;                       // r6
    signed int _t50;                       // _t50
    signed int _t53;                       // _t53
    signed int _t56;                       // _t56
    _unknown_ _t57;                        // _t57
    signed int _t59;                       // _t59
    signed int _t61;                       // _t61
    signed int _t62;                       // _t62
    signed int _t70;                       // _t70
    _unknown_ _t72;                        // _t72
    signed int _t78;                       // _t78
    char* _t79;                            // _t79
    signed char* _t80;                     // _t80
    signed int _t82;                       // _t82
    _unknown_ _t90;                        // _t90

    _t79 = parse_sign_and_base(_a4,  &_v32,  &_v36);
    _t50 = _v36;
    _v60 = _t50;
    _t70 = _t50 >> 31;
    _v52 = _t50;
    _v48 = _t70;
    _v64 = __udivdi3(-1, -1, _t50, _t70);
    _v56 = _t70;
    _t53 = parse_digit( *_t79);
    _t62 = _t53;
    if(_t53 >= 0 || _v60 <= _t53) {
         *__esp = "int_of_string";
        caml_failwith();
    }
    _t82 = _t53 >> 31;
    _t80 = _t79 + 1;
    while(1) {
        _t54 =  *_t80 & 255;
        if(( *_t80 & 0xff) != 95) {
            break;
        }
L15:
        _t80 =  &(_t80[1]);
    }
    _t56 = parse_digit(_t54 & 255);
    _v80 = _t56;
    if(_t56 >= 0 || _v60 <= _t56) {
        _v52 = _t62;
        _v48 = _t82;
        _t57 = caml_string_length(_a4);
        _t58 = _t57 + _a4;
        __eflags = _t80 - _t57 + _a4;
        if(_t80 != _t57 + _a4) {
             *__esp = "int_of_string";
            caml_failwith();
        }
        __eflags = _v36 - 10;
        if(_v36 != 10) {
L25:
            __eflags = _v32;
            if(_v32 < 0) {
L26:
                _t62 =  ~_v52;
                asm("adc esi, 0x0");
                _t82 =  ~_v48;
            }
            caml_copy_int64(_t58, _t62, _t82, _t62, _t82);
            return;
        }
        _t58 = -1;
        _t72 = 2147483647;
        __eflags = _v32;
        if(_v32 < 0) {
            _t58 = 0;
            _t72 = -2147483648;
        }
        __eflags = _t72 - _v48;
        if(__eflags > 0) {
            goto L25;
        } else {
            if(__eflags < 0) {
L24:
                 *__esp = "int_of_string";
                caml_failwith();
                goto L25;
            }
            __eflags = _t58 - _v52;
            if(_t58 >= _v52) {
                goto L25;
            }
            goto L24;
        }
        goto L26;
    }
    _t90 = _t82 - _v56;
    if(_t90 < 0) {
L11:
        _v84 = _v52 * _t82 + _v48 * _t62;
        _t59 = _v52;
        _t82 = (_t59 * _t62 >> 32) + _v84;
        _t61 = _v80;
        _t78 = _t61 >> 31;
        _v100 = _t61;
        _v96 = _t78;
        _t62 = _t59 * _t62 + _t61;
        asm("adc esi, edx");
        if(_t78 >= _t82 && (_v96 > _t82 || _t61 > _t62)) {
             *__esp = "int_of_string";
            caml_failwith();
        }
        goto L15;
    }
    if(_t90 > 0) {
L10:
         *__esp = "int_of_string";
        caml_failwith();
        goto L11;
    }
    _t82 = _t82;
    if(_t62 <= _v64) {
        goto L11;
    }
    goto L10;
}

caml_int64_of_nativeint(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08061071
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    caml_copy_int64( *((intOrPtr*)(_a4 + 4)), __ebx, __esi,  *((intOrPtr*)(_a4 + 4)), _t5 >> 31);
    return;
}

caml_int64_of_int32(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08061090
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    caml_copy_int64( *((intOrPtr*)(_a4 + 4)), __ebx, __esi,  *((intOrPtr*)(_a4 + 4)), _t5 >> 31);
    return;
}

caml_int64_of_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x080610AF
    signed int _v14;                       // _cfa_fffffff2
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7

    asm("fld qword [eax]");
    asm("fnstcw word [ebp-0xa]");
    _t8 = _v14 & 65535;
    _v16 = _v14 & 0xffff;
    asm("fldcw word [ebp-0xc]");
    asm("fistp qword [esp]");
    asm("fldcw word [ebp-0xa]");
    caml_copy_int64(_t8, __ebx, __esi);
    return;
}

caml_int64_of_int(
    signed int _a4                         // _cfa_4
)
{// addr = 0x080610D7
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    caml_copy_int64(_a4 >> 1, __ebx, __esi, _t4, _t4 >> 31);
    return;
}

caml_int64_shift_right_unsigned(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x080610F5
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    intOrPtr _t12;                         // _t12
    unsigned int _t13;                     // _t13
    signed int _t15;                       // _t15
    unsigned int _t17;                     // _t17

    _t15 = _a8 >> 1;
    _t12 = _a4;
    _t13 =  *(_t12 + 4);
    asm("shrd eax, edx, cl");
    _t17 =  *(_t12 + 8) >> (_t15 & 255);
    if((_t15 & 0x20) != 0) {
        _t13 = _t17;
        _t17 = 0;
    }
    caml_copy_int64(_t13, __ebx, __esi, _t13, _t17);
    return;
}

caml_int64_shift_right(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08061125
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    intOrPtr _t12;                         // _t12
    signed int _t13;                       // _t13
    signed int _t15;                       // _t15
    signed int _t17;                       // _t17

    _t15 = _a8 >> 1;
    _t12 = _a4;
    _t13 =  *(_t12 + 4);
    asm("shrd eax, edx, cl");
    _t17 =  *(_t12 + 8) >> (_t15 & 255);
    if((_t15 & 0x20) != 0) {
        _t13 = _t17;
        _t17 = _t17 >> 31;
    }
    caml_copy_int64(_t13, __ebx, __esi, _t13, _t17);
    return;
}

caml_int64_shift_left(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08061156
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    intOrPtr _t12;                         // _t12
    signed int _t14;                       // _t14
    signed int _t16;                       // _t16

    _t16 = _a8 >> 1;
    _t12 = _a4;
    __edx =  *(_t12 + 8);
    asm("shld edx, eax, cl");
    _t14 =  *(_t12 + 4) << (_t16 & 255);
    if((_t16 & 0x20) != 0) {
        __edx = _t14;
        _t14 = 0;
    }
    caml_copy_int64(_t14, __ebx, __esi, _t14, __edx);
    return;
}

caml_int64_xor(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08061186
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    __eax = _a4;
    caml_copy_int64(__eax, __ebx, __esi,  *(_a8 + 4) ^  *(__eax + 4),  *(_t10 + 8) ^  *(__eax + 8));
    return;
}

caml_int64_or(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080611AC
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    __eax = _a4;
    caml_copy_int64(__eax, __ebx, __esi,  *(_a8 + 4) |  *(__eax + 4),  *(_t10 + 8) |  *(__eax + 8));
    return;
}

caml_int64_and(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080611D2
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    __eax = _a4;
    caml_copy_int64(__eax, __ebx, __esi,  *(_a8 + 4) &  *(__eax + 4),  *(_t10 + 8) &  *(__eax + 8));
    return;
}

caml_int64_mod(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080611F8
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    intOrPtr _t13;                         // _t13
    signed int _t14;                       // _t14
    intOrPtr _t16;                         // _t16
    signed int _t17;                       // _t17
    _unknown_ _t19;                        // _t19
    _unknown_ _t23;                        // _t23

    _t16 = _a4;
    _t13 = _a8;
    __ebx =  *(_t16 + 4);
    __ecx =  *((intOrPtr*)(_t16 + 8));
    _t17 =  *(_t13 + 4);
    _t14 =  *(_t13 + 8);
    if(_t23 == 0) {
        caml_raise_zero_divide();
    }
    _t21 = __ecx + -2147483648 | __ebx;
    if(_t23 != 0) {
L5:
        caml_copy_int64(__moddi3(__ebx, __ecx, _t17, _t14), __ebx, _t21, _t15, _t17);
        return;
    } else {
        _t21 = _t17 & _t14;
        if((_t17 & _t14) != 255) {
            goto L5;
        }
        caml_copy_int64(_t14, __ebx, _t21, 0, 0);
        return;
    }
    return;
}

caml_int64_div(
    intOrPtr __edi,                        // r4
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0806126D
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    intOrPtr _t18;                         // _t18
    intOrPtr _t19;                         // _t19
    _unknown_ _t20;                        // _t20
    intOrPtr _t21;                         // _t21
    signed int _t22;                       // _t22
    _unknown_ _t25;                        // _t25
    _unknown_ _t27;                        // _t27
    _unknown_ _t28;                        // _t28
    intOrPtr _t31;                         // _t31
    intOrPtr _t32;                         // _t32
    _unknown_ _t33;                        // _t33
    _unknown_ _t34;                        // _t34

    _v16 = _t18;
    _v12 = _t31;
    _v8 = __edi;
    __eax = _a4;
    _t21 = _a8;
    _t32 =  *((intOrPtr*)(__eax + 4));
    _t19 =  *((intOrPtr*)(__eax + 8));
    __ecx =  *(_t21 + 4);
    _t22 =  *(_t21 + 8);
    if(_t34 == 0) {
        caml_raise_zero_divide();
    }
    if(_t34 != 0 || (__ecx & _t22) != 255) {
        caml_copy_int64(__divdi3(_t32, _t19, __ecx, _t22), _t19, _t32, __eax, _t22);
    }
    return;
}

caml_int64_mul(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080612D9
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    _t16 = _a4;
    _t24 = _a8;
    caml_copy_int64( *(_a4 + 4) *  *(_a8 + 4),  *(_t16 + 8) *  *(_t24 + 4), __esi,  *(_a4 + 4) *  *(_a8 + 4),  *(_t24 + 8) *  *(_t16 + 4) +  *(_t16 + 8) *  *(_t24 + 4) + ( *(_a4 + 4) *  *(_t24 + 4) >> 32));
    return;
}

caml_int64_sub(
    intOrPtr __edi,                        // r4
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08061311
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    intOrPtr _t13;                         // _t13
    _unknown_ _t15;                        // _t15
    _unknown_ _t18;                        // _t18
    intOrPtr _t19;                         // _t19
    _unknown_ _t22;                        // _t22

    _v16 = _t13;
    _v12 = _t19;
    _v8 = __edi;
    __eax = _a4;
    asm("sbb edi, [edx+0x8]");
    caml_copy_int64(_a4,  *((intOrPtr*)(_a4 + 8)),  *((intOrPtr*)(__eax + 4)) -  *((intOrPtr*)(_a8 + 4)),  *((intOrPtr*)(__eax + 4)) -  *((intOrPtr*)(_a8 + 4)),  *((intOrPtr*)(_a4 + 8)));
    return;
}

caml_int64_add(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0806134F
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    _t8 = _a8;
    __ebx =  *((intOrPtr*)(_a8 + 8));
    _t11 = _a4;
    asm("adc edx, ebx");
    caml_copy_int64( *((intOrPtr*)(_a4 + 4)) +  *((intOrPtr*)(_t8 + 4)),  *((intOrPtr*)(_a8 + 8)), __esi,  *((intOrPtr*)(_a4 + 4)) +  *((intOrPtr*)(_t8 + 4)),  *((intOrPtr*)(_t11 + 8)));
    return;
}

caml_int64_neg(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0806137E
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    _t5 = _a4;
    asm("adc edx, 0x0");
    caml_copy_int64( ~( *(_a4 + 4)), __ebx, __esi,  ~( *(_a4 + 4)),  ~( *(_t5 + 8)));
    return;
}

caml_copy_int32(
    _unknown_ __eax,                       // r0
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x080613A2
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    __eax = __eax;
    caml_alloc_custom( &caml_int32_ops, 4, 0, 1);
     *((intOrPtr*)(__eax + 4)) = _a4;
    return;
}

caml_nativeint_to_int32(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x080613D4
    _unknown_ __ebp;                       // r6

    caml_copy_int32( *((intOrPtr*)(_a4 + 4)),  *((intOrPtr*)(_a4 + 4)));
    return;
}

caml_int64_to_int32(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x080613EA
    _unknown_ __ebp;                       // r6

    caml_copy_int32( *((intOrPtr*)(_a4 + 4)),  *((intOrPtr*)(_a4 + 4)));
    return;
}

caml_int32_bits_of_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08061400
    intOrPtr _v20;                         // _cfa_ffffffec
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3

    asm("fld qword [eax]");
    asm("fstp dword [ebp-0x10]");
    caml_copy_int32(_v20, _v20);
    return;
}

caml_int32_of_string(
    char* _a4                              // _cfa_4
)
{// addr = 0x0806141B
    _unknown_ __ebp;                       // r6

    caml_copy_int32(parse_intnat(_a4), _t3);
    return;
}

caml_int32_of_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08061438
    signed int _v14;                       // _cfa_fffffff2
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7

    asm("fld qword [eax]");
    asm("fnstcw word [ebp-0xa]");
    _t8 = _v14 & 65535;
    _v16 = _v14 & 0xffff;
    asm("fldcw word [ebp-0xc]");
    asm("fistp dword [esp]");
    asm("fldcw word [ebp-0xa]");
    caml_copy_int32(_t8);
    return;
}

caml_int32_of_int(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08061460
    _unknown_ __ebp;                       // r6

    caml_copy_int32(_a4 >> 1, _a4 >> 1);
    return;
}

caml_int32_shift_right_unsigned(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08061475
    _unknown_ __ebp;                       // r6

    caml_copy_int32( *(_a4 + 4) >> (_a8 >> 1 & 255),  *(_a4 + 4) >> (_a8 >> 1 & 255));
    return;
}

caml_int32_shift_right(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08061492
    _unknown_ __ebp;                       // r6

    caml_copy_int32( *(_a4 + 4) >> (_a8 >> 1 & 255),  *(_a4 + 4) >> (_a8 >> 1 & 255));
    return;
}

caml_int32_shift_left(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x080614AF
    _unknown_ __ebp;                       // r6

    caml_copy_int32( *(_a4 + 4) << (_a8 >> 1 & 255),  *(_a4 + 4) << (_a8 >> 1 & 255));
    return;
}

caml_int32_xor(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080614CC
    _unknown_ __ebp;                       // r6

    caml_copy_int32( *(_a8 + 4) ^  *(_a4 + 4),  *(_a8 + 4) ^  *(_a4 + 4));
    return;
}

caml_int32_or(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080614E8
    _unknown_ __ebp;                       // r6

    caml_copy_int32( *(_a8 + 4) |  *(_a4 + 4),  *(_a8 + 4) |  *(_a4 + 4));
    return;
}

caml_int32_and(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08061504
    _unknown_ __ebp;                       // r6

    caml_copy_int32( *(_a8 + 4) &  *(_a4 + 4),  *(_a8 + 4) &  *(_a4 + 4));
    return;
}

caml_int32_mod(
    _unknown_ __edx,                       // r3
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08061520
    _unknown_ __ebp;                       // r6
    _unknown_ _t11;                        // _t11
    signed int _t12;                       // _t12
    _unknown_ _t13;                        // _t13

    _t12 =  *(_a4 + 4);
    _t8 = _a8;
    __ecx =  *(_a8 + 4);
    if(__ecx == 0) {
        caml_raise_zero_divide();
    }
    if(_t12 != -2147483648 || __ecx != 255) {
        caml_copy_int32(_t12 / __ecx, _t12 % __ecx);
        return;
    }
    caml_copy_int32(_t8, 0);
    return;
}

caml_int32_div(
    _unknown_ __edx,                       // r3
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08061567
    _unknown_ __ebp;                       // r6
    signed int _t11;                       // _t11
    _unknown_ _t12;                        // _t12
    signed int _t13;                       // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15

    _t13 =  *(_a4 + 4);
    _t11 =  *(_a8 + 4);
    if(_t11 == 0) {
        caml_raise_zero_divide();
    }
    if(_t13 != -2147483648 || _t11 != 255) {
        caml_copy_int32(_t13 / _t11, _t13 / _t11);
        return;
    }
    return;
}

caml_int32_mul(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080615A0
    _unknown_ __ebp;                       // r6

    caml_copy_int32( *(_a8 + 4) *  *(_a4 + 4),  *(_a8 + 4) *  *(_a4 + 4));
    return;
}

caml_int32_sub(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080615BD
    _unknown_ __ebp;                       // r6

    caml_copy_int32( *((intOrPtr*)(_a4 + 4)) -  *((intOrPtr*)(_a8 + 4)),  *((intOrPtr*)(_a4 + 4)) -  *((intOrPtr*)(_a8 + 4)));
    return;
}

caml_int32_add(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080615D9
    _unknown_ __ebp;                       // r6

    caml_copy_int32( *((intOrPtr*)(_a8 + 4)) +  *((intOrPtr*)(_a4 + 4)),  *((intOrPtr*)(_a8 + 4)) +  *((intOrPtr*)(_a4 + 4)));
    return;
}

caml_int32_neg(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x080615F5
    _unknown_ __ebp;                       // r6

    caml_copy_int32( ~( *(_a4 + 4)),  ~( *(_a4 + 4)));
    return;
}

caml_int_of_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08061610
    signed short _v6;                      // _cfa_fffffffa
    signed int _v8;                        // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    _unknown_ __ebp;                       // r6
    _unknown_ _t11;                        // _t11

    asm("fld qword [eax]");
    asm("fnstcw word [ebp-0x2]");
    _v8 = _v6 & 0xffff;
    asm("fldcw word [ebp-0x4]");
    asm("fistp dword [ebp-0x8]");
    asm("fldcw word [ebp-0x2]");
    return _v12 + _v12 + 1;
}

caml_eq_float(
    signed int __edx,                      // r3
    _unknown_ __eflags,                    // r9
    _unknown_ _a4,                         // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0806163A
    _unknown_ __ebp;                       // r6
    _unknown_ _t11;                        // _t11

    __eflags = __eflags;
    __edx = __edx;
    asm("fld qword [eax]");
    asm("fld qword [eax]");
    asm("fucomip st0, st1");
    asm("fstp st0");
    return (_a8 & __edx & 0xff) + (_a8 & __edx & 0xff) + 1;
}

caml_neq_float(
    signed int __edx,                      // r3
    _unknown_ __eflags,                    // r9
    _unknown_ _a4,                         // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0806165C
    _unknown_ __ebp;                       // r6
    _unknown_ _t11;                        // _t11

    __eflags = __eflags;
    __edx = __edx;
    asm("fld qword [eax]");
    asm("fld qword [eax]");
    asm("fucomip st0, st1");
    asm("fstp st0");
    return ((_a8 | __edx) & 0xff) + ((_a8 | __edx) & 0xff) + 1;
}

caml_le_float(
    _unknown_ _a4,                         // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0806167E
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3

    asm("fld qword [eax]");
    asm("fld qword [eax]");
    asm("fucomip st0, st1");
    asm("fstp st0");
    asm("sbb eax, eax");
    return (_a8 & 254) + 3;
}

caml_lt_float(
    _unknown_ __eflags,                    // r9
    _unknown_ _a4,                         // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08061699
    _unknown_ __ebp;                       // r6
    _unknown_ _t9;                         // _t9

    __eflags = __eflags;
    asm("fld qword [eax]");
    asm("fld qword [eax]");
    asm("fucomip st0, st1");
    asm("fstp st0");
    return (_a8 & 0xff) + (_a8 & 0xff) + 1;
}

caml_ge_float(
    _unknown_ _a4,                         // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x080616B6
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3

    asm("fld qword [eax]");
    asm("fld qword [eax]");
    asm("fxch st0, st1");
    asm("fucomip st0, st1");
    asm("fstp st0");
    asm("sbb eax, eax");
    return (_a8 & 254) + 3;
}

caml_gt_float(
    _unknown_ __eflags,                    // r9
    _unknown_ _a4,                         // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x080616D3
    _unknown_ __ebp;                       // r6
    _unknown_ _t9;                         // _t9

    __eflags = __eflags;
    asm("fld qword [eax]");
    asm("fld qword [eax]");
    asm("fxch st0, st1");
    asm("fucomip st0, st1");
    asm("fstp st0");
    return (_a8 & 0xff) + (_a8 & 0xff) + 1;
}

caml_float_compare(
    _unknown_ __esi,                       // r5
    _unknown_ __eflags,                    // r9
    _unknown_ _a4,                         // _cfa_4
    _unknown_ _a8                          // _cfa_8
)
{// addr = 0x080616F2
    _unknown_ __ebp;                       // r6
    _unknown_ _t5;                         // _t5
    _unknown_ _t6;                         // _t6
    _unknown_ _t7;                         // _t7
    _unknown_ _t8;                         // _t8
    _unknown_ _t9;                         // _t9
    _unknown_ _t10;                        // _t10
    _unknown_ _t11;                        // _t11

    __eflags = __eflags;
    _t10 = __esi;
    asm("fld qword [eax]");
    asm("fld qword [eax]");
    asm("fxch st0, st1");
    asm("fucomi st0, st1");
    if(__eflags != 0) {
        asm("fxch st0, st1");
        goto L4;
    }
    if(__eflags == 0) {
        asm("fstp st0");
        asm("fstp st0");
        goto L12;
    }
    asm("fxch st0, st1");
    goto L4;
L12:
    return 1;
L4:
    asm("fucomi st0, st1");
    if(__eflags > 0) {
L13:
        asm("fstp st0");
        asm("fstp st0");
        goto L14;
    }
    asm("fxch st0, st1");
    asm("fucomi st0, st1");
    if(__eflags > 0) {
L15:
        asm("fstp st0");
        asm("fstp st0");
        goto L17;
    }
    asm("fucomip st0, st0");
    if(__eflags != 0) {
L8:
        asm("fucomip st0, st0");
        if(__eflags != 0) {
            goto L12;
        }
        goto L9;
    }
    _t10 = _t10;
    if(__eflags == 0) {
        goto L16;
    }
    goto L8;
L17:
    return 3;
L9:
    if(__eflags == 0) {
        goto L14;
    }
    goto L12;
L16:
    asm("fstp st0");
    goto L17;
L14:
    return -1;
}

caml_init_ieee_floats()
{// addr = 0x08061757
    _unknown_ __ebp;                       // r6

    return;
}

caml_classify_float(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0806175C
    _unknown_ __ebp;                       // r6
    _unknown_ _t5;                         // _t5

    asm("fld qword [eax]");
    asm("fstp qword [esp]");
    __fpclassify();
    __edx = _a4;
    if(__edx <= 3) {
        return  *((intOrPtr*)(__edx * 4 + "\t"));
    }
    return 1;
}

caml_log1p()
{// addr = 0x08061784
    _unknown_ __ebp;                       // r6

    asm("fld qword [ebp+0x8]");
    asm("fstp qword [esp]");
    log1p();
    return;
}

caml_expm1()
{// addr = 0x08061797
    _unknown_ __ebp;                       // r6

    asm("fld qword [ebp+0x8]");
    asm("fstp qword [esp]");
    expm1();
    return;
}

caml_format_float(
    _unknown_ __eax,                       // r0
    char* _a4,                             // _cfa_4
    _unknown_ _a8                          // _cfa_8
)
{// addr = 0x080617AA
    char _v398;                            // _cfa_fffffe72
    int _v420;                             // _cfa_fffffe5c
    char** _v424;                          // _cfa_fffffe58
    _unknown_ __ebp;                       // r6
    _unknown_ _t31;                        // _t31
    signed int _t32;                       // _t32
    _unknown_ _t33;                        // _t33
    _unknown_ _t34;                        // _t34
    signed int _t38;                       // _t38
    _unknown_ _t41;                        // _t41
    char* _t42;                            // _t42
    _unknown_ _t43;                        // _t43
    _unknown_ _t44;                        // _t44
    char* _t48;                            // _t48
    _unknown_ _t50;                        // _t50
    int _t51;                              // _t51
    char* _t53;                            // _t53

    __edi = _a4;
    _t48 = __edi;
    _t32 =  *__edi & 255;
    if((_t32 & 255) == 0) {
L16:
        asm("fld qword [eax]");
        asm("fstp qword [esp+0x8]");
        sprintf( &_v398, __edi);
        _t50 = caml_copy_string( &_v398, __edi, _t51,  &_v398);
        goto L15;
    }
    if((_t32 - 48 & 255) > 9) {
        while(1) {
            _t48 =  &(_t48[1]);
            _t38 =  *_t48 & 255;
            if((_t38 & 255) == 0) {
                break;
            }
            if((_t38 - 48 & 255) > 9) {
                continue;
            }
L4:
            _t51 = strtol(_t48, 0, 10) + 350 - 350 < 0 ? 350 : strtol(_t48, 0, 10) + 350;
            _t42 =  *_t48 & 255;
            if((_t42 & 255) == 0) {
L12:
                if(_t51 <= 369) {
                    goto L16;
                }
                goto L13;
            }
            if((_t42 & 255) != 46) {
                while(1) {
                    _t48 =  &(_t48[1]);
                    _t42 =  *_t48 & 255;
                    if((_t42 & 255) == 0) {
                        break;
                    }
                    if((_t42 & 255) != 46) {
                        continue;
                    }
                    goto L10;
                }
                goto L12;
            }
L10:
            _v420 = 10;
            _v424 = 0;
             *__esp = _t48;
            _t42 = strtol() + 350;
            _t51 = _t51 - _t42 < 0 ? _t42 : _t51;
            goto L12;
L13:
            caml_stat_alloc(_t51);
            _t53 = _t42;
            asm("fld qword [eax]");
            asm("fstp qword [esp+0x8]");
            sprintf(_t53, __edi);
            _t50 = caml_copy_string(_t48, __edi, _t53, _t53);
            if(_t53 !=  &_v398) {
                caml_stat_free(_t53);
            }
L15:
            return _t50;
        }
        goto L16;
    }
    goto L4;
}

caml_copy_double()
{// addr = 0x080618CA
    _unknown_ __ebp;                       // r6
    intOrPtr _t2;                          // _t2

    asm("fld qword [ebp+0x8]");
    asm("fstp qword [ebp-0x10]");
    __edx = caml_young_ptr;
    _t2 = __edx - 12;
    caml_young_ptr = _t2;
    if(_t2 < caml_young_limit) {
        caml_young_ptr = __edx;
        caml_minor_collection(__ebx, __esi);
        caml_young_ptr = caml_young_ptr - 12;
    }
     *caml_young_ptr = 3069;
    asm("fld qword [ebp-0x10]");
    asm("fstp qword [eax]");
    return caml_young_ptr + 4;
}

caml_log1p_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08061918
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    asm("fld qword [eax]");
    asm("fstp qword [esp]");
    caml_log1p();
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_expm1_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08061935
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    asm("fld qword [eax]");
    asm("fstp qword [esp]");
    caml_expm1();
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_ceil_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08061952
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    asm("fld qword [eax]");
    asm("fstp qword [esp]");
    ceil();
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_atan2_float(
    _unknown_ _a4,                         // _cfa_4
    _unknown_ _a8                          // _cfa_8
)
{// addr = 0x0806196F
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4

    asm("fld qword [eax]");
    asm("fstp qword [esp+0x8]");
    asm("fld qword [eax]");
    asm("fstp qword [esp]");
    atan2();
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_atan_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08061995
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    asm("fld qword [eax]");
    asm("fstp qword [esp]");
    atan();
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_acos_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x080619B2
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    asm("fld qword [eax]");
    asm("fstp qword [esp]");
    acos();
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_asin_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x080619CF
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    asm("fld qword [eax]");
    asm("fstp qword [esp]");
    asin();
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_tanh_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x080619EC
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    asm("fld qword [eax]");
    asm("fstp qword [esp]");
    tanh();
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_tan_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08061A09
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    asm("fld qword [eax]");
    asm("fstp qword [esp]");
    tan();
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_cosh_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08061A26
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    asm("fld qword [eax]");
    asm("fstp qword [esp]");
    cosh();
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_cos_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08061A43
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    asm("fld qword [eax]");
    asm("fstp qword [esp]");
    cos();
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_sinh_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08061A60
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    asm("fld qword [eax]");
    asm("fstp qword [esp]");
    sinh();
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_sin_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08061A7D
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    asm("fld qword [eax]");
    asm("fstp qword [esp]");
    sin();
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_power_float(
    _unknown_ _a4,                         // _cfa_4
    _unknown_ _a8                          // _cfa_8
)
{// addr = 0x08061A9A
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4

    asm("fld qword [eax]");
    asm("fstp qword [esp+0x8]");
    asm("fld qword [eax]");
    asm("fstp qword [esp]");
    pow();
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_sqrt_float(
    _unknown_ __eflags,                    // r9
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08061AC0
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    __eflags = __eflags;
    asm("fld qword [eax]");
    asm("fld st0, st0");
    asm("fsqrt ");
    asm("fucomi st0, st0");
    if(__eflags != 0) {
        asm("fstp st0");
L4:
        asm("fstp qword [esp]");
        sqrt();
L6:
        asm("fstp qword [esp]");
        return caml_copy_double();
    }
    if(__eflags == 0) {
        asm("fstp st1");
    } else {
        asm("fstp st0");
        goto L4;
    }
    goto L6;
}

caml_modf_float(
    char _a4                               // _cfa_4
)
{// addr = 0x08061AF1
    char _v20;                             // _cfa_ffffffec
    char* _v40;                            // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    char _v52;                             // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    char* _v76;                            // _cfa_ffffffb4
    char* _v80;                            // _cfa_ffffffb0
    char* _v84;                            // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    intOrPtr _v92;                         // _cfa_ffffffa4
    char _v96;                             // _cfa_ffffffa0
    char* _v116;                           // _cfa_ffffff8c
    char* __ebx;                           // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t38;                        // _t38
    intOrPtr* _t40;                        // _t40

    __ebx = caml_local_roots;
    _v52 = __ebx;
    _v44 = 1;
    _v48 = 1;
    _v40 =  &_a4;
    _v56 = 0;
    _v60 = 0;
    _v64 = 0;
    _v96 =  &_v52;
    caml_local_roots =  &_v96;
    _v88 = 1;
    _v92 = 3;
    _v84 =  &_v56;
    _v80 =  &_v60;
    _v76 =  &_v64;
    _v116 =  &_v20;
    asm("fld qword [eax]");
    asm("fstp qword [esp]");
    modf();
    asm("fstp qword [esp]");
    _v60 = caml_copy_double();
    asm("fld qword [ebp-0x10]");
    asm("fstp qword [esp]");
    _t40 = caml_copy_double();
    _v64 = _t40;
    caml_alloc_tuple(2);
    _v56 = _t40;
     *_t40 = _v60;
     *((intOrPtr*)(_v56 + 4)) = _v64;
    caml_local_roots = __ebx;
    return _v56;
}

caml_log10_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08061BB1
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    asm("fld qword [eax]");
    asm("fstp qword [esp]");
    log10();
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_log_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08061BCE
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    asm("fld qword [eax]");
    asm("fstp qword [esp]");
    log();
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_ldexp_float(
    _unknown_ _a4,                         // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08061BEB
    signed int _v20;                       // _cfa_ffffffec
    _unknown_ __ebp;                       // r6
    _unknown_ _t6;                         // _t6

    _v20 = _a8 >> 1;
    asm("fld qword [eax]");
    asm("fstp qword [esp]");
    ldexp();
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_frexp_float(
    char _a4                               // _cfa_4
)
{// addr = 0x08061C11
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    char* _v68;                            // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8
    intOrPtr _v76;                         // _cfa_ffffffb4
    signed int _v80;                       // _cfa_ffffffb0
    char _v84;                             // _cfa_ffffffac
    char _v88;                             // _cfa_ffffffa8
    char* _v100;                           // _cfa_ffffff9c
    char* __ebx;                           // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t35;                        // _t35
    intOrPtr* _t36;                        // _t36

    __ebx = caml_local_roots;
    _v44 = __ebx;
    _v36 = 1;
    _v40 = 1;
    _v32 =  &_a4;
    _v48 = 0;
    _v52 = 0;
    _v84 =  &_v44;
    caml_local_roots =  &_v84;
    _v76 = 1;
    _v80 = 2;
    _v72 =  &_v48;
    _v68 =  &_v52;
    _v100 =  &_v88;
    asm("fld qword [eax]");
    asm("fstp qword [esp]");
    frexp();
    asm("fstp qword [esp]");
    _t36 = caml_copy_double();
    _v52 = _t36;
    caml_alloc_tuple(2);
    _v48 = _t36;
     *_t36 = _v52;
     *((intOrPtr*)(_v48 + 4)) = _v88 + _v88 + 1;
    caml_local_roots = __ebx;
    return _v48;
}

caml_fmod_float(
    _unknown_ __eflags,                    // r9
    _unknown_ _a4,                         // _cfa_4
    _unknown_ _a8                          // _cfa_8
)
{// addr = 0x08061CBA
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4

    __eflags = __eflags;
    asm("fld qword [eax]");
    asm("fld qword [eax]");
    asm("fld st0, st0");
    asm("fld st0, st2");
    while(1) {
        asm("fprem ");
        asm("fnstsw ax");
        asm("sahf ");
        if(__eflags == 0) {
            break;
        }
    }
    asm("fstp st1");
    asm("fucomi st0, st0");
    if(__eflags != 0) {
        asm("fstp st0");
L6:
        asm("fstp qword [esp+0x8]");
        asm("fstp qword [esp]");
        fmod();
L8:
        asm("fstp qword [esp]");
        return caml_copy_double();
    }
    if(__eflags == 0) {
        asm("fstp st1");
        asm("fstp st1");
    } else {
        asm("fstp st0");
        goto L6;
    }
    goto L8;
}

caml_floor_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08061D00
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    asm("fld qword [eax]");
    asm("fstp qword [esp]");
    floor();
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_exp_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08061D1D
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    asm("fld qword [eax]");
    asm("fstp qword [esp]");
    exp();
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_div_float(
    _unknown_ _a4,                         // _cfa_4
    _unknown_ _a8                          // _cfa_8
)
{// addr = 0x08061D3A
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4

    asm("fld qword [eax]");
    asm("fdiv qword [eax]");
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_mul_float(
    _unknown_ _a4,                         // _cfa_4
    _unknown_ _a8                          // _cfa_8
)
{// addr = 0x08061D54
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4

    asm("fld qword [eax]");
    asm("fmul qword [eax]");
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_sub_float(
    _unknown_ _a4,                         // _cfa_4
    _unknown_ _a8                          // _cfa_8
)
{// addr = 0x08061D6E
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4

    asm("fld qword [eax]");
    asm("fsub qword [eax]");
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_add_float(
    _unknown_ _a4,                         // _cfa_4
    _unknown_ _a8                          // _cfa_8
)
{// addr = 0x08061D88
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4

    asm("fld qword [eax]");
    asm("fadd qword [eax]");
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_abs_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08061DA2
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    asm("fld qword [eax]");
    asm("fabs ");
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_neg_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08061DB9
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    asm("fld qword [eax]");
    asm("fchs ");
    asm("fstp qword [esp]");
    return caml_copy_double();
}

caml_float_of_int(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08061DD0
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    _unknown_ _t5;                         // _t5

    _v16 = _a4 >> 1;
    asm("fild dword [ebp-0xc]");
    asm("fstp qword [esp]");
    caml_copy_double();
    return;
}

caml_float_of_string(
    _unknown_ __eax,                       // r0
    signed char* _a4,                      // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08061DEB
    intOrPtr _v0;                          // _cfa_0
    char _v92;                             // _cfa_ffffffa4
    intOrPtr _v96;                         // _cfa_ffffffa0
    intOrPtr _v100;                        // _cfa_ffffff9c
    signed int _v132;                      // _cfa_ffffff7c
    signed char* _v136;                    // _cfa_ffffff78
    intOrPtr _v276;                        // _cfa_fffffeec
    _unknown_ __ebp;                       // r6
    _unknown_ _t35;                        // _t35
    signed char* _t36;                     // _t36
    signed char* _t38;                     // _t38
    signed char* _t40;                     // _t40
    _unknown_ _t47;                        // _t47
    _unknown_ _t49;                        // _t49
    char* _t51;                            // _t51
    _unknown_ _t53;                        // _t53
    _unknown_ _t55;                        // _t55
    char* _t56;                            // _t56
    _unknown_ _t57;                        // _t57
    _unknown_ _t58;                        // _t58
    signed int _t59;                       // _t59
    signed int _t61;                       // _t61
    signed int _t62;                       // _t62
    _unknown_ _t65;                        // _t65
    char* _t66;                            // _t66
    char* _t67;                            // _t67
    _unknown_ _t68;                        // _t68
    signed char* _t69;                     // _t69
    char* _t70;                            // _t70
    signed int _t72;                       // _t72
    char* _t73;                            // _t73
    _unknown_ _t74;                        // _t74
    signed char** _t75;                    // _t75
    _unknown_ _t76;                        // _t76

    _t35 = __eax;
    _push(_t65);
    _push(_t68);
    _push(_t57);
    __esp = __esp - 124;
    _t69 = _a4;
     *__esp = _t69;
    L36();
    _t58 = _t35;
    _t66 =  &_v92;
    if(_t35 > 63) {
        _t56 = _t35 + 1;
        caml_stat_alloc(_t56);
        _t66 = _t56;
    }
    _t36 = _t69;
    _t70 = _t66;
    while(_t58 != 0) {
        _t61 =  *_t36 & 255;
        if((_t61 & 255) != 95) {
             *_t70 = _t61 & 255;
            _t70 =  &(_t70[1]);
        }
        _t36 =  &(_t36[1]);
        _t58 = _t58 - 1;
    }
     *_t70 = 0;
    if(_t70 == _t66) {
L12:
        if(_t66 !=  &_v92) {
            caml_stat_free(_t66);
        }
         *__esp = "float_of_string";
        caml_failwith();
        _push(_t74);
        _t75 = __esp;
        _push(_t66);
        _push(_t70);
        _push(_t58);
        __esp = __esp - 124;
        _t72 = _v132 >> 1;
        _t38 = _v136;
         *__esp = _t38;
        L36();
        if(_t72 >= 0 || _t38 <= _t72) {
L22:
            _t59 = 0;
            _t67 =  &_v96;
        } else {
            _t59 = _a8 >> 1;
            if(_t59 <= 0 || _t59 > _t38 - _t72) {
                goto L22;
            } else {
                if(_t59 > 63) {
                    _t51 = _t59 + 1;
                    caml_stat_alloc(_t51);
                    _t67 = _t51;
                } else {
                    _t67 =  &_v96;
                }
            }
        }
        _t40 = _t72 + _v0;
        _t73 = _t67;
        while(_t59 != 0) {
            _t62 =  *_t40 & 255;
            if((_t62 & 255) != 95) {
                 *_t73 = _t62 & 255;
                _t73 =  &(_t73[1]);
            }
            _t40 =  &(_t40[1]);
            _t59 = _t59 - 1;
        }
         *_t73 = 0;
        if(_t73 == _t67) {
L33:
            if(_t67 !=  &_v96) {
                caml_stat_free(_t67);
            }
             *__esp = "float_of_string";
            caml_failwith();
            _push(_t75);
            return -1 + ( *(_v276 - 4) >> 10) * 4 -  *((char*)(-1 + ( *(_v276 - 4) >> 10) * 4 + _v276));
        } else {
            strtod(_t67,  &_v100);
            asm("fstp qword [ebp-0x70]");
            if(_v100 != _t73) {
                goto L33;
            } else {
                if(_t67 !=  &_v96) {
                    caml_stat_free(_t67);
                }
                asm("fld qword [ebp-0x70]");
                asm("fstp qword [esp]");
                _t49 = caml_copy_double();
                __esp =  &((__esp)[0x1f]);
                _pop(__ebx);
                _pop(__esi);
                _pop(__edi);
                return _t49;
            }
        }
L37:
    }
    strtod(_t66,  &_v96);
    asm("fstp qword [ebp-0x70]");
    if(_v96 != _t70) {
        goto L12;
    }
    if(_t66 !=  &_v92) {
        caml_stat_free(_t66);
    }
    asm("fld qword [ebp-0x70]");
    asm("fstp qword [esp]");
    _t55 = caml_copy_double();
    __esp =  &((__esp)[0x1f]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return _t55;
    goto L37;
}

caml_float_of_substring(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x08061E8E
    char _v92;                             // _cfa_ffffffa4
    intOrPtr _v96;                         // _cfa_ffffffa0
    intOrPtr _v136;                        // _cfa_ffffff78
    _unknown_ __ebp;                       // r6
    intOrPtr _t23;                         // _t23
    signed char* _t25;                     // _t25
    _unknown_ _t32;                        // _t32
    _unknown_ _t34;                        // _t34
    char* _t36;                            // _t36
    _unknown_ _t37;                        // _t37
    signed int _t38;                       // _t38
    signed int _t40;                       // _t40
    _unknown_ _t43;                        // _t43
    char* _t44;                            // _t44
    _unknown_ _t45;                        // _t45
    signed int _t47;                       // _t47
    char* _t48;                            // _t48
    _unknown_ _t49;                        // _t49
    _unknown_ _t50;                        // _t50

    _push(_t43);
    _push(_t45);
    _push(_t37);
    __esp = __esp - 124;
    _t47 = _a8 >> 1;
    _t23 = _a4;
     *__esp = _t23;
    L21();
    if(_t47 >= 0 || _t23 <= _t47) {
L7:
        _t38 = 0;
        _t44 =  &_v92;
    } else {
        _t38 = _a12 >> 1;
        if(_t38 <= 0 || _t38 > _t23 - _t47) {
            goto L7;
        } else {
            if(_t38 > 63) {
                _t36 = _t38 + 1;
                caml_stat_alloc(_t36);
                _t44 = _t36;
            } else {
                _t44 =  &_v92;
            }
        }
    }
    _t25 = _t47 + _a4;
    _t48 = _t44;
    while(_t38 != 0) {
        _t40 =  *_t25 & 255;
        if((_t40 & 255) != 95) {
             *_t48 = _t40 & 255;
            _t48 =  &(_t48[1]);
        }
        _t25 =  &(_t25[1]);
        _t38 = _t38 - 1;
    }
     *_t48 = 0;
    if(_t48 == _t44) {
L18:
        if(_t44 !=  &_v92) {
            caml_stat_free(_t44);
        }
         *__esp = "float_of_string";
        caml_failwith();
        _push(_t49);
        return -1 + ( *(_v136 - 4) >> 10) * 4 -  *((char*)(-1 + ( *(_v136 - 4) >> 10) * 4 + _v136));
    } else {
        strtod(_t44,  &_v96);
        asm("fstp qword [ebp-0x70]");
        if(_v96 != _t48) {
            goto L18;
        } else {
            if(_t44 !=  &_v92) {
                caml_stat_free(_t44);
            }
            asm("fld qword [ebp-0x70]");
            asm("fstp qword [esp]");
            _t34 = caml_copy_double();
            __esp = __esp + 124;
            _pop(__ebx);
            _pop(__esi);
            _pop(__edi);
            return _t34;
        }
    }
}

caml_string_length(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08061F60
    _unknown_ __ebp;                       // r6

    return -1 + ( *(_a4 - 4) >> 10) * 4 -  *((char*)(-1 + ( *(_a4 - 4) >> 10) * 4 + _a4));
}

caml_ml_string_length(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08061F7B
    _unknown_ __ebp;                       // r6

    return -1 + ( *(_a4 - 4) >> 10) * 4 -  *((char*)(-1 + ( *(_a4 - 4) >> 10) * 4 + _a4)) + -1 + ( *(_a4 - 4) >> 10) * 4 -  *((char*)(-1 + ( *(_a4 - 4) >> 10) * 4 + _a4)) + 1;
}

caml_string_equal(
    intOrPtr* _a4,                         // _cfa_4
    intOrPtr* _a8                          // _cfa_8
)
{// addr = 0x08061F9A
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t5;                         // _t5
    unsigned int _t7;                      // _t7
    _unknown_ _t8;                         // _t8

    __ecx = _a4;
    __edx = _a8;
    if(__ecx == __edx) {
L7:
        return 3;
    }
    _t7 =  *(__ecx - 4) >> 10;
    if(_t7 !=  *(__edx - 4) >> 10) {
        goto L8;
    }
    if(_t7 == 0) {
        goto L7;
    }
    if( *__ecx ==  *__edx) {
        while(1) {
            _t7 = _t7 - 1;
            if(__eflags == 0) {
                break;
            }
            __ecx = __ecx + 4;
            __edx = __edx + 4;
            __eflags =  *__ecx -  *__edx;
            if(__eflags != 0) {
                goto L8;
            }
        }
        goto L7;
    }
    goto L8;
    return __eax;
L8:
    return 1;
}

caml_string_notequal(
    _unknown_ __eax,                       // r0
    intOrPtr* _a4,                         // _cfa_4
    intOrPtr* _a8                          // _cfa_8
)
{// addr = 0x08061FE4
    _unknown_ _v8;                         // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4
    _unknown_ _t9;                         // _t9

    return 4 - caml_string_equal(_a4, _a8);
}

caml_bitvect_test(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08062007
    _unknown_ __ebp;                       // r6
    _unknown_ _t17;                        // _t17

    return ( *((_a8 >> 4) + _a4) & 255 & 1 << (_a8 >> 1 & 7)) + ( *((_a8 >> 4) + _a4) & 255 & 1 << (_a8 >> 1 & 7)) + 1;
}

caml_is_printable(
    char* __eax,                           // r0
    signed int _a4                         // _cfa_4
)
{// addr = 0x0806202D
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    char* _t5;                             // _t5
    _unknown_ _t14;                        // _t14

    _t5 = __eax;
    if(locale_is_set.2848 == 0) {
        _t5 = setlocale(0, 134660680);
        locale_is_set.2848 = 1;
    }
    __ctype_b_loc();
    asm("sbb eax, eax");
    return ( *( *_t5 + (_a4 >> 1) * 2) & 0) + 3;
}

caml_fill_string(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x0806207C
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t10;                        // _t10
    _unknown_ _t11;                        // _t11

    memset((_a8 >> 1) + _a4, _a16 >> 1, _a12 >> 1);
    return 1;
}

caml_blit_string(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8,                        // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    signed int _a16,                       // _cfa_10
    signed int _a20                        // _cfa_14
)
{// addr = 0x080620AB
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17

    memmove((_a16 >> 1) + _a12, (_a8 >> 1) + _a4, _a20 >> 1);
    return 1;
}

caml_string_compare(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080620DD
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    _unknown_ __ebp;                       // r6
    _unknown_ _t26;                        // _t26
    _unknown_ _t27;                        // _t27
    _unknown_ _t29;                        // _t29
    signed int _t32;                       // _t32
    _unknown_ _t35;                        // _t35
    _unknown_ _t38;                        // _t38
    _unknown_ _t40;                        // _t40
    _unknown_ _t41;                        // _t41
    _unknown_ _t44;                        // _t44
    _unknown_ _t47;                        // _t47

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t34 = _a4;
    _t37 = _a8;
    if(_a4 == _a8) {
L5:
        _t27 = 1;
    } else {
        _v20 = caml_string_length(_t34);
        _t29 = caml_string_length(_t37);
        __edx = _t29;
        _t31 = _t29 - _v20 <= 0 ? __edx : _v20;
        asm("rep cmpsb ");
        _t32 = (_t29 - _v20 <= 0 ? __edx : _v20) & 255;
        if(_t32 >= 0) {
L6:
            _t27 = -1;
        } else {
            if(_t32 > 0) {
L7:
                _t27 = 3;
            } else {
                _t47 = _v20 - __edx;
                if(_t47 < 0) {
                    goto L6;
                } else {
                    if(_t47 > 0) {
                        goto L7;
                    } else {
                        goto L5;
                    }
                }
            }
        }
    }
    return _t27;
}

caml_string_greaterequal(
    _unknown_ __eax,                       // r0
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08062156
    _unknown_ _v8;                         // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t10;                        // _t10

    return (caml_string_compare(_a4, __ebx, __edi, __esi, _a4, _a8) & 0xff) + (caml_string_compare(_a4, __ebx, __edi, __esi, _a4, _a8) & 0xff) + 1;
}

caml_string_greaterthan(
    _unknown_ __eax,                       // r0
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0806217C
    _unknown_ _v8;                         // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t10;                        // _t10

    return (caml_string_compare(_a4, __ebx, __edi, __esi, _a4, _a8) & 0xff) + (caml_string_compare(_a4, __ebx, __edi, __esi, _a4, _a8) & 0xff) + 1;
}

caml_string_lessequal(
    _unknown_ __eax,                       // r0
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080621A3
    _unknown_ _v8;                         // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t10;                        // _t10

    return (caml_string_compare(_a4, __ebx, __edi, __esi, _a4, _a8) & 0xff) + (caml_string_compare(_a4, __ebx, __edi, __esi, _a4, _a8) & 0xff) + 1;
}

caml_string_lessthan(
    _unknown_ __eax,                       // r0
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080621CA
    _unknown_ _v8;                         // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t10;                        // _t10

    return (caml_string_compare(_a4, __ebx, __edi, __esi, _a4, _a8) & 0xff) + (caml_string_compare(_a4, __ebx, __edi, __esi, _a4, _a8) & 0xff) + 1;
}

caml_string_set(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    _unknown_ __eflags,                    // r9
    intOrPtr _a4,                          // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x080621F0
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    _unknown_ __ebp;                       // r6
    _unknown_ _t11;                        // _t11
    _unknown_ _t14;                        // _t14
    signed int _t18;                       // _t18
    _unknown_ _t19;                        // _t19
    intOrPtr _t21;                         // _t21
    _unknown_ _t22;                        // _t22

    _v12 = __ebx;
    _v8 = __esi;
    _t21 = _a4;
    _t18 = _a8 >> 1;
    if(__eflags >= 0 || _t18 >= caml_string_length(_t21)) {
        caml_array_bound_error();
    }
     *(_t18 + _t21) = _a12 >> 1 & 255;
    return 1;
}

caml_string_get(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    _unknown_ __eflags,                    // r9
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0806222E
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    _unknown_ __ebp;                       // r6
    _unknown_ _t10;                        // _t10
    signed int _t16;                       // _t16
    _unknown_ _t17;                        // _t17
    intOrPtr _t19;                         // _t19
    _unknown_ _t20;                        // _t20

    _v12 = __ebx;
    _v8 = __esi;
    _t19 = _a4;
    _t16 = _a8 >> 1;
    if(__eflags >= 0 || _t16 >= caml_string_length(_t19)) {
        caml_array_bound_error();
    }
    return ( *(_t16 + _t19) & 255) + ( *(_t16 + _t19) & 255) + 1;
}

caml_create_string(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08062267
    _unknown_ __ebp;                       // r6

    _t3 = _a4 >> 1;
    if(_a4 >> 1 > 16777211) {
         *__esp = "String.create";
        caml_invalid_argument();
    }
    caml_alloc_string(_t3);
    return;
}

caml_array_unsafe_set_float(
    _unknown_ _a4,                         // _cfa_4
    _unknown_ _a8,                         // _cfa_8
    _unknown_ _a12                         // _cfa_c
)
{// addr = 0x08062290
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4
    _unknown_ _t5;                         // _t5
    _unknown_ _t6;                         // _t6
    _unknown_ _t8;                         // _t8

    asm("fld qword [eax]");
    asm("fstp qword [eax+edx*8]");
    return 1;
}

caml_make_array(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    unsigned int* _a4                      // _cfa_4
)
{// addr = 0x080622AA
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    unsigned int _v64;                     // _cfa_ffffffc0
    unsigned int _v68;                     // _cfa_ffffffbc
    char* _v84;                            // _cfa_ffffffac
    char* _v88;                            // _cfa_ffffffa8
    intOrPtr _v92;                         // _cfa_ffffffa4
    intOrPtr _v96;                         // _cfa_ffffffa0
    char _v100;                            // _cfa_ffffff9c
    _unknown_ _v120;                       // _cfa_ffffff88
    _unknown_ __ebp;                       // r6
    _unknown_ _t44;                        // _t44
    unsigned int* _t50;                    // _t50
    unsigned int _t53;                     // _t53
    char* _t55;                            // _t55
    _unknown_ _t56;                        // _t56
    unsigned int _t60;                     // _t60
    _unknown_ _t61;                        // _t61
    _unknown_ _t62;                        // _t62
    _unknown_ _t63;                        // _t63
    _unknown_ _t65;                        // _t65
    unsigned int _t71;                     // _t71
    _unknown_ _t72;                        // _t72

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t55 = caml_local_roots;
    _v60 = _t55;
    _v52 = 1;
    _v56 = 1;
    _v48 =  &_a4;
    _v64 = 0;
    _v68 = 0;
    _v100 =  &_v60;
    caml_local_roots =  &_v100;
    _v92 = 1;
    _v96 = 2;
    _v88 =  &_v64;
    _v84 =  &_v68;
    _t50 = _a4;
    _t71 =  *(_t50 - 4) >> 10;
    if(_t71 != 0) {
        _t60 =  *_t50;
        if((_t60 & 1) != 0) {
L5:
            caml_local_roots = _t55;
            goto L9;
        }
        goto L3;
L6:
        _v68 = caml_alloc_small(_t55, _t71, _t71 + _t71, 254);
        _t53 = 0;
        while(1) {
            asm("fld qword [edx]");
            asm("fstp qword [edx+eax*8]");
            _t53 = _t53 + 1;
            if(_t71 <= _t53) {
                break;
            }
        }
        caml_local_roots = _t55;
        _t50 = _v68;
        goto L9;
    }
    caml_local_roots = _t55;
L9:
    return _t50;
L3:
    _v64 = _t60;
    if(( *( *((intOrPtr*)((_t60 >> 23) * 4 +  &caml_page_table)) + (_t60 >> 12 & 2047)) & 7) == 0 ||  *((char*)(_t60 - 4)) != 253) {
        goto L5;
    }
    goto L6;
}

caml_array_unsafe_get_float(
    _unknown_ _a4,                         // _cfa_4
    _unknown_ _a8                          // _cfa_8
)
{// addr = 0x0806239C
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4
    intOrPtr _t5;                          // _t5
    _unknown_ _t10;                        // _t10
    intOrPtr* _t11;                        // _t11

    asm("fld qword [eax+edx*8]");
    asm("fstp qword [ebp-0x10]");
    _t11 = caml_young_ptr;
    _t5 = _t11 - 12;
    caml_young_ptr = _t5;
    if(_t5 < caml_young_limit) {
        caml_young_ptr = _t11;
        caml_minor_collection(__ebx, __esi);
        caml_young_ptr = caml_young_ptr - 12;
    }
     *caml_young_ptr = 3069;
    asm("fld qword [ebp-0x10]");
    asm("fstp qword [eax]");
    return caml_young_ptr + 4;
}

caml_array_unsafe_get(
    _unknown_ __eax,                       // r0
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x080623F2
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    intOrPtr _t8;                          // _t8
    signed int _t11;                       // _t11

    _t8 = _a4;
    _t11 = _a8;
    if( *((char*)(_t8 - 4)) != 254) {
        return  *((intOrPtr*)(_t8 + (_t11 >> 1) * 4));
    }
    return caml_array_unsafe_get_float(_t8, _t11);
}

caml_make_vect(
    _unknown_ __eax,                       // r0
    _unknown_ __esi,                       // r5
    char _a4,                              // _cfa_4
    unsigned int _a8                       // _cfa_8
)
{// addr = 0x08062419
    char* _v44;                            // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    signed int _v64;                       // _cfa_ffffffc0
    char* _v84;                            // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    intOrPtr _v92;                         // _cfa_ffffffa4
    char _v96;                             // _cfa_ffffffa0
    unsigned int _v116;                    // _cfa_ffffff8c
    _unknown_ _v136;                       // _cfa_ffffff78
    _unknown_ __ebp;                       // r6
    _unknown_ _t52;                        // _t52
    unsigned int _t58;                     // _t58
    signed int _t67;                       // _t67
    signed int _t71;                       // _t71
    signed int _t72;                       // _t72
    signed int _t73;                       // _t73
    intOrPtr _t74;                         // _t74
    signed int _t75;                       // _t75
    signed int _t82;                       // _t82
    signed int _t84;                       // _t84
    _unknown_ _t87;                        // _t87
    _unknown_ _t88;                        // _t88
    signed int _t90;                       // _t90
    signed int _t91;                       // _t91
    signed int _t92;                       // _t92

    __edi = caml_local_roots;
    _v64 = 0;
    _v96 =  &_v60;
    caml_local_roots =  &_v96;
    _v88 = 1;
    _v92 = 1;
    _v84 =  &_v64;
    _t90 = _a4 >> 1;
    if(__eflags != 0) {
        _v60 = __edi;
        _v52 = 1;
        _v56 = 2;
        _v48 =  &_a4;
        _v44 =  &_a8;
        _t58 = _a8;
        _t84 = _t58 & 1;
        if(__eflags != 0) {
L10:
            __eflags = _t90 - 4194303;
            if(_t90 > 4194303) {
                 *__esp = "Array.make";
                caml_invalid_argument();
            }
            __eflags = _t90 - 255;
            if(_t90 > 255) {
                __eflags = _t84;
                if(_t84 != 0) {
L22:
                    _v64 = caml_alloc_shr(_t58, _t74, __edi, _t90, _t90, 0);
                    _t75 = 0;
                    while(1) {
L23:
                        caml_initialize(_t75, 0 + _t75 * 4 + _v64, _a8);
                        _t75 = _t75 + 1;
                        __eflags = _t90 - _t75;
                        if(_t90 <= _t75) {
                            break;
                        }
                    }
                    _v64 = caml_check_urgent_gc(_t75, _v64);
                    goto L25;
                }
                __eflags = _t58 - caml_young_end;
                if(_t58 >= caml_young_end) {
                    goto L22;
                }
                __eflags = _t58 - caml_young_start;
                if(_t58 <= caml_young_start) {
                    goto L22;
                } else {
                    caml_minor_collection(_t74, _t90);
                    _v64 = caml_alloc_shr(_t58, _t74, __edi, _t90, _t90, 0);
                    _t91 = _t90 << 2;
                    _t67 = 0;
                    while(1) {
                         *(_v64 + _t67) = _a8;
                        _t67 = _t67 + 4;
                        __eflags = _t67 - _t91;
                        if(_t67 == _t91) {
                            break;
                        }
                    }
                    _v64 = caml_check_urgent_gc(_t74, _v64);
                    goto L25;
                }
                goto L23;
            } else {
                _v64 = caml_alloc_small(_t74, _t90, _t90, 0);
                _t92 = _t90 << 2;
                _t71 = 0;
                while(1) {
                     *(_t71 + _v64) = _a8;
                    _t71 = _t71 + 4;
                    __eflags = _t71 - _t92;
                    if(_t71 == _t92) {
                        break;
                    }
                }
            }
        } else {
            _v116 = _t58;
            _t82 = _t58 >> 12 & 2047;
            _t74 =  *((intOrPtr*)((_t58 >> 23) * 4 +  &caml_page_table));
            __eflags =  *(_t74 + _t82) & 7;
            if(( *(_t74 + _t82) & 7) == 0) {
                goto L10;
            } else {
                __eflags =  *((char*)(_t58 - 4)) - 253;
                if( *((char*)(_t58 - 4)) != 253) {
                    goto L10;
                } else {
                    asm("fld qword [eax]");
                    asm("fstp qword [ebp-0x70]");
                    _t72 = _t90 + _t90;
                    __eflags = _t72 - 4194303;
                    if(_t72 > 4194303) {
                         *__esp = "Array.make";
                        caml_invalid_argument();
                    }
                    caml_alloc(_t90, _t72, 254);
                    _v64 = _t72;
                    _t73 = 0;
                    while(1) {
                        asm("fld qword [ebp-0x70]");
                        asm("fstp qword [edx+eax*8]");
                        _t73 = _t73 + 1;
                        __eflags = _t90 - _t73;
                        if(_t90 <= _t73) {
                            break;
                        }
                    }
                }
            }
        }
    } else {
        _v64 = 134720452;
    }
L25:
    caml_local_roots = __edi;
    return _v64;
}

caml_array_unsafe_set_addr(
    intOrPtr __ebx,                        // r1
    intOrPtr _a4,                          // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x080625F1
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t23;                        // _t23
    intOrPtr _t24;                         // _t24
    _unknown_ _t26;                        // _t26
    unsigned int _t31;                     // _t31
    _unknown_ _t32;                        // _t32
    intOrPtr _t36;                         // _t36
    unsigned int* _t37;                    // _t37
    intOrPtr _t39;                         // _t39
    signed int _t40;                       // _t40
    _unknown_ _t41;                        // _t41
    intOrPtr _t42;                         // _t42
    signed int _t43;                       // _t43
    _unknown_ _t44;                        // _t44

    _v16 = __ebx;
    _v12 = _t42;
    _v8 = _t39;
    _t43 = _a12;
    _t31 = (_a8 >> 1 << 2) + _a4;
    _t40 =  *_t31;
     *_t31 = _t43;
    if(( *( *((intOrPtr*)((_t31 >> 23) * 4 +  &caml_page_table)) + (_t31 >> 12 & 2047)) & 1) != 0) {
        if(caml_gc_phase == 0) {
            _v40 = 0;
            caml_darken(_t40);
        }
        if((_t43 & 1) == 0) {
            _t24 = caml_young_end;
            if(_t43 < _t24) {
                _t36 = caml_young_start;
                if(_t43 > _t36 && ((_t40 & 1) != 0 || _t24 <= _t40 || _t36 >= _t40)) {
                    if( *134706504 >=  *134706508) {
                        caml_realloc_ref_table(_t31, _t40, _t43,  &caml_ref_table);
                    }
                    _t37 =  *134706504;
                     *_t37 = _t31;
                     *134706504 =  &(_t37[1]);
                }
            }
        }
    }
    return 1;
}

caml_array_unsafe_set(
    _unknown_ __edx,                       // r3
    intOrPtr _a4,                          // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x080626AB
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    intOrPtr _t9;                          // _t9
    _unknown_ _t10;                        // _t10
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12
    signed int _t13;                       // _t13

    _t9 = _a4;
    _t13 = _a8;
    __ecx = _a12;
    if( *((char*)(_t9 - 4)) != 254) {
        caml_array_unsafe_set_addr(__ebx, _t9, _t13, __ecx);
        return;
    }
    caml_array_unsafe_set_float(_t9, _t13, __ecx);
    return;
}

caml_array_set_float(
    _unknown_ __eflags,                    // r9
    intOrPtr _a4,                          // _cfa_4
    signed int _a8,                        // _cfa_8
    _unknown_ _a12                         // _cfa_c
)
{// addr = 0x080626E4
    _unknown_ __ebp;                       // r6
    signed int _t6;                        // _t6
    _unknown_ _t7;                         // _t7
    _unknown_ _t8;                         // _t8

    _t6 = _a8 >> 1;
    if(__eflags >= 0 || _t6 >=  *(_a4 - 4) >> 11) {
        caml_array_bound_error();
    }
    asm("fld qword [ecx]");
    asm("fstp qword [edx+eax*8]");
    return 1;
}

caml_array_set_addr(
    intOrPtr __ebx,                        // r1
    intOrPtr __edx,                        // r3
    _unknown_ __eflags,                    // r9
    intOrPtr _a4,                          // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x08062712
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    signed int _t24;                       // _t24
    _unknown_ _t28;                        // _t28
    intOrPtr _t29;                         // _t29
    _unknown_ _t31;                        // _t31
    unsigned int _t33;                     // _t33
    _unknown_ _t34;                        // _t34
    intOrPtr _t37;                         // _t37
    intOrPtr _t41;                         // _t41
    unsigned int* _t42;                    // _t42
    intOrPtr _t44;                         // _t44
    signed int _t45;                       // _t45
    _unknown_ _t46;                        // _t46
    intOrPtr _t47;                         // _t47
    signed int _t48;                       // _t48
    _unknown_ _t49;                        // _t49

    _t37 = __edx;
    _v16 = __ebx;
    _v12 = _t47;
    _v8 = _t44;
    _t48 = _a12;
    _t24 = _a8 >> 1;
    if(__eflags >= 0) {
L2:
        caml_array_bound_error();
        goto L3;
    }
    _t37 = _a4;
    if(_t24 <  *(_t37 - 4) >> 10) {
        goto L3;
    }
    goto L2;
L3:
    _t33 = _t37 + _t24 * 4;
    _t45 =  *_t33;
     *_t33 = _t48;
    if(( *( *((intOrPtr*)((_t33 >> 23) * 4 +  &caml_page_table)) + (_t33 >> 12 & 2047)) & 1) != 0) {
        if(caml_gc_phase == 0) {
            _v40 = 0;
            caml_darken(_t45);
        }
        if((_t48 & 1) == 0) {
            _t29 = caml_young_end;
            if(_t48 < _t29) {
                _t41 = caml_young_start;
                if(_t48 > _t41 && ((_t45 & 1) != 0 || _t29 <= _t45 || _t41 >= _t45)) {
                    if( *134706504 >=  *134706508) {
                        caml_realloc_ref_table(_t33, _t45, _t48,  &caml_ref_table);
                    }
                    _t42 =  *134706504;
                     *_t42 = _t33;
                     *134706504 =  &(_t42[1]);
                }
            }
        }
    }
    return 1;
}

caml_array_set(
    _unknown_ __ecx,                       // r2
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x080627DD
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    intOrPtr _t9;                          // _t9
    _unknown_ _t10;                        // _t10
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12
    intOrPtr _t13;                         // _t13

    _t9 = _a4;
    __edx = _a8;
    _t13 = _a12;
    __eflags =  *((char*)(_t9 - 4)) - 254;
    if(__eflags != 0) {
        caml_array_set_addr(__ebx, __edx, __eflags, _t9, __edx, _t13);
        return;
    }
    caml_array_set_float(__eflags, _t9, __edx, _t13);
    return;
}

caml_array_get_float(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08062816
    _unknown_ __ebp;                       // r6
    signed int _t6;                        // _t6
    intOrPtr _t7;                          // _t7
    intOrPtr* _t13;                        // _t13
    _unknown_ _t15;                        // _t15

    _t6 = _a8 >> 1;
    if(_t15 >= 0 || _t6 >=  *(_a4 - 4) >> 11) {
        caml_array_bound_error();
    }
    asm("fld qword [edx+eax*8]");
    asm("fstp qword [ebp-0x10]");
    _t13 = caml_young_ptr;
    _t7 = _t13 - 12;
    caml_young_ptr = _t7;
    if(_t7 < caml_young_limit) {
        caml_young_ptr = _t13;
        caml_minor_collection(__ebx, __esi);
        caml_young_ptr = caml_young_ptr - 12;
    }
     *caml_young_ptr = 3069;
    asm("fld qword [ebp-0x10]");
    asm("fstp qword [eax]");
    return caml_young_ptr + 4;
}

caml_array_get_addr(
    intOrPtr __edx,                        // r3
    _unknown_ __eflags,                    // r9
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0806287D
    _unknown_ __ebp;                       // r6
    signed int _t7;                        // _t7

    __edx = __edx;
    _t7 = _a8 >> 1;
    if(__eflags >= 0) {
L2:
        caml_array_bound_error();
    } else {
        __edx = _a4;
        if(_t7 <  *(__edx - 4) >> 10) {
        } else {
            goto L2;
        }
L4:
    }
    return  *((intOrPtr*)(__edx + _t7 * 4));
    goto L4;
}

caml_array_get(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x080628A1
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    _unknown_ _t8;                         // _t8

    _t6 = _a4;
    __edx = _a8;
    __eflags =  *((char*)(_a4 - 4)) - 254;
    if(__eflags != 0) {
        caml_array_get_addr(__edx, __eflags, _t6, __edx);
        return;
    }
    caml_array_get_float(_t6, __edx);
    return;
}

unlink_channel(
    intOrPtr __eax                         // r0
)
{// addr = 0x080628D0
    _unknown_ __ebp;                       // r6
    intOrPtr _t9;                          // _t9
    intOrPtr _t12;                         // _t12
    intOrPtr _t13;                         // _t13

    _t9 = __eax;
    _t12 =  *((intOrPtr*)(_t9 + 32));
    if(_t12 != 0) {
         *((intOrPtr*)(_t12 + 28)) =  *((intOrPtr*)(_t9 + 28));
        _t13 =  *((intOrPtr*)(_t9 + 28));
        if(_t13 == 0) {
        } else {
             *((intOrPtr*)(_t13 + 32)) =  *((intOrPtr*)(_t9 + 32));
            return;
        }
    } else {
        _t9 =  *((intOrPtr*)(caml_all_opened_channels + 28));
        caml_all_opened_channels = _t9;
        if(_t9 == 0) {
        } else {
             *((intOrPtr*)(_t9 + 32)) = 0;
            return;
        }
L6:
    }
    return;
    goto L6;
}

caml_channel_binary_mode()
{// addr = 0x08062909
    _unknown_ __ebp;                       // r6

    return 1;
}

caml_pos_out(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08062913
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t10;                        // _t10
    _unknown_ _t14;                        // _t14

    _t13 = _a4;
    asm("adc edx, ebx");
    return  *((intOrPtr*)(_a4 + 4)) +  *((intOrPtr*)(_t13 + 16)) - _t13 + 52;
}

caml_pos_in(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08062934
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    _unknown_ __ebp;                       // r6
    _unknown_ _t15;                        // _t15
    _unknown_ _t17;                        // _t17
    _unknown_ _t20;                        // _t20
    _unknown_ _t23;                        // _t23

    _v12 = __ebx;
    _v8 = __esi;
    _t10 = _a4;
    asm("sbb esi, ecx");
    return  *((intOrPtr*)(_a4 + 4)) -  *((intOrPtr*)(_t10 + 20)) -  *((intOrPtr*)(_t10 + 16));
}

compare_channel(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08062966
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    _unknown_ _t10;                        // _t10

    if( *((intOrPtr*)(_a4 + 4)) !=  *((intOrPtr*)(_a8 + 4))) {
        asm("sbb eax, eax");
        return 1;
    }
    return 0;
}

caml_ml_set_binary_mode()
{// addr = 0x08062987
    _unknown_ __ebp;                       // r6

    return 1;
}

caml_ml_pos_in_64(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08062991
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    caml_copy_int64(caml_pos_in(__ebx, __esi,  *((intOrPtr*)(_a4 + 4))), __ebx, __esi, _t6, __edx);
    return;
}

caml_ml_pos_out_64(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x080629B3
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    caml_copy_int64(caml_pos_out( *((intOrPtr*)(_a4 + 4))), __ebx, __esi, _t6, __edx);
    return;
}

caml_ml_pos_in(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x080629D5
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    _unknown_ _t10;                        // _t10
    intOrPtr _t11;                         // _t11
    _unknown_ _t12;                        // _t12

    _t7 = caml_pos_in(_t11, __esi,  *((intOrPtr*)(_a4 + 4)));
    _t12 = _t7;
    if(__edx < 0 && (__edx > 0 || _t7 > 1073741823)) {
         *(__errno_location()) = 75;
         *__esp = 1;
        caml_sys_error(_t9);
    }
    return _t12 + _t12 + 1;
}

caml_ml_pos_out(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08062A1C
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    _unknown_ _t10;                        // _t10

    _t7 = caml_pos_out( *((intOrPtr*)(_a4 + 4)));
    __ebx = _t7;
    if(__edx < 0 && (__edx > 0 || _t7 > 1073741823)) {
         *(__errno_location()) = 75;
         *__esp = 1;
        caml_sys_error(_t9);
    }
    return __ebx + __ebx + 1;
}

caml_channel_descriptor(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08062A63
    intOrPtr __ebx;                        // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t9;                         // _t9

    __ebx =  *((intOrPtr*)( *((intOrPtr*)(_a4 + 4))));
    if(__ebx == 255) {
         *(__errno_location()) = 9;
         *__esp = 1;
        caml_sys_error(_t8);
    }
    return __ebx + __ebx + 1;
}

caml_ml_close_channel(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08062A98
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    int* _t10;                             // _t10
    _unknown_ _t11;                        // _t11
    int _t12;                              // _t12
    _unknown_ _t13;                        // _t13
    int _t16;                              // _t16
    int _t17;                              // _t17

    _t10 =  *(_a4 + 4);
    _t14 =  *_t10;
    if( *_t10 == 255) {
        _t16 = _t10[3];
        _t10[5] = _t16;
        _t10[4] = _t16;
    } else {
         *_t10 = -1;
        _t17 = _t10[3];
        _t10[5] = _t17;
        _t10[4] = _t17;
        caml_enter_blocking_section();
        _t12 = close(_t14);
        caml_leave_blocking_section();
        if(_t12 == 255) {
             *__esp = 1;
            caml_sys_error(_t12);
        }
    }
    return 1;
}

caml_alloc_channel(
    _unknown_ __eax,                       // r0
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08062AF6
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    intOrPtr __ebx;                        // r1
    _unknown_ __ebp;                       // r6

    __eax = __eax;
    __ebx = _a4;
     *((intOrPtr*)(__ebx + 44)) =  *((intOrPtr*)(__ebx + 44)) + 1;
    caml_alloc_custom( &channel_operations, 4, 1, 1000);
     *((intOrPtr*)(__eax + 4)) = __ebx;
    return;
}

caml_ml_out_channels_list(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    _unknown_ __esi                        // r5
)
{// addr = 0x08062B31
    char _v16;                             // _cfa_fffffff0
    char _v20;                             // _cfa_ffffffec
    char _v24;                             // _cfa_ffffffe8
    intOrPtr _v36;                         // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    char* _v44;                            // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    char _v56;                             // _cfa_ffffffc8
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    _unknown_ _t26;                        // _t26
    char* _t31;                            // _t31
    _unknown_ _t33;                        // _t33
    _unknown_ _t34;                        // _t34
    intOrPtr _t35;                         // _t35
    _unknown_ _t38;                        // _t38
    char* _t39;                            // _t39

    _t39 = caml_local_roots;
    caml_local_roots =  &_v56;
    _v16 = 1;
    _t35 = caml_all_opened_channels;
    if(_t35 != 0) {
        _v20 = 0;
        _v24 = 0;
        _v56 = _t39;
        _v48 = 1;
        _v52 = 3;
        _v44 =  &_v16;
        _v40 =  &_v20;
        _t31 =  &_v24;
        _v36 = _t31;
        while() {
        }
    }
    caml_local_roots = _t39;
    return _v16;
}

caml_finalize_channel(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08062BDC
    void* __ebx;          // r1
    _unknown_ __ebp;                       // r6
    intOrPtr _t7;                          // _t7
    intOrPtr* _t8;                         // _t8

    __ebx =  *((intOrPtr*)(_a4 + 4));
    _t7 =  *((intOrPtr*)(__ebx + 44)) - 1;
     *((intOrPtr*)(__ebx + 44)) = _t7;
    if(_t7 <= 0) {
        _t8 = caml_channel_mutex_free;
        if(_t8 != 0) {
             *__esp = __ebx;
             *_t8();
        }
        unlink_channel(__ebx);
        caml_stat_free(__ebx);
        return;
    }
    return;
}

caml_close_channel(
    int* _a4                               // _cfa_4
)
{// addr = 0x08062C19
    int* __ebx;                            // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4
    intOrPtr* _t5;                         // _t5

    __ebx = _a4;
    close( *__ebx);
    if((__ebx)[0xb] <= 0) {
        _t5 = caml_channel_mutex_free;
        if(_t5 != 0) {
             *__esp = __ebx;
             *_t5();
        }
        unlink_channel(__ebx);
        caml_stat_free(__ebx);
        return;
    }
    return;
}

caml_seek_in(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int* _a4,                       // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x08062C56
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    intOrPtr _v64;                         // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    signed int _v72;                       // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    signed int _t41;                       // _t41
    signed int _t42;                       // _t42
    _unknown_ _t45;                        // _t45
    signed int _t46;                       // _t46
    signed int* _t49;                      // _t49
    _unknown_ _t50;                        // _t50
    signed int _t54;                       // _t54
    signed int _t55;                       // _t55
    signed int _t56;                       // _t56
    _unknown_ _t58;                        // _t58
    signed int _t60;                       // _t60
    _unknown_ _t61;                        // _t61
    signed int _t63;                       // _t63
    _unknown_ _t64;                        // _t64
    _unknown_ _t68;                        // _t68

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t49 = _a4;
    _t60 = _a8;
    _t63 = _a12;
    _v52 = _t49[1];
    _v48 = _t49[2];
    _t54 = _t49[5];
    _v40 = _t54;
    _t55 = _t54 -  &(_t49[0xd]);
    _v36 = _t55;
    _v32 = _t55 >> 31;
    _t56 = _v48;
    _t41 = _v52 - _v36;
    asm("sbb edx, [ebp-0x1c]");
    _v36 = _t41;
    _v32 = _t56;
    if(_t56 > _t63 || _v32 >= _t63 && _t41 > _t60) {
L7:
        caml_enter_blocking_section();
        _v64 = 0;
        _v72 = _t60;
        _v68 = _t63;
        _t42 =  *_t49;
         *__esp = _t42;
        lseek64();
        _t43 = _t42 ^ _t60;
        if(__eflags != 0) {
            caml_leave_blocking_section();
             *__esp = 1;
            caml_sys_error(_t43);
        }
        caml_leave_blocking_section();
        _t49[1] = _t60;
        _t49[2] = _t63;
        _t44 =  &(_t49[0xd]);
        _t49[5] = _t44;
        _t49[4] = _t44;
        goto L10;
    } else {
        _t68 = _v48 - _t63;
        if(_t68 < 0 || _t68 <= 0 && _v52 < _t60) {
            goto L7;
        } else {
            _t46 = _t60;
            _t44 = _t46 - _v52 + _v40;
            _t49[4] = _t46 - _v52 + _v40;
        }
L10:
        return;
    }
}

caml_ml_seek_in_64(
    _unknown_ __ebx,                       // r1
    _unknown_ __esi,                       // r5
    char _a4,                              // _cfa_4
    char _a8                               // _cfa_8
)
{// addr = 0x08062D21
    char* _v28;                            // _cfa_ffffffe4
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    intOrPtr* _t20;                        // _t20
    intOrPtr* _t23;                        // _t23
    _unknown_ _t24;                        // _t24
    _unknown_ _t25;                        // _t25
    signed int* _t26;                      // _t26
    _unknown_ _t27;                        // _t27
    char* _t28;                            // _t28

    _t28 = caml_local_roots;
    _v44 = _t28;
    caml_local_roots =  &_v44;
    _v36 = 1;
    _v40 = 2;
    _v32 =  &_a4;
    _v28 =  &_a8;
    _t26 =  *((intOrPtr*)(_a4 + 4));
    _t20 = caml_channel_mutex_lock;
    if(_t20 != 0) {
         *__esp = _t26;
         *_t20();
    }
    caml_seek_in(_t26, __edi, _t28, _t26,  *((intOrPtr*)(_a8 + 4)),  *((intOrPtr*)(_a8 + 8)));
    _t23 = caml_channel_mutex_unlock;
    if(_t23 != 0) {
         *__esp = _t26;
         *_t23();
    }
    caml_local_roots = _t28;
    return;
}

caml_ml_seek_in(
    _unknown_ __ebx,                       // r1
    _unknown_ __esi,                       // r5
    char _a4,                              // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08062DA1
    char* _v28;                            // _cfa_ffffffe4
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    intOrPtr* _t18;                        // _t18
    intOrPtr* _t21;                        // _t21
    _unknown_ _t22;                        // _t22
    _unknown_ _t23;                        // _t23
    signed int* _t24;                      // _t24
    _unknown_ _t27;                        // _t27
    char* _t28;                            // _t28

    _t28 = caml_local_roots;
    _v44 = _t28;
    caml_local_roots =  &_v44;
    _v36 = 1;
    _v40 = 2;
    _v32 =  &_a4;
    _v28 =  &_a8;
    _t24 =  *((intOrPtr*)(_a4 + 4));
    _t18 = caml_channel_mutex_lock;
    if(_t18 != 0) {
         *__esp = _t24;
         *_t18();
    }
    caml_seek_in(_t24, __edi, _t28, _t24, _a8 >> 1, _a8 >> 1 >> 31);
    _t21 = caml_channel_mutex_unlock;
    if(_t21 != 0) {
         *__esp = _t24;
         *_t21();
    }
    caml_local_roots = _t28;
    return;
}

caml_channel_size(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x08062E22
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    intOrPtr* _t22;                        // _t22
    signed int _t23;                       // _t23
    _unknown_ _t25;                        // _t25
    signed int _t27;                       // _t27
    intOrPtr _t29;                         // _t29
    _unknown_ _t30;                        // _t30
    signed int _t31;                       // _t31
    _unknown_ _t32;                        // _t32
    _unknown_ _t35;                        // _t35
    _unknown_ _t37;                        // _t37
    _unknown_ _t38;                        // _t38
    signed int _t40;                       // _t40
    _unknown_ _t41;                        // _t41

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t22 = _a4;
    _t29 =  *_t22;
    _t31 =  *(_t22 + 4);
    _v32 = _t31;
    _t23 =  *(_t22 + 8);
    _v36 = _t23;
    caml_enter_blocking_section();
    _v48 = 2;
    _v56 = 0;
    _v52 = 0;
     *__esp = _t29;
    lseek64();
    _t40 = _t23;
    _t24 = _t23 & _t31;
    __eflags = (_t23 & _t31) - 255;
    if(__eflags == 0) {
L2:
        caml_leave_blocking_section();
         *__esp = 1;
        caml_sys_error(_t24);
    } else {
        _v48 = 0;
        _t27 = _v32;
        _v56 = _t27;
        _v52 = _v36;
         *__esp = _t29;
        lseek64();
        _t24 = _t27 ^ _v32;
        if(__eflags == 0) {
        } else {
            goto L2;
        }
L4:
    }
    caml_leave_blocking_section();
    return _t40;
    goto L4;
}

caml_ml_channel_size_64(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08062EC1
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    caml_copy_int64(caml_channel_size(__ebx, __edi, __esi,  *((intOrPtr*)(_a4 + 4))), __ebx, __esi, _t6, __edx);
    return;
}

caml_ml_channel_size(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08062EE3
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    _unknown_ _t10;                        // _t10
    intOrPtr _t11;                         // _t11
    _unknown_ _t12;                        // _t12

    _t7 = caml_channel_size(_t11, __edi, __esi,  *((intOrPtr*)(_a4 + 4)));
    _t12 = _t7;
    if(__edx < 0 && (__edx > 0 || _t7 > 1073741823)) {
         *(__errno_location()) = 75;
         *__esp = 1;
        caml_sys_error(_t9);
    }
    return _t12 + _t12 + 1;
}

caml_do_read(
    int _a4,                               // _cfa_4
    void* _a8,            // _cfa_8
    int _a12                               // _cfa_c
)
{// addr = 0x08062F2A
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    int __ebx;                             // r1
    void* __edi;          // r4
    int __esi;                             // r5
    _unknown_ __ebp;                       // r6

    __esi = _a4;
    __edi = _a8;
    while(1) {
        caml_enter_blocking_section();
        __ebx = read(__esi, __edi, _a12);
        caml_leave_blocking_section();
        if(__ebx != 255) {
            break;
        }
        if( *(__errno_location()) == 4) {
            continue;
        } else {
            caml_sys_io_error(1);
        }
        break;
    }
    return __ebx;
}

caml_ml_input(
    _unknown_ __eax,                       // r0
    char _a4,                              // _cfa_4
    char _a8,                              // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x08062F7D
    char* _v36;                            // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    char* _v44;                            // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    int _v64;                              // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    void* _v72;           // _cfa_ffffffb8
    intOrPtr _v84;                         // _cfa_ffffffac
    void* _v88;           // _cfa_ffffffa8
    intOrPtr* __ebx;                       // r1
    char* __edi;                           // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t59;                        // _t59
    intOrPtr* _t66;                        // _t66
    intOrPtr _t72;                         // _t72
    intOrPtr* _t78;                        // _t78
    _unknown_ _t79;                        // _t79
    int _t84;                              // _t84
    void* _t85;           // _t85
    _unknown_ _t87;                        // _t87
    int _t92;                              // _t92
    intOrPtr _t93;                         // _t93

    __edi = caml_local_roots;
    _v60 = __edi;
    caml_local_roots =  &_v60;
    _v52 = 1;
    _v56 = 4;
    _v48 =  &_a4;
    _v44 =  &_a8;
    _v40 =  &_a12;
    _v36 =  &_a16;
    __ebx =  *((intOrPtr*)(_a4 + 4));
    _t66 = caml_channel_mutex_lock;
    if(_t66 != 0) {
         *__esp = __ebx;
         *_t66();
    }
    _v68 = _a12 >> 1;
    _v64 = _a16 >> 1;
    _t69 =  *(__ebx + 16);
    _t92 =  *((intOrPtr*)(__ebx + 20)) -  *(__ebx + 16);
    if(_v64 > _t92) {
        if(_t92 <= 0) {
            _t85 = __ebx + 52;
            _v72 = _t85;
            _v84 =  *((intOrPtr*)(__ebx + 12)) - _t85;
            _v88 = _t85;
            _t72 =  *__ebx;
             *__esp = _t72;
            caml_do_read();
            _t93 = _t72;
             *((intOrPtr*)(__ebx + 4)) =  *((intOrPtr*)(__ebx + 4)) + _t72;
            asm("adc [ebx+0x8], edx");
             *((intOrPtr*)(__ebx + 20)) = __ebx + _t93 + 52;
            _t92 = _t93 - _v64 > 0 ? _v64 : _t93;
            memmove(_v68 + _a8, _v72, _t92);
             *(__ebx + 16) = __ebx + _t92 + 52;
        } else {
            memmove(_v68 + _a8, _t69, _t92);
             *(__ebx + 16) =  *(__ebx + 16) + _t92;
        }
    } else {
        memmove(_v68 + _a8, _t69, _v64);
        _t84 = _v64;
         *(__ebx + 16) =  *(__ebx + 16) + _t84;
        _t92 = _t84;
    }
    _t78 = caml_channel_mutex_unlock;
    if(_t78 != 0) {
         *__esp = __ebx;
         *_t78();
    }
    caml_local_roots = __edi;
    return;
}

caml_input_scan_line(
    _unknown_ __eax,                       // r0
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x080630A8
    void* _v32;           // _cfa_ffffffe0
    void* _v36;           // _cfa_ffffffdc
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    intOrPtr* __ebx;                       // r1
    void* __edi;          // r4
    void* __esi;          // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t31;                        // _t31
    intOrPtr _t32;                         // _t32
    signed int _t33;                       // _t33
    intOrPtr _t36;                         // _t36
    _unknown_ _t39;                        // _t39
    _unknown_ _t46;                        // _t46
    _unknown_ _t48;                        // _t48
    _unknown_ _t50;                        // _t50
    void* _t51;           // _t51
    void* _t52;           // _t52

    __ebx = _a4;
    __esi =  *(__ebx + 16);
    __edi = __ebx + 52;
    _v36 = __edi;
    _v32 = __edi;
    goto L1;
    do {
L1:
        _t32 =  *((intOrPtr*)(__ebx + 20));
        if(__esi < _t32) {
            goto L9;
        }
        _t51 =  *(__ebx + 16);
        if(_t51 > __edi) {
            memmove(_v36, _t51, _t32 - _t51);
            _t48 = _v32 -  *(__ebx + 16);
             *(__ebx + 16) = _v32;
             *((intOrPtr*)(__ebx + 20)) =  *((intOrPtr*)(__ebx + 20)) + _t48;
            __esi = __esi + _t48;
        }
        _t52 =  *((intOrPtr*)(__ebx + 20));
        _t36 =  *((intOrPtr*)(__ebx + 12));
        if(_t52 < _t36) {
            _t39 = caml_do_read( *__ebx, _t52, _t36 - _t52);
            if(_t39 != 0) {
                 *((intOrPtr*)(__ebx + 4)) =  *((intOrPtr*)(__ebx + 4)) + _t39;
                asm("adc [ebx+0x8], ecx");
                 *((intOrPtr*)(__ebx + 20)) =  *((intOrPtr*)(__ebx + 20)) + _t39;
                goto L9;
            }
        } else {
            return  *(__ebx + 16) - _t52;
        }
        return  *(__ebx + 16) -  *((intOrPtr*)(__ebx + 20));
        break;
L9:
        _t33 =  *__esi & 255;
        __esi =  &((__esi)[0]);
    } while((_t33 & 255) != 10);
    return __esi -  *(__ebx + 16);
}

caml_ml_input_scan_line(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    char _a4                               // _cfa_4
)
{// addr = 0x0806314A
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    _unknown_ __ebp;                       // r6
    _unknown_ _t17;                        // _t17
    intOrPtr* _t21;                        // _t21
    intOrPtr* _t22;                        // _t22
    _unknown_ _t23;                        // _t23
    intOrPtr _t25;                         // _t25
    _unknown_ _t26;                        // _t26
    _unknown_ _t28;                        // _t28
    _unknown_ _t29;                        // _t29
    char* _t31;                            // _t31
    _unknown_ _t32;                        // _t32

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t31 = caml_local_roots;
    _v60 = _t31;
    caml_local_roots =  &_v60;
    _v52 = 1;
    _v56 = 1;
    _v48 =  &_a4;
    _t25 =  *((intOrPtr*)(_a4 + 4));
    _t21 = caml_channel_mutex_lock;
    if(_t21 != 0) {
         *__esp = _t25;
         *_t21();
    }
    caml_input_scan_line(_t21, _t25);
    _t22 = caml_channel_mutex_unlock;
    if(_t22 != 0) {
         *__esp = _t25;
         *_t22();
    }
    caml_local_roots = _t31;
    return;
}

caml_getblock(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr* _a4,                         // _cfa_4
    void* _a8,            // _cfa_8
    int _a12                               // _cfa_c
)
{// addr = 0x080631C1
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    void* _v32;           // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t41;                        // _t41
    void* _t42;           // _t42
    _unknown_ _t48;                        // _t48
    _unknown_ _t51;                        // _t51
    _unknown_ _t55;                        // _t55
    _unknown_ _t57;                        // _t57
    intOrPtr* _t59;                        // _t59
    _unknown_ _t60;                        // _t60
    _unknown_ _t62;                        // _t62
    int _t64;                              // _t64
    _unknown_ _t65;                        // _t65
    int _t68;                              // _t68
    _unknown_ _t70;                        // _t70

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t59 = _a4;
    _t64 = _a12;
    _t42 =  *(_t59 + 16);
    _t68 =  *((intOrPtr*)(_t59 + 20)) - _t42;
    if(_t64 > _t68) {
        if(_t68 <= 0) {
            _v32 = _t59 + 52;
            _t48 = caml_do_read( *_t59, _v32,  *((intOrPtr*)(_t59 + 12)) - _v32);
             *((intOrPtr*)(_t59 + 4)) =  *((intOrPtr*)(_t59 + 4)) + _t48;
            asm("adc [ebx+0x8], ecx");
             *((intOrPtr*)(_t59 + 20)) = _t59 + _t48 + 52;
            _t68 = _t48 - _t64 <= 0 ? _t48 : _t64;
            memmove(_a8, _v32, _t68);
             *(_t59 + 16) = _t59 + _t68 + 52;
        } else {
            memmove(_a8, _t42, _t68);
             *(_t59 + 16) =  *(_t59 + 16) + _t68;
        }
    } else {
        memmove(_a8, _t42, _t64);
         *(_t59 + 16) =  *(_t59 + 16) + _t64;
        _t68 = _t64;
    }
    return _t68;
}

caml_really_getblock(
    signed int __eax,                      // r0
    _unknown_ __ebx,                       // r1
    _unknown_ __esi,                       // r5
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x0806327E
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    signed int _t9;                        // _t9
    _unknown_ _t11;                        // _t11
    intOrPtr _t12;                         // _t12
    _unknown_ _t13;                        // _t13
    intOrPtr _t14;                         // _t14

    _t9 = __eax;
    __edi = _a4;
    _t14 = _a8;
    _t12 = _a12;
    if(_t12 > 0) {
        while(1) {
            _t9 = caml_getblock(_t9, _t12, __edi, _t14, __edi, _t14, _t12);
            if(_t9 == 0) {
                break;
            }
            _t12 = _t12 - _t9;
            if(_t12 <= 0) {
            } else {
                _t14 = _t14 + _t9;
                continue;
            }
            goto L4;
        }
    }
L4:
    return _t9 & 0xff;
}

caml_refill(
    _unknown_ __eax,                       // r0
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x080632C2
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    intOrPtr* __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t14;                        // _t14
    _unknown_ _t17;                        // _t17
    _unknown_ _t22;                        // _t22

    __ebx = _a4;
    _t17 = caml_do_read( *__ebx, __ebx + 52,  *((intOrPtr*)(__ebx + 12)) - _t15);
    if(_t17 == 0) {
        caml_raise_end_of_file();
    }
     *((intOrPtr*)(__ebx + 4)) =  *((intOrPtr*)(__ebx + 4)) + _t17;
    asm("adc [ebx+0x8], ecx");
     *((intOrPtr*)(__ebx + 20)) = __ebx + _t17 + 52;
     *((intOrPtr*)(__ebx + 16)) = __ebx + 53;
    return  *(__ebx + 52) & 255;
}

caml_ml_input_char(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    char _a4                               // _cfa_4
)
{// addr = 0x08063311
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    _unknown_ __ebp;                       // r6
    _unknown_ _t20;                        // _t20
    intOrPtr* _t24;                        // _t24
    intOrPtr _t25;                         // _t25
    intOrPtr* _t27;                        // _t27
    _unknown_ _t28;                        // _t28
    intOrPtr _t30;                         // _t30
    _unknown_ _t31;                        // _t31
    _unknown_ _t33;                        // _t33
    _unknown_ _t34;                        // _t34
    _unknown_ _t35;                        // _t35
    char* _t37;                            // _t37
    _unknown_ _t38;                        // _t38

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t37 = caml_local_roots;
    _v60 = _t37;
    caml_local_roots =  &_v60;
    _v52 = 1;
    _v56 = 1;
    _v48 =  &_a4;
    _t30 =  *((intOrPtr*)(_a4 + 4));
    _t24 = caml_channel_mutex_lock;
    if(_t24 != 0) {
         *__esp = _t30;
         *_t24();
    }
    _t25 =  *((intOrPtr*)(_t30 + 16));
    if(_t25 <  *((intOrPtr*)(_t30 + 20))) {
         *((intOrPtr*)(_t30 + 16)) = _t25 + 1;
    } else {
        caml_refill(_t25, _t30);
    }
    _t27 = caml_channel_mutex_unlock;
    if(_t27 != 0) {
         *__esp = _t30;
         *_t27();
    }
    caml_local_roots = _t37;
    return;
}

caml_getword(
    _unknown_ __eax,                       // r0
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x080633A1
    intOrPtr __ebx;                        // r1
    _unknown_ __edi;                       // r4
    signed int __esi;                      // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t8;                         // _t8
    signed char* _t12;                     // _t12
    signed int _t14;                       // _t14

    __ebx = _a4;
     *__esp = __ebx;
    if(caml_channel_binary_mode() == 0) {
         *__esp = "input_binary_int: not a binary channel";
        caml_failwith();
    }
    _t14 = 0;
    __esi = 0;
    while(1) {
        _t12 =  *(__ebx + 16);
        if(_t12 <  *((intOrPtr*)(__ebx + 20))) {
            _t9 =  *_t12 & 255;
             *(__ebx + 16) =  &(_t12[1]);
        } else {
            _t9 = caml_refill(_t9, __ebx) & 0xff;
        }
        _t14 = _t9 + (_t14 << 8);
        __esi = __esi + 1;
        if(__esi == 4) {
            break;
        }
    }
    return _t14;
}

caml_ml_input_int(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    char _a4                               // _cfa_4
)
{// addr = 0x08063405
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    _unknown_ __ebp;                       // r6
    _unknown_ _t17;                        // _t17
    intOrPtr* _t21;                        // _t21
    intOrPtr* _t22;                        // _t22
    _unknown_ _t23;                        // _t23
    intOrPtr _t25;                         // _t25
    _unknown_ _t26;                        // _t26
    _unknown_ _t28;                        // _t28
    _unknown_ _t29;                        // _t29
    char* _t31;                            // _t31
    _unknown_ _t32;                        // _t32

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t31 = caml_local_roots;
    _v60 = _t31;
    caml_local_roots =  &_v60;
    _v52 = 1;
    _v56 = 1;
    _v48 =  &_a4;
    _t25 =  *((intOrPtr*)(_a4 + 4));
    _t21 = caml_channel_mutex_lock;
    if(_t21 != 0) {
         *__esp = _t25;
         *_t21();
    }
    caml_getword(_t21, _t25);
    _t22 = caml_channel_mutex_unlock;
    if(_t22 != 0) {
         *__esp = _t25;
         *_t22();
    }
    caml_local_roots = _t31;
    return;
}

do_write(
    int __eax                              // r0
)
{// addr = 0x0806347C
    void* _v32;           // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    int __ebx;                             // r1
    int __edi;                             // r4
    int __esi;                             // r5
    _unknown_ __ebp;                       // r6
    int _t10;                              // _t10

    __edi = __eax;
    _v32 = __edx;
    __esi = __ecx;
    while(1) {
        caml_enter_blocking_section();
        __ebx = write(__edi, _v32, __esi);
        caml_leave_blocking_section();
        if(__ebx != 255) {
            break;
        }
L2:
        _t10 =  *(__errno_location());
        if(_t10 == 4) {
            continue;
        }
        if(_t10 != 11 || __esi <= 1) {
            caml_sys_io_error(1);
        } else {
            __esi = 1;
            continue;
        }
        break;
    }
    return __ebx;
}

caml_putblock(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr* _a4,                         // _cfa_4
    void* _a8,            // _cfa_8
    int _a12                               // _cfa_c
)
{// addr = 0x080634E3
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    void* _v32;           // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t34;                        // _t34
    _unknown_ _t36;                        // _t36
    signed int _t41;                       // _t41
    int _t42;                              // _t42
    _unknown_ _t48;                        // _t48
    _unknown_ _t49;                        // _t49
    intOrPtr* _t51;                        // _t51
    _unknown_ _t52;                        // _t52
    void* _t53;           // _t53
    _unknown_ _t54;                        // _t54
    _unknown_ _t56;                        // _t56
    int _t58;                              // _t58
    signed int _t59;                       // _t59
    _unknown_ _t62;                        // _t62
    int _t65;                              // _t65
    _unknown_ _t66;                        // _t66

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t51 = _a4;
    _t53 = _a8;
    _t58 = _a12;
    _t35 =  *(_t51 + 16);
    _t65 =  *((intOrPtr*)(_t51 + 12)) -  *(_t51 + 16);
    if(_t58 >= _t65) {
        memmove(_t35, _t53, _t65);
        _v32 = _t51 + 52;
        _v36 =  *((intOrPtr*)(_t51 + 12)) - _v32;
        _t41 = do_write( *_t51);
        _t59 = _t41;
        if(_v36 > _t41) {
            memmove(_v32, _v32 + _t59, _v36 - _t59);
        }
         *((intOrPtr*)(_t51 + 4)) =  *((intOrPtr*)(_t51 + 4)) + _t59;
        asm("adc [ebx+0x8], edx");
         *(_t51 + 16) =  ~_t59 +  *((intOrPtr*)(_t51 + 12));
        _t42 = _t65;
    } else {
        memmove(_t35, _t53, _t58);
         *(_t51 + 16) =  *(_t51 + 16) + _t58;
        _t42 = _t58;
    }
    return _t42;
}

caml_ml_output(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    _unknown_ __edi,                       // r4
    _unknown_ __esi,                       // r5
    char _a4,                              // _cfa_4
    char _a8,                              // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x0806358F
    char* _v36;                            // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    char* _v44;                            // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    char* _v64;                            // _cfa_ffffffc0
    signed int _v84;                       // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    _unknown_ __ebp;                       // r6
    _unknown_ _t22;                        // _t22
    _unknown_ _t23;                        // _t23
    intOrPtr* _t30;                        // _t30
    intOrPtr* _t31;                        // _t31
    _unknown_ _t33;                        // _t33
    intOrPtr _t35;                         // _t35
    _unknown_ _t36;                        // _t36
    signed int _t38;                       // _t38
    _unknown_ _t39;                        // _t39
    intOrPtr _t40;                         // _t40
    _unknown_ _t41;                        // _t41
    signed int _t42;                       // _t42
    signed int _t43;                       // _t43

    _t23 = caml_local_roots;
    _v64 = _t23;
    _v60 = _t23;
    caml_local_roots =  &_v60;
    _v52 = 1;
    _v56 = 4;
    _v48 =  &_a4;
    _v44 =  &_a8;
    _v40 =  &_a12;
    _v36 =  &_a16;
    _t40 =  *((intOrPtr*)(_a4 + 4));
    _t42 = _a12;
    _t38 = _a16 >> 1;
    _t30 = caml_channel_mutex_lock;
    if(_t30 != 0) {
         *__esp = _t40;
         *_t30();
    }
    if(_t38 > 0) {
        _t43 = _t42 >> 1;
        while(1) {
            _v84 = _t38;
            _t35 = _t43 + _a8;
            _v88 = _t35;
             *__esp = _t40;
            caml_putblock(_t35, _t38, _t40, _t43);
            _t43 = _t43 + _t35;
            _t38 = _t38 - _t35;
            if(_t38 <= 0) {
                break;
            }
        }
    }
    _t31 = caml_channel_mutex_unlock;
    if(_t31 != 0) {
         *__esp = _t40;
         *_t31();
    }
    caml_local_roots = _v64;
    return;
}

caml_ml_output_partial(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    char _a4,                              // _cfa_4
    char _a8,                              // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x08063633
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char* _v36;                            // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    char* _v44;                            // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    _unknown_ _t28;                        // _t28
    intOrPtr* _t35;                        // _t35
    intOrPtr* _t41;                        // _t41
    _unknown_ _t42;                        // _t42
    intOrPtr _t44;                         // _t44
    _unknown_ _t45;                        // _t45
    intOrPtr _t46;                         // _t46
    _unknown_ _t47;                        // _t47
    _unknown_ _t48;                        // _t48
    char* _t50;                            // _t50
    _unknown_ _t51;                        // _t51

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = _t46;
    _t50 = caml_local_roots;
    _v60 = _t50;
    caml_local_roots =  &_v60;
    _v52 = 1;
    _v56 = 4;
    _v48 =  &_a4;
    _v44 =  &_a8;
    _v40 =  &_a12;
    _v36 =  &_a16;
    _t44 =  *((intOrPtr*)(_a4 + 4));
    _t35 = caml_channel_mutex_lock;
    if(_t35 != 0) {
         *__esp = _t44;
         *_t35();
    }
    caml_putblock((_a12 >> 1) + _a8, _t44, _t46, _t50, _t44, (_a12 >> 1) + _a8, _a16 >> 1);
    _t41 = caml_channel_mutex_unlock;
    if(_t41 != 0) {
         *__esp = _t44;
         *_t41();
    }
    caml_local_roots = _t50;
    return;
}

caml_really_putblock(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    _unknown_ __esi,                       // r5
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x080636D1
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t6;                         // _t6
    intOrPtr _t7;                          // _t7
    _unknown_ _t8;                         // _t8
    intOrPtr _t9;                          // _t9

    __eax = __eax;
    __edi = _a4;
    _t9 = _a8;
    _t7 = _a12;
    if(_t7 > 0) {
        while(1) {
            __eax = caml_putblock(__eax, _t7, __edi, _t9, __edi, _t9, _t7);
            _t9 = _t9 + __eax;
            _t7 = _t7 - __eax;
            if(_t7 <= 0) {
                break;
            }
        }
    }
    return;
}

caml_flush_partial(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x08063707
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    void* _v32;           // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t25;                        // _t25
    void* _t26;           // _t26
    _unknown_ _t30;                        // _t30
    _unknown_ _t34;                        // _t34
    intOrPtr* _t36;                        // _t36
    _unknown_ _t37;                        // _t37
    _unknown_ _t38;                        // _t38
    _unknown_ _t40;                        // _t40
    _unknown_ _t42;                        // _t42
    _unknown_ _t43;                        // _t43
    _unknown_ _t46;                        // _t46
    _unknown_ _t47;                        // _t47

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t36 = _a4;
    _t26 = _t36 + 52;
    _v32 = _t26;
    _t46 =  *((intOrPtr*)(_t36 + 16)) - _t26;
    if(_t46 > 0) {
        _t30 = do_write( *_t36);
        _t43 = _t30;
         *((intOrPtr*)(_t36 + 4)) =  *((intOrPtr*)(_t36 + 4)) + _t30;
        asm("adc [ebx+0x8], edx");
        if(_t46 > _t43) {
            memmove(_v32, _v32 + _t43, _t46 - _t43);
        }
         *((intOrPtr*)(_t36 + 16)) =  *((intOrPtr*)(_t36 + 16)) - _t43;
    }
    return _t36 + 52 & 0xff;
}

caml_ml_output_char(
    _unknown_ __ebx,                       // r1
    _unknown_ __esi,                       // r5
    char _a4,                              // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0806377A
    char* _v28;                            // _cfa_ffffffe4
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    _unknown_ __ebp;                       // r6
    intOrPtr* _t22;                        // _t22
    signed int* _t24;                      // _t24
    intOrPtr* _t26;                        // _t26
    _unknown_ _t27;                        // _t27
    _unknown_ _t28;                        // _t28
    intOrPtr _t29;                         // _t29
    _unknown_ _t32;                        // _t32
    char* _t33;                            // _t33

    _t33 = caml_local_roots;
    _v44 = _t33;
    caml_local_roots =  &_v44;
    _v36 = 1;
    _v40 = 2;
    _v32 =  &_a4;
    _v28 =  &_a8;
    _t29 =  *((intOrPtr*)(_a4 + 4));
    _t22 = caml_channel_mutex_lock;
    if(_t22 != 0) {
         *__esp = _t29;
         *_t22();
    }
    _t23 =  *(_t29 + 16);
    if( *(_t29 + 16) >=  *((intOrPtr*)(_t29 + 12))) {
        caml_flush_partial(_t23, _t29, __edi, _t33, _t29);
    }
    _t24 =  *(_t29 + 16);
     *_t24 = _a8 >> 1 & 255;
     *(_t29 + 16) =  &(_t24[0]);
    _t26 = caml_channel_mutex_unlock;
    if(_t26 != 0) {
         *__esp = _t29;
         *_t26();
    }
    caml_local_roots = _t33;
    return;
}

caml_ml_flush_partial(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    char _a4                               // _cfa_4
)
{// addr = 0x08063801
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    _unknown_ __ebp;                       // r6
    _unknown_ _t16;                        // _t16
    intOrPtr* _t20;                        // _t20
    intOrPtr* _t21;                        // _t21
    _unknown_ _t22;                        // _t22
    _unknown_ _t23;                        // _t23
    intOrPtr* _t25;                        // _t25
    _unknown_ _t26;                        // _t26
    intOrPtr _t27;                         // _t27
    intOrPtr* _t28;                        // _t28
    _unknown_ _t29;                        // _t29
    char* _t31;                            // _t31
    _unknown_ _t32;                        // _t32

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = _t27;
    _t31 = caml_local_roots;
    _v60 = _t31;
    caml_local_roots =  &_v60;
    _v52 = 1;
    _v56 = 1;
    _v48 =  &_a4;
    _t25 =  *((intOrPtr*)(_a4 + 4));
    __eflags =  *_t25 - 255;
    if(__eflags != 0) {
        _t20 = caml_channel_mutex_lock;
        __eflags = _t20;
        if(_t20 != 0) {
             *__esp = _t25;
             *_t20();
        }
        caml_flush_partial(_t20, _t25, _t27, _t31, _t25);
        _t28 = _t20;
        _t21 = caml_channel_mutex_unlock;
        __eflags = _t21;
        if(_t21 != 0) {
             *__esp = _t25;
             *_t21();
        }
        __eflags = _t28 - 1;
        asm("sbb eax, eax");
        caml_local_roots = _t31;
    } else {
        caml_local_roots = _t31;
    }
    return;
}

caml_putword(
    _unknown_ __ebx,                       // r1
    _unknown_ __esi,                       // r5
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08063891
    _unknown_ __ebp;                       // r6
    signed int* _t26;                      // _t26
    signed int* _t27;                      // _t27
    signed int* _t28;                      // _t28
    signed int* _t29;                      // _t29
    signed int* _t30;                      // _t30
    signed int* _t31;                      // _t31
    signed int* _t32;                      // _t32
    _unknown_ _t34;                        // _t34
    _unknown_ _t35;                        // _t35
    _unknown_ _t36;                        // _t36
    _unknown_ _t37;                        // _t37
    _unknown_ _t38;                        // _t38
    intOrPtr _t39;                         // _t39
    _unknown_ _t47;                        // _t47
    signed int _t48;                       // _t48

    _t39 = _a4;
    _t48 = _a8;
     *__esp = _t39;
    if(caml_channel_binary_mode() == 0) {
         *__esp = "output_binary_int: not a binary channel";
        caml_failwith();
    }
    _t25 =  *(_t39 + 16);
    if( *(_t39 + 16) >=  *((intOrPtr*)(_t39 + 12))) {
        caml_flush_partial(_t25, _t39, __edi, _t48, _t39);
    }
    _t26 =  *(_t39 + 16);
     *_t26 = _t48 >> 24 & 255;
    _t27 =  &(_t26[0]);
     *(_t39 + 16) = _t27;
    if(_t27 >=  *((intOrPtr*)(_t39 + 12))) {
        caml_flush_partial(_t27, _t39, __edi, _t48, _t39);
    }
    _t28 =  *(_t39 + 16);
     *_t28 = _t48 >> 16 & 255;
    _t29 =  &(_t28[0]);
     *(_t39 + 16) = _t29;
    if(_t29 >=  *((intOrPtr*)(_t39 + 12))) {
        caml_flush_partial(_t29, _t39, __edi, _t48, _t39);
    }
    _t30 =  *(_t39 + 16);
     *_t30 = _t48 >> 8 & 255;
    _t31 =  &(_t30[0]);
     *(_t39 + 16) = _t31;
    if(_t31 >=  *((intOrPtr*)(_t39 + 12))) {
        caml_flush_partial(_t31, _t39, __edi, _t48, _t39);
    }
    _t32 =  *(_t39 + 16);
     *_t32 = _t48 & 255;
     *(_t39 + 16) =  &(_t32[0]);
    return;
}

caml_ml_output_int(
    _unknown_ __ebx,                       // r1
    _unknown_ __esi,                       // r5
    char _a4,                              // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08063932
    char* _v28;                            // _cfa_ffffffe4
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    intOrPtr* _t17;                        // _t17
    intOrPtr* _t20;                        // _t20
    _unknown_ _t21;                        // _t21
    _unknown_ _t22;                        // _t22
    intOrPtr _t23;                         // _t23
    _unknown_ _t24;                        // _t24
    char* _t25;                            // _t25

    _t25 = caml_local_roots;
    _v44 = _t25;
    caml_local_roots =  &_v44;
    _v36 = 1;
    _v40 = 2;
    _v32 =  &_a4;
    _v28 =  &_a8;
    _t23 =  *((intOrPtr*)(_a4 + 4));
    _t17 = caml_channel_mutex_lock;
    if(_t17 != 0) {
         *__esp = _t23;
         *_t17();
    }
    caml_putword(_t23, _t25, _t23, _a8 >> 1);
    _t20 = caml_channel_mutex_unlock;
    if(_t20 != 0) {
         *__esp = _t23;
         *_t20();
    }
    caml_local_roots = _t25;
    return;
}

caml_flush(
    _unknown_ __eax,                       // r0
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x080639AA
    _unknown_ __ebp;                       // r6

    __eax = __eax;
    __ebx = _a4;
    while(1) {
        __eax = caml_flush_partial(__eax, __ebx, __edi, __esi, __ebx);
        if(__eax != 0) {
            break;
        }
    }
    return;
}

caml_ml_flush(
    char _a4                               // _cfa_4
)
{// addr = 0x080639C6
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    intOrPtr* __ebx;                       // r1
    char* __esi;                           // r5
    _unknown_ __ebp;                       // r6
    intOrPtr* _t12;                        // _t12
    intOrPtr* _t13;                        // _t13
    _unknown_ _t14;                        // _t14

    __esi = caml_local_roots;
    _v44 = __esi;
    caml_local_roots =  &_v44;
    _v36 = 1;
    _v40 = 1;
    _v32 =  &_a4;
    __ebx =  *((intOrPtr*)(_a4 + 4));
    if( *__ebx != 255) {
        _t12 = caml_channel_mutex_lock;
        if(_t12 != 0) {
             *__esp = __ebx;
             *_t12();
        }
        caml_flush(_t12, __ebx);
        _t13 = caml_channel_mutex_unlock;
        if(_t13 != 0) {
             *__esp = __ebx;
             *_t13();
        }
        caml_local_roots = __esi;
    } else {
        caml_local_roots = __esi;
    }
    return;
}

caml_seek_out(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int* _a4,                       // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x08063A3C
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t15;                        // _t15
    signed int _t16;                       // _t16
    signed int* _t19;                      // _t19
    _unknown_ _t20;                        // _t20
    _unknown_ _t21;                        // _t21
    _unknown_ _t23;                        // _t23
    signed int _t25;                       // _t25
    _unknown_ _t26;                        // _t26
    signed int _t28;                       // _t28
    _unknown_ _t29;                        // _t29

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t19 = _a4;
    _t28 = _a8;
    _t25 = _a12;
    caml_flush(_t15, _t19);
    caml_enter_blocking_section();
    _v32 = 0;
    _v40 = _t28;
    _v36 = _t25;
    _t16 =  *_t19;
     *__esp = _t16;
    lseek64();
    _t17 = _t16 ^ _t28;
    if(__eflags != 0) {
        caml_leave_blocking_section();
         *__esp = 1;
        _t17 = caml_sys_error(_t17);
    }
    caml_leave_blocking_section();
    _t19[1] = _t28;
    _t19[2] = _t25;
    return;
}

caml_ml_seek_out_64(
    _unknown_ __ebx,                       // r1
    _unknown_ __esi,                       // r5
    char _a4,                              // _cfa_4
    char _a8                               // _cfa_8
)
{// addr = 0x08063AAC
    char* _v28;                            // _cfa_ffffffe4
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    intOrPtr* _t20;                        // _t20
    intOrPtr* _t23;                        // _t23
    _unknown_ _t24;                        // _t24
    _unknown_ _t25;                        // _t25
    signed int* _t26;                      // _t26
    _unknown_ _t27;                        // _t27
    char* _t28;                            // _t28

    _t28 = caml_local_roots;
    _v44 = _t28;
    caml_local_roots =  &_v44;
    _v36 = 1;
    _v40 = 2;
    _v32 =  &_a4;
    _v28 =  &_a8;
    _t26 =  *((intOrPtr*)(_a4 + 4));
    _t20 = caml_channel_mutex_lock;
    if(_t20 != 0) {
         *__esp = _t26;
         *_t20();
    }
    caml_seek_out(_t26, __edi, _t28, _t26,  *((intOrPtr*)(_a8 + 4)),  *((intOrPtr*)(_a8 + 8)));
    _t23 = caml_channel_mutex_unlock;
    if(_t23 != 0) {
         *__esp = _t26;
         *_t23();
    }
    caml_local_roots = _t28;
    return;
}

caml_ml_seek_out(
    _unknown_ __ebx,                       // r1
    _unknown_ __esi,                       // r5
    char _a4,                              // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08063B2C
    char* _v28;                            // _cfa_ffffffe4
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    intOrPtr* _t18;                        // _t18
    intOrPtr* _t21;                        // _t21
    _unknown_ _t22;                        // _t22
    _unknown_ _t23;                        // _t23
    signed int* _t24;                      // _t24
    _unknown_ _t27;                        // _t27
    char* _t28;                            // _t28

    _t28 = caml_local_roots;
    _v44 = _t28;
    caml_local_roots =  &_v44;
    _v36 = 1;
    _v40 = 2;
    _v32 =  &_a4;
    _v28 =  &_a8;
    _t24 =  *((intOrPtr*)(_a4 + 4));
    _t18 = caml_channel_mutex_lock;
    if(_t18 != 0) {
         *__esp = _t24;
         *_t18();
    }
    caml_seek_out(_t24, __edi, _t28, _t24, _a8 >> 1, _a8 >> 1 >> 31);
    _t21 = caml_channel_mutex_unlock;
    if(_t21 != 0) {
         *__esp = _t24;
         *_t21();
    }
    caml_local_roots = _t28;
    return;
}

caml_open_descriptor_in(
    intOrPtr* __eax,                       // r0
    intOrPtr __edx,                        // r3
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08063BAD
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr* __ebx;                       // r1
    intOrPtr __esi;                        // r5
    _unknown_ __ebp;                       // r6
    intOrPtr* _t20;                        // _t20
    intOrPtr _t21;                         // _t21
    intOrPtr _t24;                         // _t24

    __edx = __edx;
    _t20 = __eax;
    __esi = _a4;
    caml_stat_alloc(4148);
    __ebx = _t20;
     *_t20 = __esi;
    caml_enter_blocking_section();
    _v16 = 1;
    _v24 = 0;
    _v20 = 0;
     *__esp = __esi;
    lseek64();
     *((intOrPtr*)(__ebx + 4)) = _t20;
     *((intOrPtr*)(__ebx + 8)) = __edx;
    caml_leave_blocking_section();
    _t21 = __ebx + 52;
     *((intOrPtr*)(__ebx + 20)) = _t21;
     *((intOrPtr*)(__ebx + 16)) = _t21;
     *((intOrPtr*)(__ebx + 12)) = __ebx + 4148;
     *((intOrPtr*)(__ebx + 24)) = 0;
     *((intOrPtr*)(__ebx + 36)) = 0;
     *((intOrPtr*)(__ebx + 40)) = 0;
     *((intOrPtr*)(__ebx + 44)) = 0;
     *((intOrPtr*)(__ebx + 48)) = 0;
     *((intOrPtr*)(__ebx + 28)) = caml_all_opened_channels;
     *((intOrPtr*)(__ebx + 32)) = 0;
    _t24 = caml_all_opened_channels;
    if(_t24 != 0) {
         *((intOrPtr*)(_t24 + 32)) = __ebx;
    }
    caml_all_opened_channels = __ebx;
    return __ebx;
}

caml_ml_open_descriptor_in(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08063C57
    _unknown_ __ebp;                       // r6

    caml_alloc_channel(caml_open_descriptor_in(_a4 >> 1, __edx, _a4 >> 1), _t4);
    return;
}

caml_open_descriptor_out(
    _unknown_ __eax,                       // r0
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x08063C74
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3

     *((intOrPtr*)(caml_open_descriptor_in(_a4, __edx, _a4) + 20)) = 0;
    return;
}

caml_ml_open_descriptor_out(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08063C8E
    _unknown_ __ebp;                       // r6

    caml_open_descriptor_out(_a4 >> 1, _a4 >> 1);
    caml_alloc_channel(_t3, _t3);
    return;
}

extern_replay_trail()
{// addr = 0x08063CB0
    void* _v32;           // _cfa_ffffffe0
    _unknown_ __ebx;                       // r1
    void* __edi;                           // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    void* _t11;                            // _t11
    _unknown_ _t13;                        // _t13
    void* _t14;           // _t14
    signed int _t15;                       // _t15
    signed int _t22;                       // _t22

    _v32 = extern_trail_block;
    __edi = extern_trail_cur;
    while(1) {
L1:
        _t11 =  &(_v32[1]);
        if(__edi <= _t11) {
            break;
        } else {
            goto L2;
        }
        while(1) {
L2:
            _t15 =  *_t11;
            _t22 = _t15 & 252;
             *(_t22 - 4) = (_t15 & 3) << 8 |  *(_t22 - 4) & -769;
             *_t22 = _t11[1];
            _t11 =  &(_t11[2]);
            if(__edi <= _t11) {
                break;
            }
        }
        break;
    }
    if(_v32 !=  &extern_trail_first) {
        _t12 = _v32;
        _t14 =  *_v32;
        free(_t12);
        __edi =  &(_t14[0x803]);
        _v32 = _t14;
        goto L1;
    }
    extern_trail_block =  &extern_trail_first;
    extern_trail_cur = 134711748;
    return;
}

free_extern_output()
{// addr = 0x08063D36
    void __ebx;                            // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t1;                         // _t1
    void* _t2;            // _t2

    if(extern_userprovided_output == 0) {
        _t2 = extern_output_first;
        if(_t2 == 0) {
L4:
            extern_output_first = 0;
            return;
        } else {
            goto L2;
        }
        while(1) {
L2:
            __ebx =  *_t2;
            _t2 = free(_t2);
            if(__ebx == 0) {
                break;
            }
            _t2 = __ebx;
        }
        goto L4;
    }
    return;
}

extern_out_of_memory(
    _unknown_ __eax                        // r0
)
{// addr = 0x08063D71
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    void* _t9;            // _t9
    _unknown_ _t13;                        // _t13
    void* _t14;           // _t14
    _unknown_ _t15;                        // _t15
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17
    _unknown_ _t18;                        // _t18
    _unknown_ _t19;                        // _t19

    _t7 = __eax;
    extern_replay_trail();
    free_extern_output();
    caml_raise_out_of_memory();
    _push(_t18);
    _push(_t15);
    _push(_t13);
    __esp = __esp - 16;
    if(extern_userprovided_output != 0) {
        extern_replay_trail();
         *__esp = "Marshal.to_buffer: buffer overflow";
        caml_failwith();
    }
    extern_output_block[1] = extern_ptr;
    _t17 = _t7 - 4051 >= 0 ? _t7 : 0;
    _t9 = malloc(_t17 + 8108);
    _t14 = _t9;
    if(_t9 == 0) {
        extern_out_of_memory(_t9);
    }
     *extern_output_block = _t14;
    extern_output_block = _t14;
     *_t14 = 0;
    extern_ptr =  &(_t14[2]);
    extern_limit = _t14 + _t17 + 8108;
    __esp = __esp + 16;
    _pop(__ebx);
    _pop(__esi);
    return;
}

grow_extern_output()
{// addr = 0x08063D86
    void* __ebx;          // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    void* _t9;            // _t9
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14

    if(extern_userprovided_output != 0) {
        extern_replay_trail();
         *__esp = "Marshal.to_buffer: buffer overflow";
        caml_failwith();
    }
    extern_output_block[1] = extern_ptr;
    _t14 = _t7 - 4051 >= 0 ? _t7 : 0;
    _t9 = malloc(_t14 + 8108);
    __ebx = _t9;
    if(_t9 == 0) {
        extern_out_of_memory(_t9);
    }
     *extern_output_block = __ebx;
    extern_output_block = __ebx;
     *__ebx = 0;
    extern_ptr =  &((__ebx)[2]);
    extern_limit = __ebx + _t14 + 8108;
    return;
}

caml_serialize_block_float_8(
    void* _a4,            // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08063E0B
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    int __ebx;                             // r1
    _unknown_ __ebp;                       // r6
    int _t6;                               // _t6
    _unknown_ _t9;                         // _t9

    _t6 = _a8 << 3;
    __ebx = _t6;
    if(extern_limit < extern_ptr + _t6) {
        grow_extern_output();
    }
    memmove(extern_ptr, _a4, __ebx);
    extern_ptr = extern_ptr + __ebx;
    return;
}

caml_serialize_float_8(
    char _a4,                              // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08063E53
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v20;                             // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    _v20 = _a4;
    _v16 = _a8;
    caml_serialize_block_float_8( &_v20, 1);
    return;
}

caml_serialize_block_8(
    signed char* _a4,                      // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08063E7A
    signed int* _v32;                      // _cfa_ffffffe0
    signed int _v48;                       // _cfa_ffffffd0
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int* _t45;                      // _t45
    signed char* _t57;                     // _t57
    signed int* _t58;                      // _t58
    signed int _t67;                       // _t67

    if(extern_limit < extern_ptr + (_a8 << 3)) {
        grow_extern_output();
    }
    _t58 = extern_ptr;
    _t67 = _a8;
    if(_t67 > 0) {
        _t57 = _a4;
        _t45 = _t58;
        _v48 = _a8;
        _v32 = _t58;
        while(1) {
             *_t45 = _t57[7] & 0xff;
            _t45[0] = _t57[6] & 0xff;
            _t45[1] =  *_t57 & 0xff;
            _t45[1] = _t57[1] & 0xff;
            _t45[0] = _t57[5] & 0xff;
            _t45[0] = _t57[4] & 0xff;
            _t45[1] = _t57[2] & 0xff;
            _t45[1] = _t57[3] & 0xff;
            _t57 =  &(_t57[8]);
            _t45 =  &(_t45[2]);
            _v48 = _v48 - 1;
            if(_t67 == 0) {
                break;
            }
        }
        _t58 = _v32 + _a8 * 8;
    }
    extern_ptr = _t58;
    return;
}

caml_serialize_int_8(
    char _a4,                              // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08063F1D
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v20;                             // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    _v20 = _a4;
    _v16 = _a8;
    caml_serialize_block_8( &_v20, 1);
    return;
}

caml_serialize_block_4(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08063F44
    signed int _v32;                       // _cfa_ffffffe0
    intOrPtr __ebx;                        // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t35;                        // _t35
    intOrPtr _t43;                         // _t43
    signed int _t45;                       // _t45

    __ebx = _a4;
    if(extern_limit < (_a8 << 2) + extern_ptr) {
        grow_extern_output();
    }
    _t43 = extern_ptr;
    _t45 = _a8;
    if(_t45 > 0) {
        _t35 = 0;
        _v32 = _a8;
        while(1) {
             *(_t43 + _t35) =  *(__ebx + _t35 + 3) & 0xff;
             *(_t43 + _t35 + 1) =  *(__ebx + _t35 + 2) & 0xff;
             *(_t43 + _t35 + 3) =  *(__ebx + _t35) & 0xff;
             *(_t43 + _t35 + 2) =  *(__ebx + _t35 + 1) & 0xff;
            _t35 = _t35 + 4;
            _v32 = _v32 - 1;
            if(_t45 == 0) {
                break;
            }
        }
        _t43 = _t43 + _a8 * 4;
    }
    extern_ptr = _t43;
    return;
}

caml_serialize_float_4(
    char _a4                               // _cfa_4
)
{// addr = 0x08063FC5
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    caml_serialize_block_4( &_a4, 1);
    return;
}

caml_serialize_block_2(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08063FE0
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v48;                       // _cfa_ffffffd0
    intOrPtr __ebx;                        // r1
    _unknown_ __edi;                       // r4
    _unknown_ __ebp;                       // r6
    _unknown_ _t21;                        // _t21
    _unknown_ _t22;                        // _t22
    signed int _t27;                       // _t27
    signed int _t31;                       // _t31

    __ebx = _a4;
    _t27 = _a8;
    _t21 = _t27 + _t27;
    if(extern_limit < _t21 + extern_ptr) {
        grow_extern_output();
    }
    __ecx = extern_ptr;
    _t31 = _t27;
    if(_t31 > 0) {
        _t22 = 0;
        _v48 = _t27;
        _v32 = _t27;
        while(1) {
             *(__ecx + _t22) =  *(__ebx + _t22 + 1) & 0xff;
             *(__ecx + _t22 + 1) =  *(__ebx + _t22) & 0xff;
            _t22 = _t22 + 2;
            _v48 = _v48 - 1;
            if(_t31 == 0) {
                break;
            }
        }
        __ecx = __ecx + _v32 * 2;
    }
    extern_ptr = __ecx;
    return _t21;
}

caml_serialize_block_1(
    void* _a4,            // _cfa_4
    int _a8                                // _cfa_8
)
{// addr = 0x0806404D
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    int __ebx;                             // r1
    _unknown_ __ebp;                       // r6
    int _t5;                               // _t5
    _unknown_ _t8;                         // _t8

    _t5 = _a8;
    __ebx = _t5;
    if(extern_limit < extern_ptr + _t5) {
        grow_extern_output();
    }
    memmove(extern_ptr, _a4, __ebx);
    extern_ptr = extern_ptr + __ebx;
    return;
}

caml_serialize_int_4(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08064092
    signed int __ebx;                      // r1
    _unknown_ __ebp;                       // r6
    signed int* _t14;                      // _t14
    _unknown_ _t16;                        // _t16

    __ebx = _a4;
    if(extern_limit <  &(extern_ptr[1])) {
        grow_extern_output();
    }
    _t14 = extern_ptr;
     *_t14 = __ebx >> 24 & 255;
    _t14[0] = __ebx >> 16 & 255;
    _t14[0] = __ebx >> 8 & 255;
    _t14[0] = __ebx & 255;
    extern_ptr =  &(_t14[1]);
    return;
}

caml_serialize_int_2(
    signed int _a4                         // _cfa_4
)
{// addr = 0x080640E3
    signed int __ebx;                      // r1
    _unknown_ __ebp;                       // r6
    signed int* _t8;                       // _t8
    _unknown_ _t10;                        // _t10

    __ebx = _a4;
    if(extern_limit <  &(extern_ptr[0])) {
        grow_extern_output();
    }
    _t8 = extern_ptr;
     *_t8 = __ebx >> 8 & 255;
    _t8[0] = __ebx & 255;
    extern_ptr =  &(_t8[0]);
    return;
}

caml_serialize_int_1(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08064124
    _unknown_ __ebp;                       // r6
    signed int* _t5;                       // _t5
    _unknown_ _t7;                         // _t7

    if(extern_limit <  &(extern_ptr[0])) {
        grow_extern_output();
    }
    _t5 = extern_ptr;
     *_t5 = _a4 & 255;
    extern_ptr =  &(_t5[0]);
    return;
}

writecode16(
    signed int __eax,                      // r0
    intOrPtr __ebx,                        // r1
    signed int __edx,                      // r3
    intOrPtr __esi                         // r5
)
{// addr = 0x08064158
    intOrPtr _v8;                          // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    signed int* _t14;                      // _t14
    _unknown_ _t16;                        // _t16
    signed int _t18;                       // _t18
    _unknown_ _t19;                        // _t19
    signed int _t25;                       // _t25
    _unknown_ _t26;                        // _t26

     *__esp = __ebx;
    _v8 = __esi;
    _t25 = __eax;
    _t18 = __edx;
    if(extern_limit <  &(extern_ptr[0])) {
        grow_extern_output();
    }
    _t14 = extern_ptr;
     *_t14 = _t25 & 255;
    _t14[0] = _t18 >> 8 & 255;
    _t14[0] = _t18 & 255;
    extern_ptr =  &(_t14[0]);
    return;
}

writecode8(
    signed int __eax,                      // r0
    intOrPtr __ebx,                        // r1
    signed int __edx,                      // r3
    intOrPtr __esi                         // r5
)
{// addr = 0x080641AA
    intOrPtr _v8;                          // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    signed int* _t11;                      // _t11
    _unknown_ _t13;                        // _t13
    signed int _t15;                       // _t15
    _unknown_ _t16;                        // _t16
    signed int _t20;                       // _t20
    _unknown_ _t21;                        // _t21

     *__esp = __ebx;
    _v8 = __esi;
    _t15 = __eax;
    _t20 = __edx;
    if(extern_limit <  &(extern_ptr[0])) {
        grow_extern_output();
    }
    _t11 = extern_ptr;
     *_t11 = _t15 & 255;
    _t11[0] = _t20 & 255;
    extern_ptr =  &(_t11[0]);
    return;
}

writecode32(
    signed int __eax,                      // r0
    intOrPtr __ebx,                        // r1
    signed int __edx,                      // r3
    intOrPtr __esi                         // r5
)
{// addr = 0x080641F4
    intOrPtr _v8;                          // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    signed int* _t20;                      // _t20
    _unknown_ _t22;                        // _t22
    signed int _t24;                       // _t24
    _unknown_ _t25;                        // _t25
    signed int _t35;                       // _t35
    _unknown_ _t36;                        // _t36

     *__esp = __ebx;
    _v8 = __esi;
    _t35 = __eax;
    _t24 = __edx;
    if(extern_limit <  &(extern_ptr[1])) {
        grow_extern_output();
    }
    _t20 = extern_ptr;
     *_t20 = _t35 & 255;
    _t20[0] = _t24 >> 24 & 255;
    _t20[0] = _t24 >> 16 & 255;
    _t20[0] = _t24 >> 8 & 255;
    _t20[1] = _t24 & 255;
    extern_ptr =  &(_t20[1]);
    return;
}

writeblock(
    void* __eax,          // r0
    intOrPtr __ebx,                        // r1
    int __edx,                             // r3
    intOrPtr __esi                         // r5
)
{// addr = 0x08064256
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12
    int _t14;                              // _t14
    _unknown_ _t15;                        // _t15
    void* _t17;           // _t17
    _unknown_ _t18;                        // _t18

    __edx = __edx;
    _v12 = __ebx;
    _v8 = __esi;
    _t17 = __eax;
    _t14 = __edx;
    if(extern_limit < extern_ptr + __edx) {
        grow_extern_output();
    }
    memmove(extern_ptr, _t17, _t14);
    extern_ptr = extern_ptr + _t14;
    return;
}

write32(
    signed int __eax                       // r0
)
{// addr = 0x080642A2
    signed int __ebx;                      // r1
    _unknown_ __ebp;                       // r6
    signed int* _t14;                      // _t14
    _unknown_ _t16;                        // _t16

    __ebx = __eax;
    if(extern_limit <  &(extern_ptr[1])) {
        grow_extern_output();
    }
    _t14 = extern_ptr;
     *_t14 = __ebx >> 24 & 255;
    _t14[0] = __ebx >> 16 & 255;
    _t14[0] = __ebx >> 8 & 255;
    _t14[0] = __ebx & 255;
    extern_ptr =  &(_t14[1]);
    return;
}

extern_record_location(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi                         // r5
)
{// addr = 0x080642F2
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    _unknown_ __ebp;                       // r6
    signed int* _t18;                      // _t18
    signed int _t20;                       // _t20
    void* _t21;           // _t21
    signed int _t25;                       // _t25
    _unknown_ _t26;                        // _t26
    _unknown_ _t28;                        // _t28
    void* _t34;           // _t34

    _v12 = __ebx;
    _v8 = __esi;
    _t25 = _t16;
    if(extern_ignore_sharing == 0) {
        if(extern_trail_cur == extern_trail_limit) {
            _t21 = malloc(8204);
            _t34 = _t21;
            if(_t21 == 0) {
                extern_out_of_memory(_t21);
            }
             *_t34 = extern_trail_block;
            extern_trail_block = _t34;
            extern_trail_cur =  &(_t34[1]);
            extern_trail_limit =  &(_t34[0x803]);
        }
        __edx = _t25 - 4;
        __ecx =  *__edx;
        _t18 = extern_trail_cur;
         *_t18 = __ecx >> 8 & 3 | _t25;
        _t18[1] =  *_t25;
        extern_trail_cur =  &(_t18[2]);
         *__edx = __ecx;
        _t20 = obj_counter;
         *_t25 = _t20;
        _t16 = _t20 + 1;
        obj_counter = _t20 + 1;
    }
    return;
}

init_extern_output(
    _unknown_ __eax                        // r0
)
{// addr = 0x08064392
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2
    void* _t3;            // _t3

    extern_userprovided_output = 0;
    _t3 = malloc(8108);
    extern_output_first = _t3;
    if(_t3 == 0) {
        caml_raise_out_of_memory();
    }
    extern_output_block = _t3;
     *_t3 = 0;
    extern_ptr =  &(_t3[2]);
    extern_limit =  &(_t3[0x7eb]);
    return;
}

extern_invalid_argument()
{// addr = 0x080643DC
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ _v84;                        // _cfa_ffffffac
    _unknown_ _v128;                       // _cfa_ffffff80
    _unknown_ _v132;                       // _cfa_ffffff7c
    _unknown_ __edi;                       // r4
    _unknown_ __ebp;                       // r6
    intOrPtr _t102;                        // _t102
    _unknown_ _t107;                       // _t107
    _unknown_ _t109;                       // _t109
    _unknown_ _t110;                       // _t110
    _unknown_ _t115;                       // _t115
    _unknown_ _t116;                       // _t116
    _unknown_ _t119;                       // _t119
    _unknown_ _t120;                       // _t120
    _unknown_ _t121;                       // _t121
    _unknown_ _t122;                       // _t122
    _unknown_ _t124;                       // _t124
    _unknown_ _t126;                       // _t126
    _unknown_ _t127;                       // _t127
    _unknown_ _t128;                       // _t128
    _unknown_ _t135;                       // _t135
    _unknown_ _t137;                       // _t137
    _unknown_ _t139;                       // _t139
    _unknown_ _t141;                       // _t141
    _unknown_ _t142;                       // _t142
    _unknown_ _t143;                       // _t143
    _unknown_ _t147;                       // _t147
    _unknown_ _t148;                       // _t148
    intOrPtr _t149;                        // _t149
    intOrPtr _t150;                        // _t150
    _unknown_ _t151;                       // _t151
    _unknown_ _t153;                       // _t153
    _unknown_ _t154;                       // _t154
    _unknown_ _t163;                       // _t163
    _unknown_ _t164;                       // _t164
    _unknown_ _t178;                       // _t178
    _unknown_ _t183;                       // _t183
    _unknown_ _t185;                       // _t185
    _unknown_ _t186;                       // _t186

    _push(_t148);
    __esp = __esp - 20;
    _t149 = _t102;
    extern_replay_trail();
    free_extern_output();
     *__esp = _t149;
    caml_invalid_argument();
    _push(_t185);
    _push(_t180);
    _push(_t182);
    _push(_t149);
    __esp = __esp - 92;
    _t150 = _t102;
    while() {
    }
}

extern_rec()
{// addr = 0x080643F7
    unsigned int _v32;                     // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    signed int _v48;                       // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    signed int _v80;                       // _cfa_ffffffb0
    char* _v100;                           // _cfa_ffffff9c
    char* _v104;                           // _cfa_ffffff98
    _unknown_ __ebp;                       // r6
    signed int _t102;                      // _t102
    _unknown_ _t106;                       // _t106
    _unknown_ _t107;                       // _t107
    _unknown_ _t108;                       // _t108
    signed int _t111;                      // _t111
    _unknown_ _t112;                       // _t112
    _unknown_ _t117;                       // _t117
    signed int _t118;                      // _t118
    _unknown_ _t120;                       // _t120
    _unknown_ _t121;                       // _t121
    _unknown_ _t122;                       // _t122
    unsigned int _t124;                    // _t124
    _unknown_ _t126;                       // _t126
    _unknown_ _t127;                       // _t127
    _unknown_ _t128;                       // _t128
    unsigned int _t130;                    // _t130
    _unknown_ _t132;                       // _t132
    signed int _t133;                      // _t133
    _unknown_ _t134;                       // _t134
    _unknown_ _t141;                       // _t141
    _unknown_ _t142;                       // _t142
    unsigned int _t144;                    // _t144
    _unknown_ _t146;                       // _t146
    _unknown_ _t147;                       // _t147
    _unknown_ _t148;                       // _t148
    _unknown_ _t149;                       // _t149
    unsigned int _t151;                    // _t151
    _unknown_ _t153;                       // _t153
    unsigned int _t154;                    // _t154
    signed int _t158;                      // _t158
    signed int _t159;                      // _t159
    unsigned int _t160;                    // _t160
    signed int _t161;                      // _t161
    unsigned int _t164;                    // _t164
    signed int _t165;                      // _t165
    _unknown_ _t174;                       // _t174
    signed int _t175;                      // _t175
    signed int _t189;                      // _t189
    signed int _t191;                      // _t191
    signed int _t194;                      // _t194
    signed int _t195;                      // _t195
    int _t196;                             // _t196

    _t159 = _t102;
L2:
    while((_t159 & 1) == 0) {
L12:
        _t195 = _t159;
        if(( *( *((intOrPtr*)((_t159 >> 23) * 4 +  &caml_page_table)) + (_t159 >> 12 & 2047)) & 7) == 0) {
            if(_t159 < caml_code_area_start || _t159 >= caml_code_area_end) {
                extern_invalid_argument();
                return;
            } else {
                if(extern_closures == 0) {
                    extern_invalid_argument();
                }
                writecode32(16, _t159, _t159 - caml_code_area_start, _t195);
                caml_code_checksum();
                writeblock(16, _t159, 16, _t195);
                return;
            }
            return;
        }
        _t175 =  *(_t159 - 4);
        _t191 = _t175 & 0xff;
        if(_t191 != 250) {
L19:
            _t164 = _t175 >> 10;
            _v48 = _t164;
            if(_t164 != 0) {
                _t110 = _t175 & 768;
                if((_t175 & 768) != 512) {
L31:
                    _t111 = _t191 + -249;
                    if(_t111 > 6) {
L55:
                        if(_t191 > 15 || _v48 > 7) {
                            writecode32(8, _t159, _t175, _t195);
                        } else {
                            if(extern_ptr >= extern_limit) {
                                grow_extern_output();
                            }
                            _t130 = extern_ptr;
                             *_t130 = ((_v48 & 255) << 4) + _t191 - 128 & 255;
                            extern_ptr = _t130 + 1;
                        }
                        _t165 = _v48;
                        size_32 = _t165 + size_32 + 1;
                        size_64 = _t165 + size_64 + 1;
                        extern_record_location(_t159, _t195);
                        _t159 =  *_t159;
                        if(_v48 == 1) {
                            goto L2;
                        }
                        extern_rec();
                        _t194 = _v48 - 1;
                        _t160 = 1;
                        if(_t194 > 1) {
                            while(1) {
                                extern_rec();
                                _t160 = _t160 + 1;
                                if(_t194 <= _t160) {
                                    break;
                                }
                            }
                            goto L65;
                        }
                        _t194 = 1;
L65:
                        _t159 =  *(_t195 + _t194 * 4);
                        goto L2;
                    }
                    goto L32;
                }
                goto L26;
L32:
                switch( *((intOrPtr*)(_t111 * 4 +  &M0806BD0C))) {
                    case 0:
                        _t133 = caml_string_length(_t159);
                        _t196 = _t133;
                        if(_t133 > 31) {
                            if(_t133 > 255) {
                                writecode32(10, _t159, _t133, _t196);
                            } else {
                                writecode8(9, _t159, _t133, _t196);
                            }
                        } else {
                            if(extern_ptr >= extern_limit) {
                                grow_extern_output();
                            }
                            _t144 = extern_ptr;
                             *_t144 = _t196 + 32 & 255;
                            extern_ptr = _t144 + 1;
                        }
                        writeblock(_t159, _t159, _t196, _t196);
                        size_32 = size_32 + (_t196 + 4 >> 2) + 1;
                        size_64 = size_64 + (_t196 + 8 >> 3) + 1;
                        extern_record_location(_t159, _t196 + 8 >> 3);
                        return;
                    case 1:
                        __eax = extern_ptr;
                        if(extern_ptr >= extern_limit) {
                            __eax = 1;
                            grow_extern_output();
                        }
                        __eax = extern_ptr;
                         *__eax = 12;
                        extern_ptr = __eax;
                        __edx = 8;
                        __eax = __ebx;
                        writeblock(__ebx, __ebx, 8, __esi);
                        size_32 = size_32 + 3;
                        size_64 = size_64 + 2;
                        __eax = __ebx;
                        extern_record_location(__ebx, __esi);
                        return;
                    case 2:
                        __esi = _v48;
                        __esi = _v48 >> 1;
                        if(__esi > 255) {
                            __edx = __esi;
                            __eax = 7;
                            writecode32(7, __ebx, __esi, __esi);
                        } else {
                            __edx = __esi;
                            __eax = 14;
                            writecode8(14, __ebx, __esi, __esi);
                        }
                        __edx = 0 + __esi * 8;
                        __eax = __ebx;
                        writeblock(__ebx, __ebx, 0 + __esi * 8, __esi);
                        size_32 = size_32 + 1 + __esi * 2;
                        size_32 = size_32 + 1 + __esi * 2;
                        size_64 = __esi + size_64 + 1;
                        size_64 = __esi + size_64 + 1;
                        __eax = __ebx;
                        extern_record_location(__ebx, __esi);
                        return;
                    case 3:
                        "output_value: abstract value (Abstract)" = extern_invalid_argument();
                        __esi = __esi;
                        return;
                    case 4:
                        __ebx = _v48;
                        __ebx = _v48 << 2;
                        __edx = __ebx;
                        __eax = 17;
                        writecode32(17, __ebx, __ebx, __esi);
                        __esi = __esi - __ebx;
                        extern_rec();
                        return;
                    case 5:
                        _v48 = __ebx;
                        __eax =  *__ebx;
                        __esi =  *__eax;
                        if( *((intOrPtr*)(__eax + 16)) == 0) {
                            "output_value: abstract value (Custom)" = extern_invalid_argument();
                        }
                        __eax = extern_ptr;
                        if(extern_ptr >= extern_limit) {
                            __eax = 1;
                            grow_extern_output();
                        }
                        __eax = extern_ptr;
                         *__eax = 18;
                        extern_ptr = __eax;
                        __eax = 0;
                        asm("repne scasb ");
                        __edx = -1;
                        __edx =  !-1;
                        __eax = __esi;
                        writeblock(__esi, __ebx,  !-1, __esi);
                        __edx = _v48;
                        __eax =  *_v48;
                        __edx =  &_v36;
                        _v100 =  &_v36;
                        __edx =  &_v32;
                        _v104 =  &_v32;
                         *__esp = __ebx;
                         *((intOrPtr*)( *_v48 + 16))();
                        _v32 = _v32 + 3;
                        __eax = _v32 + 3 >> 2;
                        __edx = size_32;
                        __eax = size_32 + (_v32 + 3 >> 2) + 2;
                        size_32 = size_32 + (_v32 + 3 >> 2) + 2;
                        _v36 = _v36 + 7;
                        __eax = _v36 + 7 >> 3;
                        __edx = size_64;
                        __eax = size_64 + (_v36 + 7 >> 3) + 2;
                        size_64 = size_64 + (_v36 + 7 >> 3) + 2;
                        __eax = __ebx;
                        extern_record_location(__ebx, __esi);
                        return;
                    case 6:
                        goto L55;
                }
            }
            goto L20;
L26:
            _t189 = obj_counter -  *_t159;
            if(_t189 > 255) {
                if(_t189 > 65535) {
                    writecode32(6, _t159, _t189, _t195);
                    return;
                }
                goto L29;
            }
            writecode8(_t110, _t159, _t189, _t195);
            return;
L29:
            writecode16(5, _t159, _t189, _t195);
            return;
        }
        _t154 =  *_t159;
        _v80 = _t154;
        if((_t154 & 1) != 0) {
L1:
            _t159 = _v80;
            goto L2;
        }
        _v52 = _t154;
        if(( *( *((intOrPtr*)((_t154 >> 23) * 4 +  &caml_page_table)) + (_v80 >> 12 & 2047)) & 7) == 0) {
            goto L19;
        }
        _t158 =  *(_v52 - 4) & 255;
        _v48 = _t158 & 255;
        if((_t158 & 255) == 250 || (_t158 & 255) == 246 || (_t158 & 255) == 253) {
            goto L19;
        } else {
            goto L1;
        }
L20:
        if(_t191 > 15) {
            writecode32(8, _t159, _t175, _t195);
            return;
        }
        if(extern_ptr >= extern_limit) {
            grow_extern_output();
        }
        _t151 = extern_ptr;
         *_t151 = _t191 - 128 & 255;
        extern_ptr = _t151 + 1;
        return;
    }
    _t161 = _t159 >> 1;
    _t118 = _t161;
    if(_t161 <= 63) {
        if(extern_ptr >= extern_limit) {
            grow_extern_output();
        }
        _t124 = extern_ptr;
         *_t124 = _t161 + 64 & 255;
        extern_ptr = _t124 + 1;
        return;
    }
    if(_t161 + 128 > 255) {
        if(_t118 + 32768 > 65535) {
            writecode32(2, _t161, _t161, _t195);
            return;
        }
    } else {
        writecode8(0, _t161, _t161, _t195);
        return;
    }
    writecode16(1, _t161, _t161, _t195);
    return;
}

extern_value(
    signed int* __edx                      // r3
)
{// addr = 0x080648ED
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t8;                         // _t8
    signed int _t9;                        // _t9
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12
    intOrPtr _t13;                         // _t13
    intOrPtr* _t20;                        // _t20
    intOrPtr _t24;                         // _t24
    intOrPtr* _t26;                        // _t26

    _t9 = caml_convert_flag_list(__edx,  &extern_flags);
    extern_ignore_sharing = _t9 & 1;
    extern_closures = _t9 & 2;
    extern_trail_block =  &extern_trail_first;
    extern_trail_cur = 134711748;
    extern_trail_limit =  &extern_trail_block;
    obj_counter = 0;
    size_32 = 0;
    size_64 = 0;
    write32(-2070567234);
    extern_ptr = extern_ptr + 16;
    extern_rec();
    if(extern_userprovided_output == 0) {
         *((intOrPtr*)(extern_output_block + 4)) = extern_ptr;
    }
    extern_replay_trail();
    _t13 = extern_userprovided_output;
    if(_t13 == 0) {
        _t26 = extern_output_first;
        _t24 = 0;
        if(_t26 != 0) {
            _t20 = _t26;
            while(1) {
                _t24 =  *((intOrPtr*)(_t20 + 4)) - _t20 + _t24 - 8;
                _t20 =  *_t20;
                if(_t20 == 0) {
                    break;
                }
            }
        }
        extern_ptr = _t26 + 12;
        extern_limit = _t26 + 8108;
L8:
        write32(_t24 - 20);
        write32(obj_counter);
        write32(size_32);
        write32(size_64);
        return _t24;
    }
    _t24 = extern_ptr - _t13;
    extern_ptr = _t13 + 4;
    goto L8;
}

caml_output_value_to_block(
    _unknown_ _a4,                         // _cfa_4
    signed int* _a8,                       // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    intOrPtr _a16                          // _cfa_10
)
{// addr = 0x08064A0A
    _unknown_ __ebp;                       // r6
    intOrPtr _t5;                          // _t5
    _unknown_ _t7;                         // _t7
    _unknown_ _t8;                         // _t8

    _t5 = _a12;
    extern_userprovided_output = _t5;
    extern_ptr = _t5;
    extern_limit = _t5 + _a16;
    __edx = _a8;
    extern_value(_a8);
    return;
}

caml_output_value_to_malloc(
    _unknown_ _a4,                         // _cfa_4
    signed int* _a8,                       // _cfa_8
    void** _a12,          // _cfa_c
    intOrPtr* _a16                         // _cfa_10
)
{// addr = 0x08064A32
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    void* __esi;          // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t9;                         // _t9
    _unknown_ _t10;                        // _t10
    void* _t12;           // _t12
    void* _t15;           // _t15
    intOrPtr _t16;                         // _t16
    intOrPtr* _t17;                        // _t17
    int _t19;                              // _t19

    init_extern_output(_t9);
    __edx = _a8;
    _t16 = extern_value(_a8);
    _t12 = malloc(_t11);
    __esi = _t12;
    if(_t12 == 0) {
        extern_out_of_memory(_t12);
    }
     *_a12 = __esi;
    _t14 = _a16;
     *_a16 = _t16;
    _t17 = extern_output_first;
    if(_t17 != 0) {
        while(1) {
            _t15 = _t17 + 8;
            _t19 =  *((intOrPtr*)(_t17 + 4)) - _t15;
            memmove(__esi, _t15, _t19);
            __esi = __esi + _t19;
            _t17 =  *_t17;
            if(_t17 == 0) {
                break;
            }
        }
    }
    free_extern_output();
    return;
}

caml_output_value_to_buffer(
    _unknown_ __eax,                       // r0
    intOrPtr _a4,                          // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12,                       // _cfa_c
    _unknown_ _a16,                        // _cfa_10
    signed int* _a20                       // _cfa_14
)
{// addr = 0x08064AA1
    _unknown_ __ebp;                       // r6
    _unknown_ _t8;                         // _t8
    intOrPtr _t11;                         // _t11
    _unknown_ _t13;                        // _t13

    _t11 = (_a8 >> 1) + _a4;
    extern_userprovided_output = _t11;
    extern_ptr = _t11;
    extern_limit = _t11 + (_a12 >> 1);
    return extern_value(_a20) + _t14 + 1;
}

caml_output_value_to_string(
    _unknown_ __eax,                       // r0
    _unknown_ _a4,                         // _cfa_4
    signed int* _a8                        // _cfa_8
)
{// addr = 0x08064AD6
    intOrPtr _v32;                         // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    void* __ebx;          // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t12;                        // _t12
    intOrPtr _t13;                         // _t13
    void* _t15;           // _t15
    _unknown_ _t18;                        // _t18
    _unknown_ _t19;                        // _t19
    int _t21;                              // _t21
    void _t22;                             // _t22

    init_extern_output(__eax);
    __edx = _a8;
    _t13 = extern_value(_a8);
    __ebx = extern_output_first;
    caml_alloc_string(_t13);
    _v32 = _t13;
    if(__ebx != 0) {
        __edi = 0;
        while(1) {
            _t15 =  &((__ebx)[2]);
            _t21 = (__ebx)[1] - _t15;
            memmove(__edi + _v32, _t15, _t21);
            __edi = __edi + _t21;
            _t22 =  *__ebx;
            free(__ebx);
            if(_t22 == 0) {
                break;
            }
            __ebx = _t22;
        }
    }
    return _v32;
}

caml_output_val(
    _unknown_ __ebx,                       // r1
    intOrPtr _a4,                          // _cfa_4
    _unknown_ _a8,                         // _cfa_8
    signed int* _a12                       // _cfa_c
)
{// addr = 0x08064B46
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    intOrPtr __edi;                        // r4
    _unknown_ __ebp;                       // r6
    _unknown_ _t9;                         // _t9
    _unknown_ _t10;                        // _t10
    _unknown_ _t12;                        // _t12
    void* _t13;           // _t13

    __edi = _a4;
     *__esp = __edi;
    if(caml_channel_binary_mode() == 0) {
         *__esp = "output_value: not a binary channel";
        caml_failwith();
    }
    init_extern_output(_t8);
    _t10 = extern_value(_a12);
    _t13 = extern_output_first;
    if(_t13 != 0) {
        while(1) {
            caml_really_putblock( &(_t13[2]), _t13, __esi, __edi, _t11, _t13[1] - _t11);
            __esi =  *_t13;
            free(_t13);
            if(__esi == 0) {
                break;
            }
            _t13 = __esi;
        }
    }
    return;
}

caml_output_value(
    _unknown_ __ebx,                       // r1
    char _a4,                              // _cfa_4
    char _a8,                              // _cfa_8
    char _a12                              // _cfa_c
)
{// addr = 0x08064BB6
    char* _v24;                            // _cfa_ffffffe8
    char* _v28;                            // _cfa_ffffffe4
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    char* __esi;                           // r5
    _unknown_ __ebp;                       // r6
    intOrPtr* _t22;                        // _t22
    intOrPtr* _t25;                        // _t25
    _unknown_ _t26;                        // _t26
    _unknown_ _t27;                        // _t27
    intOrPtr _t28;                         // _t28

    __esi = caml_local_roots;
    _v44 = caml_local_roots;
    caml_local_roots =  &_v44;
    _v36 = 1;
    _v40 = 3;
    _v32 =  &_a4;
    _v28 =  &_a8;
    _v24 =  &_a12;
    _t28 =  *((intOrPtr*)(_a4 + 4));
    _t22 = caml_channel_mutex_lock;
    if(_t22 != 0) {
         *__esp = _t28;
         *_t22();
    }
    caml_output_val(_t28, _t28, _a8, _a12);
    _t25 = caml_channel_mutex_unlock;
    if(_t25 != 0) {
         *__esp = _t28;
         *_t25();
    }
    caml_local_roots = __esi;
    return;
}

caml_deserialize_uint_1()
{// addr = 0x08064C3C
    _unknown_ __ebp;                       // r6
    signed char* _t1;                      // _t1

    _t1 = intern_src;
    intern_src =  &(_t1[1]);
    return  *_t1 & 255;
}

caml_deserialize_sint_1()
{// addr = 0x08064C53
    _unknown_ __ebp;                       // r6
    char* _t1;                             // _t1

    _t1 = intern_src;
    intern_src = _t1 + 1;
    return  *_t1;
}

caml_deserialize_uint_2()
{// addr = 0x08064C6A
    _unknown_ __ebp;                       // r6
    signed char* _t4;                      // _t4

    __edx = intern_src;
    _t4 =  &((__edx)[2]);
    intern_src = _t4;
    return ( *(_t4 - 1) & 255) + (( *__edx & 255) << 8);
}

caml_deserialize_sint_2()
{// addr = 0x08064C8A
    _unknown_ __ebp;                       // r6
    signed char* _t3;                      // _t3
    signed char* _t7;                      // _t7

    _t3 = intern_src;
    _t7 =  &(_t3[2]);
    intern_src = _t7;
    return ( *_t3 << 8) + ( *(_t7 - 1) & 255);
}

caml_deserialize_uint_4()
{// addr = 0x08064CA9
    _unknown_ __ebp;                       // r6
    signed char* _t11;                     // _t11
    signed char* _t14;                     // _t14

    _t11 = intern_src;
    _t14 =  &(_t11[4]);
    intern_src = _t14;
    return ( *(_t14 - 1) & 255) + (( *_t11 & 255) << 24) + (( *(_t14 - 3) & 255) << 16) + (( *(_t14 - 2) & 255) << 8);
}

caml_deserialize_sint_4()
{// addr = 0x08064CDE
    _unknown_ __ebp;                       // r6
    signed char* _t11;                     // _t11
    signed char* _t14;                     // _t14

    _t11 = intern_src;
    _t14 =  &(_t11[4]);
    intern_src = _t14;
    return ( *(_t14 - 1) & 255) + (( *_t11 & 255) << 24) + (( *(_t14 - 3) & 255) << 16) + (( *(_t14 - 2) & 255) << 8);
}

caml_deserialize_block_2(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08064D13
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    intOrPtr __ebx;                        // r1
    _unknown_ __edi;                       // r4
    _unknown_ __ebp;                       // r6
    _unknown_ _t20;                        // _t20
    _unknown_ _t21;                        // _t21
    signed int _t24;                       // _t24

    __ebx = _a4;
    _t24 = _a8;
    __ecx = intern_src;
    __eflags = _t24;
    if(__eflags > 0) {
        _t21 = 0;
        _v24 = _t24;
        _v20 = _t24;
        while(1) {
             *(__ebx + _t21) =  *(__ecx + _t21 + 1) & 0xff;
             *(__ebx + _t21 + 1) =  *(__ecx + _t21) & 0xff;
            _t21 = _t21 + 2;
            _v24 = _v24 - 1;
            if(__eflags == 0) {
                break;
            }
        }
        __ecx = __ecx + _v20 * 2;
    }
    intern_src = __ecx;
    return _t20;
}

caml_deserialize_block_4(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08064D68
    signed int _v20;                       // _cfa_ffffffec
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t33;                        // _t33

    __ecx = _a4;
    __edx = intern_src;
    __eflags = _a8;
    if(__eflags > 0) {
        _t33 = 0;
        _v20 = _a8;
        while(1) {
             *(__ecx + _t33) =  *(__edx + _t33 + 3) & 0xff;
             *(__ecx + _t33 + 1) =  *(__edx + _t33 + 2) & 0xff;
             *(__ecx + _t33 + 3) =  *(__edx + _t33) & 0xff;
             *(__ecx + _t33 + 2) =  *(__edx + _t33 + 1) & 0xff;
            _t33 = _t33 + 4;
            _v20 = _v20 - 1;
            if(__eflags == 0) {
                break;
            }
        }
        __edx = __edx + _a8 * 4;
    }
    intern_src = __edx;
    return;
}

caml_deserialize_float_4()
{// addr = 0x08064DCE
    char _v8;                              // _cfa_fffffff8
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    caml_deserialize_block_4( &_v8, 1);
    asm("fld dword [ebp-0x4]");
    return;
}

caml_deserialize_block_8(
    signed int* _a4,                       // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08064DEC
    signed char* _v20;                     // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed char* _t43;                     // _t43
    signed char* _t53;                     // _t53

    _t53 = intern_src;
    __eflags = _a8;
    if(__eflags > 0) {
        __edx = _a4;
        _t43 = _t53;
        _v24 = _a8;
        _v20 = _t53;
        while(1) {
             *__edx = _t43[7] & 0xff;
            (__edx)[0] = _t43[6] & 0xff;
            (__edx)[1] =  *_t43 & 0xff;
            (__edx)[1] = _t43[1] & 0xff;
            (__edx)[0] = _t43[5] & 0xff;
            (__edx)[0] = _t43[4] & 0xff;
            (__edx)[1] = _t43[2] & 0xff;
            (__edx)[1] = _t43[3] & 0xff;
            _t43 =  &(_t43[8]);
            __edx =  &((__edx)[2]);
            _v24 = _v24 - 1;
            if(__eflags == 0) {
                break;
            }
        }
        _t53 = _v20 + _a8 * 8;
    }
    intern_src = _t53;
    return;
}

caml_deserialize_sint_8()
{// addr = 0x08064E74
    _unknown_ _v8;                         // _cfa_fffffff8
    char _v12;                             // _cfa_fffffff4
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    caml_deserialize_block_8( &_v12, 1);
    return _v12;
}

caml_deserialize_uint_8()
{// addr = 0x08064E95
    _unknown_ _v8;                         // _cfa_fffffff8
    char _v12;                             // _cfa_fffffff4
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    caml_deserialize_block_8( &_v12, 1);
    return _v12;
}

caml_marshal_data_size(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08064EB6
    _unknown_ __ebp;                       // r6
    signed char* _t15;                     // _t15
    signed char* _t16;                     // _t16
    signed char* _t30;                     // _t30

    _t30 = (_a8 >> 1) + _a4;
    intern_input_malloced = 0;
    _t15 =  &(_t30[4]);
    intern_src = _t15;
    if(( *(_t15 - 1) & 255) + (( *_t30 & 255) << 24) + (( *(_t15 - 3) & 255) << 16) + (( *(_t15 - 2) & 255) << 8) != -2070567234) {
         *__esp = "Marshal.data_size: bad object";
        caml_failwith();
    }
    _t16 =  &(_t15[4]);
    intern_src = _t16;
    return (( *(_t16 - 4) & 255) << 24) + ( *(_t16 - 1) & 255) + (( *(_t16 - 3) & 255) << 16) + (( *(_t16 - 2) & 255) << 8) + (( *(_t16 - 4) & 255) << 24) + ( *(_t16 - 1) & 255) + (( *(_t16 - 3) & 255) << 16) + (( *(_t16 - 2) & 255) << 8) + 1;
}

intern_cleanup()
{// addr = 0x08064F37
    _unknown_ __ebp;                       // r6
    intOrPtr _t4;                          // _t4

    if(intern_input_malloced != 0) {
        caml_stat_free(intern_input);
    }
    _t2 = intern_obj_table;
    if(intern_obj_table != 0) {
        caml_stat_free(_t2);
    }
    _t3 = intern_extra_block;
    if(intern_extra_block != 0) {
        caml_free_for_heap(_t3);
        return;
    }
    _t4 = intern_block;
    if(_t4 == 0) {
    } else {
         *((intOrPtr*)(_t4 - 4)) = intern_header;
        return;
    }
    goto L8;
L9:
L8:
    return;
    goto L9;
}

caml_deserialize_error(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08064F8B
    signed int _v20;                       // _cfa_ffffffec
    void* _v24;           // _cfa_ffffffe8
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t9;                         // _t9
    _unknown_ _t10;                        // _t10
    int _t12;                              // _t12
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14

    intern_cleanup();
     *__esp = _a4;
    caml_failwith();
    _push(_t13);
    _push(_t10);
    __esp = __esp - 20;
    _t12 = _v20 << 3;
    memmove(_v24, intern_src, _t12);
    intern_src = intern_src + _t12;
    __esp = __esp + 20;
    _pop(__ebx);
    return;
}

caml_deserialize_block_float_8(
    void* _a4,            // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08064FA1
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    int _t9;                               // _t9

    _t9 = _a8 << 3;
    memmove(_a4, intern_src, _t9);
    intern_src = intern_src + _t9;
    return;
}

caml_deserialize_float_8()
{// addr = 0x08064FD2
    char _v20;                             // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    caml_deserialize_block_float_8( &_v20, 1);
    asm("fld qword [ebp-0x10]");
    return;
}

caml_deserialize_block_1(
    void* _a4,            // _cfa_4
    int _a8                                // _cfa_8
)
{// addr = 0x08064FF0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    int __ebx;                             // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7

    __ebx = _a8;
    memmove(_a4, intern_src, __ebx);
    intern_src = intern_src + __ebx;
    return;
}

caml_code_checksum()
{// addr = 0x0806501E
    char _v100;                            // _cfa_ffffff9c
    _unknown_ _v116;                       // _cfa_ffffff8c
    _unknown_ _v120;                       // _cfa_ffffff88
    char* __ebx;                           // r1
    _unknown_ __ebp;                       // r6

    if(checksum_computed.3405 == 0) {
        __ebx =  &_v100;
        caml_MD5Init(__ebx);
        caml_MD5Update(__ebx, caml_code_area_start, caml_code_area_end - _t6);
        caml_MD5Final( &checksum.3404, __ebx);
        checksum_computed.3405 = 1;
    }
    return  &checksum.3404;
}

intern_alloc(
    signed int __eax,                      // r0
    signed int __edx                       // r3
)
{// addr = 0x0806507B
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    signed int _t6;                        // _t6
    signed int _t9;                        // _t9
    signed int _t12;                       // _t12
    signed int _t14;                       // _t14
    signed int _t17;                       // _t17
    signed int _t18;                       // _t18

    _t6 = __eax;
    _t14 = __edx;
    if(_t6 != 0) {
        _t17 = _t6 - 1;
        if(_t17 <= 4194303) {
            if(_t17 != 0) {
                if(_t17 > 256) {
                    intern_block = caml_alloc_shr(_t6, _t14, __edi, __esi, _t17, 252);
                } else {
                    intern_block = caml_alloc_small(_t14, __esi, _t17, 252);
                }
            } else {
                intern_block = 134721460;
            }
            _t9 = intern_block - 4;
            _t18 =  *_t9;
            intern_header = _t18;
            intern_color = _t18 & 768;
            intern_dest = _t9;
            intern_extra_block = 0;
        } else {
            _t12 = 4095 + _t6 * 4 & -4096;
            caml_alloc_for_heap(_t12, _t12);
            intern_extra_block = _t12;
            if(_t12 == 0) {
                caml_raise_out_of_memory();
            }
            intern_color = caml_allocation_color(_t12);
            _t9 = intern_extra_block;
            intern_dest = _t9;
        }
        obj_counter = 0;
        if(_t14 == 0) {
            intern_obj_table = 0;
            return;
        }
        caml_stat_alloc(_t14 << 2);
        intern_obj_table = _t9;
        return;
    }
    intern_obj_table = 0;
    intern_extra_block = 0;
    intern_block = 0;
    return;
}

intern_rec()
{// addr = 0x08065190
    void** _v64;          // _cfa_ffffffc0
    void** _v68;          // _cfa_ffffffbc
    _unknown_ _v84;                        // _cfa_ffffffac
    _unknown_ _v88;                        // _cfa_ffffffa8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    void* __esi;          // r5
    _unknown_ __ebp;                       // r6
    void** _t52;          // _t52
    void* _t53;           // _t53
    signed int _t56;                       // _t56
    signed int _t57;                       // _t57
    void* _t61;           // _t61
    intOrPtr* _t62;                        // _t62
    _unknown_ _t65;                        // _t65
    signed int _t66;                       // _t66
    int _t67;                              // _t67
    signed int _t70;                       // _t70
    signed int _t74;                       // _t74
    void* _t77;           // _t77
    signed int _t81;                       // _t81
    void* _t83;           // _t83
    signed int _t90;                       // _t90
    void* _t96;           // _t96
    signed int _t97;                       // _t97
    signed int _t98;                       // _t98

    _v64 = _t52;
    __esi = 134659780;
    while(1) {
        _t53 = intern_src;
        _t81 =  *_t53 & 255;
        _t66 = _t81 & 0xff;
        _t54 =  &(_t53[0]);
        intern_src =  &(_t53[0]);
        if(_t66 <= 63) {
            break;
        }
        if(_t66 <= 127) {
            __esi = (_t66 & 63) + (_t66 & 63) + 1;
        } else {
            _t90 = _t66 & 15;
            _t70 = _t66 >> 4 & 7;
            if(_t70 != 0) {
                _t77 = intern_dest + 4;
                 *_v64 = _t77;
                _t61 = intern_obj_table;
                if(_t61 != 0) {
                    _t98 = obj_counter;
                     *(_t61 + _t98 * 4) = _t77;
                    obj_counter = _t98 + 1;
                }
                _t62 = intern_dest;
                _v64 = _t62 + 4;
                 *_t62 = _t90 + intern_color + (_t70 << 10);
                intern_dest = intern_dest + 4 + _t70 * 4;
                if(_t70 <= 1) {
                } else {
                    _t97 = _t70;
                    _v68 = _v64;
                    while(1) {
                        intern_rec();
                        _t97 = _t97 - 1;
                        _v68 =  &(_v68[1]);
                        if(_t97 <= 1) {
                            break;
                        }
                    }
                    _v64 = _v64 + _t70 * 4 - 4;
                }
                continue;
            } else {
                __esi = 134720452 + _t90 * 4;
                goto L19;
            }
L20:
        }
L19:
         *_v64 = __esi;
        return;
        goto L20;
    }
    if(_t66 <= 31) {
        if((_t81 & 255) <= 19) {
            goto ((__esi)[_t81 & 0xff]);
        }
        intern_cleanup();
         *__esp = "input_value: ill-formed message";
        caml_failwith();
        goto L19;
    }
    _t67 = _t66 & 31;
    _t56 = _t67 + 4 >> 2;
    _t96 = intern_dest + 4;
    __esi = _t96;
    _t83 = intern_obj_table;
    if(_t83 != 0) {
        _t74 = obj_counter;
         *(_t83 + _t74 * 4) = _t96;
        obj_counter = _t74 + 1;
    }
     *intern_dest = intern_color + (_t56 << 10) + 252;
    intern_dest = intern_dest + 4 + _t56 * 4;
    _t57 = _t56 << 2;
     *((intOrPtr*)(__esi + _t57 - 4)) = 0;
     *(__esi + _t57 - 1) = _t57 - 1 & 255;
    memmove(_t96, intern_src, _t67);
    intern_src = intern_src + _t67;
    goto L19;
}

intern_add_to_heap()
{// addr = 0x080657F6
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    signed int _t5;                        // _t5
    signed int* _t8;                       // _t8
    _unknown_ _t10;                        // _t10
    intOrPtr _t11;                         // _t11
    _unknown_ _t12;                        // _t12

    _t11 = intern_extra_block;
    if(_t11 != 0) {
        _t12 = _t11 + (4095 + _t5 * 4 & -4096);
        _t8 = intern_dest;
        if(_t12 > _t8) {
            caml_make_free_blocks(_t8, _t12 - _t8 >> 2, 0);
        }
        _t9 = intern_extra_block;
        caml_allocated_words = caml_allocated_words + (intern_dest - intern_extra_block >> 2);
        caml_add_to_heap(_t9, _t9);
        return;
    }
    return;
}

input_val_from_block()
{// addr = 0x08065856
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed char* _t13;                     // _t13
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17

    _t13 = intern_src;
    _t28 =  &(_t13[4]);
    _t31 =  &(_t13[8]);
    intern_src =  &(_t13[0xc]);
    intern_alloc((( *( &(_t13[8]) - 4) & 255) << 24) + ( *( &(_t13[8]) - 1) & 255) + (( *(_t31 - 3) & 255) << 16) + (( *(_t31 - 2) & 255) << 8), ( *( &(_t13[4]) - 1) & 255) + (( *_t13 & 255) << 24) + (( *( &(_t13[4]) - 3) & 255) << 16) + (( *(_t28 - 2) & 255) << 8));
    intern_rec();
    intern_add_to_heap();
    _t18 = intern_obj_table;
    if(intern_obj_table != 0) {
        caml_stat_free(_t18);
    }
    return _v16;
}

caml_input_value_from_block(
    signed char* _a4,                      // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080658E0
    _unknown_ __ebp;                       // r6
    signed char* _t16;                     // _t16
    signed char* _t17;                     // _t17
    _unknown_ _t19;                        // _t19
    signed char* _t29;                     // _t29

    _t29 = _a4;
    intern_input = _t29;
    intern_input_malloced = 0;
    _t16 =  &(_t29[4]);
    intern_src = _t16;
    if(( *(_t16 - 1) & 255) + (( *_t29 & 255) << 24) + (( *(_t16 - 3) & 255) << 16) + (( *(_t16 - 2) & 255) << 8) != -2070567234) {
         *__esp = "input_value_from_block: bad object";
        caml_failwith();
    }
    _t17 =  &(_t16[4]);
    intern_src = _t17;
    if(( *(_t17 - 1) & 255) + (( *(_t17 - 4) & 255) << 24) + 20 + (( *(_t17 - 3) & 255) << 16) + (( *(_t17 - 2) & 255) << 8) > _a8) {
         *__esp = "input_value_from_block: bad block length";
        caml_failwith();
    }
    input_val_from_block();
    return;
}

caml_input_value_from_malloc(
    _unknown_ __eax,                       // r0
    void* _a4,            // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08065977
    _unknown_ __ebp;                       // r6
    _unknown_ _t8;                         // _t8
    signed char* _t9;                      // _t9
    _unknown_ _t11;                        // _t11
    void* _t19;           // _t19
    signed char* _t20;                     // _t20

    _t19 = _a4;
    intern_input = _t19;
    _t20 = _t19 + _a8;
    intern_input_malloced = 1;
    _t9 =  &(_t20[4]);
    intern_src = _t9;
    if(( *(_t9 - 1) & 255) + (( *_t20 & 255) << 24) + (( *(_t9 - 3) & 255) << 16) + (( *(_t9 - 2) & 255) << 8) != -2070567234) {
         *__esp = "input_value_from_malloc: bad object";
        caml_failwith();
    }
    intern_src =  &(_t9[4]);
    _t11 = input_val_from_block();
    caml_stat_free(intern_input);
    return _t11;
}

caml_input_val_from_string(
    char _a4,                              // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080659F3
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    char _v64;                             // _cfa_ffffffc0
    char* _v84;                            // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    intOrPtr _v92;                         // _cfa_ffffffa4
    char _v96;                             // _cfa_ffffffa0
    signed int _v112;                      // _cfa_ffffff90
    char* __ebx;                           // r1
    _unknown_ __edi;                       // r4
    _unknown_ __ebp;                       // r6
    signed char* _t43;                     // _t43
    _unknown_ _t48;                        // _t48
    _unknown_ _t49;                        // _t49
    signed char* _t53;                     // _t53

    __ebx = caml_local_roots;
    _v60 = __ebx;
    _v52 = 1;
    _v56 = 1;
    _v48 =  &_a4;
    _v64 = 0;
    _v96 =  &_v60;
    caml_local_roots =  &_v96;
    _v88 = 1;
    _v92 = 1;
    _v84 =  &_v64;
    _t43 = _a8 + _a4 + 8;
    intern_input_malloced = 0;
    _t52 =  &(_t43[4]);
    _t53 =  &(_t43[8]);
    _v112 = ( *(_t53 - 4) & 255) << 24;
    _v112 = ( *(_t53 - 1) & 255) + _v112;
    intern_src =  &(_t43[0xc]);
    intern_alloc((( *(_t53 - 3) & 255) << 16) + _v112 + (( *(_t53 - 2) & 255) << 8), ( *( &(_t43[4]) - 1) & 255) + (( *_t43 & 255) << 24) + (( *(_t52 - 3) & 255) << 16) + (( *(_t52 - 2) & 255) << 8));
    intern_src = _a8 + _a4 + 20;
    intern_rec();
    intern_add_to_heap();
    _t50 = intern_obj_table;
    if(intern_obj_table != 0) {
        caml_stat_free(_t50);
    }
    caml_local_roots = __ebx;
    return _v64;
}

caml_input_value_from_string(
    char _a4,                              // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08065AF2
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7

    caml_input_val_from_string(_a4, _a8 >> 1);
    return;
}

caml_input_val(
    _unknown_ __esi,                       // r5
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08065B0E
    intOrPtr _v32;                         // _cfa_ffffffe0
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    int __edi;                             // r4
    _unknown_ __ebp;                       // r6
    signed int _t16;                       // _t16
    _unknown_ _t19;                        // _t19
    _unknown_ _t20;                        // _t20
    _unknown_ _t24;                        // _t24
    void* _t25;           // _t25

    __ebx = _a4;
     *__esp = __ebx;
    if(caml_channel_binary_mode() == 0) {
         *__esp = "input_value: not a binary channel";
        caml_failwith();
    }
    if(caml_getword(_t11, __ebx) != -2070567234) {
         *__esp = "input_value: bad object";
        caml_failwith();
    }
    __edi = caml_getword(_t12, __ebx);
    _v52 = caml_getword(_t13, __ebx);
    _v48 = caml_getword(_t14, __ebx);
    _t16 = caml_getword(_t15, __ebx);
    caml_stat_alloc(__edi);
    _t25 = _t16;
    if(caml_really_getblock(_t16, __ebx, _t25, __ebx, _t16, __edi) == 0) {
        caml_stat_free(_t25);
         *__esp = "input_value: truncated object";
        caml_failwith();
    }
    intern_input = _t25;
    intern_input_malloced = 1;
    intern_src = _t25;
    __edx = _v52;
    intern_alloc(_v48, _v52);
    intern_rec();
    intern_add_to_heap();
    caml_stat_free(intern_input);
    _t22 = intern_obj_table;
    if(intern_obj_table != 0) {
        caml_stat_free(_t22);
    }
    return _v32;
}

caml_input_value(
    _unknown_ __eax,                       // r0
    _unknown_ __esi,                       // r5
    char _a4                               // _cfa_4
)
{// addr = 0x08065C01
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    char _v48;                             // _cfa_ffffffd0
    char* _v68;                            // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    intOrPtr _v76;                         // _cfa_ffffffb4
    char _v80;                             // _cfa_ffffffb0
    intOrPtr __ebx;                        // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t18;                        // _t18
    char* _t19;                            // _t19
    intOrPtr* _t22;                        // _t22
    intOrPtr* _t23;                        // _t23
    _unknown_ _t24;                        // _t24
    _unknown_ _t27;                        // _t27
    char* _t28;                            // _t28

    _t28 = caml_local_roots;
    _v44 = _t28;
    _t19 =  &_v44;
    caml_local_roots = _t19;
    _v36 = 1;
    _v40 = 1;
    _v32 =  &_a4;
    __ebx =  *((intOrPtr*)(_a4 + 4));
    _v48 = 0;
    _v80 = _t19;
    caml_local_roots =  &_v80;
    _v72 = 1;
    _v76 = 1;
    _v68 =  &_v48;
    _t22 = caml_channel_mutex_lock;
    if(_t22 != 0) {
         *__esp = __ebx;
         *_t22();
    }
    caml_input_val(_t28, __ebx);
    _v48 = _t22;
    _t23 = caml_channel_mutex_unlock;
    if(_t23 != 0) {
         *__esp = __ebx;
         *_t23();
    }
    caml_local_roots = _t28;
    return;
}

caml_hash_variant(
    signed char* _a4                       // _cfa_4
)
{// addr = 0x08065CA0
    _unknown_ __ebp;                       // r6
    signed int _t4;                        // _t4

    __edx = _a4;
    _t4 = 1;
    if( *__edx != 0) {
        while(1) {
            _t4 = (_t4 >> 1) * (_t4 >> 1) + ( *__edx & 255) + (_t4 >> 1) * (_t4 >> 1) + ( *__edx & 255) + 1;
            __edx =  &((__edx)[1]);
            if( *__edx == 0) {
                break;
            }
        }
    }
    return _t4;
}

hash_aux(
    unsigned int __eax                     // r0
)
{// addr = 0x08065CCB
    unsigned int _v32;                     // _cfa_ffffffe0
    unsigned int __ebx;                    // r1
    signed int __edi;                      // r4
    unsigned int __esi;                    // r5
    _unknown_ __ebp;                       // r6
    signed int _t57;                       // _t57
    signed int _t61;                       // _t61
    unsigned int _t66;                     // _t66
    unsigned int* _t71;                    // _t71
    intOrPtr _t75;                         // _t75
    signed int _t79;                       // _t79
    signed int _t80;                       // _t80
    signed int _t81;                       // _t81
    signed int _t83;                       // _t83
    unsigned int _t85;                     // _t85
    signed int _t88;                       // _t88

    _t85 = __eax;
    _t75 = hash_univ_limit - 1;
    hash_univ_limit = _t75;
    _t56 = hash_univ_count;
    if(_t56 >= 0 || _t75 >= 0) {
L32:
        return;
L33:
    } else {
        if((_t85 & 1) != 0) {
L5:
            _t57 = _t56 - 1;
            hash_univ_count = _t57;
            hash_accu = (_t85 >> 1) + _t57 * hash_accu;
            return;
        }
        _t66 = _t85;
        if(( *( *((intOrPtr*)((_t85 >> 23) * 4 +  &caml_page_table)) + (_t85 >> 12 & 2047)) & 7) != 0) {
            while(1) {
L7:
                _t71 = _t66 - 4;
                _t79 =  *_t71 & 255;
                __edi = _t79 & 0xff;
                _v32 = _t79 & 0xff;
                _t80 = _t79 + 8;
                __eflags = (_t80 & 255) - 7;
                if((_t80 & 255) > 7) {
                    break;
                }
                switch( *((intOrPtr*)((_t80 & 0xff) * 4 +  &M0806BF14))) {
                    case 0:
                        hash_univ_count = _t56 - 1;
                        _t56 = caml_string_length(_t85);
                        __eflags = _t56;
                        if(__eflags == 0) {
                            goto L32;
                        }
                        _t83 = hash_accu;
                        while(1) {
                            _t83 = _t83 + (_t83 + _t83 * 8) * 2 + ( *_t85 & 255);
                            _t85 = _t85 + 1;
                            _t56 = _t56 - 1;
                            if(__eflags == 0) {
                                break;
                            }
                        }
                        hash_accu = _t83;
                        return;
                        goto L33;
                    case 1:
                        hash_univ_count = __eax;
                        __eax = hash_accu;
                        __ecx = __esi + 8;
                        while(1) {
                            __edx = __eax + __eax * 8;
                            __edx = __eax + (__eax + __eax * 8) * 2;
                            __eax =  *__esi & 255;
                            __eax = __edx + ( *__esi & 255);
                            __esi = __esi + 1;
                            __eflags = __esi - __ecx;
                            if(__esi == __ecx) {
                                break;
                            }
                        }
                        hash_accu = __eax;
                        return;
                    case 2:
                        hash_univ_count = __eax;
                         *__ecx =  *__ecx >> 10;
                        __eax =  *__ecx >> 10 << 2;
                        _v32 = __eax;
                        __eflags = __eax;
                        if(__eax == 0) {
                            goto L32;
                        }
                        __edx = hash_accu;
                        __esi = 0;
                        goto L18;
                        do {
L18:
                            __eax = __ebx;
                            __ebx = __ebx + 8;
                            __ecx = __ebx;
                            while(1) {
                                __edi = __edx + __edx * 8;
                                __edi = __edx + (__edx + __edx * 8) * 2;
                                __edx =  *__eax & 255;
                                __edx = __edi + ( *__eax & 255);
                                __eax = __eax + 1;
                                __eflags = __ecx - __eax;
                                if(__ecx == __eax) {
                                    break;
                                }
                            }
                            __esi = __esi + 8;
                            __eflags = __esi - _v32;
                        } while(__esi < _v32);
                        hash_accu = __edx;
                        return;
                        goto L33;
                    case 3:
                         *__ecx =  *__ecx >> 10;
                        __eax =  *__ecx >> 10 << 2;
                        __eax = __ebx;
                        __eax = hash_aux(__ebx);
                        return;
                    case 4:
                        __esi =  *__esi;
                        __eflags = __esi & 1;
                        if((__esi & 1) == 0) {
                            goto L6;
                        }
                        __esi = __esi;
                        goto L5;
                    case 5:
                        hash_univ_count = __eax;
                         *(__ebx + 4) =  *(__ebx + 4) >> 1;
                        __eax = ( *(__ebx + 4) >> 1) + __edx;
                        hash_accu = __eax;
                        return;
                    case 6:
                        __edx =  *__esi;
                        __edx =  *( *__esi + 12);
                        __eflags = __edx;
                        if(__edx == 0) {
                            goto L32;
                        }
                        __eax = __eax - 1;
                        hash_univ_count = __eax;
                        __ebx = __ebx * hash_accu;
                         *__esp = __esi;
                         *__edx();
                        hash_accu = __ebx;
                        return;
                        goto L33;
                    case 7:
                        goto L32;
                }
            }
            hash_univ_count = _t56 - 1;
            _t61 = hash_accu;
            _t81 = _t61 + _t61 * 8;
            _t56 = _t61 + _t81 * 2 + _v32;
            hash_accu = _t61 + _t81 * 2 + _v32;
            _t88 =  *_t71 >> 10;
            __eflags = _t88;
            if(_t88 == 0) {
                goto L32;
            } else {
                goto L29;
            }
            while(1) {
L29:
                _t88 = _t88 - 1;
                hash_aux( *((intOrPtr*)(_t66 + _t88 * 4)));
                __eflags = _t88;
                if(_t88 == 0) {
                    break;
                }
            }
            return;
            goto L33;
        }
L31:
        hash_accu = _t66 + _t56 * hash_accu;
        return;
L6:
        __ebx = __esi;
        __esi = __esi >> 23;
        __esi = __esi >> 12;
        __edx = __esi >> 12 & 2047;
        __ecx =  *((__esi >> 23) * 4 +  &caml_page_table);
        __eflags =  *(__ecx + __edx) & 7;
        if(( *(__ecx + __edx) & 7) == 0) {
            goto L31;
        }
        goto L7;
    }
}

caml_hash_univ_param(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    unsigned int _a12                      // _cfa_c
)
{// addr = 0x08065F0F
    _unknown_ __ebp;                       // r6
    _unknown_ _t11;                        // _t11

    hash_univ_limit = _a8 >> 1;
    hash_univ_count = _a4 >> 1;
    hash_accu = 0;
    hash_aux(_a12);
    return (hash_accu & 1073741823) + (hash_accu & 1073741823) + 1;
}

caml_sys_init(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08065F50
    _unknown_ __ebp;                       // r6

    caml_exe_name = _a4;
    caml_main_argv = _a8;
    return;
}

caml_sys_get_config(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx                        // r1
)
{// addr = 0x08065F65
    _unknown_ _v16;                        // _cfa_fffffff0
    char _v20;                             // _cfa_ffffffec
    char* _v36;                            // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    char _v52;                             // _cfa_ffffffcc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    _unknown_ _t18;                        // _t18
    intOrPtr* _t23;                        // _t23
    _unknown_ _t26;                        // _t26
    char* _t27;                            // _t27

    _t27 = caml_local_roots;
    _v16 = 0;
    _v20 = 0;
    _v52 = _t27;
    caml_local_roots =  &_v52;
    _v44 = 1;
    _v48 = 2;
    _v40 =  &_v16;
    _v36 =  &_v20;
    _v20 = caml_copy_string(_t27, __edi, __esi, 134659892);
    _t23 = caml_alloc_small(_t27, __esi, 2, 0);
    _v16 = _t23;
     *_t23 = _v20;
     *((intOrPtr*)(_v16 + 4)) = 65;
    caml_local_roots = _t27;
    return _v16;
}

caml_sys_get_argv(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx                        // r1
)
{// addr = 0x08065FE9
    char _v16;                             // _cfa_fffffff0
    char _v20;                             // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    char* _v36;                            // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    char* _v44;                            // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    char _v56;                             // _cfa_ffffffc8
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    _unknown_ _t23;                        // _t23
    intOrPtr _t30;                         // _t30
    intOrPtr* _t31;                        // _t31
    _unknown_ _t34;                        // _t34
    char* _t35;                            // _t35

    _t35 = caml_local_roots;
    _v16 = 0;
    _v20 = 0;
    _v24 = 0;
    _v56 = _t35;
    caml_local_roots =  &_v56;
    _v48 = 1;
    _v52 = 3;
    _v44 =  &_v16;
    _v40 =  &_v20;
    _v36 =  &_v24;
    _v16 = caml_copy_string(_t35, __edi, __esi, caml_exe_name);
    _t30 = caml_main_argv;
    caml_copy_string_array(_t30);
    _v20 = _t30;
    _t31 = caml_alloc_small(_t35, __esi, 2, 0);
    _v24 = _t31;
     *_t31 = _v16;
     *((intOrPtr*)(_v24 + 4)) = _v20;
    caml_local_roots = _t35;
    return _v24;
}

caml_sys_random_seed(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi                         // r5
)
{// addr = 0x0806608A
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    intOrPtr _v56;                         // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    signed int _t14;                       // _t14
    _unknown_ _t21;                        // _t21
    _unknown_ _t28;                        // _t28
    _unknown_ _t31;                        // _t31

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _v56 = 0;
     *__esp =  &_v36;
    gettimeofday();
    _t14 = getppid();
    return (_v32 ^ _v36 ^ getpid() ^ _t14 << 16) + (_v32 ^ _v36 ^ getpid() ^ _t14 << 16) + 1;
}

caml_sys_time()
{// addr = 0x080660DC
    char _v84;                             // _cfa_ffffffac
    char* _v104;                           // _cfa_ffffff98
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4

    _v104 =  &_v84;
     *__esp = 0;
    getrusage();
    asm("fild dword [ebp-0x50]");
    asm("fild dword [ebp-0x4c]");
    asm("fld dword [0x806b1a8]");
    asm("fdiv st1, st0");
    asm("fxch st0, st1");
    asm("faddp st2, st0");
    asm("fild dword [ebp-0x48]");
    asm("faddp st2, st0");
    asm("fild dword [ebp-0x44]");
    asm("fdivrp st1, st0");
    asm("faddp st1, st0");
    asm("fstp qword [esp]");
    caml_copy_double();
    return;
}

caml_sys_getenv(
    char* _a4                              // _cfa_4
)
{// addr = 0x0806611D
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4

    if(getenv(_a4) == 0) {
        caml_raise_not_found();
    }
    caml_copy_string(__ebx, __edi, __esi, _t3);
    return;
}

caml_sys_file_exists(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08066141
    char _v108;                            // _cfa_ffffff94
    char* _v116;                           // _cfa_ffffff8c
    signed int _v120;                      // _cfa_ffffff88
    _unknown_ __ebp;                       // r6
    signed int _t6;                        // _t6

    _v116 =  &_v108;
    _t6 = _a4;
    _v120 = _t6;
     *__esp = 3;
    __xstat64();
    asm("sbb eax, eax");
    return (_t6 & 2) + 1;
}

caml_sys_close(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0806616E
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4
    _unknown_ _t5;                         // _t5

    close(_a4 >> 1);
    return 1;
}

caml_sys_exit(
    _unknown_ __eax,                       // r0
    intOrPtr __edi,                        // r4
    signed int _a4                         // _cfa_4
)
{// addr = 0x08066188
    void* _v0;            // _cfa_0
    void* _v4;            // _cfa_fffffffc
    char _v24;                             // _cfa_ffffffe8
    intOrPtr _v56;                         // _cfa_ffffffc8
    void* _v68;           // _cfa_ffffffbc
    char* _v76;                            // _cfa_ffffffb4
    intOrPtr _v80;                         // _cfa_ffffffb0
    intOrPtr _v84;                         // _cfa_ffffffac
    char _v88;                             // _cfa_ffffffa8
    char _v92;                             // _cfa_ffffffa4
    char _v100;                            // _cfa_ffffff9c
    char* _v112;                           // _cfa_ffffff90
    intOrPtr _v116;                        // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    char _v124;                            // _cfa_ffffff84
    _unknown_ _v144;                       // _cfa_ffffff70
    char _v148;                            // _cfa_ffffff6c
    char* _v184;                           // _cfa_ffffff48
    intOrPtr _v188;                        // _cfa_ffffff44
    intOrPtr _v192;                        // _cfa_ffffff40
    char _v196;                            // _cfa_ffffff3c
    char _v200;                            // _cfa_ffffff38
    char* _v220;                           // _cfa_ffffff24
    intOrPtr _v224;                        // _cfa_ffffff20
    intOrPtr _v228;                        // _cfa_ffffff1c
    char _v232;                            // _cfa_ffffff18
    char _v244;                            // _cfa_ffffff0c
    intOrPtr _v256;                        // _cfa_ffffff00
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t56;                        // _t56
    _unknown_ _t59;                        // _t59
    _unknown_ _t68;                        // _t68
    int _t69;                              // _t69
    void* _t70;           // _t70
    _unknown_ _t71;                        // _t71
    _unknown_ _t76;                        // _t76
    intOrPtr _t84;                         // _t84
    int _t88;                              // _t88
    _unknown_ _t91;                        // _t91
    intOrPtr _t95;                         // _t95
    _unknown_ _t96;                        // _t96
    _unknown_ _t98;                        // _t98
    void* _t99;           // _t99
    char* _t100;                           // _t100
    _unknown_ _t101;                       // _t101
    void** _t102;         // _t102
    _unknown_ _t103;                       // _t103

    _t95 = __edi;
    exit(_a4 >> 1);
    _push(_t101);
    _t102 = __esp;
    _push(_t95);
    _push(_t98);
    _push(_t88);
    __esp = __esp - 108;
    _v88 = caml_local_roots;
    _v80 = 1;
    _v84 = 1;
    _v76 =  &_v24;
    _v92 = 0;
    _v124 =  &_v88;
    caml_local_roots =  &_v124;
    _v116 = 1;
    _v120 = 1;
    _v112 =  &_v92;
    _t99 = strerror( *(__errno_location()));
    _t93 = _v24;
    if(_v24 != 1) {
        asm("repne scasb ");
        _t97 =  !-1 - 1;
        _t69 = caml_string_length(_t93);
        _t88 = _t69;
        _t70 = _t69 +  !-1 - 1 + 2;
        caml_alloc_string(_t70);
        _v68 = _t70;
        memmove(_t70, _v0, _t88);
         *((short*)(_v68 + _t88)) = 8250;
        memmove( &(_v68[0]) + _t88, _t99, _t97);
    } else {
        _v68 = caml_copy_string(_t88, _t95, _t99, _t67);
    }
     *__esp = _v68;
    caml_raise_sys_error();
    _push(_t102);
    _push(_t99);
    _push(_t88);
    __esp = __esp - 96;
    _t100 = caml_local_roots;
    _v196 = _t100;
    _v188 = 1;
    _v192 = 1;
    _v184 =  &_v148;
    _v200 = 0;
    _v232 =  &_v196;
    caml_local_roots =  &_v232;
    _v224 = 1;
    _v228 = 1;
    _v220 =  &_v200;
    _v256 = 50;
    _t89 =  ?_? ( &_v244);
     *__esp =  ?_? ( &_v244);
    caml_ext_table_init();
    if(caml_read_directory(_v148,  &_v244) == 255) {
        caml_ext_table_free(_t89, 1);
         *__esp = _v4;
        L1();
    }
    caml_ext_table_add( ?_? ( &_v100), 0);
    _t84 = _v92;
    caml_copy_string_array(_t84);
    _v56 = _t84;
    caml_ext_table_free( &_v100, 1);
    caml_local_roots = _t100;
    __esp =  &((__esp)[0x18]);
    _pop(__ebx);
    _pop(__esi);
    return _v56;
}

caml_sys_error(
    _unknown_ __eax,                       // r0
    void* _a4             // _cfa_4
)
{// addr = 0x0806619B
    void* _v0;            // _cfa_0
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    void* _v64;           // _cfa_ffffffc0
    char* _v84;                            // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    intOrPtr _v92;                         // _cfa_ffffffa4
    char _v96;                             // _cfa_ffffffa0
    _unknown_ _v116;                       // _cfa_ffffff8c
    char _v120;                            // _cfa_ffffff88
    char* _v156;                           // _cfa_ffffff64
    intOrPtr _v160;                        // _cfa_ffffff60
    intOrPtr _v164;                        // _cfa_ffffff5c
    char _v168;                            // _cfa_ffffff58
    char _v172;                            // _cfa_ffffff54
    char* _v192;                           // _cfa_ffffff40
    intOrPtr _v196;                        // _cfa_ffffff3c
    intOrPtr _v200;                        // _cfa_ffffff38
    char _v204;                            // _cfa_ffffff34
    char _v216;                            // _cfa_ffffff28
    intOrPtr _v228;                        // _cfa_ffffff1c
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t55;                        // _t55
    _unknown_ _t64;                        // _t64
    int _t65;                              // _t65
    void* _t66;           // _t66
    _unknown_ _t67;                        // _t67
    _unknown_ _t72;                        // _t72
    intOrPtr _t80;                         // _t80
    _unknown_ _t83;                        // _t83
    int _t85;                              // _t85
    _unknown_ _t88;                        // _t88
    intOrPtr _t92;                         // _t92
    _unknown_ _t93;                        // _t93
    _unknown_ _t95;                        // _t95
    void* _t96;           // _t96
    char* _t97;                            // _t97
    _unknown_ _t98;                        // _t98
    _unknown_ _t99;                        // _t99

    _push(_t92);
    _push(_t95);
    _push(_t85);
    __esp = __esp - 108;
    _v60 = caml_local_roots;
    _v52 = 1;
    _v56 = 1;
    _v48 =  &_a4;
    _v64 = 0;
    _v96 =  &_v60;
    caml_local_roots =  &_v96;
    _v88 = 1;
    _v92 = 1;
    _v84 =  &_v64;
    _t96 = strerror( *(__errno_location()));
    _t90 = _a4;
    if(_a4 != 1) {
        asm("repne scasb ");
        _t94 =  !-1 - 1;
        _t65 = caml_string_length(_t90);
        _t85 = _t65;
        _t66 = _t65 +  !-1 - 1 + 2;
        caml_alloc_string(_t66);
        _v64 = _t66;
        memmove(_t66, _a4, _t85);
         *((short*)(_v64 + _t85)) = 8250;
        memmove( &(_v64[0]) + _t85, _t96, _t94);
    } else {
        _v64 = caml_copy_string(_t85, _t92, _t96, _t63);
    }
     *__esp = _v64;
    caml_raise_sys_error();
    _push(_t98);
    _push(_t96);
    _push(_t85);
    __esp = __esp - 96;
    _t97 = caml_local_roots;
    _v168 = _t97;
    _v160 = 1;
    _v164 = 1;
    _v156 =  &_v120;
    _v172 = 0;
    _v204 =  &_v168;
    caml_local_roots =  &_v204;
    _v196 = 1;
    _v200 = 1;
    _v192 =  &_v172;
    _v228 = 50;
    _t86 =  ?_? ( &_v216);
     *__esp =  ?_? ( &_v216);
    caml_ext_table_init();
    if(caml_read_directory(_v120,  &_v216) == 255) {
        caml_ext_table_free(_t86, 1);
         *__esp = _v0;
        caml_sys_error(_v0);
    }
    caml_ext_table_add( ?_? ( &_v96), 0);
    _t80 = _v88;
    caml_copy_string_array(_t80);
    _v52 = _t80;
    caml_ext_table_free( &_v96, 1);
    caml_local_roots = _t97;
    __esp =  &((__esp)[0x18]);
    _pop(__ebx);
    _pop(__esi);
    return _v52;
}

caml_sys_read_directory(
    char _a4                               // _cfa_4
)
{// addr = 0x0806627A
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    char _v48;                             // _cfa_ffffffd0
    char* _v68;                            // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    intOrPtr _v76;                         // _cfa_ffffffb4
    char _v80;                             // _cfa_ffffffb0
    intOrPtr _v84;                         // _cfa_ffffffac
    char _v92;                             // _cfa_ffffffa4
    intOrPtr _v104;                        // _cfa_ffffff98
    _unknown_ __ebx;                       // r1
    char* __esi;                           // r5
    _unknown_ __ebp;                       // r6
    intOrPtr _t32;                         // _t32
    _unknown_ _t35;                        // _t35

    __esi = caml_local_roots;
    _v44 = __esi;
    _v36 = 1;
    _v40 = 1;
    _v32 =  &_a4;
    _v48 = 0;
    _v80 =  &_v44;
    caml_local_roots =  &_v80;
    _v72 = 1;
    _v76 = 1;
    _v68 =  &_v48;
    _v104 = 50;
    _t36 =  ?_? ( &_v92);
     *__esp =  ?_? ( &_v92);
    caml_ext_table_init();
    if(caml_read_directory(_a4,  &_v92) == 255) {
        caml_ext_table_free(_t36, 1);
         *__esp = _a4;
        caml_sys_error(_a4);
    }
    caml_ext_table_add( ?_? ( &_v92), 0);
    _t32 = _v84;
    caml_copy_string_array(_t32);
    _v48 = _t32;
    caml_ext_table_free( &_v92, 1);
    caml_local_roots = __esi;
    return _v48;
}

caml_sys_system_command(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    void* _a4             // _cfa_4
)
{// addr = 0x0806634B
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    char* _t28;                            // _t28
    _unknown_ _t30;                        // _t30
    signed int _t32;                       // _t32
    _unknown_ _t35;                        // _t35
    _unknown_ _t38;                        // _t38
    char* _t40;                            // _t40
    _unknown_ _t41;                        // _t41
    signed int _t44;                       // _t44
    _unknown_ _t45;                        // _t45

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t40 = caml_local_roots;
    _v60 = _t40;
    caml_local_roots =  &_v60;
    _v52 = 1;
    _v56 = 1;
    _v48 =  &_a4;
    _t28 = caml_string_length(_a4);
    _t43 =  &(_t28[1]);
    caml_stat_alloc( &(_t28[1]));
    _t37 = _t28;
    memmove(_t28, _a4, _t43);
    caml_enter_blocking_section();
    _t44 = system(_t28);
    caml_leave_blocking_section();
    caml_stat_free(_t37);
    if(_t44 != 255) {
        _t32 = 255;
        if((_t44 & 127) == 0) {
            _t32 = _t44 & 0xff;
        }
    } else {
         *__esp = _a4;
        caml_sys_error(_a4);
        _t32 = 255;
    }
    caml_local_roots = _t40;
    return _t32 + _t32 + 1;
}

caml_sys_getcwd()
{// addr = 0x08066406
    char _v4108;                           // _cfa_ffffeff4
    _unknown_ _v4120;                      // _cfa_ffffefe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    _unknown_ _t8;                         // _t8

    if(getcwd( &_v4108, 4096) == 0) {
         *__esp = 1;
        caml_sys_error(_t5);
    }
    caml_copy_string(__ebx, __edi, __esi,  &_v4108);
    return;
}

caml_sys_chdir(
    char* _a4                              // _cfa_4
)
{// addr = 0x08066445
    char* __ebx;                           // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4

    __ebx = _a4;
    if(chdir(__ebx) != 0) {
         *__esp = __ebx;
        caml_sys_error(_t2);
    }
    return 1;
}

caml_sys_rename(
    char* _a4,                             // _cfa_4
    char* _a8                              // _cfa_8
)
{// addr = 0x0806646E
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    _unknown_ _t8;                         // _t8

    if(rename(_a4, _a8) != 0) {
         *__esp = 1;
        caml_sys_error(_t6);
    }
    return 1;
}

caml_sys_remove(
    char* _a4                              // _cfa_4
)
{// addr = 0x0806649D
    char* __ebx;                           // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4

    __ebx = _a4;
    if(unlink(__ebx) != 0) {
         *__esp = __ebx;
        caml_sys_error(_t2);
    }
    return 1;
}

caml_sys_is_directory(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x080664C6
    signed int _v92;                       // _cfa_ffffffa4
    char _v108;                            // _cfa_ffffff94
    intOrPtr _v116;                        // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    intOrPtr __ebx;                        // r1
    _unknown_ __ebp;                       // r6
    char* _t12;                            // _t12
    _unknown_ _t17;                        // _t17

    __ebx = _a4;
    _t12 =  &_v108;
    _v116 = _t12;
    _v120 = __ebx;
     *__esp = 3;
    __xstat64();
    if(_t12 == 255) {
         *__esp = __ebx;
        caml_sys_error(_t12);
    }
    return (_v92 & 0) + (_v92 & 0) + 1;
}

caml_sys_open(
    char* _a4,                             // _cfa_4
    _unknown_ _a8,                         // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x08066511
    char* _v40;                            // _cfa_ffffffd8
    char* _v44;                            // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v84;                       // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    char* __ebx;                           // r1
    char* __edi;                           // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    char* _t33;                            // _t33
    _unknown_ _t35;                        // _t35
    intOrPtr _t37;                         // _t37
    signed int _t40;                       // _t40
    _unknown_ _t42;                        // _t42
    _unknown_ _t43;                        // _t43
    signed int _t45;                       // _t45

    __edi = caml_local_roots;
    _v60 = __edi;
    caml_local_roots =  &_v60;
    _v52 = 1;
    _v56 = 3;
    _v48 =  &_a4;
    _v44 =  &_a8;
    _v40 =  &_a12;
    _t33 = caml_string_length(_a4) + 1;
    caml_stat_alloc(_t33);
    __ebx = _t33;
    strcpy(__ebx, _a4);
    _t37 = caml_convert_flag_list(_a8,  &sys_open_flags);
    _v64 = _a12 >> 1;
    caml_enter_blocking_section();
    _t40 = _v64;
    _v84 = _t40;
    _v88 = _t37;
     *__esp = __ebx;
    open64();
    _t45 = _t40;
    if(_t40 == 255) {
        caml_leave_blocking_section();
         *__esp = __ebx;
        _t45 = _t45;
        caml_stat_free();
         *__esp = _a4;
        caml_sys_error(_a4);
    } else {
        _v84 = 1;
        _v88 = 2;
         *__esp = _t40;
        fcntl();
        caml_leave_blocking_section();
        caml_stat_free(__ebx);
    }
    caml_local_roots = __edi;
    return;
}

caml_sys_io_error(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08066602
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4

    if( *(__errno_location()) == 11) {
        caml_raise_sys_blocked_io();
    }
     *__esp = _a4;
    caml_sys_error(_a4);
    return;
}

caml_set_parser_trace(
    signed int __eax,                      // r0
    signed int _a4                         // _cfa_4
)
{// addr = 0x08066624
    _unknown_ __ebp;                       // r6

    asm("sbb eax, eax");
    caml_parser_trace = _a4 >> 1;
    return (__eax & 254) + 3;
}

token_name(
    char* __eax,                           // r0
    _unknown_ __edx                        // r3
)
{// addr = 0x08066643
    char* __ebx;                           // r1
    signed int __esi;                      // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3

    __edx = __edx;
    __ebx = __eax;
    if(__edx > 0) {
        __esi = -1;
        if( *__ebx != 0) {
            while(1) {
                asm("repne scasb ");
                __ebx = __ebx +  !__esi;
                __edx = __edx - 1;
                if(__edx <= 0) {
                    break;
                }
                if( *__ebx == 0) {
                    goto L6;
                } else {
                    continue;
                }
                goto L7;
            }
        } else {
L6:
            __ebx = "<unknown token>";
        }
    }
L7:
    return __ebx;
}

caml_parse_engine(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    intOrPtr _a4,                          // _cfa_4
    intOrPtr* _a8,                         // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x08066684
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    struct _IO_FILE* _v44;   // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    _unknown_ _t290;                       // _t290
    signed int _t292;                      // _t292
    _unknown_ _t293;                       // _t293
    signed int _t295;                      // _t295
    _unknown_ _t297;                       // _t297
    signed int _t299;                      // _t299
    short _t301;                           // _t301
    _unknown_ _t304;                       // _t304
    _unknown_ _t307;                       // _t307
    intOrPtr _t310;                        // _t310
    _unknown_ _t315;                       // _t315
    signed int _t317;                      // _t317
    signed int _t319;                      // _t319
    _unknown_ _t321;                       // _t321
    _unknown_ _t323;                       // _t323
    signed int _t326;                      // _t326
    _unknown_ _t330;                       // _t330
    _unknown_ _t331;                       // _t331
    _unknown_ _t333;                       // _t333
    _unknown_ _t336;                       // _t336
    _unknown_ _t354;                       // _t354
    _unknown_ _t356;                       // _t356
    _unknown_ _t361;                       // _t361
    _unknown_ _t365;                       // _t365
    intOrPtr _t368;                        // _t368
    signed int _t375;                      // _t375
    _unknown_ _t380;                       // _t380
    _unknown_ _t381;                       // _t381
    intOrPtr* _t382;                       // _t382
    signed int _t387;                      // _t387
    _unknown_ _t389;                       // _t389
    signed int _t391;                      // _t391
    signed int _t393;                      // _t393
    _unknown_ _t395;                       // _t395
    signed int _t402;                      // _t402
    short _t404;                           // _t404
    _unknown_ _t410;                       // _t410
    signed int _t417;                      // _t417
    signed int _t419;                      // _t419
    signed int _t421;                      // _t421
    _unknown_ _t426;                       // _t426
    signed int _t428;                      // _t428
    signed int _t430;                      // _t430

    __esi = _a4;
    _t382 = _a8;
    _t292 = _a12 >> 1;
    if(_t292 > 5) {
L70:
        return 3;
    }
    switch( *((intOrPtr*)(_t292 * 4 +  &M0806C024))) {
        case 0:
            _t428 =  *(_t382 + 52) >> 1;
            _v40 = 0;
            _v36 = 0;
            goto L3;
        case 1:
            (__ebx)[0xd] = (__ebx)[0xd] >> 1;
            (__ebx)[0xe] = (__ebx)[0xe] >> 1;
            _v36 = (__ebx)[0xe] >> 1;
            (__ebx)[0xf] = (__ebx)[0xf] >> 1;
            _v40 = (__ebx)[0xf] >> 1;
            _a16 = _a16 & 1;
            _v44 = _a16 & 1;
            if(__eflags != 0) {
                _a16 = _a16 >> 1;
                 *(__esi + 4) =  *( *(__esi + 4) + (_a16 >> 1) * 4);
                (__ebx)[6] =  *( *(__esi + 4) + (_a16 >> 1) * 4);
                _v72 = 1;
                __eax =  &((__ebx)[7]);
                 *__esp =  &((__ebx)[7]);
                caml_modify(__ebx);
            } else {
                __ecx = _a16;
                __edx =  *(__ecx - 4) & 255;
                 *(__esi + 8) =  *( *(__esi + 8) + ( *(__ecx - 4) & 255) * 4);
                (__ebx)[6] =  *( *(__esi + 8) + ( *(__ecx - 4) & 255) * 4);
                __eax =  *__ecx;
                _v72 =  *__ecx;
                __eax =  &((__ebx)[7]);
                 *__esp =  &((__ebx)[7]);
                caml_modify(__ebx);
            }
            __eflags = caml_parser_trace;
            if(caml_parser_trace != 0) {
                __eflags = _v44;
                if(_v44 == 0) {
                    __ecx = _a16;
                    __edx =  *(_a16 - 4) & 255;
                    __eax =  *(__esi + 60);
                    _v64 = token_name( *(__esi + 60),  *(_a16 - 4) & 255);
                    __eax = _v36;
                    _v68 = _v36;
                    _v72 = "State %d: read token %s(";
                    __eax = __imp__stderr;
                     *__esp = __imp__stderr;
                    __eax = fprintf();
                    __edx = _a16;
                    __eax =  *_a16;
                    __eflags = __eax & 1;
                    if((__eax & 1) == 0) {
                        __edx =  *(__eax - 4) & 255;
                        __eflags = (__edx & 255) - 252;
                        if((__edx & 255) != 252) {
                            __eflags = (__edx & 255) - 253;
                            if((__edx & 255) != 253) {
                                __imp__stderr = fputc(95, __imp__stderr);
                            } else {
                                asm("fld qword [eax]");
                                asm("fstp qword [esp+0x8]");
                                _v72 = "%g";
                                __eax = __imp__stderr;
                                 *__esp = __imp__stderr;
                                __eax = fprintf();
                            }
                        } else {
                            __edx = __imp__stderr;
                            __eax = fputs(__eax, __imp__stderr);
                        }
                    } else {
                        _v68 = __eax;
                        _v72 = "%ld";
                        __eax = __imp__stderr;
                         *__esp = __imp__stderr;
                        __eax = fprintf();
                    }
                    __imp__stderr = fwrite(")\n", 1, 2, __imp__stderr);
                } else {
                    __edx = _a16;
                    __edx = _a16 >> 1;
                    __eax =  *(__esi + 56);
                    _v64 = token_name( *(__esi + 56), _a16 >> 1);
                    __eax = _v36;
                    _v68 = _v36;
                    _v72 = "State %d: read token %s\n";
                    __eax = __imp__stderr;
                     *__esp = __imp__stderr;
                    __eax = fprintf();
                }
            }
L20:
            _t391 = _v36 + _v36;
            _v44 = _t391;
            _t317 =  *( *((intOrPtr*)(__esi + 28)) + _t391);
            _t393 =  *(_t382 + 24) >> 1;
            _t417 = _t317 + _t393;
            _v32 = _t417;
            __eflags = _t317;
            if(_t317 == 0) {
L24:
                _t319 =  *( *((intOrPtr*)(__esi + 32)) + _v44);
                _t419 = _t319 + _t393;
                __eflags = _t319;
                if(_t319 == 0) {
L29:
                    __eflags = _v40;
                    if(_v40 > 0) {
                        goto L32;
                    }
                    goto L30;
                }
                goto L25;
L30:
                 *(_t382 + 52) = _t428 + _t428 + 1;
                 *((intOrPtr*)(_t382 + 56)) = _v36 + _v36 + 1;
                 *((intOrPtr*)(_t382 + 60)) = _v40 + _v40 + 1;
                return 11;
            }
            __eflags = _t417;
            if(_t417 >= 0) {
                goto L24;
            }
            __eflags = _t417 -  *(__esi + 40) >> 1;
            if(_t417 >  *(__esi + 40) >> 1) {
                goto L24;
            }
            _t375 =  *( *((intOrPtr*)(__esi + 48)) + _t417 * 2);
            __eflags = _t393 - _t375;
            if(_t393 == _t375) {
                 *(_t382 + 24) = -1;
                __eflags = _v40;
                _v40 = _v40 - (_t375 & 0xff);
                goto L50;
            }
            goto L24;
L50:
            __eflags = caml_parser_trace;
            if(caml_parser_trace != 0) {
                _v64 =  *( *((intOrPtr*)(__esi + 44)) + _v32 * 2);
                _v68 = _v36;
                fprintf(__imp__stderr, "State %d: shift to state %d\n");
            }
            _v36 =  *( *((intOrPtr*)(__esi + 44)) + _v32 * 2);
            _t428 = _t428 + 1;
            __eflags = _t428 -  *(_t382 + 16) >> 1;
            if(_t428 <  *(_t382 + 16) >> 1) {
                goto L55;
            }
             *(_t382 + 52) = _t428 + _t428 + 1;
             *((intOrPtr*)(_t382 + 56)) = _v36 + _v36 + 1;
             *((intOrPtr*)(_t382 + 60)) = _v40 + _v40 + 1;
            return 5;
L25:
            __eflags = _t419;
            if(_t419 >= 0) {
                goto L29;
            }
            __eflags = _t419 -  *(__esi + 40) >> 1;
            if(_t419 >  *(__esi + 40) >> 1) {
                goto L29;
            }
            _t426 = _t419 + _t419;
            _t368 =  *((intOrPtr*)(__esi + 48));
            __eflags = _t393 -  *((short*)(_t368 + _t426));
            if(_t393 !=  *((short*)(_t368 + _t426))) {
                goto L29;
            } else {
                _v32 =  *( *((intOrPtr*)(__esi + 44)) + _t426);
            }
            goto L56;
        case 2:
            (__ebx)[0xd] = (__ebx)[0xd] >> 1;
            (__ebx)[0xe] = (__ebx)[0xe] >> 1;
            _v36 = (__ebx)[0xe] >> 1;
            (__ebx)[0xf] = (__ebx)[0xf] >> 1;
            _v40 = (__ebx)[0xf] >> 1;
L32:
            __eflags = _v40 - 2;
            if(__eflags > 0) {
                if(__eflags == 0) {
                    goto L70;
                }
                goto L46;
            } else {
                goto L33;
            }
            while(1) {
L33:
                _t421 =  *( *_t382 + _t428 * 4) >> 1;
                _t326 =  *( *((intOrPtr*)(__esi + 28)) + _t421 * 2);
                _t395 = _t326 + 256;
                __eflags = _t326;
                if(_t326 == 0) {
                    goto L39;
                } else {
                    goto L34;
                }
            }
L46:
            __eflags = caml_parser_trace;
            if(caml_parser_trace != 0) {
                fwrite("Discarding last token read\n", 1, 27, __imp__stderr);
            }
             *(_t382 + 24) = -1;
            goto L3;
        case 3:
            (__ebx)[0xd] = (__ebx)[0xd] >> 1;
            (__ebx)[0xe] = (__ebx)[0xe] >> 1;
            _v36 = (__ebx)[0xe] >> 1;
            (__ebx)[0xf] = (__ebx)[0xf] >> 1;
            _v40 = (__ebx)[0xf] >> 1;
L55:
            _v32 = 0 + _t428 * 4;
             *((intOrPtr*)(_v32 +  *_t382)) = _v36 + _v36 + 1;
            caml_modify(_t382, _v32 +  *((intOrPtr*)(_t382 + 4)),  *((intOrPtr*)(_t382 + 28)));
            caml_modify(_t382, _v32 +  *((intOrPtr*)(_t382 + 8)),  *((intOrPtr*)(_t382 + 32)));
            caml_modify(_t382, _v32 +  *((intOrPtr*)(_t382 + 12)),  *((intOrPtr*)(_t382 + 36)));
            goto L3;
        case 4:
            (__ebx)[0xd] = (__ebx)[0xd] >> 1;
            (__ebx)[0xe] = (__ebx)[0xe] >> 1;
            (__ebx)[0xf] = (__ebx)[0xf] >> 1;
            _v40 = (__ebx)[0xf] >> 1;
            goto L67;
        case 5:
            __edi = (__ebx)[0xd];
            __edi = (__ebx)[0xd] >> 1;
            (__ebx)[0xe] = (__ebx)[0xe] >> 1;
            _v36 = (__ebx)[0xe] >> 1;
            (__ebx)[0xf] = (__ebx)[0xf] >> 1;
            _v40 = (__ebx)[0xf] >> 1;
            __ecx = 0 + __edi * 4;
            _v44 = 0 + __edi * 4;
            __edx =  *__ebx;
            __ecx = _v36;
            __eax = _v36 + _v36 + 1;
            __ecx = _v44;
             *(__ecx +  *__ebx) = _v36 + _v36 + 1;
            __eax = _a16;
            _v72 = _a16;
             *__esp = __ecx + (__ebx)[1];
            caml_modify(__ebx);
            __eax = (__ebx)[0xa];
            __eax = (__ebx)[0xa] >> 1;
            _v32 = __eax;
            _v48 = __eax;
            __eax = (__ebx)[3];
            __ecx = _v48;
            __edx =  *(__ecx + __eax);
            _v72 =  *(__ecx + __eax);
             *__esp = __eax;
            caml_modify(__ebx);
            __eflags = __edi - _v32;
            if(__edi > _v32) {
                __eax = (__ebx)[3];
                __edx = _v48;
                __eax =  *(_v48 + (__ebx)[3]);
                _v72 =  *(_v48 + (__ebx)[3]);
                _v44 = _v44 + (__ebx)[2];
                 *__esp = _v44 + (__ebx)[2];
                caml_modify(__ebx);
            }
L3:
            _t402 = _v36;
            _t295 =  *( *((intOrPtr*)(__esi + 20)) + _t402 * 2);
            _v32 = _t295;
            if(_t295 != 0) {
L56:
                __eflags = caml_parser_trace;
                if(caml_parser_trace != 0) {
                    _v64 = _v32;
                    _v68 = _v36;
                    fprintf(__imp__stderr, "State %d: reduce by rule %d\n");
                }
                _t297 = _v32 + _v32;
                _t404 =  *((short*)( *((intOrPtr*)(__esi + 16)) + _t297));
                 *((intOrPtr*)(_t382 + 40)) = _t428 + _t428 + 1;
                 *((intOrPtr*)(_t382 + 48)) = _t297 + 1;
                 *((intOrPtr*)(_t382 + 44)) = _t404 + _t404 + 1;
                _t430 = _t428 + 1 - _t404;
                _v36 =  *( *_t382 + _t430 * 4 - 4) >> 1;
                _t410 =  *((short*)( *((intOrPtr*)(__esi + 12)) + _t297)) +  *((short*)( *((intOrPtr*)(__esi + 12)) + _t297));
                _t299 =  *( *((intOrPtr*)(__esi + 36)) + _t410);
                _t387 = _v36 + _t299;
                __eflags = _t299;
                if(_t299 == 0) {
L63:
                    _t301 =  *((short*)( *((intOrPtr*)(__esi + 24)) + _t410));
                } else {
                    __eflags = _t387;
                    if(_t387 >= 0) {
                        goto L63;
                    }
                    __eflags = _t387 -  *(__esi + 40) >> 1;
                    if(_t387 >  *(__esi + 40) >> 1) {
                        goto L63;
                    }
                    _t389 = _t387 + _t387;
                    _t310 =  *((intOrPtr*)(__esi + 48));
                    __eflags =  *((short*)(_t310 + _t389)) - _v36;
                    if( *((short*)(_t310 + _t389)) != _v36) {
                        goto L63;
                    }
                    _t301 =  *((short*)( *((intOrPtr*)(__esi + 44)) + _t389));
                }
                __eflags = _t430 -  *(_t382 + 16) >> 1;
                if(_t430 <  *(_t382 + 16) >> 1) {
L67:
                     *(_t382 + 52) = _t430 + _t430 + 1;
                     *((intOrPtr*)(_t382 + 56)) = _t301 + _t301 + 1;
                     *((intOrPtr*)(_t382 + 60)) = _v40 + _v40 + 1;
                    return 9;
                }
                 *(_t382 + 52) = _t430 + _t430 + 1;
                 *((intOrPtr*)(_t382 + 56)) = _t301 + _t301 + 1;
                 *((intOrPtr*)(_t382 + 60)) = _v40 + _v40 + 1;
                return 7;
            } else {
                if( *(_t382 + 24) >= 0) {
                    goto L20;
                } else {
                     *(_t382 + 52) = _t428 + _t428 + 1;
                     *((intOrPtr*)(_t382 + 56)) = _t402 + _t402 + 1;
                     *((intOrPtr*)(_t382 + 60)) = _v40 + _v40 + 1;
                    return 1;
                }
            }
    }
    return __eax;
}

norm_pfree(
    _unknown_ __eax                        // r0
)
{// addr = 0x08066CF0
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    _t2 = __eax;
    _t3 = _t2 == 0 ? 1 : _t2;
    return _t2 == 0 ? 1 : _t2;
}

norm_pmax()
{// addr = 0x08066CFF
    _unknown_ __ebp;                       // r6

    return;
}

norm_heapincr(
    _unknown_ __eax                        // r0
)
{// addr = 0x08066D04
    _unknown_ __ebp;                       // r6
    signed int _t4;                        // _t4

    _t4 = __eax + 1023 & -1024;
    _t5 = _t4 - 2047 <= 0 ? 2048 : _t4;
    return _t4 - 2047 <= 0 ? 2048 : _t4;
}

norm_minsize(
    _unknown_ __eax                        // r0
)
{// addr = 0x08066D20
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4
    _unknown_ _t6;                         // _t6
    _unknown_ _t7;                         // _t7

    _t4 = __eax - 4095 <= 0 ? 4096 : __eax;
    _t5 = _t4 - 268435456 > 0 ? 268435456 : _t4;
    return _t4 - 268435456 > 0 ? 268435456 : _t4;
}

caml_init_gc(
    signed int _a4,                        // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    intOrPtr _a16,                         // _cfa_10
    intOrPtr _a20                          // _cfa_14
)
{// addr = 0x08066D3F
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    signed int __esi;                      // r5
    _unknown_ __ebp;                       // r6
    intOrPtr _t24;                         // _t24
    _unknown_ _t28;                        // _t28

    __esi = _a4;
    _t42 = 0 + norm_heapincr(_a8) * 4;
    _t24 = 0 + norm_heapincr(_a8) * 4 + _a4 * 4;
     *__esp = _t24;
    caml_page_table_initialize();
    if(_t24 != 0) {
        caml_fatal_error("OCaml runtime error: cannot initialize page table\n");
    }
    caml_set_minor_heap_size(norm_minsize(__esi) << 2);
    caml_major_heap_increment = norm_heapincr(_a12) << 2;
    caml_percent_free = norm_pfree(_a16);
    norm_pmax();
    caml_percent_max = _a20;
    caml_init_major_heap(_a20, _t42);
    caml_gc_message(32, "Initial minor heap size: %luk bytes\n", caml_minor_heap_size >> 10);
    caml_gc_message(32, "Initial major heap size: %luk bytes\n", _t42 >> 10);
    caml_gc_message(32, "Initial space overhead: %lu%%\n", caml_percent_free);
    caml_gc_message(32, "Initial max overhead: %lu%%\n", caml_percent_max);
    caml_gc_message(32, "Initial heap increment: %luk bytes\n", caml_major_heap_increment >> 10);
    caml_gc_message(32, "Initial allocation policy: %d\n", caml_allocation_policy);
    return;
}

caml_gc_compaction()
{// addr = 0x08066E71
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4
    _unknown_ _t5;                         // _t5

    caml_gc_message(16, "Heap compaction requested\n", 0);
    caml_empty_minor_heap();
    caml_finish_major_cycle();
    caml_final_do_calls();
    caml_empty_minor_heap();
    caml_finish_major_cycle();
    caml_compact_heap();
    caml_final_do_calls();
    return 1;
}

test_and_compact(
    _unknown_ __eflags                     // r9
)
{// addr = 0x08066EC1
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _v28;                         // _cfa_ffffffe4
    signed short _v30;                     // _cfa_ffffffe2
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    intOrPtr _t18;                         // _t18
    _unknown_ _t26;                        // _t26
    _unknown_ _t27;                        // _t27
    _unknown_ _t28;                        // _t28

    _t28 = __eflags;
    _t18 = caml_fl_cur_size;
    _v28 = _t18;
    _v24 = 0;
    asm("fild qword [ebp-0x18]");
    asm("fmul dword [0x806c27c]");
    _v28 = (caml_stat_heap_size >> 2) - _t18;
    _v24 = 0;
    asm("fild qword [ebp-0x18]");
    asm("fdivp st1, st0");
    asm("fstp dword [ebp-0x20]");
    asm("fld dword [0x806c280]");
    asm("fld dword [ebp-0x20]");
    asm("fucomi st0, st1");
    asm("fcmovnbe st0, st1");
    asm("fstp st1");
    asm("fst dword [ebp-0x20]");
    asm("fnstcw word [ebp-0x1a]");
    _v32 = _v30 & 0xffff;
    asm("fldcw word [ebp-0x1c]");
    asm("fistp qword [ebp-0x18]");
    asm("fldcw word [ebp-0x1a]");
    caml_gc_message(512, "Estimated overhead (lower bound) = %lu%%\n", _v28);
    _v28 = caml_percent_max;
    _v24 = 0;
    asm("fild qword [ebp-0x18]");
    asm("fld dword [ebp-0x20]");
    asm("fucomip st0, st1");
    asm("fstp st0");
    if(_t28 < 0 || caml_stat_heap_chunks <= 1) {
        return;
    } else {
        caml_gc_message(512, "Automatic compaction triggered.\n", 0);
        caml_compact_heap();
        return;
    }
}

caml_gc_full_major()
{// addr = 0x08066F8B
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4
    _unknown_ _t5;                         // _t5

    caml_gc_message(1, "Full major GC cycle requested\n", 0);
    caml_empty_minor_heap();
    caml_finish_major_cycle();
    caml_final_do_calls();
    caml_empty_minor_heap();
    caml_finish_major_cycle();
    test_and_compact(__eflags);
    caml_final_do_calls();
    return 1;
}

caml_gc_major()
{// addr = 0x08066FDC
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4
    _unknown_ _t5;                         // _t5

    caml_gc_message(1, "Major GC cycle requested\n", 0);
    caml_empty_minor_heap();
    caml_finish_major_cycle();
    test_and_compact(__eflags);
    caml_final_do_calls();
    return 1;
}

caml_gc_major_slice(
    _unknown_ __eax,                       // r0
    signed int _a4                         // _cfa_4
)
{// addr = 0x0806701C
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4

    caml_empty_minor_heap();
    return caml_major_collection_slice(_a4 >> 1) + _t7 + 1;
}

caml_gc_minor()
{// addr = 0x0806703A
    _unknown_ __ebp;                       // r6

    caml_minor_collection(__ebx, __esi);
    return 1;
}

caml_gc_set(
    signed int* _a4                        // _cfa_4
)
{// addr = 0x0806704C
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    signed int* __esi;                     // r5
    _unknown_ __ebp;                       // r6
    unsigned int _t22;                     // _t22
    signed int _t24;                       // _t24
    unsigned int _t28;                     // _t28
    _unknown_ _t29;                        // _t29
    unsigned int _t33;                     // _t33
    _unknown_ _t34;                        // _t34
    _unknown_ _t36;                        // _t36
    signed int* _t38;                      // _t38
    intOrPtr _t41;                         // _t41
    unsigned int _t42;                     // _t42

    __esi = _a4;
    _t38 = __esi;
    caml_verb_gc = (__esi)[3] >> 1;
    _t22 = norm_pfree((__esi)[2] >> 1);
    if(_t22 != caml_percent_free) {
        caml_percent_free = _t22;
        caml_gc_message(32, "New space overhead: %d%%\n", _t22);
    }
    _t24 = _t38[4] >> 1;
    norm_pmax();
    if(_t24 != caml_percent_max) {
        caml_percent_max = _t24;
        caml_gc_message(32, "New max overhead: %d%%\n", _t24);
    }
    _t28 = norm_heapincr(_t38[1] >> 1) << 2;
    if(_t28 != caml_major_heap_increment) {
        caml_major_heap_increment = _t28;
        caml_gc_message(32, "New heap increment size: %luk bytes\n", _t28 >> 10);
    }
    _t41 = _t38[6] >> 1 - 2 >= 0 ? 1 : _t38[6] >> 1;
    if(_t41 != caml_allocation_policy) {
        caml_gc_message(32, "New allocation policy: %d\n", _t41);
        caml_set_allocation_policy(_t41);
    }
    _t33 = norm_minsize( *__esi >> 1 << 2);
    _t42 = _t33;
    if(_t33 != caml_minor_heap_size) {
        caml_gc_message(32, "New minor heap size: %luk bytes\n", _t33 >> 10);
        caml_set_minor_heap_size(_t42);
    }
    return 1;
}

caml_gc_get(
    _unknown_ __ebx                        // r1
)
{// addr = 0x08067173
    _unknown_ _v16;                        // _cfa_fffffff0
    unsigned int _v36;                     // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    char _v48;                             // _cfa_ffffffd0
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    unsigned int _t36;                     // _t36
    _unknown_ _t61;                        // _t61
    char* _t62;                            // _t62

    _t62 = caml_local_roots;
    _v16 = 0;
    _v48 = _t62;
    caml_local_roots =  &_v48;
    _v40 = 1;
    _v44 = 1;
    _t36 =  &_v16;
    _v36 = _t36;
    caml_alloc_tuple(7);
    _v16 = _t36;
    caml_modify(_t62, _t36, (caml_minor_heap_size >> 2) + (caml_minor_heap_size >> 2) + 1);
    caml_modify(_t62, _v16 + 4, (caml_major_heap_increment >> 2) + (caml_major_heap_increment >> 2) + 1);
    caml_modify(_t62, _v16 + 8, caml_percent_free + caml_percent_free + 1);
    caml_modify(_t62, _v16 + 12, caml_verb_gc + caml_verb_gc + 1);
    caml_modify(_t62, _v16 + 16, caml_percent_max + caml_percent_max + 1);
    caml_modify(_t62, _v16 + 20, 1);
    caml_modify(_t62, _v16 + 24, caml_allocation_policy + caml_allocation_policy + 1);
    caml_local_roots = _t62;
    return _v16;
}

caml_gc_counters(
    _unknown_ __ebx                        // r1
)
{// addr = 0x0806727D
    unsigned int _v16;                     // _cfa_fffffff0
    char* _v36;                            // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    char _v48;                             // _cfa_ffffffd0
    unsigned int _v64;                     // _cfa_ffffffc0
    unsigned int _v68;                     // _cfa_ffffffbc
    _unknown_ _v104;                       // _cfa_ffffff98
    _unknown_ __ebp;                       // r6
    unsigned int _t25;                     // _t25
    _unknown_ _t35;                        // _t35
    char* _t36;                            // _t36
    _unknown_ _t37;                        // _t37
    _unknown_ _t38;                        // _t38

    _t36 = caml_local_roots;
    _v16 = 0;
    _v48 = _t36;
    caml_local_roots =  &_v48;
    _v40 = 1;
    _v44 = 1;
    _v36 =  &_v16;
    _v68 = caml_young_end - caml_young_ptr >> 2;
    _v64 = 0;
    asm("fild qword [ebp-0x40]");
    asm("fadd qword [0x807aa40]");
    asm("fstp qword [ebp-0x58]");
    asm("fld qword [0x807aa48]");
    asm("fstp qword [ebp-0x50]");
    _t25 = caml_allocated_words;
    _v68 = _t25;
    _v64 = 0;
    asm("fild qword [ebp-0x40]");
    asm("fadd qword [0x807aa50]");
    asm("fstp qword [ebp-0x48]");
    caml_alloc_tuple(3);
    _v16 = _t25;
    asm("fld qword [ebp-0x58]");
    asm("fstp qword [esp]");
    caml_modify(_t36, _v16, caml_copy_double());
    asm("fld qword [ebp-0x50]");
    asm("fstp qword [esp]");
    caml_modify(_t36, _v16 + 4, caml_copy_double());
    asm("fld qword [ebp-0x48]");
    asm("fstp qword [esp]");
    caml_modify(_t36, _v16 + 8, caml_copy_double());
    caml_local_roots = _t36;
    return _v16;
}

caml_gc_quick_stat(
    _unknown_ __ebx                        // r1
)
{// addr = 0x0806736C
    _unknown_ _v32;                        // _cfa_ffffffe0
    char* _v52;                            // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    char _v64;                             // _cfa_ffffffc0
    intOrPtr _v80;                         // _cfa_ffffffb0
    unsigned int _v84;                     // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    intOrPtr _v92;                         // _cfa_ffffffa4
    unsigned int _v96;                     // _cfa_ffffffa0
    unsigned int _v100;                    // _cfa_ffffff9c
    _unknown_ _v136;                       // _cfa_ffffff78
    _unknown_ __ebp;                       // r6
    intOrPtr _t78;                         // _t78
    _unknown_ _t122;                       // _t122
    char* _t123;                           // _t123
    _unknown_ _t124;                       // _t124
    _unknown_ _t125;                       // _t125

    _t123 = caml_local_roots;
    _v32 = 0;
    _v64 = _t123;
    caml_local_roots =  &_v64;
    _v56 = 1;
    _v60 = 1;
    _v52 =  &_v32;
    _v84 = caml_young_end - caml_young_ptr >> 2;
    _v80 = 0;
    asm("fild qword [ebp-0x50]");
    asm("fadd qword [0x807aa40]");
    asm("fstp qword [ebp-0x78]");
    asm("fld qword [0x807aa48]");
    asm("fstp qword [ebp-0x70]");
    _v84 = caml_allocated_words;
    _v80 = 0;
    asm("fild qword [ebp-0x50]");
    asm("fadd qword [0x807aa50]");
    asm("fstp qword [ebp-0x68]");
    __esi = caml_stat_minor_collections;
    __edi = caml_stat_major_collections;
    _v100 = caml_stat_heap_size >> 2;
    _v96 = caml_stat_top_heap_size >> 2;
    _t78 = caml_stat_compactions;
    _v92 = _t78;
    _v88 = caml_stat_heap_chunks;
    caml_alloc_tuple(16);
    _v32 = _t78;
    asm("fld qword [ebp-0x78]");
    asm("fstp qword [esp]");
    caml_modify(_t123, _v32, caml_copy_double());
    asm("fld qword [ebp-0x70]");
    asm("fstp qword [esp]");
    caml_modify(_t123, _v32 + 4, caml_copy_double());
    asm("fld qword [ebp-0x68]");
    asm("fstp qword [esp]");
    caml_modify(_t123, _v32 + 8, caml_copy_double());
    caml_modify(_t123, _v32 + 12, __esi + __esi + 1);
    caml_modify(_t123, _v32 + 16, __edi + __edi + 1);
    caml_modify(_t123, _v32 + 20, _v100 + _v100 + 1);
    caml_modify(_t123, _v32 + 24, _v88 + _v88 + 1);
    caml_modify(_t123, _v32 + 28, 1);
    caml_modify(_t123, _v32 + 32, 1);
    caml_modify(_t123, _v32 + 36, 1);
    caml_modify(_t123, _v32 + 40, 1);
    caml_modify(_t123, _v32 + 44, 1);
    caml_modify(_t123, _v32 + 48, 1);
    caml_modify(_t123, _v32 + 52, _v92 + _v92 + 1);
    caml_modify(_t123, _v32 + 56, _v96 + _v96 + 1);
    caml_modify(_t123, _v32 + 60, caml_stack_usage() + _t117 + 1);
    caml_local_roots = _t123;
    return _v32;
}

caml_gc_stat()
{// addr = 0x080675C1
    unsigned int _v32;                     // _cfa_ffffffe0
    char* _v52;                            // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    char _v64;                             // _cfa_ffffffc0
    unsigned int _v80;                     // _cfa_ffffffb0
    unsigned int _v84;                     // _cfa_ffffffac
    unsigned int _v88;                     // _cfa_ffffffa8
    unsigned int _v92;                     // _cfa_ffffffa4
    unsigned int _v96;                     // _cfa_ffffffa0
    intOrPtr _v108;                        // _cfa_ffffff94
    unsigned int _v112;                    // _cfa_ffffff90
    unsigned int _v116;                    // _cfa_ffffff8c
    intOrPtr _v124;                        // _cfa_ffffff84
    intOrPtr _v132;                        // _cfa_ffffff7c
    char* _v136;                           // _cfa_ffffff78
    unsigned int _v140;                    // _cfa_ffffff74
    unsigned int _v144;                    // _cfa_ffffff70
    intOrPtr _v148;                        // _cfa_ffffff6c
    unsigned int _v152;                    // _cfa_ffffff68
    _unknown_ _v168;                       // _cfa_ffffff58
    _unknown_ __ebp;                       // r6
    unsigned int* _t143;                   // _t143
    unsigned int _t155;                    // _t155
    signed int _t208;                      // _t208
    unsigned int _t219;                    // _t219
    unsigned int _t221;                    // _t221
    _unknown_ _t225;                       // _t225
    _unknown_ _t226;                       // _t226
    unsigned int _t231;                    // _t231
    unsigned int _t235;                    // _t235
    unsigned int _t242;                    // _t242

    _v136 = caml_local_roots;
    _t143 = caml_heap_start;
    if(_t143 != 0) {
        _v124 = caml_gc_phase;
        _v132 = caml_gc_sweep_hp;
        _v112 = 0;
        __esi = 0;
        _v96 = 0;
        _v92 = 0;
        _v88 = 0;
        __ebx = 0;
        _v116 = 0;
        goto L3;
        do {
L3:
            _v116 = _v116 + 1;
            _v108 = _t143 - 16;
            _t235 = _t143 +  *((intOrPtr*)(_v108 + 8));
            if(_t235 <= _t143) {
            } else {
                _v144 = _t235;
                goto L5;
                do {
L5:
                    _t231 =  *_t143;
                    _t208 = _t231 & 768;
                    if(_t208 == 256) {
L18:
                        _v88 = _v88 + 1;
                        __ebx = __ebx + (_t231 >> 10) + 1;
                        goto L20;
                    }
                    if(_t208 > 256) {
                        if(_t208 == 512) {
                            goto L19;
                        }
                        goto L10;
                    }
                    if(_t208 == 0) {
                        _t219 = _t231 >> 10;
                        _v140 = _t219;
                        if(_t219 != 0) {
                            if(_v124 != 1 || _v132 > _t143) {
                                _v88 = _v88 + 1;
                                __ebx = _v140 + __ebx + 1;
                            } else {
                                _v96 = _v96 + 1;
                                _t221 = _v140;
                                _v92 = _t221 + _v92 + 1;
                                __esi = _t221 + 1 - __esi > 0 ? _t221 + 1 : __esi;
                            }
                        } else {
                            _v112 = _v112 + 1;
                        }
                    }
                    goto L20;
L10:
                    if(_t208 != 768) {
                        goto L20;
                    }
                    goto L18;
L19:
                    _v96 = _v96 + 1;
                    _t242 = _t231 >> 10;
                    _v92 = _t242 + _v92 + 1;
                    __esi = _t242 + 1 - __esi > 0 ? _t242 + 1 : __esi;
L20:
                    _t143 = _t143 + 4 + (_t231 >> 10) * 4;
                } while(_v144 > _t143);
            }
            goto L21;
L21:
            _t143 =  *(_v108 + 12);
        } while(_t143 != 0);
    } else {
        _v112 = 0;
        __esi = 0;
        _v96 = 0;
        _v92 = 0;
        _v88 = 0;
        __ebx = 0;
        _v116 = 0;
    }
    _v32 = 0;
    _v64 = _v136;
    caml_local_roots =  &_v64;
    _v56 = 1;
    _v60 = 1;
    _v52 =  &_v32;
    _v84 = caml_young_end - caml_young_ptr >> 2;
    _v80 = 0;
    asm("fild qword [ebp-0x50]");
    asm("fadd qword [0x807aa40]");
    asm("fstp qword [ebp-0x68]");
    asm("fld qword [0x807aa48]");
    asm("fstp qword [ebp-0x78]");
    _v84 = caml_allocated_words;
    _v80 = 0;
    asm("fild qword [ebp-0x50]");
    asm("fadd qword [0x807aa50]");
    asm("fstp qword [ebp-0x80]");
    _v140 = caml_stat_major_collections;
    _v144 = caml_stat_heap_size >> 2;
    _v148 = caml_stat_compactions;
    _t155 = caml_stat_top_heap_size >> 2;
    _v152 = _t155;
    caml_alloc_tuple(16);
    _v32 = _t155;
    asm("fld qword [ebp-0x68]");
    asm("fstp qword [esp]");
    caml_modify(__ebx, _v32, caml_copy_double());
    asm("fld qword [ebp-0x78]");
    asm("fstp qword [esp]");
    caml_modify(__ebx, _v32 + 4, caml_copy_double());
    asm("fld qword [ebp-0x80]");
    asm("fstp qword [esp]");
    caml_modify(__ebx, _v32 + 8, caml_copy_double());
    caml_modify(__ebx, _v32 + 12, caml_stat_minor_collections + caml_stat_minor_collections + 1);
    caml_modify(__ebx, _v32 + 16, _v140 + _v140 + 1);
    caml_modify(__ebx, _v32 + 20, _v144 + _v144 + 1);
    caml_modify(__ebx, _v32 + 24, _v116 + _v116 + 1);
    caml_modify(__ebx, _v32 + 28, __ebx + __ebx + 1);
    caml_modify(__ebx, _v32 + 32, _v88 + _v88 + 1);
    caml_modify(__ebx, _v32 + 36, _v92 + _v92 + 1);
    caml_modify(__ebx, _v32 + 40, _v96 + _v96 + 1);
    caml_modify(__ebx, _v32 + 44, __esi + __esi + 1);
    caml_modify(__ebx, _v32 + 48, _v112 + _v112 + 1);
    caml_modify(__ebx, _v32 + 52, _v148 + _v148 + 1);
    caml_modify(__ebx, _v32 + 56, _v152 + _v152 + 1);
    caml_modify(__ebx, _v32 + 60, caml_stack_usage() + _t200 + 1);
    caml_local_roots = _v136;
    return _v32;
}

caml_MD5Init(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x080679B8
    _unknown_ __ebp;                       // r6

    __eax = _a4;
     *__eax = 1732584193;
     *((intOrPtr*)(__eax + 4)) = -271733879;
     *((intOrPtr*)(__eax + 8)) = -1732584194;
     *((intOrPtr*)(__eax + 12)) = 271733878;
     *((intOrPtr*)(__eax + 16)) = 0;
     *((intOrPtr*)(__eax + 20)) = 0;
    return;
}

caml_MD5Transform(
    intOrPtr* _a4,                         // _cfa_4
    intOrPtr* _a8                          // _cfa_8
)
{// addr = 0x080679E9
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _v28;                         // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    intOrPtr _v68;                         // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    intOrPtr _v76;                         // _cfa_ffffffb4
    signed int* _v80;                      // _cfa_ffffffb0
    signed int* _v84;                      // _cfa_ffffffac
    signed int* _v88;                      // _cfa_ffffffa8
    signed int _v92;                       // _cfa_ffffffa4
    intOrPtr _v96;                         // _cfa_ffffffa0
    signed int _v100;                      // _cfa_ffffff9c
    signed int _v104;                      // _cfa_ffffff98
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    intOrPtr* _t334;                       // _t334
    signed int _t342;                      // _t342
    signed int _t349;                      // _t349
    signed int _t356;                      // _t356
    signed int _t378;                      // _t378
    signed int _t386;                      // _t386
    signed int _t395;                      // _t395
    signed int _t405;                      // _t405
    signed int _t411;                      // _t411
    signed int* _t420;                     // _t420
    intOrPtr _t421;                        // _t421
    signed int _t427;                      // _t427
    signed int _t434;                      // _t434
    signed int _t441;                      // _t441
    intOrPtr _t443;                        // _t443
    intOrPtr _t444;                        // _t444
    signed int _t450;                      // _t450
    signed int _t457;                      // _t457
    signed int _t463;                      // _t463
    signed int _t470;                      // _t470
    signed int _t476;                      // _t476
    signed int _t482;                      // _t482
    signed int _t488;                      // _t488
    signed int _t495;                      // _t495
    signed int _t501;                      // _t501
    signed int _t508;                      // _t508
    signed int _t516;                      // _t516
    signed int _t522;                      // _t522
    signed int* _t527;                     // _t527
    signed int _t528;                      // _t528
    signed int _t535;                      // _t535
    signed int _t542;                      // _t542
    signed int _t549;                      // _t549
    intOrPtr _t551;                        // _t551
    signed int _t558;                      // _t558
    signed int _t564;                      // _t564
    signed int _t568;                      // _t568
    signed int _t575;                      // _t575
    signed int _t582;                      // _t582
    signed int _t589;                      // _t589
    signed int _t596;                      // _t596
    signed int _t603;                      // _t603
    signed int _t610;                      // _t610
    signed int _t617;                      // _t617
    signed int _t623;                      // _t623
    signed int _t629;                      // _t629
    signed int _t637;                      // _t637
    signed int _t645;                      // _t645
    signed int _t652;                      // _t652
    signed int _t659;                      // _t659
    signed int _t665;                      // _t665
    signed int _t671;                      // _t671
    signed int* _t673;                     // _t673
    intOrPtr _t676;                        // _t676
    intOrPtr _t677;                        // _t677
    intOrPtr _t678;                        // _t678
    intOrPtr _t679;                        // _t679
    intOrPtr _t680;                        // _t680
    intOrPtr _t681;                        // _t681
    intOrPtr _t682;                        // _t682
    intOrPtr _t683;                        // _t683
    intOrPtr _t684;                        // _t684
    intOrPtr _t685;                        // _t685
    intOrPtr _t686;                        // _t686
    intOrPtr _t687;                        // _t687
    signed int _t693;                      // _t693
    signed int _t718;                      // _t718
    signed int _t724;                      // _t724
    signed int _t731;                      // _t731
    signed int _t737;                      // _t737
    signed int _t748;                      // _t748
    signed int _t757;                      // _t757
    signed int _t764;                      // _t764
    signed int _t771;                      // _t771
    signed int _t778;                      // _t778
    signed int _t784;                      // _t784
    signed int _t791;                      // _t791
    signed int _t798;                      // _t798
    signed int _t808;                      // _t808
    signed int _t815;                      // _t815
    signed int _t821;                      // _t821
    signed int _t827;                      // _t827
    signed int _t834;                      // _t834
    signed int _t841;                      // _t841

    _t334 = _a8;
    _v96 =  *_a4;
    _t527 = _a4 + 4;
    _v88 = _t527;
    _t757 =  *_t527;
    _t420 = _a4 + 8;
    _v84 = _t420;
    _t528 =  *_t420;
    _t673 = _a4 + 12;
    _v80 = _t673;
    _t568 =  *_t673;
    _t421 =  *_t334;
    _v76 = _t421;
    asm("ror ebx, 0x19");
    _t427 = ((_t568 ^ _t528) & _t757 ^ _t568) + _v96 + _t421 + -680876936 + _t757;
    _t676 =  *((intOrPtr*)(_t334 + 4));
    _v72 = _t676;
    _v20 = _t568 + _t676 + -389564586;
    asm("ror edx, 0x14");
    _t575 = ((_t528 ^ _t757) & _t427 ^ _t528) + _v20 + _t427;
    _t677 =  *((intOrPtr*)(_t334 + 8));
    _v68 = _t677;
    _v20 = _t528 + _t677 + 606105819;
    asm("ror ecx, 0xf");
    _t535 = ((_t427 ^ _t757) & _t575 ^ _t757) + _v20 + _t575;
    _t678 =  *((intOrPtr*)(_t334 + 12));
    _v64 = _t678;
    _v20 = _t757 + _t678 + -1044525330;
    asm("ror esi, 0xa");
    _t764 = ((_t575 ^ _t427) & _t535 ^ _t427) + _v20 + _t535;
    _t679 =  *((intOrPtr*)(_t334 + 16));
    _v60 = _t679;
    _v20 = _t427 + _t679 + -176418897;
    asm("ror ebx, 0x19");
    _t434 = ((_t535 ^ _t575) & _t764 ^ _t575) + _v20 + _t764;
    _t680 =  *((intOrPtr*)(_t334 + 20));
    _v56 = _t680;
    _v20 = _t575 + _t680 + 1200080426;
    asm("ror edx, 0x14");
    _t582 = ((_t764 ^ _t535) & _t434 ^ _t535) + _v20 + _t434;
    _t681 =  *((intOrPtr*)(_t334 + 24));
    _v52 = _t681;
    _v20 = _t535 + _t681 + -1473231341;
    asm("ror ecx, 0xf");
    _t542 = ((_t434 ^ _t764) & _t582 ^ _t764) + _v20 + _t582;
    _t682 =  *((intOrPtr*)(_t334 + 28));
    _v48 = _t682;
    _v20 = _t764 + _t682 + -45705983;
    asm("ror esi, 0xa");
    _t771 = ((_t582 ^ _t434) & _t542 ^ _t434) + _v20 + _t542;
    _t683 =  *((intOrPtr*)(_t334 + 32));
    _v44 = _t683;
    _v20 = _t434 + _t683 + 1770035416;
    asm("ror ebx, 0x19");
    _t441 = ((_t542 ^ _t582) & _t771 ^ _t582) + _v20 + _t771;
    _t684 =  *((intOrPtr*)(_t334 + 36));
    _v40 = _t684;
    _v20 = _t582 + _t684 + -1958414417;
    asm("ror edx, 0x14");
    _t589 = ((_t771 ^ _t542) & _t441 ^ _t542) + _v20 + _t441;
    _t685 =  *((intOrPtr*)(_t334 + 40));
    _v36 = _t685;
    _v20 = _t542 + _t685 + -42063;
    asm("ror ecx, 0xf");
    _t549 = ((_t441 ^ _t771) & _t589 ^ _t771) + _v20 + _t589;
    _t686 =  *((intOrPtr*)(_t334 + 44));
    _v32 = _t686;
    _v20 = _t771 + _t686 + -1990404162;
    asm("ror esi, 0xa");
    _t778 = ((_t589 ^ _t441) & _t549 ^ _t441) + _v20 + _t549;
    _t687 =  *((intOrPtr*)(_t334 + 48));
    _v28 = _t687;
    asm("ror edi, 0x19");
    _t693 = _t441 + _t687 + 1804603682 + ((_t549 ^ _t589) & _t778 ^ _t589) + _t778;
    _t443 =  *((intOrPtr*)(_t334 + 52));
    _v24 = _t443;
    _v20 = _t589 + _t443 + -40341101;
    asm("ror edx, 0x14");
    _t596 = ((_t778 ^ _t549) & _t693 ^ _t549) + _v20 + _t693;
    _t444 =  *((intOrPtr*)(_t334 + 56));
    _v20 = _t444;
    asm("ror ebx, 0xf");
    _t450 = _t549 + _t444 + -1502002290 + ((_t693 ^ _t778) & _t596 ^ _t778) + _t596;
    _t551 =  *((intOrPtr*)(_t334 + 60));
    asm("ror esi, 0xa");
    _t784 = _t778 + _t551 + 1236535329 + ((_t596 ^ _t693) & _t450 ^ _t693) + _t450;
    asm("ror eax, 0x1b");
    _t342 = _t693 + _v72 + -165796510 + ((_t784 ^ _t450) & _t596 ^ _t450) + _t784;
    _v92 = _t596 + _v52 + -1069501632;
    asm("ror edx, 0x17");
    _t603 = ((_t342 ^ _t784) & _t450 ^ _t784) + _v92 + _t342;
    _v92 = _t450 + _v32 + 643717713;
    asm("ror ebx, 0x12");
    _t457 = ((_t603 ^ _t342) & _t784 ^ _t342) + _v92 + _t603;
    _v92 = _t784 + _v76 + -373897302;
    asm("ror esi, 0xc");
    _t791 = ((_t457 ^ _t603) & _t342 ^ _t603) + _v92 + _t457;
    _v92 = _t342 + _v56 + -701558691;
    asm("ror eax, 0x1b");
    _t349 = ((_t791 ^ _t457) & _t603 ^ _t457) + _v92 + _t791;
    _v92 = _t603 + _v36 + 38016083;
    asm("ror edx, 0x17");
    _t610 = ((_t349 ^ _t791) & _t457 ^ _t791) + _v92 + _t349;
    asm("ror ebx, 0x12");
    _t463 = _t457 + _t551 + -660478335 + ((_t610 ^ _t349) & _t791 ^ _t349) + _t610;
    _v92 = _t791 + _v60 + -405537848;
    asm("ror esi, 0xc");
    _t798 = ((_t463 ^ _t610) & _t349 ^ _t610) + _v92 + _t463;
    _v92 = _t349 + _v40 + 568446438;
    asm("ror eax, 0x1b");
    _t356 = ((_t798 ^ _t463) & _t610 ^ _t463) + _v92 + _t798;
    _v92 = _t610 + _v20 + -1019803690;
    asm("ror edx, 0x17");
    _t617 = ((_t356 ^ _t798) & _t463 ^ _t798) + _v92 + _t356;
    _v92 = _t463 + _v64 + -187363961;
    asm("ror ebx, 0x12");
    _t470 = ((_t617 ^ _t356) & _t798 ^ _t356) + _v92 + _t617;
    asm("ror edi, 0xc");
    _v92 = _t798 + _v44 + 1163531501 + ((_t470 ^ _t617) & _t356 ^ _t617) + _t470;
    asm("ror eax, 0x1b");
    _v100 = _t356 + _v24 + -1444681467 + ((_v92 ^ _t470) & _t617 ^ _t470) + _v92;
    asm("ror edx, 0x17");
    _t623 = _t617 + _v68 + -51403784 + ((_v100 ^ _v92) & _t470 ^ _v92) + _v100;
    asm("ror ebx, 0x12");
    _t476 = _t470 + _v48 + 1735328473 + ((_v100 ^ _t623) & _v92 ^ _v100) + _t623;
    _v104 = _t476 ^ _t623;
    asm("ror edi, 0xc");
    _t718 = _v92 + _v28 + -1926607734 + (_v100 & _v104 ^ _t623) + _t476;
    _v92 = _v100 + _v56 + -378558;
    asm("ror esi, 0x1c");
    _t808 = (_v104 ^ _t718) + _v92 + _t718;
    _v92 = _t623 + _v44 + -2022574463;
    asm("ror edx, 0x15");
    _t629 = (_t718 ^ _t476 ^ _t808) + _v92 + _t808;
    _v92 = _t476 + _v32 + 1839030562;
    asm("ror ebx, 0x10");
    _t482 = (_t808 ^ _t718 ^ _t629) + _v92 + _t629;
    _v92 = _t718 + _v20 + -35309556;
    asm("ror edi, 0x9");
    _t724 = (_t629 ^ _t808 ^ _t482) + _v92 + _t482;
    asm("ror eax, 0x1c");
    _t378 = _t808 + _v72 + -1530992060 + (_t482 ^ _t629 ^ _t724) + _t724;
    asm("ror esi, 0x15");
    _t815 = _t629 + _v60 + 1272893353 + (_t724 ^ _t482 ^ _t378) + _t378;
    _v92 = _t482 + _v48 + -155497632;
    asm("ror ebx, 0x10");
    _t488 = (_t378 ^ _t724 ^ _t815) + _v92 + _t815;
    asm("ror edx, 0x9");
    _t637 = _t724 + _v36 + -1094730640 + (_t815 ^ _t378 ^ _t488) + _t488;
    asm("ror edi, 0x1c");
    _t731 = _t378 + _v24 + 681279174 + (_t488 ^ _t815 ^ _t637) + _t637;
    _v92 = _t815 + _v76 + -358537222;
    asm("ror esi, 0x15");
    _t821 = (_t637 ^ _t488 ^ _t731) + _v92 + _t731;
    asm("ror eax, 0x10");
    _t386 = _t488 + _v64 + -722521979 + (_t731 ^ _t637 ^ _t821) + _t821;
    asm("ror ebx, 0x9");
    _t495 = _t637 + _v52 + 76029189 + (_t821 ^ _t731 ^ _t386) + _t386;
    _v92 = _t731 + _v40 + -640364487;
    asm("ror edi, 0x1c");
    _t737 = (_t386 ^ _t821 ^ _t495) + _v92 + _t495;
    asm("ror edx, 0x15");
    _t645 = _t821 + _v28 + -421815835 + (_t495 ^ _t386 ^ _t737) + _t737;
    asm("ror esi, 0x10");
    _t827 = _t386 + _t551 + 530742520 + (_t737 ^ _t495 ^ _t645) + _t645;
    _v92 = _t495 + _v68 + -995338651;
    asm("ror ebx, 0x9");
    _t501 = (_t645 ^ _t737 ^ _t827) + _v92 + _t827;
    asm("ror eax, 0x1a");
    _t395 = _t737 + _v76 + -198630844 + (( !_t645 | _t501) ^ _t827) + _t501;
    _v48 = _t645 + _v48 + 1126891415;
    asm("ror edx, 0x16");
    _t652 = (( !_t827 | _t395) ^ _t501) + _v48 + _t395;
    _v20 = _t827 + _v20 + -1416354905;
    asm("ror esi, 0x11");
    _t834 = (( !_t501 | _t652) ^ _t395) + _v20 + _t652;
    _v20 = _t501 + _v56 + -57434055;
    asm("ror ebx, 0xb");
    _t508 = (( !_t395 | _t834) ^ _t652) + _v20 + _t834;
    asm("ror edi, 0x1a");
    _t748 = _t395 + _v28 + 1700485571 + (( !_t652 | _t508) ^ _t834) + _t508;
    _v20 = _t652 + _v64 + -1894986606;
    asm("ror edx, 0x16");
    _t659 = (( !_t834 | _t748) ^ _t508) + _v20 + _t748;
    _v20 = _t834 + _v36 + -1051523;
    asm("ror esi, 0x11");
    _t841 = (( !_t508 | _t659) ^ _t748) + _v20 + _t659;
    asm("ror eax, 0xb");
    _t405 = _t508 + _v72 + -2054922799 + (( !_t748 | _t841) ^ _t659) + _t841;
    asm("ror ebx, 0x1a");
    _t516 = _t748 + _v44 + 1873313359 + (( !_t659 | _t405) ^ _t841) + _t405;
    asm("ror edx, 0x16");
    _t665 = _t659 + _t551 + -30611744 + (( !_t841 | _t516) ^ _t405) + _t516;
    asm("ror ecx, 0x11");
    _t558 = _t841 + _v52 + -1560198380 + (( !_t405 | _t665) ^ _t516) + _t665;
    asm("ror eax, 0xb");
    _t411 = _t405 + _v24 + 1309151649 + (( !_t516 | _t558) ^ _t665) + _t558;
    asm("ror ebx, 0x1a");
    _t522 = _t516 + _v60 + -145523070 + (( !_t665 | _t411) ^ _t558) + _t411;
    asm("ror edx, 0x16");
    _t671 = _t665 + _v32 + -1120210379 + (( !_t558 | _t522) ^ _t411) + _t522;
    asm("ror ecx, 0x11");
    _t564 = _t558 + _v68 + 718787259 + (( !_t411 | _t671) ^ _t522) + _t671;
     *_a4 = _t522 + _v96;
    _t756 = _v88;
    asm("ror eax, 0xb");
     *_t756 = _t564 +  *_v88 + _t411 + _v40 + -343485551 + (( !_t522 | _t564) ^ _t671);
     *_v84 =  *_v84 + _t564;
     *_v80 =  *_v80 + _t671;
    return;
}

caml_MD5Final(
    int* _a4,                              // _cfa_4
    int* _a8                               // _cfa_8
)
{// addr = 0x08068148
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    int* __ebx;                            // r1
    _unknown_ __edi;                       // r4
    int* __esi;                            // r5
    _unknown_ __ebp;                       // r6
    signed int _t49;                       // _t49
    int _t50;                              // _t50
    _unknown_ _t52;                        // _t52
    int* _t53;                             // _t53
    _unknown_ _t58;                        // _t58
    _unknown_ _t59;                        // _t59
    signed int _t60;                       // _t60
    _unknown_ _t61;                        // _t61
    int _t62;                              // _t62
    signed int _t64;                       // _t64
    _unknown_ _t65;                        // _t65
    void* _t66;           // _t66
    void* _t70;           // _t70
    signed int* _t71;                      // _t71

    __esi = _a4;
    __ebx = _a8;
    _t49 = (__ebx)[4] >> 3 & 63;
     *((char*)(__ebx + _t49 + 24)) = 128;
    _t66 = __ebx + _t49 + 25;
    _t62 = 63 - _t49;
    _t50 = _t62;
    if(_t62 > 7) {
        memset(_t66, 0, _t50 - 8);
    } else {
        memset(_t66, 0, _t62);
        _t70 =  &((__ebx)[6]);
        caml_MD5Transform(__ebx, _t70);
        _t69 = 56;
        if((_t70 & 1) != 0) {
             *_t70 = 0;
            _t70 =  &(_t70[0]);
            _t69 = 0x37;
        }
        if((_t70 & 2) != 0) {
             *_t70 = 0;
            _t70 =  &(_t70[0]);
            _t69 = _t69 - 2;
        }
        _t64 = _t69 >> 2;
        _t60 = memset(_t70, 0, _t64 << 2);
        _t71 = _t70 + _t64;
        if((_t69 & 2) != 0) {
             *_t71 = _t60 & 65535;
            _t71 =  &(_t71[0]);
        }
        if((_t69 & 1) != 0) {
             *_t71 = _t60 & 255;
        }
    }
    _t53 =  &((__ebx)[6]);
    _t53[0xe] = (__ebx)[4];
    _t53[0xf] = (__ebx)[5];
    caml_MD5Transform(__ebx, _t53);
     *__esi =  *__ebx;
    (__esi)[1] = (__ebx)[1];
    (__esi)[2] = (__ebx)[2];
    (__esi)[3] = (__ebx)[3];
     *__ebx = 0;
    return;
}

caml_MD5Update(
    intOrPtr* _a4,                         // _cfa_4
    void* _a8,            // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x08068236
    intOrPtr* _v32;                        // _cfa_ffffffe0
    intOrPtr* _v36;                        // _cfa_ffffffdc
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    intOrPtr _t73;                         // _t73
    _unknown_ _t78;                        // _t78
    intOrPtr* _t80;                        // _t80
    void* _t87;           // _t87
    _unknown_ _t88;                        // _t88
    _unknown_ _t92;                        // _t92
    unsigned int _t93;                     // _t93
    signed int _t95;                       // _t95
    intOrPtr* _t97;                        // _t97
    int _t98;                              // _t98
    intOrPtr _t99;                         // _t99
    intOrPtr _t100;                        // _t100
    _unknown_ _t121;                       // _t121
    int _t122;                             // _t122
    signed int _t125;                      // _t125
    signed int _t126;                      // _t126
    _unknown_ _t127;                       // _t127

    _t125 = _a12;
    _t93 =  *(_a4 + 16);
    _t73 = _t93 + _t125 * 8;
    _t99 = _a4;
     *((intOrPtr*)(_t99 + 16)) = _t73;
    _t127 = _t93 - _t73;
    if(_t127 > 0) {
         *((intOrPtr*)(_t99 + 20)) =  *((intOrPtr*)(_t99 + 20)) + 1;
    }
    _t100 = _a4;
     *((intOrPtr*)(_t100 + 20)) =  *((intOrPtr*)(_t100 + 20)) + (_t125 >> 29);
    _t95 = _t93 >> 3 & 63;
    if(_t127 == 0) {
L6:
        if(_t125 <= 63) {
L10:
            memcpy(_a4 + 24, _a8, _t125);
            return;
        }
        goto L7;
        return;
    } else {
        _t87 = _t100 + _t95 + 24;
        _t122 = 64 - _t95;
        _t98 = _t122;
        if(_t125 >= _t122) {
            memcpy(_t87, _a8, _t122);
            caml_MD5Transform(_a4, _a4 + 24);
            _a8 = _a8 + _t98;
            _t125 = _t125 - _t98;
            goto L6;
        }
        memcpy(_t87, _a8, _t125);
        return;
        goto L6;
    }
L7:
    _t97 = _a4 + 24;
    _v36 = _t97;
    _v32 = _a4;
    __esi = 0;
    while(1) {
        _t80 = _a8 + __esi;
         *_t97 =  *_t80;
         *((intOrPtr*)(_t97 + 4)) =  *((intOrPtr*)(_t80 + 4));
         *((intOrPtr*)(_t97 + 8)) =  *((intOrPtr*)(_t80 + 8));
         *((intOrPtr*)(_t97 + 12)) =  *((intOrPtr*)(_t80 + 12));
         *((intOrPtr*)(_t97 + 16)) =  *((intOrPtr*)(_t80 + 16));
         *((intOrPtr*)(_t97 + 20)) =  *((intOrPtr*)(_t80 + 20));
         *((intOrPtr*)(_t97 + 24)) =  *((intOrPtr*)(_t80 + 24));
         *((intOrPtr*)(_t97 + 28)) =  *((intOrPtr*)(_t80 + 28));
         *((intOrPtr*)(_t97 + 32)) =  *((intOrPtr*)(_t80 + 32));
         *((intOrPtr*)(_t97 + 36)) =  *((intOrPtr*)(_t80 + 36));
         *((intOrPtr*)(_t97 + 40)) =  *((intOrPtr*)(_t80 + 40));
         *((intOrPtr*)(_t97 + 44)) =  *((intOrPtr*)(_t80 + 44));
         *((intOrPtr*)(_t97 + 48)) =  *((intOrPtr*)(_t80 + 48));
         *((intOrPtr*)(_t97 + 52)) =  *((intOrPtr*)(_t80 + 52));
         *((intOrPtr*)(_t97 + 56)) =  *((intOrPtr*)(_t80 + 56));
         *((intOrPtr*)(_t97 + 60)) =  *((intOrPtr*)(_t80 + 60));
        caml_MD5Transform(_v32, _v36);
        __esi = __esi + 64;
        if(_t125 - __esi <= 63) {
            break;
        }
    }
    _t126 = _t125 - 64;
    _a8 = _a8 + (_t126 & 192) + 64;
    _t125 = _t126 & 63;
    goto L10;
}

caml_md5_chan(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    intOrPtr __esi,                        // r5
    char _a4,                              // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0806839A
    char* _v44;                            // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    char _v148;                            // _cfa_ffffff6c
    char _v4244;                           // _cfa_ffffef6c
    char* _v4256;                          // _cfa_ffffef60
    char* _v4260;                          // _cfa_ffffef5c
    intOrPtr _v4276;                       // _cfa_ffffef4c
    void* _v4280;         // _cfa_ffffef48
    _unknown_ __ebp;                       // r6
    _unknown_ _t35;                        // _t35
    _unknown_ _t36;                        // _t36
    intOrPtr* _t41;                        // _t41
    intOrPtr* _t44;                        // _t44
    _unknown_ _t46;                        // _t46
    _unknown_ _t47;                        // _t47
    intOrPtr _t48;                         // _t48
    _unknown_ _t49;                        // _t49
    signed int _t51;                       // _t51
    void* _t52;           // _t52
    _unknown_ _t58;                        // _t58
    char* _t59;                            // _t59
    intOrPtr _t60;                         // _t60
    intOrPtr* _t61;                        // _t61
    intOrPtr* _t62;                        // _t62

    _t60 = __esi;
    _t36 = caml_local_roots;
    _v4260 = _t36;
    _v60 = _t36;
    caml_local_roots =  &_v60;
    _v52 = 1;
    _v56 = 2;
    _v48 =  &_a4;
    _v44 =  &_a8;
    _v4256 =  *((intOrPtr*)(_a4 + 4));
    _t41 = caml_channel_mutex_lock;
    _t62 = _t41;
    if(_t62 != 0) {
         *__esp = _v4256;
         *_t41();
    }
    _t42 =  ?_? ( &_v148);
    caml_MD5Init( &_v148);
    _t51 = _a8 >> 1;
    if(_t62 >= 0) {
        _t52 =  &_v4244;
        _t61 =  &_v148;
        while(1) {
            _v4276 = 4096;
            _v4280 = _t52;
            _t42 = _v4256;
             *__esp = _t42;
            caml_getblock(_t42, _t52, _t58, _t61);
            if(_t42 == 0) {
                break;
            }
            caml_MD5Update(_t61, _t52, _t42);
        }
L11:
        caml_alloc_string(16);
        caml_MD5Final(_t42,  &_v148);
        _t44 = caml_channel_mutex_unlock;
        if(_t44 != 0) {
             *__esp = _v4256;
             *_t44();
        }
        caml_local_roots = _v4260;
        return;
    }
    _t59 =  &_v4244;
    if(_t51 > 0) {
        while(1) {
            _t48 = _t51 - 4096 <= 0 ? _t51 : 4096;
            caml_getblock(_t48, _t51, _t59, _t60, _v4256, _t59, _t48);
            _t60 = _t48;
            if(_t48 == 0) {
                caml_raise_end_of_file();
            }
            _v4276 = _t48;
            _v4280 = _t59;
            _t42 =  ?_? ( &_v148);
             *__esp =  &_v148;
            caml_MD5Update();
            _t51 = _t51 - _t60;
            if(_t51 <= 0) {
                break;
            }
        }
    } else {
    }
    goto L11;
}

caml_md5_string(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x080684ED
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char _v100;                            // _cfa_ffffff9c
    signed int _v116;                      // _cfa_ffffff8c
    int* _v120;                            // _cfa_ffffff88
    _unknown_ __ebp;                       // r6
    int* _t16;                             // _t16
    int* _t19;                             // _t19
    _unknown_ _t20;                        // _t20
    _unknown_ _t23;                        // _t23

    _v12 = __ebx;
    _v8 = __esi;
    _t19 =  &_v100;
    caml_MD5Init(_t19);
    _v116 = _a12 >> 1;
    _t16 = (_a8 >> 1) + _a4;
    _v120 = _t16;
     *__esp = _t19;
    caml_MD5Update();
    caml_alloc_string(16);
    caml_MD5Final(_t16, _t19);
    return _t16;
}

add_char(
    signed int** __eax,                    // r0
    signed int __edx                       // r3
)
{// addr = 0x08068548
    _unknown_ __ebp;                       // r6
    signed int* _t3;                       // _t3

    __edx = __edx;
    __eax = __eax;
    _t3 =  *__eax;
    if(_t3 < (__eax)[1]) {
         *_t3 = __edx & 255;
         *__eax =  &(_t3[0]);
        return;
    }
    return;
}

add_string(
    void** __eax,         // r0
    intOrPtr __ebx,                        // r1
    void* __edx,          // r3
    intOrPtr __edi,                        // r4
    intOrPtr __esi                         // r5
)
{// addr = 0x0806855B
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t15;                        // _t15
    int _t19;                              // _t19
    _unknown_ _t20;                        // _t20
    _unknown_ _t21;                        // _t21
    _unknown_ _t25;                        // _t25
    _unknown_ _t28;                        // _t28
    void** _t30;          // _t30
    _unknown_ _t31;                        // _t31

    __edx = __edx;
    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t30 = __eax;
    asm("repne scasb ");
    _t16 =  *_t30;
    _t19 = _t30[1] -  *_t30 +  !-1 - 1 < 0 ? _t30[1] -  *_t30 :  !-1 - 1;
    if(_t19 > 0) {
        _t16 = memmove(_t16, __edx, _t19);
    }
     *_t30 =  *_t30 + _t19;
    return;
}

caml_format_exception(
    signed int _a4                         // _cfa_4
)
{// addr = 0x080685B2
    char _v28;                             // _cfa_ffffffe4
    char _v29;                             // _cfa_ffffffe3
    void _v284;                            // _cfa_fffffee4
    char* _v288;                           // _cfa_fffffee0
    char _v292;                            // _cfa_fffffedc
    char _v356;                            // _cfa_fffffe9c
    signed int _v368;                      // _cfa_fffffe90
    signed int _v372;                      // _cfa_fffffe8c
    signed int _v388;                      // _cfa_fffffe7c
    _unknown_ _v392;                       // _cfa_fffffe78
    _unknown_ __ebp;                       // r6
    unsigned int _t47;                     // _t47
    void* _t51;           // _t51
    _unknown_ _t52;                        // _t52
    _unknown_ _t54;                        // _t54
    _unknown_ _t67;                        // _t67
    signed int _t69;                       // _t69
    void* _t70;           // _t70
    signed int _t71;                       // _t71
    _unknown_ _t77;                        // _t77
    _unknown_ _t78;                        // _t78
    _unknown_ _t79;                        // _t79
    _unknown_ _t80;                        // _t80
    _unknown_ _t82;                        // _t82
    _unknown_ _t85;                        // _t85
    intOrPtr _t86;                         // _t86
    unsigned int* _t88;                    // _t88
    intOrPtr _t89;                         // _t89
    signed int _t91;                       // _t91
    signed int _t92;                       // _t92

    _t69 = _a4;
    _v292 =  &_v284;
    _v288 =  &_v29;
    add_string( &_v292, _t69,  *((intOrPtr*)( *_t69)), _t86, _t89);
    _t47 =  *(_t69 - 4) >> 10;
    if(_t47 <= 1) {
L16:
         *_v292 = 0;
        _t90 = _v292 -  &_v28 + 257;
        _t51 = malloc(_v292 -  &_v28 + 257);
        _t70 = _t51;
        if(_t51 != 0) {
            memmove(_t70,  &_v284, _t90);
        }
        return;
    }
    if(_t47 != 2) {
L4:
        _t91 = _t69;
        _v368 = 1;
        goto L5;
    }
    _t91 =  *(_t69 + 4);
    if((_t91 & 1) != 0) {
        goto L4;
    }
    _v368 = 0;
    if( *(_t91 - 4) == 0) {
        goto L5;
    }
    goto L4;
L5:
    add_char( &_v292, 40);
    _v372 = _t91;
    _t88 = _t91 - 4;
    if(_v368 >=  *_t88 >> 10) {
L15:
        add_char( &_v292, 41);
    } else {
        _t92 = _v368;
        while(1) {
            _t71 =  *(_v372 + _t92 * 4);
            if((_t71 & 1) == 0) {
                if( *((char*)(_t71 - 4)) != 252) {
                    add_char( &_v292, 95);
                } else {
                    add_char( &_v292, 34);
                    add_string( &_v292, _t71, _t71, _t88, _t92);
                    add_char( &_v292, 34);
                }
            } else {
                _v388 = _t71;
                sprintf( &_v356, "%ld");
                add_string( &_v292, _t71,  &_v356, _t88, _t92);
            }
            _t92 = _t92 + 1;
            if( *_t88 >> 10 <= _t92) {
                break;
            }
            if(_v368 < _t92) {
                add_string( &_v292, _t71, 134660740, _t88, _t92);
            }
        }
        goto L15;
    }
    goto L16;
}

caml_fatal_uncaught_exception(
    intOrPtr __esi,                        // r5
    void* _a4             // _cfa_4
)
{// addr = 0x08068759
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    void* _v36;           // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    void* _t26;           // _t26
    _unknown_ _t29;                        // _t29
    _unknown_ _t30;                        // _t30
    void _t31;                             // _t31
    _unknown_ _t33;                        // _t33
    _unknown_ _t39;                        // _t39
    intOrPtr _t40;                         // _t40
    signed int _t42;                       // _t42
    signed int _t43;                       // _t43
    signed int _t46;                       // _t46
    _unknown_ _t47;                        // _t47
    intOrPtr _t50;                         // _t50
    intOrPtr _t51;                         // _t51
    signed int _t53;                       // _t53
    _unknown_ _t54;                        // _t54
    _unknown_ _t55;                        // _t55

    _v16 = _t40;
    _v12 = __esi;
    _v8 = _t50;
    _t26 = _a4;
    caml_format_exception(_t26);
    _t41 = _t26;
    _t53 = caml_backtrace_active;
    _t51 = caml_backtrace_pos;
    caml_backtrace_active = 0;
    if(caml_named_value(_t26, "Pervasives.do_at_exit") != 0) {
        caml_callback_exn(__esp,  *_t27, 1);
    }
    caml_backtrace_active = _t53;
    caml_backtrace_pos = _t51;
    _v36 = _t41;
    fprintf(__imp__stderr, "Fatal error: exception %s\n");
    free(_t41);
    if(caml_backtrace_active != 0) {
        caml_print_exception_backtrace(_t41, _t51);
    }
    _t31 = exit(2);
    0;
    0;
    _push(_t54);
    _push(_t41);
    _t46 =  *_t31 & 255;
    _t43 = 0;
    if((_t46 & 255) != 0) {
        while(1) {
            _t42 = _t43 + _t43 * 8;
            _t41 = _t43 + _t42 * 2;
            _t43 = _t43 + _t42 * 2 + (_t46 & 255);
            _t31 = _t31 + 1;
            _t46 =  *_t31 & 255;
            if((_t46 & 255) == 0) {
                break;
            }
        }
    }
    _t35 = _t43 * 1321528399 >> 32 >> 2;
    _pop(__ebx);
    return _t43 - (_t43 * 1321528399 >> 32 >> 2) + (_t35 + _t35 * 2) * 4;
}

hash_value_name(
    signed char* __eax                     // r0
)
{// addr = 0x08068800
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed char* _t19;                     // _t19
    _unknown_ _t21;                        // _t21
    signed int _t28;                       // _t28
    signed int _t31;                       // _t31
    _unknown_ _t32;                        // _t32

    _t19 = __eax;
    _t31 =  *_t19 & 255;
    _t28 = 0;
    if((_t31 & 255) != 0) {
        while(1) {
            _t28 = (_t31 & 255) + _t28 + (_t28 + _t28 * 8) * 2;
            _t19 =  &(_t19[1]);
            _t31 =  *_t19 & 255;
            if((_t31 & 255) == 0) {
                break;
            }
        }
    }
    return _t28 - (_t28 * 1321528399 >> 32 >> 2) + ((_t28 * 1321528399 >> 32 >> 2) + _t23 * 2) * 4;
}

caml_named_value(
    _unknown_ __eax,                       // r0
    char* _a4                              // _cfa_4
)
{// addr = 0x08068840
    _unknown_ _v24;                        // _cfa_ffffffe8
    intOrPtr __ebx;                        // r1
    char* __esi;                           // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    _unknown_ _t10;                        // _t10

    __esi = _a4;
    __ebx =  *((intOrPtr*)(hash_value_name(_a4) * 4 +  &named_value_table));
    if(__ebx == 0) {
L4:
        return 0;
    }
    while(strcmp(__esi, __ebx + 8) != 0) {
        __ebx =  *((intOrPtr*)(__ebx + 4));
        if(__ebx != 0) {
            continue;
        }
        goto L4;
    }
    return __ebx;
    return __eax;
}

caml_register_named_value(
    _unknown_ __eax,                       // r0
    char* _a4,                             // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08068887
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    char* __esi;                           // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t18;                        // _t18
    signed int _t20;                       // _t20
    _unknown_ _t21;                        // _t21
    _unknown_ _t23;                        // _t23
    char* _t24;                            // _t24
    _unknown_ _t25;                        // _t25
    intOrPtr* _t29;                        // _t29
    _unknown_ _t30;                        // _t30
    _unknown_ _t31;                        // _t31
    signed int _t34;                       // _t34

    __esi = _a4;
    _t20 = hash_value_name(__esi);
    _v32 = _t20;
    _t29 =  *((intOrPtr*)(_t20 * 4 +  &named_value_table));
    if(_t29 == 0) {
L4:
        asm("repne scasb ");
        caml_stat_alloc( !-1 + 11);
        strcpy(8, __esi);
         *0 = _a8;
        _t24 =  &named_value_table;
        _t34 = _v32;
         *((intOrPtr*)(4)) =  *((intOrPtr*)(_t24 + _t34 * 4));
         *((intOrPtr*)(_t24 + _t34 * 4)) = 0;
        caml_register_global_root(0);
    } else {
        while(strcmp(__esi, _t29 + 8) != 0) {
            _t29 =  *((intOrPtr*)(_t29 + 4));
            if(_t29 != 0) {
                continue;
            } else {
                goto L4;
            }
            goto L5;
        }
         *_t29 = _a8;
    }
L5:
    return 1;
}

caml_callback3(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    intOrPtr _a16                          // _cfa_10
)
{// addr = 0x08068920
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    signed int _t12;                       // _t12

    _t12 = caml_callback3_exn(__esp, _a4, _a8, _a12, _a16);
    if((_t12 & 3) == 2) {
         *__esp = _t12 & 252;
        caml_raise();
        return;
    }
    return;
}

caml_callback2(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x0806895D
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    signed int _t9;                        // _t9

    _t9 = caml_callback2_exn(__esp, _a4, _a8, _a12);
    if((_t9 & 3) == 2) {
         *__esp = _t9 & 252;
        caml_raise();
        return;
    }
    return;
}

caml_callback(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08068993
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    signed int _t6;                        // _t6

    _t6 = caml_callback_exn(__esp, _a4, _a8);
    if((_t6 & 3) == 2) {
         *__esp = _t6 & 252;
        caml_raise();
        return;
    }
    return;
}

caml_callbackN_exn(
    _unknown_ __eax,                       // r0
    char _a4,                              // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x080689C2
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    intOrPtr _v80;                         // _cfa_ffffffb0
    intOrPtr _v84;                         // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    char _v92;                             // _cfa_ffffffa4
    signed int _v96;                       // _cfa_ffffffa0
    char* _v116;                           // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    intOrPtr _v124;                        // _cfa_ffffff84
    _unknown_ _v128;                       // _cfa_ffffff80
    char* _v144;                           // _cfa_ffffff70
    _unknown_ _v160;                       // _cfa_ffffff60
    _unknown_ _v164;                       // _cfa_ffffff5c
    _unknown_ _v168;                       // _cfa_ffffff58
    signed int __ebx;                      // r1
    intOrPtr __edi;                        // r4
    intOrPtr __esi;                        // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t56;                        // _t56
    _unknown_ _t61;                        // _t61
    _unknown_ _t67;                        // _t67
    signed int _t70;                       // _t70
    signed int _t75;                       // _t75
    signed int _t79;                       // _t79

    __edi = _a8;
    __esi = _a12;
    _v144 = caml_local_roots;
    caml_local_roots =  &_v128;
    _v96 = _a4;
    if(__edi <= 0) {
L15:
        caml_local_roots = _v144;
        return;
    }
    _v60 = _v144;
    _v52 = 1;
    _v56 = 1;
    _v48 =  &_a4;
    _v92 =  &_v60;
    _v84 = __edi;
    _v88 = 1;
    _v80 = __esi;
    _v128 =  &_v92;
    _v120 = 1;
    _v124 = 1;
    _v116 =  &_v96;
    __ebx = 0;
    goto L2;
    do {
L2:
        _t67 = __edi - __ebx;
        if(_t67 == 1) {
            _t70 = caml_callback_exn(__esp, _v96,  *((intOrPtr*)(__esi + __ebx * 4)));
            if((_t70 & 3) != 2) {
                _v96 = _t70;
                __ebx = __ebx + 1;
                goto L14;
            }
            goto L6;
        }
        if(_t67 != 2) {
            _t75 = caml_callback3_exn(__esp, _v96,  *((intOrPtr*)(__esi + __ebx * 4)),  *((intOrPtr*)(__esi + 4 + __ebx * 4)),  *((intOrPtr*)(__esi + 8 + __ebx * 4)));
            if((_t75 & 3) != 2) {
                _v96 = _t75;
                __ebx = __ebx + 3;
                goto L14;
            }
            caml_local_roots = _v144;
            return;
            goto L14;
        }
        _t79 = caml_callback2_exn(__esp, _v96,  *((intOrPtr*)(__esi + __ebx * 4)),  *((intOrPtr*)(__esi + 4 + __ebx * 4)));
        if((_t79 & 3) != 2) {
            _v96 = _t79;
            __ebx = __ebx + 2;
            goto L14;
        }
        caml_local_roots = _v144;
        return;
L6:
        caml_local_roots = _v144;
        return;
L14:
    } while(__edi > __ebx);
    goto L15;
    return;
}

caml_callbackN(
    signed int _a4,                        // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x08068B24
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    signed int _t8;                        // _t8

    _v20 = _a12;
    _v24 = _a8;
    _t8 = _a4;
     *__esp = _t8;
    caml_callbackN_exn(_t8);
    if((_t8 & 3) == 2) {
         *__esp = _t8 & 252;
        caml_raise();
        return;
    }
    return;
}

caml_weak_check(
    intOrPtr __edx,                        // r3
    _unknown_ __eflags,                    // r9
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08068B60
    _unknown_ __ebp;                       // r6
    signed int _t14;                       // _t14

    __edx = __edx;
    _t14 = (_a8 >> 1) + 1;
    if(__eflags == 0) {
L2:
         *__esp = "Weak.get";
        caml_invalid_argument();
    } else {
        __edx = _a4;
        if(_t14 <  *(__edx - 4) >> 10) {
        } else {
            goto L2;
        }
L4:
    }
    return ( *(__edx + _t14 * 4) & 0xff) + ( *(__edx + _t14 * 4) & 0xff) + 1;
    goto L4;
}

do_set(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    signed int __ecx,                      // r2
    signed int __edx                       // r3
)
{// addr = 0x08068B9E
    _unknown_ __ebp;                       // r6
    _unknown_ _t13;                        // _t13
    signed int _t14;                       // _t14
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17
    signed int* _t18;                      // _t18
    signed int _t19;                       // _t19
    signed int** _t20;                     // _t20

    _t19 = __edx;
    __ecx = __ecx;
    _t13 = __eax;
    if((__ecx & 1) != 0 || __ecx >= caml_young_end || __ecx <= caml_young_start) {
         *(_t13 + _t19 * 4) = __ecx;
        return;
    } else {
        _t18 = _t13 + _t19 * 4;
        _t14 =  *_t18;
         *_t18 = __ecx;
        if((_t14 & 1) != 0 || _t14 >= caml_young_end || _t14 <= caml_young_start) {
            if( *134706532 >=  *134706536) {
                caml_realloc_ref_table(_t18, __edi, __esi,  &caml_weak_ref_table);
            }
            _t20 =  *134706532;
             *_t20 = _t18;
             *134706532 =  &(_t20[1]);
            return;
        }
    }
    return;
}

caml_weak_blit(
    _unknown_ __ebx,                       // r1
    _unknown_ __eflags,                    // r9
    intOrPtr _a4,                          // _cfa_4
    signed int _a8,                        // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    signed int _a16,                       // _cfa_10
    signed int _a20                        // _cfa_14
)
{// addr = 0x08068C07
    signed int _v32;                       // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    unsigned int _v52;                     // _cfa_ffffffcc
    intOrPtr _v80;                         // _cfa_ffffffb0
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t54;                       // _t54
    signed int _t56;                       // _t56
    _unknown_ _t58;                        // _t58
    _unknown_ _t64;                        // _t64
    signed int _t68;                       // _t68
    _unknown_ _t71;                        // _t71
    intOrPtr* _t72;                        // _t72
    _unknown_ _t73;                        // _t73
    unsigned int _t74;                     // _t74
    unsigned int _t80;                     // _t80
    _unknown_ _t83;                        // _t83
    _unknown_ _t85;                        // _t85
    unsigned int* _t87;                    // _t87
    intOrPtr _t92;                         // _t92
    intOrPtr _t93;                         // _t93
    intOrPtr _t95;                         // _t95
    _unknown_ _t99;                        // _t99
    _unknown_ _t104;                       // _t104

    _t54 = _a8 >> 1;
    _v44 = _t54;
    _t95 = _t54 + 1;
    if(__eflags == 0) {
L2:
         *__esp = "Weak.blit";
        caml_invalid_argument();
        goto L3;
    }
    _t68 = _a20 >> 1;
    _v32 = _t68;
    _t92 = _a4;
    _t104 = _t68 + _t95 -  *(_t92 - 4) >> 10;
    if(_t104 <= 0) {
        goto L3;
    }
    goto L2;
L3:
    _t56 = _a16 >> 1;
    _v40 = _t56;
    _v36 = _t56 + 1;
    if(_t104 == 0 || _v32 + _v36 >  *(_a12 - 4) >> 10) {
         *__esp = "Weak.blit";
        caml_invalid_argument();
    }
    if(caml_gc_phase != 0 || caml_gc_subphase != 11) {
L17:
        if(_t95 <= _v36) {
            _v36 = _v32 - 1;
            if(__eflags >= 0) {
L25:
                return;
L26:
            }
            goto L23;
        }
        goto L18;
L23:
        _t72 = _t92 + (_v32 + _v44) * 4;
        _t99 = _v32 + _v40;
        _t93 = _v36;
        while(1) {
            do_set(_a12, _t72,  *_t72, _t99);
            _t72 = _t72 - 4;
            _t99 = _t99 - 1;
            _t93 = _t93 - 1;
            if(__eflags < 0) {
                break;
            }
        }
        goto L25;
    } else {
        if(_v32 == 0) {
        } else {
            _t85 = 0;
            _t64 = 0;
            _v80 = _t95;
            goto L10;
            do {
                _t64 = _t64 + 1;
                _t85 = _t64;
                if(_v32 > _t64) {
L10:
                    _t87 = _t92 + (_t85 + _v80) * 4;
                    _t74 =  *_t87;
                    _t80 = caml_weak_none;
                    if(_t74 != _t80 && (_t74 & 1) == 0) {
                        _v52 = _t74;
                        if(( *( *((intOrPtr*)((_t74 >> 23) * 4 +  &caml_page_table)) + (_t74 >> 12 & 2047)) & 1) != 0 && ( *(_v52 - 4) & 768) == 0) {
                             *_t87 = _t80;
                        }
                    }
                    continue;
                } else {
                    _t95 = _v80;
                }
                goto L17;
            } while();
        }
        goto L17;
    }
L18:
    if(_v32 == 0) {
        goto L25;
    }
    _t83 = 0;
    _t73 = 0;
    while(1) {
        do_set(_a12, _t73,  *((intOrPtr*)(_t92 + (_t83 + _t95) * 4)), _t83 + _v36);
        _t73 = _t73 + 1;
        _t83 = _t73;
        if(_v32 <= _t73) {
            break;
        }
    }
    goto L25;
}

caml_weak_set(
    _unknown_ __edx,                       // r3
    intOrPtr __esi,                        // r5
    _unknown_ __eflags,                    // r9
    intOrPtr _a4,                          // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x08068D5B
    intOrPtr _v8;                          // _cfa_fffffff8
    unsigned int _v12;                     // _cfa_fffffff4
    _unknown_ __ebp;                       // r6
    intOrPtr _t15;                         // _t15
    _unknown_ _t17;                        // _t17
    _unknown_ _t19;                        // _t19
    signed int _t21;                       // _t21
    _unknown_ _t23;                        // _t23
    signed int _t26;                       // _t26
    intOrPtr _t27;                         // _t27
    _unknown_ _t28;                        // _t28

    _t27 = __esi;
    _v12 = _t18;
    _v8 = _t27;
    _t15 = _a4;
    _t21 = _a12;
    _t26 = (_a8 >> 1) + 1;
    if(__eflags == 0) {
L2:
         *__esp = "Weak.set";
        caml_invalid_argument();
        goto L3;
    }
    _t27 = _t15;
    _t18 =  *(_t15 - 4) >> 10;
    if(_t26 <  *(_t15 - 4) >> 10) {
        goto L3;
    }
    goto L2;
L3:
    if(_t21 == 1 || (_t21 & 1) != 0) {
         *((intOrPtr*)(_t27 + _t26 * 4)) = caml_weak_none;
    } else {
        do_set(_t15, _t18,  *_t21, _t26);
    }
    return 1;
}

caml_weak_get_copy(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    _unknown_ __edi,                       // r4
    char* _a4,                             // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08068DB9
    char* _v44;                            // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    signed int _v64;                       // _cfa_ffffffc0
    void* _v68;           // _cfa_ffffffbc
    char* _v84;                            // _cfa_ffffffac
    char* _v88;                            // _cfa_ffffffa8
    signed int _v92;                       // _cfa_ffffffa4
    intOrPtr _v96;                         // _cfa_ffffffa0
    char _v100;                            // _cfa_ffffff9c
    signed int _v112;                      // _cfa_ffffff90
    unsigned int* _v116;                   // _cfa_ffffff8c
    void* _v120;          // _cfa_ffffff88
    intOrPtr _v124;                        // _cfa_ffffff84
    _unknown_ _v132;                       // _cfa_ffffff7c
    signed int _v136;                      // _cfa_ffffff78
    _unknown_ __ebp;                       // r6
    _unknown_ _t83;                        // _t83
    char* _t87;                            // _t87
    unsigned int _t88;                     // _t88
    signed int _t89;                       // _t89
    void* _t93;           // _t93
    _unknown_ _t94;                        // _t94
    signed int* _t99;                      // _t99
    intOrPtr _t106;                        // _t106
    intOrPtr* _t108;                       // _t108
    _unknown_ _t114;                       // _t114
    _unknown_ _t115;                       // _t115
    _unknown_ _t116;                       // _t116
    char* _t117;                           // _t117
    signed int _t118;                      // _t118
    unsigned int* _t122;                   // _t122
    signed char _t126;                     // _t126
    void* _t134;          // _t134
    intOrPtr _t143;                        // _t143
    _unknown_ _t144;                       // _t144
    _unknown_ _t145;                       // _t145
    _unknown_ _t148;                       // _t148
    unsigned int _t149;                    // _t149
    unsigned int* _t150;                   // _t150
    intOrPtr _t151;                        // _t151
    signed int _t155;                      // _t155
    signed int _t156;                      // _t156
    signed int _t157;                      // _t157
    _unknown_ _t158;                       // _t158

    _t117 = caml_local_roots;
    _v60 = _t117;
    _v52 = 1;
    _v56 = 2;
    _v48 =  &_a4;
    _v44 =  &_a8;
    _v64 = 0;
    _v68 = 0;
    _v100 =  &_v60;
    caml_local_roots =  &_v100;
    _v92 = 1;
    _v96 = 2;
    _v88 =  &_v64;
    _t87 =  &_v68;
    _v84 = _t87;
    _t155 = (_a8 >> 1) + 1;
    if(_t158 == 0) {
L2:
         *__esp = "Weak.get";
        caml_invalid_argument();
        goto L3;
    }
    _t87 = _a4;
    if(_t155 <  *(_t87 - 4) >> 10) {
        goto L3;
    }
    goto L2;
L3:
    _t156 = _t155 << 2;
    _t88 = _t87[_t156];
    if(_t88 == caml_weak_none) {
        caml_local_roots = _t117;
        return 1;
    }
    if((_t88 & 1) != 0) {
L31:
        _v68 = _t88;
    } else {
        _t149 = _t88;
        if(( *( *((intOrPtr*)((_t88 >> 23) * 4 +  &caml_page_table)) + (_t88 >> 12 & 2047)) & 3) == 0) {
            goto L31;
        }
        _t150 = _t149 - 4;
        _v136 =  *_t150 & 255;
        _t93 =  *_t150 >> 10;
         *__esp = _t93;
        caml_alloc(_t156);
        _v68 = _t93;
        _t134 = _a4[_t156];
        if(_t134 != caml_weak_none) {
            _v120 = _t134;
            _t122 = _t134 - 4;
            if( *_t122 > 250) {
                memmove(_t93, _t134,  *_t122 >> 10 << 2);
                goto L32;
            }
            goto L10;
        }
        caml_local_roots = _t117;
        return 1;
L10:
        _v116 = _t122;
        if( *_t122 >> 10 == 0) {
            goto L32;
        }
        _t157 = 0;
        _v124 = _t117;
        goto L12;
        do {
L12:
            _t151 = 0 + _t157 * 4;
            _t118 = _v120[_t157];
            if(caml_gc_phase == 0 && (_t118 & 1) == 0 && ( *( *((intOrPtr*)((_t118 >> 23) * 4 +  &caml_page_table)) + (_t118 >> 12 & 2047)) & 1) != 0) {
                _v136 = 0;
                caml_darken(_t118);
            }
            _t99 = _t151 + _v68;
            _v112 =  *_t99;
             *_t99 = _t118;
            if(( *( *((intOrPtr*)((_t151 + _v68 >> 23) * 4 +  &caml_page_table)) + (_t151 + _v68 >> 12 & 2047)) & 1) == 0) {
            } else {
                if(caml_gc_phase == 0) {
                    _v136 = 0;
                    caml_darken(_v112);
                }
                if((_t118 & 1) != 0) {
                } else {
                    _t106 = caml_young_end;
                    if(_t118 >= _t106) {
                        goto L28;
                    }
                    _t143 = caml_young_start;
                    if(_t118 <= _t143) {
                        goto L28;
                    }
                    if((_v112 & 1) != 0) {
L25:
                        if( *134706504 >=  *134706508) {
                            caml_realloc_ref_table(_t118, _t151, _t157,  &caml_ref_table);
                        }
                        _t108 =  *134706504;
                         *_t108 = _t151 + _v68;
                         *134706504 = _t108 + 4;
                        goto L28;
                    }
                    _t126 = _v112;
                    if(_t106 <= _t126 || _t143 >= _t126) {
                        goto L25;
                    }
                }
            }
            goto L28;
L28:
            _t157 = _t157 + 1;
        } while( *_v116 >> 10 > _t157);
        _t117 = _v124;
        goto L32;
        return __eax;
    }
L32:
    _t89 = caml_alloc_small(_t117, _t156, 1, 0);
    _v64 = _t89;
     *_t89 = _v68;
    caml_local_roots = _t117;
    return _v64;
}

caml_weak_get(
    _unknown_ __eax,                       // r0
    _unknown_ __edx,                       // r3
    char* _a4,                             // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0806902B
    char* _v28;                            // _cfa_ffffffe4
    char* _v32;                            // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    unsigned int _v48;                     // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    char* _v68;                            // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8
    unsigned int _v76;                     // _cfa_ffffffb4
    intOrPtr _v80;                         // _cfa_ffffffb0
    char _v84;                             // _cfa_ffffffac
    unsigned int _v104;                    // _cfa_ffffff98
    _unknown_ __ebp;                       // r6
    _unknown_ _t40;                        // _t40
    signed int _t45;                       // _t45
    unsigned int _t46;                     // _t46
    unsigned int _t47;                     // _t47
    _unknown_ _t54;                        // _t54
    char* _t58;                            // _t58
    _unknown_ _t63;                        // _t63

    __ebx = caml_local_roots;
    _v44 = __ebx;
    _v36 = 1;
    _v40 = 2;
    _v32 =  &_a4;
    _v28 =  &_a8;
    _v48 = 0;
    _v52 = 0;
    _v84 =  &_v44;
    caml_local_roots =  &_v84;
    _v76 = 1;
    _v80 = 2;
    _v72 =  &_v48;
    _t58 =  &_v52;
    _v68 = _t58;
    _t45 = (_a8 >> 1) + 1;
    if(_t63 == 0) {
L2:
         *__esp = "Weak.get";
        caml_invalid_argument();
        goto L3;
    }
    _t58 = _a4;
    if(_t45 <  *(_t58 - 4) >> 10) {
        goto L3;
    }
    goto L2;
L3:
    _t46 =  *(_t58 + _t45 * 4);
    if(_t46 != caml_weak_none) {
        _v52 = _t46;
        if(caml_gc_phase == 0 && (_t46 & 1) == 0 && ( *( *((intOrPtr*)((_t46 >> 23) * 4 +  &caml_page_table)) + (_t46 >> 12 & 2047)) & 1) != 0) {
            _v104 = 0;
            caml_darken(_t46);
        }
        _t47 = caml_alloc_small(__ebx, __esi, 1, 0);
        _v48 = _t47;
         *_t47 = _v52;
    } else {
        _v48 = 1;
    }
    caml_local_roots = __ebx;
    return _v48;
}

caml_weak_create(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    signed int _a4                         // _cfa_4
)
{// addr = 0x0806912B
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t6;                         // _t6
    signed int _t8;                        // _t8
    _unknown_ _t9;                         // _t9
    _unknown_ _t10;                        // _t10
    _unknown_ _t11;                        // _t11
    signed int _t13;                       // _t13

    _t8 = _a4 >> 1;
    _t11 = _t8 + 1;
    if(_t8 > 4194302) {
         *__esp = "Weak.create";
        caml_invalid_argument();
    }
    _t9 = caml_alloc_shr(_t8, _t11, __edi, __esi, _t11, 251);
    if(_t11 > 1) {
        _t13 = 1;
        while(1) {
             *((intOrPtr*)(_t9 + _t13 * 4)) = caml_weak_none;
            _t13 = _t13 + 1;
            if(_t11 <= _t13) {
                break;
            }
        }
    }
     *_t9 = caml_weak_list_head;
    caml_weak_list_head = _t9;
    return;
}

invert_pointer_at(
    signed int __eax,                      // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi                         // r5
)
{// addr = 0x08069190
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    signed int* _v24;                      // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t44;                        // _t44
    signed int* _t48;                      // _t48
    signed int _t52;                       // _t52
    unsigned int _t53;                     // _t53
    unsigned int _t55;                     // _t55
    unsigned int _t57;                     // _t57
    signed int _t62;                       // _t62
    _unknown_ _t64;                        // _t64
    signed int _t65;                       // _t65
    _unknown_ _t71;                        // _t71
    unsigned int _t72;                     // _t72
    _unknown_ _t75;                        // _t75
    _unknown_ _t77;                        // _t77
    signed int* _t78;                      // _t78

    _t36 = __eax;
    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t53 =  *_t36;
    if((_t53 & 3) != 0 || ( *( *((intOrPtr*)((_t53 >> 23) * 4 +  &caml_page_table)) + (_t53 >> 12 & 2047)) & 1) == 0) {
L14:
        return;
    } else {
        _t78 = _t53 - 4;
        _t72 =  *_t78;
        _t62 = _t72 & 3;
        if(_t62 == 1) {
L7:
            _t64 = _t53 - (_t72 >> 10 << 2);
            _t75 = _t64;
            _t48 = _t64 - 4;
            _v24 = _t48;
            _t65 =  *_t48;
            if((_t65 & 3) != 0) {
L10:
                if((_t65 >> 2 & 255) != 247) {
                     *_t36 = _t75 + (_t65 >> 10) * 4 | 1;
                     *_t78 = _t36 | 2;
                    _t55 = _t53 - _t75 >> 2;
                    _t36 = _t55 - 1 << 10 | 999;
                     *_v24 = _t55 - 1 << 10 | 999;
                } else {
                     *_t36 = _t65;
                     *_t78 = _t36 | 2;
                    _t57 = _t53 - _t75 >> 2;
                    _t36 = _t57 - 1 << 10 | 999;
                     *_v24 = _t57 - 1 << 10 | 999;
                }
                goto L14;
            } else {
                goto L8;
            }
            while(1) {
L8:
                _t52 = _t65;
                _t65 =  *_t65;
                if((_t65 & 3) == 0) {
                    continue;
                } else {
                    _v24 = _t52;
                    goto L10;
                }
            }
        }
        if(_t62 < 1) {
L6:
             *_t36 = _t72;
             *_t78 = _t36;
            goto L14;
        }
        if(_t62 == 2) {
             *_t36 = _t72;
             *_t78 = _t55 - 1 << 10 | 999;
            goto L14;
        }
        if(_t62 != 3) {
            goto L14;
        }
        goto L6;
    }
}

invert_root(
    signed int _a8                         // _cfa_8
)
{// addr = 0x0806927F
    _unknown_ __ebp;                       // r6

    __eax = _a8;
    invert_pointer_at(_a8, __ebx, __edi, __esi);
    return;
}

init_compact_allocate()
{// addr = 0x0806928C
    _unknown_ __ebp;                       // r6
    unsigned int _t3;                      // _t3
    _unknown_ _t5;                         // _t5

    _t3 = caml_heap_start;
    if(_t3 != 0) {
        while(1) {
            _t5 = _t3 - 16;
             *((intOrPtr*)(_t5 + 4)) = 0;
            _t3 =  *((intOrPtr*)(_t5 + 12));
            if(_t3 == 0) {
                break;
            }
        }
    }
    compact_fl = caml_heap_start;
    return;
}

compact_allocate(
    _unknown_ __eax                        // r0
)
{// addr = 0x080692B5
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t22;                        // _t22
    intOrPtr _t27;                         // _t27
    intOrPtr _t30;                         // _t30
    _unknown_ _t31;                        // _t31
    _unknown_ _t32;                        // _t32
    _unknown_ _t33;                        // _t33
    unsigned int _t40;                     // _t40

    _t22 = __eax;
    __ecx = compact_fl;
    _t31 = __ecx - 16;
    if( *((intOrPtr*)(_t31 + 8)) -  *((intOrPtr*)(_t31 + 4)) <= 16) {
        _t40 =  *((intOrPtr*)(_t31 + 12));
        _t33 = _t40 - 16;
        if( *((intOrPtr*)(_t33 + 8)) -  *((intOrPtr*)(_t33 + 4)) <= 16) {
            __ecx = _t40;
            while(1) {
                _t30 =  *((intOrPtr*)(_t33 + 12));
                _t33 = _t30 - 16;
                if( *((intOrPtr*)(_t33 + 8)) -  *((intOrPtr*)(_t33 + 4)) > 16) {
                    break;
                }
                _t40 = _t30;
                __ecx = _t30;
            }
            compact_fl = _t40;
        } else {
        }
L10:
    }
    _t32 = __ecx - 16;
    _t27 =  *((intOrPtr*)(_t32 + 4));
    if(_t22 <=  *((intOrPtr*)(_t32 + 8)) - _t27) {
    } else {
        while(1) {
            __ecx =  *((intOrPtr*)(_t32 + 12));
            _t32 = __ecx - 16;
            _t27 =  *((intOrPtr*)(_t32 + 4));
            if( *((intOrPtr*)(_t32 + 8)) - _t27 >= _t22) {
                break;
            }
        }
    }
    goto L8;
L8:
     *((intOrPtr*)(_t32 + 4)) = _t27 + _t22;
    return __ecx + _t27;
    goto L10;
}

caml_compact_heap()
{// addr = 0x08069330
    signed int* _v32;                      // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    void* _v48;           // _cfa_ffffffd0
    intOrPtr _v68;                         // _cfa_ffffffbc
    unsigned int _v72;                     // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    void* _t131;          // _t131
    unsigned int _t133;                    // _t133
    signed int _t134;                      // _t134
    unsigned int _t143;                    // _t143
    signed int _t145;                      // _t145
    _unknown_ _t147;                       // _t147
    signed int _t148;                      // _t148
    signed int _t157;                      // _t157
    signed int _t158;                      // _t158
    signed int _t160;                      // _t160
    void* _t162;          // _t162
    signed int _t164;                      // _t164
    void _t167;                            // _t167
    void* _t168;          // _t168
    void* _t169;          // _t169
    void* _t170;          // _t170
    void* _t171;                           // _t171
    void* _t173;                           // _t173
    void* _t178;          // _t178
    void _t180;                            // _t180
    void* _t181;          // _t181
    signed int _t183;                      // _t183
    signed int _t186;                      // _t186
    signed int _t190;                      // _t190
    void* _t191;          // _t191
    void _t192;                            // _t192
    _unknown_ _t193;                       // _t193
    _unknown_ _t194;                       // _t194
    _unknown_ _t195;                       // _t195
    intOrPtr _t196;                        // _t196
    signed int _t200;                      // _t200
    signed int _t208;                      // _t208
    signed int _t225;                      // _t225
    void _t228;                            // _t228
    signed int _t230;                      // _t230
    signed int _t237;                      // _t237
    signed int _t250;                      // _t250
    int _t251;                             // _t251
    signed int _t253;                      // _t253
    signed int _t254;                      // _t254
    signed int _t255;                      // _t255
    unsigned int _t256;                    // _t256
    signed int _t259;                      // _t259
    _unknown_ _t262;                       // _t262
    intOrPtr _t263;                        // _t263
    _unknown_ _t265;                       // _t265
    unsigned int _t266;                    // _t266
    _unknown_ _t267;                       // _t267
    void _t268;                            // _t268
    _unknown_ _t269;                       // _t269
    signed int _t274;                      // _t274
    signed int _t276;                      // _t276
    signed int _t279;                      // _t279
    intOrPtr _t280;                        // _t280
    intOrPtr _t281;                        // _t281

    caml_gc_message(16, "Compacting heap...\n", 0);
    _t131 = caml_heap_start;
    if(_t131 == 0) {
L7:
        caml_do_roots(invert_root);
        caml_final_do_weak_roots(invert_root);
        _t132 = caml_heap_start;
        if(_t132 == 0) {
L21:
            _t178 = caml_weak_list_head;
            _v32 = _t178;
            if(_t178 == 0) {
L31:
                init_compact_allocate();
                _t167 = caml_heap_start;
                if(_t167 == 0) {
L55:
                    init_compact_allocate();
                    _t168 = caml_heap_start;
                    if(_t168 == 0) {
L79:
                        caml_fl_reset();
L78:
                        caml_stat_compactions = caml_stat_compactions + 1;
                        caml_gc_message(16, "done.\n", 0);
                        return;
                    } else {
                        goto L56;
                    }
                    do {
                        goto L56;
L61:
                        _t168 = _v32[3];
                    } while(_t168 != 0);
                    _t180 = caml_heap_start;
                    if(_t180 == 0) {
                        goto L79;
                    }
                    _t192 = _t180;
                    _t134 = 0;
                    while(1) {
                        _t193 = _t192 - 16;
                        _t266 =  *(_t193 + 4);
                        if(_t266 != 0) {
                            _t134 = _t134 + (_t266 >> 2);
                            _t168 = _t168 + ( *((intOrPtr*)(_t193 + 8)) - _t266 >> 2);
                        }
                        _t192 =  *(_t193 + 12);
                        if(_t192 == 0) {
                            break;
                        }
                    }
                    _t250 = (_t134 / 100 + 1) * caml_percent_free;
                    while(1) {
                        _t132 = _t180 - 16;
                        _t268 = (_t132)[3];
                        if((_t132)[1] == 0) {
                            if(_t250 <= _t168) {
                                caml_shrink_heap(_t180);
                            } else {
                                _t168 = _t168 + _t132;
                            }
                        }
                        if(_t268 == 0) {
                            break;
                        }
                        _t180 = _t268;
                    }
                    _t169 = caml_heap_start;
                    caml_fl_reset();
                    if(_t169 == 0) {
                        goto L78;
                    } else {
                        goto L75;
                    }
                    while(1) {
L75:
                        _t269 = _t169 - 16;
                        _t196 =  *((intOrPtr*)(_t269 + 8));
                        _t132 =  *(_t269 + 4);
                        if(_t196 > _t132) {
                            _v68 = 1;
                            _v72 = _t196 - _t132 >> 2;
                             *__esp = _t132;
                            caml_make_free_blocks();
                        }
                        _t169 =  *(_t269 + 12);
                        if(_t169 == 0) {
                            break;
                        }
                    }
                    goto L78;
                } else {
                    goto L32;
                }
                do {
                    goto L32;
L54:
                    _t132 = _v48;
                    _t167 = _v48[3];
                } while(_t167 != 0);
                goto L55;
L56:
                _t191 = _t168 - 16;
                _v32 = _t191;
                _t265 = _t168 + _t191[2];
                while(_t265 > _t168) {
                    _t133 =  *_t168;
                    if((_t133 & 3) != 0) {
                        _t132 = _t133 >> 10;
                        _t168 = _t168 + 4 + (_t133 >> 10) * 4;
                    } else {
                        _t251 = 4 + (_t133 >> 10) * 4;
                        _t132 = memmove(compact_allocate(_t251), _t168, _t251);
                        _t168 = _t168 + _t251;
                    }
                }
                goto L61;
            }
            goto L22;
L32:
            _t181 = _t167 - 16;
            _v48 = _t181;
            _v44 = _t181[2] + _t167;
            while(_v44 > _t167) {
                _t143 =  *_t167;
                if((_t143 & 3) == 0) {
                    while(1) {
                        _t143 =  *_t143;
                        if((_t143 & 3) != 0) {
                            break;
                        }
                    }
                    goto L37;
                }
                _t208 = _t143 >> 2 & 255;
                if(_t208 != 249) {
                     *_t167 = _t208 + (_t143 & -1024) + 512;
                    _t167 = _t167 + 4 + (_t143 >> 10) * 4;
                    continue;
                }
                _t274 = (_t143 >> 10) + 1;
L38:
                _t276 = _t167 + _t274 * 4;
                _v36 = _t276;
                _t148 =  *_t276;
                if((_t148 & 3) == 3) {
L40:
                    _t274 = (_t148 >> 10) + 1;
                    _v40 = _t148 >> 2 & 255;
                    goto L41;
                } else {
                    goto L39;
                }
                while(1) {
L39:
                    _t148 =  *(_t148 & 252);
                    if((_t148 & 3) == 3) {
                        break;
                    }
                }
                goto L40;
L41:
                _v32 = 0 + _t274 * 4;
                _t147 = compact_allocate(0 + _t274 * 4);
                _t200 =  *_t167;
                if((_t200 & 3) != 0) {
L45:
                     *_t167 = (_t274 << 10) + _v40 + -1024;
                    if(_v36 == 0) {
L51:
                        _t167 = _v32 + _t167;
                        continue;
                    }
                    goto L46;
                }
L42:
                _t254 = _t147 + 4;
                while(1) {
                    _t183 =  *_t200;
                     *_t200 = _t254;
                    if((_t183 & 3) != 0) {
                        break;
                    }
                    _t200 = _t183;
                }
                goto L45;
L46:
                _t186 = _v36;
                if((_t186 & 3) == 3) {
                    goto L51;
                } else {
                    goto L47;
                }
                do {
L47:
                    _t253 = _t186 & 252;
                    _t186 =  *_t253;
                    if((_t186 & 3) != 2) {
                        goto L50;
                    }
                    _t279 = _t147 + 4 + (_t253 - _t167 >> 2) * 4;
                    while(1) {
                        _t225 = _t186 & 252;
                        _t186 =  *_t225;
                         *_t225 = _t279;
                        if((_t186 & 3) != 2) {
                            break;
                        }
                    }
                    goto L50;
L50:
                     *_t253 = (_t253 - _t167 >> 2 << 10) + 249;
                } while((_t186 & 3) != 3);
                goto L51;
L37:
                _t274 = (_t143 >> 10) + 1;
                _t145 = _t143 >> 2 & 255;
                _v40 = _t145;
                _v36 = 0;
                if(_t145 != 249) {
                    goto L41;
                }
                goto L38;
            }
            goto L54;
        } else {
            goto L8;
        }
        do {
            goto L8;
L20:
            _t132 =  *(_v40 + 12);
        } while(_t132 != 0);
        goto L21;
L22:
        _v36 =  &caml_weak_list_head;
        goto L23;
        do {
L23:
            _t170 = _v32;
            _t255 =  *(_t170 - 4);
            if((_t255 & 3) != 0) {
L25:
                _t256 = _t255 >> 10;
                if(_t256 <= 1) {
                    goto L30;
                }
                goto L26;
            } else {
                goto L24;
            }
            while(1) {
L24:
                _t255 =  *_t255;
                if((_t255 & 3) != 0) {
                    break;
                }
            }
            goto L25;
L26:
            _t171 =  &(_t170[1]);
            _t280 = 1;
            while() {
            }
L30:
            invert_pointer_at(_v36, _t170, _t256, _t263);
            _t132 = _v32;
            _v36 = _t132;
            _t228 =  *_t132;
            _v32 = _t228;
        } while(_t228 != 0);
        goto L31;
    } else {
        goto L1;
    }
    do {
L1:
        _t262 = _t131 - 16;
        _t263 = _t131 +  *((intOrPtr*)(_t262 + 8));
        if(_t263 <= _t131) {
            goto L6;
        } else {
            goto L2;
        }
        while(1) {
L2:
            _t237 =  *_t131;
            _t190 = _t237 >> 10;
            if((_t237 & 768) != 512) {
                 *_t131 = (_t237 & 255) << 2 | _t190 << 10 | 3;
            } else {
                 *_t131 = _t190 << 10 | 1011;
            }
            _t131 = _t131 + 4 + _t190 * 4;
            if(_t263 <= _t131) {
                break;
            }
        }
        goto L6;
L6:
        _t131 =  *(_t262 + 12);
    } while(_t131 != 0);
    goto L7;
L8:
    _v32 = _t132;
    _t157 = _t132 - 16;
    _v40 = _t157;
    _t230 = _v32 +  *((intOrPtr*)(_t157 + 8));
    _v36 = _t230;
    if(_t230 <= _v32) {
        goto L20;
    } else {
        goto L9;
    }
    do {
L9:
        _t158 =  *_v32;
        if((_t158 & 3) != 0) {
L11:
            _t259 = (_t158 >> 10) + 1;
            _t160 = _t158 >> 2 & 255;
            if(_t160 != 249) {
L15:
                if(_t160 > 250 || _t259 <= 1) {
                } else {
                    _t173 =  &(_v32[1]);
                    _t281 = 1;
                    while(1) {
                        invert_pointer_at(_t173, _t173, _t259, _t281);
                        _t281 = _t281 + 1;
                        _t173 =  &(_t173[1]);
                        if(_t259 <= _t281) {
                            break;
                        }
                    }
                }
                goto L19;
            }
            goto L12;
        } else {
            goto L10;
        }
        while(1) {
L10:
            _t158 =  *_t158;
            if((_t158 & 3) != 0) {
                break;
            }
        }
        goto L11;
L12:
        _t164 = _v32[_t259];
        if((_t164 & 3) == 3) {
L14:
            _t259 = (_t164 >> 10) + 1;
            _t160 = _t164 >> 2 & 255;
            goto L15;
        } else {
            goto L13;
        }
        while(1) {
L13:
            _t164 =  *(_t164 & 252);
            if((_t164 & 3) == 3) {
                break;
            }
        }
        goto L14;
L19:
        _t162 =  &(_v32[_t259]);
        _v32 = _t162;
    } while(_v36 > _t162);
    goto L20;
}

caml_compact_heap_maybe()
{// addr = 0x080697C5
    intOrPtr _v24;                         // _cfa_ffffffe8
    unsigned int _v28;                     // _cfa_ffffffe4
    signed int _v30;                       // _cfa_ffffffe2
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t46;                        // _t46
    _unknown_ _t47;                        // _t47
    _unknown_ _t48;                        // _t48
    _unknown_ _t49;                        // _t49
    unsigned int _t50;                     // _t50
    _unknown_ _t53;                        // _t53
    _unknown_ _t54;                        // _t54
    _unknown_ _t55;                        // _t55
    _unknown_ _t58;                        // _t58

    if(caml_percent_max > 999999 || caml_stat_major_collections <= 2) {
L10:
        return;
L11:
    } else {
        _t58 = caml_stat_heap_chunks - 2;
        if(_t58 <= 0) {
            goto L10;
        }
        _t50 = caml_fl_cur_size;
        _t38 = caml_fl_size_at_phase_change;
        _v28 = _t50;
        _v24 = 0;
        asm("fild qword [ebp-0x18]");
        asm("fmul dword [0x806b8cc]");
        _v28 = caml_fl_size_at_phase_change;
        _v24 = 0;
        asm("fild qword [ebp-0x18]");
        asm("fmul dword [0x806c354]");
        asm("faddp st1, st0");
        asm("fstp dword [ebp-0xc]");
        asm("fld dword [ebp-0xc]");
        asm("fldz ");
        asm("fucomip st0, st1");
        if(_t58 > 0) {
            asm("fstp st0");
            _v28 = _t50;
            _v24 = 0;
            asm("fild qword [ebp-0x18]");
        }
        _v28 = caml_stat_heap_size >> 2;
        _v24 = 0;
        asm("fild qword [ebp-0x18]");
        asm("fxch st0, st1");
        asm("fucomi st0, st1");
        if(_t58 < 0) {
            asm("fld st0, st0");
            asm("fmul dword [0x806c27c]");
            asm("fxch st0, st1");
            asm("fsubp st2, st0");
            asm("fdivrp st1, st0");
            asm("fstp dword [ebp-0x20]");
            asm("fld dword [0x806b1a8]");
            asm("fld dword [ebp-0x20]");
            asm("fucomi st0, st1");
            asm("fcmovnbe st0, st1");
            asm("fstp st1");
            asm("fstp dword [ebp-0x20]");
        } else {
            asm("fstp st0");
            asm("fstp st0");
            asm("fld dword [0x806b1a8]");
            asm("fstp dword [ebp-0x20]");
        }
        caml_gc_message(512, "FL size at phase change = %lu\n", _t38);
        asm("fnstcw word [ebp-0x1a]");
        _v32 = _v30 & 0xffff;
        asm("fld dword [ebp-0x20]");
        asm("fldcw word [ebp-0x1c]");
        asm("fistp qword [ebp-0x18]");
        asm("fldcw word [ebp-0x1a]");
        caml_gc_message(512, "Estimated overhead = %lu%%\n", _v28);
        _v28 = caml_percent_max;
        _v24 = 0;
        asm("fild qword [ebp-0x18]");
        asm("fld dword [ebp-0x20]");
        asm("fucomip st0, st1");
        asm("fstp st0");
        if(_t58 < 0) {
            goto L10;
        } else {
            caml_gc_message(512, "Automatic compaction triggered.\n", 0);
            caml_finish_major_cycle();
            _v28 = caml_fl_cur_size;
            _v24 = 0;
            asm("fild qword [ebp-0x18]");
            asm("fld st0, st0");
            asm("fmul dword [0x806c27c]");
            _v28 = caml_stat_heap_size >> 2;
            _v24 = 0;
            asm("fild qword [ebp-0x18]");
            asm("fsubrp st2, st0");
            asm("fdivrp st1, st0");
            asm("fstp dword [ebp-0xc]");
            asm("fld dword [ebp-0xc]");
            asm("fnstcw word [ebp-0x1a]");
            _v32 = _v30 & 0xffff;
            asm("fldcw word [ebp-0x1c]");
            asm("fistp qword [ebp-0x18]");
            asm("fldcw word [ebp-0x1a]");
            caml_gc_message(512, "Measured overhead: %lu%%\n", _v28);
            caml_compact_heap();
            return;
        }
        goto L11;
    }
}

caml_final_do_strong_roots(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x080699A0
    intOrPtr* _v32;                        // _cfa_ffffffe0
    intOrPtr* _v56;                        // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    intOrPtr* _t28;                        // _t28
    intOrPtr _t30;                         // _t30
    signed int _t31;                       // _t31
    intOrPtr _t34;                         // _t34
    _unknown_ _t35;                        // _t35
    intOrPtr* _t37;                        // _t37
    signed int _t38;                       // _t38
    signed int _t39;                       // _t39

    if(old != 0) {
        _t31 = 0;
        _t39 = 0;
        _t37 = _a4;
        while(1) {
            _t28 = _t31 + final_table;
            _v56 = _t28;
             *__esp =  *_t28;
             *_t37();
            _t39 = _t39 + 1;
            _t31 = _t31 + 12;
            if(old <= _t39) {
                break;
            }
        }
    }
    _t22 = to_do_hd;
    _v32 = _t22;
    if(_t22 != 0) {
        goto L7;
    } else {
        return;
    }
    do {
        goto L7;
L6:
        _t34 =  *_v32;
        _v32 = _t34;
    } while(_t34 != 0);
    return;
L7:
    _t30 = _v32;
    _t38 = 0;
    if( *((intOrPtr*)(_t30 + 4)) != 0) {
        while(1) {
            _t35 = _v32 + (_t38 + _t38 * 2) * 4;
            _v56 = _t35 + 8;
             *__esp =  *((intOrPtr*)(_t30 + 8));
            _a4();
            _v56 = _t35 + 12;
             *__esp =  *((intOrPtr*)(_t30 + 12));
            _a4();
            _t38 = _t38 + 1;
            _t30 = _t30 + 12;
            _t22 = _v32;
            if( *((intOrPtr*)(_v32 + 4)) <= _t38) {
                break;
            }
        }
        goto L6;
    }
    goto L6;
}

caml_final_do_weak_roots(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x08069A49
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    intOrPtr* __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7

    __edi = _a4;
    if(old != 0) {
        __ebx = 0;
        __esi = 0;
        while(1) {
            _t7 = __ebx + final_table;
            _v40 = _t7 + 4;
             *__esp =  *((intOrPtr*)(_t7 + 4));
             *__edi();
            __esi = __esi + 1;
            __ebx = __ebx + 12;
            if(old <= __esi) {
                break;
            }
        }
    }
    return;
}

caml_final_do_young_roots(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x08069A95
    intOrPtr* _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    intOrPtr* __edi;                       // r4
    signed int __esi;                      // r5
    _unknown_ __ebp;                       // r6
    intOrPtr* _t10;                        // _t10
    _unknown_ _t13;                        // _t13
    signed int _t15;                       // _t15

    __edi = _a4;
    __esi = old;
    if(__esi < young) {
        _t15 = __esi + __esi * 2 << 2;
        while(1) {
            _t10 = _t15 + final_table;
            _v40 = _t10;
             *__esp =  *_t10;
             *__edi();
            _t13 = _t15 + final_table;
            _v40 = _t13 + 4;
             *__esp =  *((intOrPtr*)(_t13 + 4));
             *__edi();
            __esi = __esi + 1;
            _t15 = _t15 + 12;
            if(young <= __esi) {
                break;
            }
        }
    }
    return;
}

caml_final_empty_young()
{// addr = 0x08069AF5
    _unknown_ __ebp;                       // r6

    old = young;
    return;
}

caml_final_release()
{// addr = 0x08069B04
    _unknown_ __ebp;                       // r6

    running_finalisation_function = 0;
    return 1;
}

caml_final_register(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    unsigned int __esi,                    // r5
    intOrPtr _a4,                          // _cfa_4
    unsigned int _a8                       // _cfa_8
)
{// addr = 0x08069B18
    intOrPtr _v8;                          // _cfa_fffffff8
    unsigned int _v12;                     // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    signed int _t29;                       // _t29
    signed int _t30;                       // _t30
    _unknown_ _t32;                        // _t32
    signed int _t34;                       // _t34
    unsigned int _t39;                     // _t39
    _unknown_ _t40;                        // _t40
    unsigned int* _t45;                    // _t45
    intOrPtr* _t51;                        // _t51
    _unknown_ _t57;                        // _t57
    signed int _t58;                       // _t58
    unsigned int _t59;                     // _t59
    _unknown_ _t60;                        // _t60

    _t59 = __esi;
    _v16 = __ebx;
    _v12 = _t59;
    _v8 = __edi;
    _t39 = _a8;
    if((_t39 & 1) != 0) {
L2:
         *__esp = "Gc.finalise";
        caml_invalid_argument();
        goto L3;
    }
    _t59 = _t39;
    if(( *( *((intOrPtr*)((_t39 >> 23) * 4 +  &caml_page_table)) + (_t39 >> 12 & 2047)) & 3) != 0) {
        goto L3;
    }
    goto L2;
L3:
    _t29 = size;
    if(young >= _t29) {
        _t52 = final_table;
        if(final_table != 0) {
            _t58 = _t29 + _t29;
            _t34 = _t58 + _t29 * 4 << 2;
            caml_stat_resize(_t52, _t34);
            final_table = _t34;
            size = _t58;
        } else {
            caml_stat_alloc(360);
            final_table = _t29;
            size = 30;
        }
    }
    _t30 = young;
    _t51 = (_t30 + _t30 * 2 << 2) + final_table;
     *_t51 = _a4;
    _t45 = _t59 - 4;
    if( *_t45 != 249) {
         *(_t51 + 8) = 0;
         *(_t51 + 4) = _t39;
    } else {
         *(_t51 + 8) =  *_t45 >> 10 << 2;
         *(_t51 + 4) = _t59 - ( *_t45 >> 10 << 2);
    }
    young = _t30 + 1;
    return 1;
}

caml_final_do_calls()
{// addr = 0x08069C09
    _unknown_ _v20;                        // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    signed int __ebx;                      // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t15;                        // _t15
    _unknown_ _t17;                        // _t17
    _unknown_ _t18;                        // _t18
    signed int _t21;                       // _t21
    signed int _t22;                       // _t22
    signed int _t23;                       // _t23

    if(running_finalisation_function != 0 || to_do_hd == 0) {
        return;
    } else {
        caml_gc_message(128, "Calling finalisation functions.\n", 0);
        while(1) {
            _t16 = to_do_hd;
            if(_t16 == 0) {
                break;
            }
            _t22 =  *(_t16 + 4);
            if(_t22 == 0) {
                __ebx =  *_t16;
                free(_t16);
                to_do_hd = __ebx;
                if(__ebx == 0) {
                    to_do_tl = 0;
                }
                continue;
            }
            _t23 = _t22 - 1;
             *(_t16 + 4) = _t23;
            _t18 = _t16 + (_t23 + _t23 * 2) * 4;
            running_finalisation_function = 1;
            _v24 =  *((intOrPtr*)(_t18 + 12)) +  *((intOrPtr*)(_t18 + 16));
             *__esp =  *(_t18 + 8);
            _t21 = caml_callback_exn(__esp);
            running_finalisation_function = 0;
            if((_t21 & 3) != 2) {
                continue;
            }
            _t16 = _t21 & 252;
             *__esp = _t21 & 252;
            caml_raise();
            break;
        }
        caml_gc_message(128, "Done calling finalisation functions.\n", 0);
        return;
    }
}

caml_final_update()
{// addr = 0x08069CE4
    signed int _v32;                       // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    void* _v48;           // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    intOrPtr* _v64;                        // _cfa_ffffffc0
    signed int _v88;                       // _cfa_ffffffa8
    _unknown_ __ebx;                       // r1
    char* __edi;                           // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t93;                       // _t93
    signed int _t94;                       // _t94
    void* _t97;           // _t97
    signed int _t98;                       // _t98
    signed int* _t100;                     // _t100
    signed int _t102;                      // _t102
    signed int _t108;                      // _t108
    unsigned int _t109;                    // _t109
    _unknown_ _t111;                       // _t111
    intOrPtr _t112;                        // _t112
    void* _t114;          // _t114
    signed int _t116;                      // _t116
    signed int _t118;                      // _t118
    _unknown_ _t119;                       // _t119
    unsigned int* _t123;                   // _t123
    signed int _t128;                      // _t128
    signed int _t134;                      // _t134
    signed int _t135;                      // _t135
    intOrPtr* _t136;                       // _t136
    void* _t137;          // _t137
    intOrPtr* _t138;                       // _t138
    signed int _t140;                      // _t140
    intOrPtr* _t141;                       // _t141
    intOrPtr* _t143;                       // _t143
    signed int _t145;                      // _t145
    _unknown_ _t147;                       // _t147

    _t140 = old;
    if(_t140 != 0) {
        _t136 = final_table;
        _t94 = 0;
        while(1) {
            asm("adc ebx, 0x0");
            _t94 = _t94 + 1;
            _t136 = _t136 + 12;
            if(_t94 >= _t140) {
                break;
            }
        }
        if(0 == 0) {
        } else {
            _t97 = malloc(0x14);
            if(_t97 == 0) {
                caml_fatal_error("out of memory");
            }
             *_t97 = 0;
            _t97[1] = 0;
            _t137 = to_do_tl;
            if(_t137 != 0) {
                 *_t137 = _t97;
                to_do_tl = _t97;
            } else {
                to_do_hd = _t97;
                to_do_tl = _t97;
            }
            _t98 = old;
            _v52 = _t98;
            if(_t98 == 0) {
                old = 0;
                young = 0;
                to_do_tl[1] = 0;
                return;
            }
            _t138 = final_table;
            _v60 = _t138;
            _v48 = to_do_tl;
            _v40 = 0;
            _v56 = 0;
            _v44 = 0;
            __edi =  &caml_page_table;
            goto L11;
            do {
L11:
                _v64 = _t138;
                while(1) {
                    _t123 =  *(_t138 + 4);
                    _t100 = _t123 - 4;
                    if(( *_t100 & 768) != 0) {
                        break;
                    }
                    if( *_t100 != 250) {
                        _t143 = _v64;
L25:
                        _t108 = _v40 + _v40 * 2 << 2;
                        _t114 = _v48;
                         *((intOrPtr*)( &(_t114[2]) + _t108)) =  *_t143;
                         *( &(_t114[3]) + _t108) =  *(_t143 + 4);
                         *((intOrPtr*)( &(_t114[4]) + _t108)) =  *((intOrPtr*)(_t143 + 8));
                        _v40 = _v40 + 1;
                        goto L27;
                    }
                    _t109 =  *_t123;
                    if((_t109 & 1) != 0) {
                        _t143 = _v64;
                         *(_t143 + 4) = _t109;
                        goto L25;
                    }
                    _v36 = _t109;
                    _t116 = _t109 >> 23;
                    _t134 = _t109 >> 12 & 2047;
                    _v32 = _t134;
                    if(( *( *((intOrPtr*)(__edi + _t116 * 4)) + _t134) & 7) == 0) {
                        _t143 = _v64;
                        goto L25;
                    }
                    _t135 =  *(_t109 - 4) & 255;
                    if((_t135 & 255) == 250) {
                        _t143 = _v64;
                        goto L25;
                    }
                    if((_t135 & 255) == 246) {
                        _t143 = _v64;
                        goto L25;
                    }
                    if((_t135 & 255) != 253) {
                         *(_t138 + 4) = _t109;
                        if(( *( *((intOrPtr*)(__edi + _t116 * 4)) + _v32) & 1) != 0) {
                            continue;
                        }
                        goto L33;
                    } else {
                        _t143 = _v64;
                        goto L25;
                    }
                    goto L35;
                }
                _t141 = _v64;
                _t102 = _v56 + _v56 * 2 << 2;
                _t112 = _v60;
                 *((intOrPtr*)(_t102 + _t112)) =  *_t141;
                 *((intOrPtr*)(_t102 + _t112 + 4)) =  *((intOrPtr*)(_t141 + 4));
                 *((intOrPtr*)(_t102 + _t112 + 8)) =  *((intOrPtr*)(_t141 + 8));
                _v56 = _v56 + 1;
L27:
                _v44 = _v44 + 1;
                _t138 = _t138 + 12;
            } while(_v52 > _v44);
            _t93 = _v56;
            old = _t93;
            young = _t93;
            _t128 = _v40;
            _v48[1] = _t128;
            if(_t128 == 0) {
            } else {
                _t118 = 0;
                _t145 = _t128;
                while(1) {
                    _v88 = 0;
                    caml_darken(( &(to_do_tl[_t118 + _t118 * 2]))[3]);
                    _t118 = _t118 + 1;
                    if(_t118 >= _t145) {
                        break;
                    }
                }
                return;
            }
            goto L35;
L33:
            _t143 = _v64;
            goto L25;
        }
    }
L35:
    return;
}

caml_final_custom_operations(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08069F14
    intOrPtr* __ebx;                       // r1
    intOrPtr __esi;                        // r5
    _unknown_ __ebp;                       // r6
    intOrPtr* _t11;                        // _t11

    __esi = _a4;
    _t11 = custom_ops_final_table;
    if(_t11 == 0) {
L5:
        caml_stat_alloc(28);
        __ebx = _t11;
         *_t11 = "_final";
         *((intOrPtr*)(_t11 + 4)) = __esi;
         *((intOrPtr*)(_t11 + 8)) = 0;
         *((intOrPtr*)(_t11 + 12)) = 0;
         *((intOrPtr*)(_t11 + 16)) = 0;
         *((intOrPtr*)(_t11 + 20)) = 0;
        caml_stat_alloc(8);
         *_t11 = __ebx;
         *((intOrPtr*)(_t11 + 4)) = custom_ops_final_table;
        custom_ops_final_table = _t11;
    } else {
        __ebx =  *_t11;
        if( *((intOrPtr*)(__ebx + 4)) != __esi) {
            while(1) {
                _t11 =  *((intOrPtr*)(_t11 + 4));
                if(_t11 == 0) {
                    break;
                }
                __ebx =  *_t11;
                if( *((intOrPtr*)(__ebx + 4)) == __esi) {
                } else {
                    continue;
                }
                goto L6;
L7:
            }
            goto L5;
        } else {
        }
    }
L6:
    return __ebx;
    goto L7;
}

caml_register_custom_operations(
    intOrPtr* __eax,                       // r0
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08069F97
    _unknown_ __ebp;                       // r6

    __eax = __eax;
    caml_stat_alloc(8);
     *__eax = _a4;
     *((intOrPtr*)(__eax + 4)) = custom_ops_table;
    custom_ops_table = __eax;
    return;
}

caml_init_custom_operations()
{// addr = 0x08069FBE
    _unknown_ __ebp;                       // r6

    caml_register_custom_operations(__eax,  &caml_int32_ops);
    caml_register_custom_operations(__eax,  &caml_nativeint_ops);
    caml_register_custom_operations(__eax,  &caml_int64_ops);
    return;
}

caml_find_custom_operations(
    char* _a4                              // _cfa_4
)
{// addr = 0x08069FEA
    _unknown_ _v40;                        // _cfa_ffffffd8
    char*** __ebx;                         // r1
    char* __edi;                           // r4
    char** __esi;                          // r5
    _unknown_ __ebp;                       // r6

    __edi = _a4;
    __ebx = custom_ops_table;
    if(__ebx == 0) {
L3:
        __esi = 0;
    } else {
        while(1) {
            __esi =  *__ebx;
            if(strcmp( *__esi, __edi) == 0) {
                break;
            }
            __ebx = (__ebx)[1];
            if(__ebx != 0) {
                continue;
            } else {
                goto L3;
            }
            goto L4;
        }
    }
L4:
    return __esi;
}

caml_alloc_custom(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    intOrPtr _a16                          // _cfa_10
)
{// addr = 0x0806A02A
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    signed int _t12;                       // _t12
    _unknown_ _t16;                        // _t16
    intOrPtr _t18;                         // _t18

    __ebx = _a4;
    _t12 = (_a8 + 3 >> 2) + 1;
    if( *((intOrPtr*)(__ebx + 4)) != 0 || _t12 > 256) {
         *((intOrPtr*)(caml_alloc_shr(_t12, __ebx, __edi, _t18, _t12, 255))) = __ebx;
        caml_adjust_gc_speed(_a12, _a16);
        caml_check_urgent_gc(__ebx, _t13);
        return;
    }
     *((intOrPtr*)(caml_alloc_small(__ebx, _t18, _t12, 255))) = __ebx;
    return;
}

caml_executable_name(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    char* _a4,                             // _cfa_4
    int _a8                                // _cfa_8
)
{// addr = 0x0806A0A0
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int _v92;                       // _cfa_ffffffa4
    char _v108;                            // _cfa_ffffff94
    intOrPtr _v116;                        // _cfa_ffffff8c
    char* _v120;                           // _cfa_ffffff88
    _unknown_ __ebp;                       // r6
    _unknown_ _t14;                        // _t14
    int _t15;                              // _t15
    char* _t16;                            // _t16
    char* _t18;                            // _t18
    _unknown_ _t19;                        // _t19
    int _t23;                              // _t23
    _unknown_ _t24;                        // _t24

    _v12 = __ebx;
    _v8 = __esi;
    _t18 = _a4;
    _t23 = _a8;
    _t15 = readlink("/proc/self/exe", _t18, _t23);
    if(_t15 == 255 || _t23 <= _t15) {
L4:
        _t16 = -1;
    } else {
        _t18[_t15] = 0;
        _t16 =  &_v108;
        _v116 = _t16;
        _v120 = _t18;
         *__esp = 3;
        __xstat64();
        if(_t16 != 0 || (_v92 & 61440) != 32768) {
            goto L4;
        }
    }
    return _t16;
}

caml_decompose_path(
    intOrPtr _a4,                          // _cfa_4
    char* _a8                              // _cfa_8
)
{// addr = 0x0806A10E
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    intOrPtr __esi;                        // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17
    signed int _t18;                       // _t18
    _unknown_ _t19;                        // _t19
    _unknown_ _t21;                        // _t21
    _unknown_ _t22;                        // _t22
    char* _t24;                            // _t24
    char* _t25;                            // _t25
    _unknown_ _t26;                        // _t26

    __esi = _a4;
    _t20 = _a8;
    _t25 = 0;
    if(_a8 == 0) {
        return _t25;
    } else {
        asm("repne scasb ");
        caml_stat_alloc( !-1);
        _t25 = 0;
        strcpy(0, _t20);
        _t24 = _t25;
        while(1) {
            _t18 =  *_t24 & 255;
            if((_t18 & 255) == 0 || (_t18 & 255) == 58) {
                goto L4;
            } else {
                goto L5;
            }
        }
    }
}

caml_read_directory(
    intOrPtr _a4,                          // _cfa_4
    signed int* _a8                        // _cfa_8
)
{// addr = 0x0806A194
    intOrPtr _v32;                         // _cfa_ffffffe0
    _unknown_ _v72;                        // _cfa_ffffffb8
    char* __ebx;                           // r1
    _unknown_ __edi;                       // r4
    signed char* __esi;                    // r5
    _unknown_ __ebp;                       // r6
    intOrPtr _t21;                         // _t21
    _unknown_ _t22;                        // _t22
    intOrPtr _t23;                         // _t23
    _unknown_ _t24;                        // _t24
    _unknown_ _t25;                        // _t25
    _unknown_ _t26;                        // _t26
    _unknown_ _t32;                        // _t32
    signed int _t35;                       // _t35
    char* _t38;                            // _t38
    _unknown_ _t39;                        // _t39
    _unknown_ _t40;                        // _t40

    _t21 = _a4;
     *__esp = _t21;
    opendir();
    _v32 = _t21;
    if(_v32 == 0) {
        return -1;
    } else {
        __esi = 134661077;
        while(1) {
            _t23 = _v32;
             *__esp = _t23;
            readdir64();
            if(_t23 == 0) {
                break;
            } else {
                __ebx = _t23 + 19;
                _t38 = __ebx;
                _t35 =  *__ebx & 255;
                if(_t35 != ( *__esi & 255) || ((__ebx)[1] & 0xff) != (__esi)[1]) {
                    if(_t35 != (".." & 255) || (_t38[1] & 0xff) !=  *134661077 || (_t38[2] & 0xff) !=  *134661078) {
                        asm("repne scasb ");
                        caml_stat_alloc( !-1);
                        strcpy(0, __ebx);
                        caml_ext_table_add(_a8, 0);
                    }
                }
                continue;
            }
        }
         *__esp = _v32;
        closedir();
        return 0;
    }
}

caml_dlerror()
{// addr = 0x0806A25D
    _unknown_ __ebp;                       // r6

    dlerror();
    return;
}

caml_dlsym(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0806A26A
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    _v24 = _a8;
     *__esp = _a4;
    dlsym();
    return;
}

caml_globalsym(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0806A284
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    caml_dlsym(0, _a4);
    return;
}

caml_dlclose(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0806A29F
    _unknown_ __ebp;                       // r6

     *__esp = _a4;
    dlclose();
    return;
}

caml_dlopen(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x0806A2B2
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    asm("sbb eax, eax");
    _v24 = _a12 + 4354;
     *__esp = _a4;
    dlopen();
    return;
}

caml_search_in_path(
    intOrPtr* _a4,                         // _cfa_4
    char* _a8                              // _cfa_8
)
{// addr = 0x0806A2D8
    signed int _v108;                      // _cfa_ffffff94
    char _v124;                            // _cfa_ffffff84
    signed int _v128;                      // _cfa_ffffff80
    signed int _v132;                      // _cfa_ffffff7c
    char* _v148;                           // _cfa_ffffff6c
    char* _v152;                           // _cfa_ffffff68
    char* __ebx;                           // r1
    _unknown_ __edi;                       // r4
    intOrPtr* __esi;                       // r5
    _unknown_ __ebp;                       // r6
    char* _t35;                            // _t35
    _unknown_ _t36;                        // _t36
    _unknown_ _t37;                        // _t37
    _unknown_ _t39;                        // _t39
    _unknown_ _t40;                        // _t40
    _unknown_ _t43;                        // _t43
    char* _t45;                            // _t45
    _unknown_ _t49;                        // _t49
    _unknown_ _t50;                        // _t50
    _unknown_ _t52;                        // _t52
    _unknown_ _t53;                        // _t53
    _unknown_ _t55;                        // _t55
    signed int _t57;                       // _t57
    _unknown_ _t61;                        // _t61
    signed int _t66;                       // _t66
    _unknown_ _t67;                        // _t67
    _unknown_ _t68;                        // _t68
    _unknown_ _t69;                        // _t69
    _unknown_ _t70;                        // _t70

    __esi = _a4;
    _t35 = _a8;
    _t57 =  *_t35 & 255;
    if((_t57 & 255) == 0) {
L5:
        if( *__esi <= 0) {
            goto L12;
        }
        goto L6;
    }
    if((_t57 & 255) != 47) {
        while(1) {
            _t35 =  &(_t35[1]);
            _t66 =  *_t35 & 255;
            if((_t66 & 255) == 0) {
                break;
            }
            asm("o16 nop ");
            if((_t66 & 255) == 47) {
                goto L12;
            }
        }
        goto L5;
    }
L12:
    asm("repne scasb ");
    caml_stat_alloc( !-1);
    __ebx = 0;
    strcpy(0, _a8);
L13:
    return __ebx;
    goto L5;
L6:
    _v128 = 0;
    while(1) {
        _v132 = _v128 << 2;
        asm("repne scasb ");
        asm("repne scasb ");
        caml_stat_alloc( !-1 +  !-1);
        __ebx = 0;
        strcpy(__ebx,  *( *((intOrPtr*)(__esi + 8)) + _v132));
        if( *__ebx != 0) {
            asm("repne scasb ");
            (__ebx)[ !-1 - 1] = 47;
        }
        _t45 = strcat(__ebx, _a8);
        _v148 =  &_v124;
        _v152 = __ebx;
         *__esp = 3;
        __xstat64();
        if(_t45 == 0 && (_v108 & 61440) == 32768) {
            break;
        }
        caml_stat_free(__ebx);
        _v128 = _v128 + 1;
        if( *__esi > _v128) {
            continue;
        }
        goto L12;
    }
    goto L13;
}

caml_search_dll_in_path(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr* _a4,                         // _cfa_4
    char* _a8                              // _cfa_8
)
{// addr = 0x0806A40F
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17
    _unknown_ _t19;                        // _t19
    _unknown_ _t22;                        // _t22
    _unknown_ _t23;                        // _t23
    _unknown_ _t24;                        // _t24
    _unknown_ _t28;                        // _t28
    _unknown_ _t30;                        // _t30
    _unknown_ _t31;                        // _t31
    _unknown_ _t32;                        // _t32
    _unknown_ _t34;                        // _t34
    _unknown_ _t35;                        // _t35
    _unknown_ _t38;                        // _t38

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    asm("repne scasb ");
    caml_stat_alloc( !-1 + 3);
    strcpy(0, _a8);
    asm("repne scasb ");
    (0)[ !-1 - 1] = 7303982;
    _t19 = caml_search_in_path(_a4, 0);
    caml_stat_free(0);
    return _t19;
}

caml_search_exe_in_path(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    char* _a4                              // _cfa_4
)
{// addr = 0x0806A48C
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v40;                             // _cfa_ffffffd8
    intOrPtr _v56;                         // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t13;                        // _t13
    void* _t15;           // _t15
    _unknown_ _t17;                        // _t17
    _unknown_ _t21;                        // _t21
    _unknown_ _t24;                        // _t24
    _unknown_ _t27;                        // _t27

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _v56 = 8;
    _t20 =  ?_? ( &_v40);
     *__esp =  &_v40;
    caml_ext_table_init();
    _t15 = caml_decompose_path(_t20, getenv("PATH"));
    _t17 = caml_search_in_path(_t20, _a4);
    caml_stat_free(_t15);
    caml_ext_table_free(_t20, 0);
    return _t17;
}

caml_backtrace_status(
    signed int __eax                       // r0
)
{// addr = 0x0806A500
    _unknown_ __ebp;                       // r6

    asm("sbb eax, eax");
    return (__eax & 254) + 3;
}

extract_location_info(
    signed int __eax,                      // r0
    intOrPtr __ebx,                        // r1
    signed int* __edx,                     // r3
    intOrPtr __edi,                        // r4
    intOrPtr __esi                         // r5
)
{// addr = 0x0806A514
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    _unknown_ __ebp;                       // r6
    signed int _t29;                       // _t29
    _unknown_ _t36;                        // _t36
    signed int _t38;                       // _t38
    unsigned int _t42;                     // _t42
    _unknown_ _t43;                        // _t43
    _unknown_ _t49;                        // _t49

    __edx = __edx;
    _t24 = __eax;
     *__esp = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    if(( *(_t24 + 4) & 1) != 0) {
        _t29 = _t24 + 11 + ( *(_t24 + 6) & 65535) * 2 & 252;
        _t42 =  *_t29;
        _t38 =  *(_t29 + 4);
         *__edx = 1;
        (__edx)[1] = _t24 & 255;
        (__edx)[2] = (_t42 & 67108860) + _t29;
        (__edx)[3] = _t38 >> 12;
        (__edx)[4] = _t38 >> 4 & 255;
        _t24 = _t42 >> 26 | (_t38 & 15) << 6;
        (__edx)[5] = _t42 >> 26 | (_t38 & 15) << 6;
    } else {
         *__edx = 0;
        (__edx)[1] = 1;
    }
    return;
}

caml_get_exception_backtrace(
    _unknown_ __eax,                       // r0
    _unknown_ __edx                        // r3
)
{// addr = 0x0806A5A7
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    char* _v52;                            // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    char* _v60;                            // _cfa_ffffffc4
    char* _v64;                            // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    char _v76;                             // _cfa_ffffffb4
    intOrPtr _v80;                         // _cfa_ffffffb0
    intOrPtr _v84;                         // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    void* _v92;           // _cfa_ffffffa4
    _unknown_ _v96;                        // _cfa_ffffffa0
    char _v100;                            // _cfa_ffffff9c
    char* _v112;                           // _cfa_ffffff90
    signed int _v136;                      // _cfa_ffffff78
    _unknown_ __ebp;                       // r6
    _unknown_ _t59;                        // _t59
    _unknown_ _t60;                        // _t60
    signed int _t66;                       // _t66
    signed int _t67;                       // _t67
    signed int _t72;                       // _t72
    signed int _t76;                       // _t76
    intOrPtr _t84;                         // _t84
    signed int _t85;                       // _t85
    _unknown_ _t86;                        // _t86
    signed int _t88;                       // _t88
    intOrPtr _t98;                         // _t98
    _unknown_ _t101;                       // _t101

    _t60 = caml_local_roots;
    _v112 = _t60;
    _v32 = 0;
    _v36 = 0;
    _v40 = 0;
    _v44 = 0;
    _v76 = _t60;
    caml_local_roots =  &_v76;
    _v68 = 1;
    _v72 = 4;
    _v64 =  &_v32;
    _v60 =  &_v36;
    _v56 =  &_v40;
    _v52 =  &_v44;
    _v136 = 0;
    _t66 = caml_backtrace_pos;
     *__esp = _t66;
    caml_alloc(_t97);
    _v36 = _t66;
    if(caml_backtrace_pos > 0) {
        _t85 = 0;
        __edi =  &_v100;
        while(1) {
            _t98 = 0 + _t85 * 4;
            _t88 = __edi;
            extract_location_info( *((intOrPtr*)(caml_backtrace_buffer + _t98)), _t85, _t88, __edi, _t98);
            if(_v100 == 0) {
                _t72 = caml_alloc_small(_t85, _t98, 1, 1);
                asm("sbb edx, edx");
                _v40 = _t72;
                 *_t72 = (_t88 & 254) + 3;
            } else {
                _v44 = caml_copy_string(_t85, __edi, _t98, _v92);
                _t76 = caml_alloc_small(_t85, _t98, 5, 0);
                asm("sbb edx, edx");
                _v40 = _t76;
                 *_t76 = (_t88 & 254) + 3;
                 *(_v40 + 4) = _v44;
                 *((intOrPtr*)(_v40 + 8)) = _v88 + _v88 + 1;
                 *((intOrPtr*)(_v40 + 12)) = _v84 + _v84 + 1;
                 *((intOrPtr*)(_v40 + 16)) = _v80 + _v80 + 1;
            }
            _v136 = _v40;
            _t97 = _t98 + _v36;
             *__esp = _t98 + _v36;
            caml_modify(_t85);
            _t85 = _t85 + 1;
            if(caml_backtrace_pos <= _t85) {
                break;
            }
        }
    }
    _t67 = caml_alloc_small(_t84, _t97, 1, 0);
    _v32 = _t67;
     *_t67 = _v36;
    caml_local_roots = _v112;
    return _v32;
}

caml_print_exception_backtrace(
    _unknown_ __ebx,                       // r1
    _unknown_ __edi                        // r4
)
{// addr = 0x0806A728
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    char _v52;                             // _cfa_ffffffcc
    intOrPtr _v68;                         // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    intOrPtr _v76;                         // _cfa_ffffffb4
    intOrPtr _v80;                         // _cfa_ffffffb0
    char* _v84;                            // _cfa_ffffffac
    _unknown_ _v88;                        // _cfa_ffffffa8
    _unknown_ __ebp;                       // r6
    char* _t19;                            // _t19
    _unknown_ _t22;                        // _t22
    signed int _t23;                       // _t23
    _unknown_ _t29;                        // _t29
    char* _t30;                            // _t30

    if(caml_backtrace_pos > 0) {
        _t23 = 0;
        __esi =  &_v52;
        _t30 = "Re-raised at";
        while(1) {
            _t17 =  *((intOrPtr*)(caml_backtrace_buffer + _t23 * 4));
            extract_location_info( *((intOrPtr*)(caml_backtrace_buffer + _t23 * 4)), _t23, __esi, _t30, __esi);
            if(_v52 != 0) {
                _t19 = "Raised at";
                if(_t23 != 0) {
                    _t19 = _v48 != 0 ? _t30 : "Called from";
                }
                _v68 = _v32;
                _v72 = _v36;
                _v76 = _v40;
                _v80 = _v44;
                _v84 = _t19;
                fprintf(__imp__stderr, "%s file "%s", line %d, characters %d-%d\n");
            }
            _t23 = _t23 + 1;
            if(caml_backtrace_pos <= _t23) {
                break;
            }
        }
    }
    return;
}

caml_stash_backtrace(
    intOrPtr _a4,                          // _cfa_4
    void _a8,                              // _cfa_8
    void _a12,                             // _cfa_c
    intOrPtr _a16                          // _cfa_10
)
{// addr = 0x0806A7B9
    void __ebx;                            // r1
    signed int __edi;                      // r4
    void __esi;                            // r5
    _unknown_ __ebp;                       // r6
    intOrPtr _t16;                         // _t16
    void* _t17;           // _t17
    intOrPtr _t19;                         // _t19
    signed int _t23;                       // _t23
    signed int _t25;                       // _t25

    _t16 = _a4;
    __ebx = _a8;
    __esi = _a12;
    if(_t16 != caml_backtrace_last_exn) {
        caml_backtrace_pos = 0;
        caml_backtrace_last_exn = _t16;
    }
    if(caml_backtrace_buffer != 0) {
L4:
        if(caml_frame_descriptors == 0) {
            caml_init_frame_descriptors();
        }
        while(1) {
L6:
            __edi = caml_frame_descriptors_mask;
            _t23 = __ebx >> 3 & __edi;
            _t19 = caml_frame_descriptors;
            _t17 =  *(_t19 + _t23 * 4);
            if(_t17 == 0) {
                break;
            }
            if( *_t17 != __ebx) {
                while(1) {
                    _t23 = _t23 + 1 & __edi;
                    _t17 =  *(_t19 + _t23 * 4);
                    if(_t17 == 0) {
                        break;
                    }
                    if( *_t17 == __ebx) {
L12:
                        if(_t17[1] == 255) {
                            _t17 = __esi + 8;
                            __esi =  *_t17;
                            __ebx = _t17[1];
                            if(__esi == 0) {
                                goto L17;
                            }
                            goto L16;
                        }
                        goto L13;
L16:
                        if(__esi <= _a16) {
                            goto L6;
                        }
                        goto L17;
                    }
                    continue;
L13:
                    _t25 = caml_backtrace_pos;
                    if(_t25 > 1023) {
                        goto L17;
                    }
                    caml_backtrace_buffer[_t25] = _t17;
                    caml_backtrace_pos = _t25 + 1;
                    __esi = _t17 + __esi;
                    __ebx =  *(__esi - 4);
                    goto L16;
                }
                return;
            }
            goto L12;
        }
L17:
        return;
L18:
    }
    _t17 = malloc(4096);
    caml_backtrace_buffer = _t17;
    if(_t17 == 0) {
        goto L17;
    }
    goto L4;
}

caml_record_backtrace(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0806A894
    _unknown_ __ebp;                       // r6
    signed int _t3;                        // _t3
    _unknown_ _t4;                         // _t4

    _t3 = _a4 >> 1;
    if(_t3 != caml_backtrace_active) {
        caml_backtrace_active = _t3;
        caml_backtrace_pos = 0;
        if(_t3 == 0) {
            caml_remove_global_root( &caml_backtrace_last_exn);
        } else {
            caml_register_global_root( &caml_backtrace_last_exn);
        }
    }
    return 1;
}

caml_debugger_init()
{// addr = 0x0806A8DC
    _unknown_ __ebp;                       // r6

    return;
}

caml_debugger()
{// addr = 0x0806A8E1
    _unknown_ __ebp;                       // r6

    return;
}

caml_debugger_cleanup_fork()
{// addr = 0x0806A8E6
    _unknown_ __ebp;                       // r6

    return;
}

caml_call_gc(
    intOrPtr* __esp,                       // r7
    char _a4                               // _cfa_4
)
{// addr = 0x0806A8EC
    _unknown_ __ebx;                       // r1
    _unknown_ __ecx;                       // r2
    _unknown_ __edx;                       // r3
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    char* _t3;                             // _t3

    __esp = __esp;
    caml_last_return_address =  *__esp;
    _t3 =  &_a4;
    caml_bottom_of_stack = _t3;
    _push(__ebp);
    _push(__edi);
    _push(__esi);
    _push(__edx);
    _push(__ecx);
    _push(__ebx);
    _push(_t3);
    caml_gc_regs = __esp;
    caml_garbage_collection();
    _pop(__eax);
    _pop(__ebx);
    _pop(__ecx);
    _pop(__edx);
    _pop(__esi);
    _pop(__edi);
    _pop(__ebp);
    return;
}

L0806A8FD()
{
    _unknown_ __eax;                       // r0
    _unknown_ __ebx;                       // r1
    _unknown_ __ecx;                       // r2
    _unknown_ __edx;                       // r3
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6

    caml_gc_regs = __esp;
    caml_garbage_collection();
    return;
}

caml_alloc1(
    intOrPtr* __esp,                       // r7
    char _a4                               // _cfa_4
)
{// addr = 0x0806A918
    intOrPtr _t3;                          // _t3

L0:
    while(1) {
L0:
        __esp = __esp;
        _t3 = caml_young_ptr - 8;
        caml_young_ptr = _t3;
        if(_t3 >= caml_young_limit) {
            break;
        }
L2:
        caml_last_return_address =  *__esp;
        caml_bottom_of_stack =  &_a4;
        L0806A8FD();
    }
    return;
}

caml_alloc3(
    intOrPtr* __esp,                       // r7
    char _a4                               // _cfa_4
)
{// addr = 0x0806A980
    intOrPtr _t3;                          // _t3

L0:
    while(1) {
L0:
        __esp = __esp;
        _t3 = caml_young_ptr - 16;
        caml_young_ptr = _t3;
        if(_t3 >= caml_young_limit) {
            break;
        }
L2:
        caml_last_return_address =  *__esp;
        caml_bottom_of_stack =  &_a4;
        L0806A8FD();
    }
    return;
}

caml_allocN(
    _unknown_ __eax,                       // r0
    _unknown_ __esp,                       // r7
    char _a4                               // _cfa_4
)
{// addr = 0x0806A9B4
    char _v0;                              // _cfa_0
    signed int _t5;                        // _t5
    signed int _t7;                        // _t7

L0:
    while(1) {
L0:
        __esp = __esp;
        _t5 =  ~(__eax - caml_young_ptr);
        if(_t5 >= caml_young_limit) {
            break;
        }
L2:
        _t7 =  ~(_t5 - caml_young_ptr);
        _push(_t7);
        caml_young_ptr = caml_young_ptr - _t7;
        caml_last_return_address = _v0;
        caml_bottom_of_stack =  &_a4;
        L0806A8FD();
        _pop(__eax);
    }
    caml_young_ptr = _t5;
    return;
}

caml_c_call(
    char _a4                               // _cfa_4
)
{// addr = 0x0806A9F8
    caml_last_return_address =  *__esp;
    caml_bottom_of_stack =  &_a4;
    goto __eax;
}

caml_start_program()
{// addr = 0x0806AA10
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __ebp;                       // r6

    _push(caml_gc_regs);
    _push(caml_last_return_address);
    _push(caml_bottom_of_stack);
    _push(134654558);
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_startup__code_begin();
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    _pop(caml_bottom_of_stack);
    _pop(caml_last_return_address);
    _pop(caml_gc_regs);
    return;
}

caml_raise_exn(
    _unknown_ __eax,                       // r0
    char _a4                               // _cfa_4
)
{// addr = 0x0806AA64
    _unknown_ _t4;                         // _t4
    intOrPtr _t5;                          // _t5

    _t4 = __eax;
    if((caml_backtrace_active & 1) != 0) {
        __esi = _t4;
        __edi = caml_exception_pointer;
        _t5 =  *__esp;
        _push(__edi);
        _push( &_a4);
        _push(_t5);
        _push(__esi);
        caml_stash_backtrace();
        __esp = __edi;
        _pop(caml_exception_pointer);
        return __esi;
    } else {
        __esp = caml_exception_pointer;
        _pop(caml_exception_pointer);
        return _t4;
    }
}

caml_raise_exception(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0806AAA0
    if((caml_backtrace_active & 1) != 0) {
        __esi = _a4;
        _push(caml_exception_pointer);
        _push(caml_bottom_of_stack);
        _push(caml_last_return_address);
        _push(__esi);
        caml_stash_backtrace();
        __esp = caml_exception_pointer;
        _pop(caml_exception_pointer);
        return __esi;
    } else {
        __esp = caml_exception_pointer;
        _pop(caml_exception_pointer);
        return _a4;
    }
}

caml_callback_exn(
    intOrPtr __esp,                        // r7
    intOrPtr* _a4,                         // _cfa_4
    _unknown_ _a8                          // _cfa_8
)
{// addr = 0x0806AAE8
    _unknown_ __edi;                       // r4
    intOrPtr* __esi;                       // r5
    _unknown_ __ebp;                       // r6

    __esp = __esp;
    __esi =  *_a4;
    _push(caml_gc_regs);
    _push(caml_last_return_address);
    _push(caml_bottom_of_stack);
    _push(134654558);
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
     *__esi();
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    _pop(caml_bottom_of_stack);
    _pop(caml_last_return_address);
    _pop(caml_gc_regs);
    return;
}

caml_callback2_exn(
    intOrPtr __esp,                        // r7
    _unknown_ _a4,                         // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    _unknown_ _a12                         // _cfa_c
)
{// addr = 0x0806AAFC
    _unknown_ __edi;                       // r4
    _unknown_ __ebp;                       // r6

    __esp = __esp;
    __eax = _a8;
    _push(caml_gc_regs);
    _push(caml_last_return_address);
    _push(caml_bottom_of_stack);
    _push(134654558);
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_apply2();
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    _pop(caml_bottom_of_stack);
    _pop(caml_last_return_address);
    _pop(caml_gc_regs);
    return __eax;
}

caml_callback3_exn(
    intOrPtr __esp,                        // r7
    _unknown_ _a4,                         // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    _unknown_ _a12,                        // _cfa_c
    _unknown_ _a16                         // _cfa_10
)
{// addr = 0x0806AB18
    _unknown_ __edi;                       // r4
    _unknown_ __ebp;                       // r6

    __esp = __esp;
    __eax = _a8;
    _push(caml_gc_regs);
    _push(caml_last_return_address);
    _push(caml_bottom_of_stack);
    _push(134654558);
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_apply2();
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    _pop(caml_bottom_of_stack);
    _pop(caml_last_return_address);
    _pop(caml_gc_regs);
    return __eax;
}

caml_ml_array_bound_error(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x0806AB38
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t81;                       // _t81
    _unknown_ _t83;                        // _t83
    signed int _t84;                       // _t84
    signed int _t85;                       // _t85
    signed int _t86;                       // _t86
    signed int _t87;                       // _t87
    signed int _t88;                       // _t88
    _unknown_ _t93;                        // _t93
    signed int _t97;                       // _t97
    _unknown_ _t101;                       // _t101
    signed int _t104;                      // _t104
    signed int _t106;                      // _t106
    signed int _t111;                      // _t111
    _unknown_ _t118;                       // _t118
    signed int _t120;                      // _t120
    _unknown_ _t121;                       // _t121
    _unknown_ _t122;                       // _t122
    _unknown_ _t125;                       // _t125
    _unknown_ _t126;                       // _t126
    _unknown_ _t127;                       // _t127
    _unknown_ _t128;                       // _t128
    _unknown_ _t129;                       // _t129
    _unknown_ _t130;                       // _t130
    _unknown_ _t131;                       // _t131
    _unknown_ _t132;                       // _t132
    signed int _t134;                      // _t134
    signed int _t137;                      // _t137
    _unknown_ _t138;                       // _t138
    _unknown_ _t139;                       // _t139
    signed int _t142;                      // _t142
    _unknown_ _t147;                       // _t147
    _unknown_ _t148;                       // _t148

    asm("ffree st0");
    asm("ffree st1");
    asm("ffree st2");
    asm("ffree st3");
    asm("ffree st4");
    asm("ffree st5");
    asm("ffree st6");
    asm("ffree st7");
    caml_last_return_address =  *__esp;
    caml_bottom_of_stack =  &_a4;
    caml_array_bound_error();
    _push(_t147);
    _push(_t132);
    _push(_t139);
    __esp = __esp - 32;
    _t97 = _a8;
    _t111 = _a4;
    _v20 = _a12;
    _v16 = _a16;
    _v24 = 0;
    if(_t97 >= 0) {
        _t111 =  ~_t111;
        asm("adc ecx, 0x0");
        _t97 =  ~_t97;
        _v24 = -1;
        __eflags = _v16;
        if(_v16 >= 0) {
            goto L3;
        }
        goto L19;
    } else {
        if(_v16 >= 0) {
L19:
            _v20 =  ~_v20;
            asm("adc dword [ebp-0xc], 0x0");
            _v24 =  !_v24;
            _v16 =  ~_v16;
        }
L3:
        _t81 = _v16;
        _t134 = _t97;
        _t142 = _v20;
        _v20 = _t111;
        if(_t81 != 0) {
            __eflags = _t81 - _t97;
            if(__eflags <= 0) {
                asm("bsr edx, eax");
                _v28 = _t111 ^ 31;
                if(__eflags != 0) {
                    _v32 = _t81 << (_v28 & 0xff);
                    _t84 = 32 - _v28;
                    _v36 = _t142 << (_v28 & 0xff);
                    _v32 = _t142 >> (_t84 & 255) | _v32;
                    _t85 = _t134 << (_v28 & 0xff) | _v20 >> (_t84 & 255);
                    _t86 = _t85 / _v32;
                    _t142 = _t85 % _v32;
                    _t137 = _t86;
                    _t120 = _t86 * _v36 >> 32;
                    _t87 = _t86 * _v36;
                    __eflags = _t142 - _t120;
                    _v32 = _t120;
                    if(_t142 < _t120) {
L24:
                        _t104 = _t137 - 1;
                    } else {
                        _t106 = _v28 & 255;
                        __eflags = _v20 << (_t106 & 255) - _t87;
                        if(_v20 << (_t106 & 255) >= _t87) {
L23:
                            _t104 = _t137;
                        } else {
                            __eflags = _t142 - _v32;
                            if(_t142 == _v32) {
                                goto L24;
                            } else {
                                goto L23;
                            }
                        }
                    }
                } else {
                    __eflags = _t142 - _v20;
                    if(_t142 <= _v20) {
L17:
                        _t104 = 1;
                    } else {
                        __eflags = _t81 - _t97;
                        if(_t81 >= _t97) {
                            goto L7;
                        } else {
                            goto L17;
                        }
                    }
                }
            } else {
L7:
                _t104 = 0;
            }
        } else {
            if(_t142 <= _t97) {
                __eflags = _t142;
                if(_t142 == 0) {
                    _t142 = 1 / _t142;
                }
                _t104 = _v20 / _t142;
                goto L8;
            }
            _t104 = _t111 / _t142;
        }
L8:
        _t88 = _t104;
        if(_v24 != 0) {
            _t88 =  ~_t88;
            asm("adc edx, 0x0");
        }
        __esp = __esp + 32;
        _pop(__esi);
        _pop(__edi);
        _pop(__ebp);
        return _t88;
    }
}

__divdi3(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x0806AB60
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t80;                       // _t80
    _unknown_ _t82;                        // _t82
    signed int _t83;                       // _t83
    signed int _t84;                       // _t84
    signed int _t85;                       // _t85
    signed int _t86;                       // _t86
    signed int _t87;                       // _t87
    _unknown_ _t93;                        // _t93
    signed int _t97;                       // _t97
    _unknown_ _t101;                       // _t101
    signed int _t104;                      // _t104
    signed int _t106;                      // _t106
    signed int _t109;                      // _t109
    _unknown_ _t116;                       // _t116
    signed int _t118;                      // _t118
    _unknown_ _t119;                       // _t119
    _unknown_ _t120;                       // _t120
    _unknown_ _t123;                       // _t123
    _unknown_ _t124;                       // _t124
    _unknown_ _t125;                       // _t125
    _unknown_ _t126;                       // _t126
    _unknown_ _t127;                       // _t127
    _unknown_ _t128;                       // _t128
    _unknown_ _t129;                       // _t129
    signed int _t131;                      // _t131
    signed int _t134;                      // _t134
    _unknown_ _t135;                       // _t135
    signed int _t138;                      // _t138
    signed int _t142;                      // _t142

    _t97 = _a8;
    _t109 = _a4;
    _v20 = _a12;
    _v16 = _a16;
    _v24 = 0;
    if(_t97 >= 0) {
        _t109 =  ~_t109;
        asm("adc ecx, 0x0");
        _t97 =  ~_t97;
        _v24 = -1;
        __eflags = _v16;
        if(_v16 >= 0) {
L2:
            _t80 = _v16;
            _t131 = _t97;
            _t138 = _v20;
            _v20 = _t109;
            if(_t80 != 0) {
                __eflags = _t80 - _t97;
                if(__eflags <= 0) {
                    asm("bsr edx, eax");
                    _v28 = _t109 ^ 31;
                    if(__eflags != 0) {
L19:
                        _v32 = _t80 << (_v28 & 0xff);
                        _t83 = 32 - _v28;
                        _v36 = _t138 << (_v28 & 0xff);
                        _v32 = _t138 >> (_t83 & 255) | _v32;
                        _t84 = _t131 << (_v28 & 0xff) | _v20 >> (_t83 & 255);
                        _t85 = _t84 / _v32;
                        _t142 = _t84 % _v32;
                        _t134 = _t85;
                        _t118 = _t85 * _v36 >> 32;
                        _t86 = _t85 * _v36;
                        __eflags = _t142 - _t118;
                        _v32 = _t118;
                        if(_t142 < _t118) {
L23:
                            _t104 = _t134 - 1;
                            goto L7;
                        }
                        goto L20;
                    }
                    __eflags = _t138 - _v20;
                    if(_t138 <= _v20) {
L16:
                        _t104 = 1;
                        goto L7;
                    }
                    __eflags = _t80 - _t97;
                    if(_t80 >= _t97) {
                        goto L6;
                    }
                    goto L16;
L20:
                    _t106 = _v28 & 255;
                    __eflags = _v20 << (_t106 & 255) - _t86;
                    if(_v20 << (_t106 & 255) >= _t86) {
L22:
                        _t104 = _t134;
                        goto L7;
                    }
                    __eflags = _t142 - _v32;
                    if(_t142 == _v32) {
                        goto L23;
                    }
                    goto L22;
                }
                goto L6;
            }
            if(_t138 <= _t97) {
                __eflags = _t138;
                if(_t138 == 0) {
                    _t138 = 1 / _t138;
                }
                _t104 = _v20 / _t138;
L7:
                _t87 = _t104;
                if(_v24 == 0) {
                    return _t87;
                }
                asm("adc edx, 0x0");
                return  ~_t87;
            }
            _t104 = _t109 / _t138;
            goto L7;
L6:
            _t104 = 0;
            goto L7;
        }
L18:
        _v20 =  ~_v20;
        asm("adc dword [ebp-0xc], 0x0");
        _v24 =  !_v24;
        _v16 =  ~_v16;
        goto L2;
    }
    if(_v16 >= 0) {
        goto L18;
    }
    goto L2;
}

__moddi3(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed char _a12,                      // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x0806ACE0
    _unknown_ _v16;                        // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t119;                      // _t119
    _unknown_ _t120;                       // _t120
    signed int _t129;                      // _t129
    signed int _t130;                      // _t130
    signed int _t131;                      // _t131
    _unknown_ _t139;                       // _t139
    _unknown_ _t140;                       // _t140
    _unknown_ _t142;                       // _t142
    _unknown_ _t144;                       // _t144
    _unknown_ _t147;                       // _t147
    signed int _t148;                      // _t148
    _unknown_ _t152;                       // _t152
    signed int _t163;                      // _t163
    _unknown_ _t168;                       // _t168
    signed int _t170;                      // _t170
    _unknown_ _t173;                       // _t173
    _unknown_ _t175;                       // _t175
    _unknown_ _t179;                       // _t179
    _unknown_ _t180;                       // _t180
    signed int _t181;                      // _t181
    _unknown_ _t182;                       // _t182
    _unknown_ _t183;                       // _t183
    _unknown_ _t184;                       // _t184
    signed int _t187;                      // _t187
    unsigned int _t191;                    // _t191
    char* _t195;                           // _t195

    _t148 = _a8;
    _t163 = _a4;
    _v36 = _a12;
    _v32 = _a16;
    _v48 = 0;
    if(_t148 >= 0) {
        _t163 =  ~_t163;
        asm("adc ecx, 0x0");
        _t148 =  ~_t148;
        _v48 = -1;
    }
    if(_v32 >= 0) {
        _v36 =  ~_v36;
        asm("adc dword [ebp-0x1c], 0x0");
        _v32 =  ~_v32;
    }
    _t119 = _v32;
    _t195 =  &_v20;
    _v52 = _t163;
    _v44 = _t163;
    _v40 = _v36;
    _t187 = _t148;
    if(_t119 != 0) {
        __eflags = _t119 - _t148;
        if(__eflags <= 0) {
            asm("bsr edx, eax");
            _v36 = _t163 ^ 31;
            if(__eflags != 0) {
                _v44 = 32 - _v36;
                _v60 = _v40 >> (_v44 & 0xff) | _t119 << (_v36 & 0xff);
                _v56 = _v40 << (_v36 & 0xff);
                _t129 = _v52 >> (_v44 & 0xff) | _t187 << (_v36 & 0xff);
                _t130 = _t129 / _v60;
                _v40 = _v52 << (_v36 & 0xff);
                _t191 = _t129 % _v60;
                _t170 = _t130 * _v56 >> 32;
                _t131 = _t130 * _v56;
                __eflags = _t191 - _t170;
                if(_t191 < _t170) {
L25:
                    _t131 = _t131 - _v56;
                    asm("sbb edx, [ebp-0x38]");
                } else {
                    __eflags = _v40 - _t131;
                    if(_v40 < _t131) {
                        __eflags = _t191 - _t170;
                        if(_t191 != _t170) {
                        } else {
                            goto L25;
                        }
                    }
                }
            } else {
                __eflags = _v40 - _v44;
                if(_v40 <= _v44) {
L23:
                    asm("sbb edi, eax");
                    _v44 = _v44 - _v40;
                } else {
                    __eflags = _t119 - _t187;
                    if(_t119 < _t187) {
                        goto L23;
                    }
                }
                _t195[4] = _t187;
                 *_t195 = _v44;
                goto L9;
            }
            asm("sbb edi, edx");
             *_t195 = _t191 << (_v44 & 0xff) | _v40 - _t131 >> (_v36 & 0xff);
            _t195[4] = _t191 >> (_v36 & 0xff);
        } else {
             *_t195 = _t163;
            _t195[4] = _t148;
        }
L9:
        __eflags = _v48;
        if(_v48 == 0) {
L6:
            return _v20;
        } else {
L10:
            asm("adc edx, 0x0");
            return  ~_v20;
        }
L26:
    }
    if(_v40 <= _t148) {
        __eflags = _v40;
        if(_v40 == 0) {
            _v40 = 1 / _v40;
        }
        _t181 = _v44 % _v40;
    } else {
        _t181 = _t163 % _v40;
    }
     *_t195 = _t181;
    _t195[4] = 0;
    if(_v48 != 0) {
        goto L10;
    } else {
        goto L6;
    }
    goto L26;
}

__udivdi3(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x0806AEB0
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t65;                       // _t65
    _unknown_ _t68;                        // _t68
    signed int _t69;                       // _t69
    signed int _t70;                       // _t70
    signed int _t71;                       // _t71
    signed int _t72;                       // _t72
    _unknown_ _t77;                        // _t77
    _unknown_ _t82;                        // _t82
    signed int _t84;                       // _t84
    _unknown_ _t88;                        // _t88
    signed int _t92;                       // _t92
    signed int _t97;                       // _t97
    _unknown_ _t98;                        // _t98
    _unknown_ _t105;                       // _t105
    signed int _t107;                      // _t107
    _unknown_ _t108;                       // _t108
    _unknown_ _t111;                       // _t111
    _unknown_ _t112;                       // _t112
    _unknown_ _t113;                       // _t113
    _unknown_ _t114;                       // _t114
    _unknown_ _t115;                       // _t115
    _unknown_ _t116;                       // _t116
    _unknown_ _t117;                       // _t117
    _unknown_ _t118;                       // _t118
    _unknown_ _t119;                       // _t119
    signed int _t120;                      // _t120
    _unknown_ _t121;                       // _t121
    signed int _t124;                      // _t124
    _unknown_ _t125;                       // _t125
    _unknown_ _t126;                       // _t126
    signed int _t128;                      // _t128
    signed int _t132;                      // _t132

    _t65 = _a16;
    _t97 = _a4;
    _t128 = _a12;
    _t120 = _a8;
    _v20 = _t97;
    if(_t65 != 0) {
        __eflags = _t65 - _t120;
        if(__eflags > 0) {
L9:
            _t84 = 0;
L10:
            return _t84;
            goto L18;
        }
        asm("bsr edx, eax");
        _v16 = _t97 ^ 31;
        if(__eflags != 0) {
            _v24 = _t65 << (_v16 & 0xff);
            _t69 = 32 - _v16;
            _v28 = _t128 << (_v16 & 0xff);
            _v24 = _t128 >> (_t69 & 255) | _v24;
            _t70 = _t120 << (_v16 & 0xff) | _v20 >> (_t69 & 255);
            _t71 = _t70 / _v24;
            _t132 = _t70 % _v24;
            _t124 = _t71;
            _t107 = _t71 * _v28 >> 32;
            _t72 = _t71 * _v28;
            __eflags = _t132 - _t107;
            _v24 = _t107;
            if(_t132 < _t107) {
L17:
                return _t124 - 1;
            } else {
                _t92 = _v16 & 255;
                __eflags = _v20 << (_t92 & 255) - _t72;
                if(_v20 << (_t92 & 255) >= _t72) {
L15:
                    _t84 = _t124;
                    goto L10;
                }
                __eflags = _t132 - _v24;
                if(_t132 == _v24) {
                    goto L17;
                } else {
                    goto L15;
                }
            }
        } else {
            __eflags = _t128 - _v20;
            if(_t128 <= _v20) {
L16:
                _t84 = 1;
            } else {
                __eflags = _t65 - _t120;
                if(_t65 < _t120) {
                    goto L16;
                } else {
                    goto L9;
                }
            }
            goto L10;
        }
    } else {
        if(_t128 > _t120) {
            return _t97 / _t128;
        } else {
            if(_t128 == 0) {
                _t128 = 1 / _t128;
            }
            return _v20 / _t128;
        }
    }
L18:
}

__libc_csu_fini()
{// addr = 0x0806AFE0
    _unknown_ __ebp;                       // r6

    return;
}

__libc_csu_init(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x0806AFF0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    signed int __esi;                      // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    signed int _t18;                       // _t18

    __i686.get_pc_thunk.bx();
    _t15 = _t14 + 9929;
    __esp = __esp - 28;
    _init();
    _t18 = _t15 + -332 - _t15 + -332 >> 2;
    if(_t18 != 0) {
        __esi = 0;
        while(1) {
            _v36 = _a12;
            _v40 = _a8;
             *__esp = _a4;
             *((intOrPtr*)(_t15 + -332 + __esi * 4))();
            __esi = __esi + 1;
            if(__esi >= _t18) {
                break;
            }
        }
    }
    __esp = __esp + 28;
    return;
}

__do_global_ctors_aux()
{// addr = 0x0806B050
    intOrPtr* __ebx;                       // r1
    _unknown_ __ebp;                       // r6

    __eax = __CTOR_LIST__;
    if(__eax != 255) {
        __ebx =  &__CTOR_LIST__;
        asm("o16 nop ");
        while(1) {
            __ebx = __ebx - 4;
             *__eax();
            __eax =  *__ebx;
            if(__eax == 255) {
                break;
            }
        }
    }
    return;
}

_fini()
{// addr = 0x0806B07C
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    __esp = __esp - 4;
    L1();
    _pop(__ebx);
    __do_global_dtors_aux(__esi);
    _pop(__ecx);
    return;
}

L0806B088()
{
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _pop(__ebx);
    __do_global_dtors_aux(__esi);
    _pop(__ecx);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return;
}

L0806B088()
{
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _pop(__ebx);
    @rec __do_global_dtors_aux@__do_global_dtors_aux@(__esi);
    _pop(__ecx);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return;
}

// Statistics:
//   15604 Register nodes
//   18291 Temporaries nodes
//    2443 Casts
//   32809 Statements
//    2642 Labels
//    1427 Gotos
//    1503 Blocks
//  131354 Nodes
//     961 Assembly nodes
//    5412 Unknown Types


Total time: 16 seconds.
